description,code,tags
"Numbers $$$1, 2, 3, \dots n$$$ (each integer from $$$1$$$ to $$$n$$$ once) are written on a board. In one operation you can erase any two numbers $$$a$$$ and $$$b$$$ from the board and write one integer $$$\frac{a + b}{2}$$$ rounded up instead.You should perform the given operation $$$n - 1$$$ times and make the resulting number that will be left on the board as small as possible. For example, if $$$n = 4$$$, the following course of action is optimal:  choose $$$a = 4$$$ and $$$b = 2$$$, so the new number is $$$3$$$, and the whiteboard contains $$$[1, 3, 3]$$$;  choose $$$a = 3$$$ and $$$b = 3$$$, so the new number is $$$3$$$, and the whiteboard contains $$$[1, 3]$$$;  choose $$$a = 1$$$ and $$$b = 3$$$, so the new number is $$$2$$$, and the whiteboard contains $$$[2]$$$. It's easy to see that after $$$n - 1$$$ operations, there will be left only one number. Your goal is to minimize it.","def ii(): return int(input())
def mi(): return map(int, input().split())


if __name__ == '__main__':
    for _ in range(ii()):
        n = ii()
        # if n == 3:
        #     print(""2\n3 1\n2 2"")
        #     continue
        if n == 2:
            print(""2\n2 1"")
            continue

        l = list(range(1, n+1))
        a = l.pop()
        answer = []
        b = l.pop(-2)
        answer.append((a, b))
        a = int((a + b) / 2)
        while l:
            b = l.pop()
            answer.append((a, b))
            a = int((a + b) / 2)
        print(a)
        for i in answer:
            print(*i)","['greedy', 'constructive algorithms', 'math', 'implementation', 'data structures']"
"You are given an undirected graph consisting of $$$n$$$ vertices. A number is written on each vertex; the number on vertex $$$i$$$ is $$$a_i$$$. Initially there are no edges in the graph.You may add some edges to this graph, but you have to pay for them. The cost of adding an edge between vertices $$$x$$$ and $$$y$$$ is $$$a_x + a_y$$$ coins. There are also $$$m$$$ special offers, each of them is denoted by three numbers $$$x$$$, $$$y$$$ and $$$w$$$, and means that you can add an edge connecting vertices $$$x$$$ and $$$y$$$ and pay $$$w$$$ coins for it. You don't have to use special offers: if there is a pair of vertices $$$x$$$ and $$$y$$$ that has a special offer associated with it, you still may connect these two vertices paying $$$a_x + a_y$$$ coins for it.What is the minimum number of coins you have to spend to make the graph connected? Recall that a graph is connected if it's possible to get from any vertex to any other vertex using only the edges belonging to this graph.","def read_nums():
    return [int(x) for x in input().split()]


class UnionFind:
    def __init__(self, size):
        self._parents = list(range(size))

        # number of elements rooted at i
        self._sizes = [1 for _ in range(size)]

    def _root(self, a):
        while a != self._parents[a]:
            self._parents[a] = self._parents[self._parents[a]]
            a = self._parents[a]
        return a

    def find(self, a, b):
        return self._root(a) == self._root(b)

    def union(self, a, b):
        a, b = self._root(a), self._root(b)

        if self._sizes[a] < self._sizes[b]:
            self._parents[a] = b
            self._sizes[b] += self._sizes[a]
        else:
            self._parents[b] = a
            self._sizes[a] += self._sizes[b]


def count_result(num_vertex, edges):
    uf = UnionFind(num_vertex)
    res = 0
    for start, end, cost in edges:
        if uf.find(start, end):
            continue
        else:
            uf.union(start, end)
            res += cost
    return res


def main():
    n, m = read_nums()
    vertex_nums = read_nums()
    edges = []
    for i in range(m):
        nums = read_nums()
        nums[0] -= 1
        nums[1] -= 1
        edges.append(nums)

    min_index = min([x for x in zip(vertex_nums, range(n))], key=lambda x: x[0])[1]
    for i in range(n):
        if i != min_index:
            edges.append((min_index, i, vertex_nums[min_index] + vertex_nums[i]))
    edges = sorted(edges, key=lambda x: x[2])
    print(count_result(n, edges))


if __name__ == '__main__':
    main()","['dsu', 'greedy', 'graphs']"
"You are given an array $$$a_1, a_2, \ldots, a_n$$$.In one operation you can choose two elements $$$a_i$$$ and $$$a_j$$$ ($$$i \ne j$$$) and decrease each of them by one.You need to check whether it is possible to make all the elements equal to zero or not.","x=int(input())
a=list(map(int,input().split()))
c=sum(a)
d=max(a)
if d<=c//2 and x>1 and c%2==0:
    print(""YES"")
else:
    print(""NO"")","['greedy', 'math']"
"Vanya is doing his maths homework. He has an expression of form , where x1, x2, ..., xn are digits from 1 to 9, and sign  represents either a plus '+' or the multiplication sign '*'. Vanya needs to add one pair of brackets in this expression so that to maximize the value of the resulting expression.","n = raw_input()
ans = 0
a = [-1]
for i in xrange(len(n)):
    if n[i]=='*':a.append(i)
a.append(len(n))
for i in a:
    for j in a:
        if j>i:
            ans = max(ans,eval(n[:i+1]+'('+n[i+1:j]+')'+n[j:]))
ans = max(ans,eval(n))
print ans","['dp', 'greedy', 'implementation', 'expression parsing', 'brute force', 'strings']"
"Famil Door wants to celebrate his birthday with his friends from Far Far Away. He has n friends and each of them can come to the party in a specific range of days of the year from ai to bi. Of course, Famil Door wants to have as many friends celebrating together with him as possible.Far cars are as weird as Far Far Away citizens, so they can only carry two people of opposite gender, that is exactly one male and one female. However, Far is so far from here that no other transportation may be used to get to the party.Famil Door should select some day of the year and invite some of his friends, such that they all are available at this moment and the number of male friends invited is equal to the number of female friends invited. Find the maximum number of friends that may present at the party.","n = int(input())

m = [0 for _ in range(366 + 1)]
f = [0 for _ in range(366 + 1)]

for i in range(n):
    g, a, b = input().split()
    a, b = int(a), int(b)
    if g == 'M':
        for j in range(a, b + 1):
            m[j] += 1
    else:
        for j in range(a, b + 1):
            f[j] += 1

answ = 0
for i in range(1, 366 + 1):
    answ = max(answ, min(m[i], f[i]) * 2)

print(answ)",['brute force']
"Scrooge McDuck keeps his most treasured savings in a home safe with a combination lock. Each time he wants to put there the treasures that he's earned fair and square, he has to open the lock.  The combination lock is represented by n rotating disks with digits from 0 to 9 written on them. Scrooge McDuck has to turn some disks so that the combination of digits on the disks forms a secret combination. In one move, he can rotate one disk one digit forwards or backwards. In particular, in one move he can go from digit 0 to digit 9 and vice versa. What minimum number of actions does he need for that?","def my_function(no_of_disks=5, current_state=82195, unlock_state=64723):
    solution = 0
    for i in range(no_of_disks):
        x = abs(int(current_state[i]) - int(unlock_state[i]))
        y = abs(10 + int(current_state[i]) - (int(unlock_state[i])))
        z = abs(int(current_state[i]) - (10 + int(unlock_state[i])))
        solution += min(x, y, z)
    print solution


no_of_disks = int(raw_input())
current_state = raw_input()
unlock_state = raw_input()
my_function(no_of_disks, current_state, unlock_state)",['implementation']
"Tanya has $$$n$$$ candies numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th candy has the weight $$$a_i$$$.She plans to eat exactly $$$n-1$$$ candies and give the remaining candy to her dad. Tanya eats candies in order of increasing their numbers, exactly one candy per day.Your task is to find the number of such candies $$$i$$$ (let's call these candies good) that if dad gets the $$$i$$$-th candy then the sum of weights of candies Tanya eats in even days will be equal to the sum of weights of candies Tanya eats in odd days. Note that at first, she will give the candy, after it she will eat the remaining candies one by one.For example, $$$n=4$$$ and weights are $$$[1, 4, 3, 3]$$$. Consider all possible cases to give a candy to dad:  Tanya gives the $$$1$$$-st candy to dad ($$$a_1=1$$$), the remaining candies are $$$[4, 3, 3]$$$. She will eat $$$a_2=4$$$ in the first day, $$$a_3=3$$$ in the second day, $$$a_4=3$$$ in the third day. So in odd days she will eat $$$4+3=7$$$ and in even days she will eat $$$3$$$. Since $$$7 \ne 3$$$ this case shouldn't be counted to the answer (this candy isn't good).  Tanya gives the $$$2$$$-nd candy to dad ($$$a_2=4$$$), the remaining candies are $$$[1, 3, 3]$$$. She will eat $$$a_1=1$$$ in the first day, $$$a_3=3$$$ in the second day, $$$a_4=3$$$ in the third day. So in odd days she will eat $$$1+3=4$$$ and in even days she will eat $$$3$$$. Since $$$4 \ne 3$$$ this case shouldn't be counted to the answer (this candy isn't good).  Tanya gives the $$$3$$$-rd candy to dad ($$$a_3=3$$$), the remaining candies are $$$[1, 4, 3]$$$. She will eat $$$a_1=1$$$ in the first day, $$$a_2=4$$$ in the second day, $$$a_4=3$$$ in the third day. So in odd days she will eat $$$1+3=4$$$ and in even days she will eat $$$4$$$. Since $$$4 = 4$$$ this case should be counted to the answer (this candy is good).  Tanya gives the $$$4$$$-th candy to dad ($$$a_4=3$$$), the remaining candies are $$$[1, 4, 3]$$$. She will eat $$$a_1=1$$$ in the first day, $$$a_2=4$$$ in the second day, $$$a_3=3$$$ in the third day. So in odd days she will eat $$$1+3=4$$$ and in even days she will eat $$$4$$$. Since $$$4 = 4$$$ this case should be counted to the answer (this candy is good). In total there $$$2$$$ cases which should counted (these candies are good), so the answer is $$$2$$$.","n=int(raw_input())
a=list(map(int,raw_input().split()))
odd=[0 for i in xrange(n+1)]
even=[0 for i in xrange(n+1)]
for i in xrange(1,n+1):
    if i&1:
        odd[i] = a[i-1] + odd[i-1]
        even[i] += even[i-1]
    else:
        even[i]= a[i-1]+even[i-1]
        odd[i] += odd[i-1]
#print odd
#print even
count = 0
for i in xrange(1,n+1):
    x=a[i-1]
    odd_sum=odd[i-1]
    even_sum=even[i-1]
    odd_sum += (even[-1]-even[i])
    even_sum += (odd[-1]-odd[i])
    if odd_sum == even_sum:
        count += 1
#print i
print count",['implementation']
"Alice's hair is growing by leaps and bounds. Maybe the cause of it is the excess of vitamins, or maybe it is some black magic...To prevent this, Alice decided to go to the hairdresser. She wants for her hair length to be at most $$$l$$$ centimeters after haircut, where $$$l$$$ is her favorite number. Suppose, that the Alice's head is a straight line on which $$$n$$$ hairlines grow. Let's number them from $$$1$$$ to $$$n$$$. With one swing of the scissors the hairdresser can shorten all hairlines on any segment to the length $$$l$$$, given that all hairlines on that segment had length strictly greater than $$$l$$$. The hairdresser wants to complete his job as fast as possible, so he will make the least possible number of swings of scissors, since each swing of scissors takes one second.Alice hasn't decided yet when she would go to the hairdresser, so she asked you to calculate how much time the haircut would take depending on the time she would go to the hairdresser. In particular, you need to process queries of two types:  $$$0$$$ — Alice asks how much time the haircut would take if she would go to the hairdresser now.  $$$1$$$ $$$p$$$ $$$d$$$ — $$$p$$$-th hairline grows by $$$d$$$ centimeters. Note, that in the request $$$0$$$ Alice is interested in hypothetical scenario of taking a haircut now, so no hairlines change their length.","from __future__ import division
from sys import stdin, stdout

line = stdin.readline().rstrip(""\n"")
n, m, l = map(int, line.split())

line = stdin.readline().rstrip(""\n"")
a = map(int, line.split())

a = [0] + a + [0]
res = 0
for i in range(1, n + 1):
    if a[i] > l and not a[i - 1] > l:
        res += 1

reqs = []


for _ in xrange(m):
    line = stdin.readline().rstrip(""\n"")
    t = map(int, line.split())
    if len(t) == 1:
        reqs.append((0, ))
    else:
        t, p, d = t
        reqs.append((t, p, d))

for ting in reqs:
    if len(ting) == 1:
        stdout.write(str(res) + ""\n"")
    else:
        t, p, d = ting
        a[p] += d
        if a[p] > l and a[p] - d <= l:
            if a[p - 1] > l and a[p + 1] > l:
                res -= 1
            elif a[p - 1] <= l and a[p + 1] <= l:
                res += 1","['dsu', 'implementation']"
"Levko loves permutations very much. A permutation of length n is a sequence of distinct positive integers, each is at most n.Let’s assume that value gcd(a, b) shows the greatest common divisor of numbers a and b. Levko assumes that element pi of permutation p1, p2, ... , pn is good if gcd(i, pi) &gt; 1. Levko considers a permutation beautiful, if it has exactly k good elements. Unfortunately, he doesn’t know any beautiful permutation. Your task is to help him to find at least one of them.","n, k = map(int, input().split())

if k == n:
    print(-1)
else:
    print(*([n - k] + list(range(1, n - k)) + list(range(n - k + 1, n + 1))))","['constructive algorithms', 'number theory', 'math']"
"The ship crashed into a reef and is sinking. Now the entire crew must be evacuated. All n crew members have already lined up in a row (for convenience let's label them all from left to right with positive integers from 1 to n) and await further instructions. However, one should evacuate the crew properly, in a strict order. Specifically:The first crew members to leave the ship are rats. Then women and children (both groups have the same priority) leave the ship. After that all men are evacuated from the ship. The captain leaves the sinking ship last.If we cannot determine exactly who should leave the ship first for any two members of the crew by the rules from the previous paragraph, then the one who stands to the left in the line leaves the ship first (or in other words, the one whose number in the line is less).For each crew member we know his status as a crew member, and also his name. All crew members have different names. Determine the order in which to evacuate the crew.","d = {
    'rat':[],
    'child':[],
    'man':[],
    'captain':[]
}
i = int(input())
while i:
    s = input()
    data = s.split()
    if data[1] == 'child' or data[1] == 'woman':
        d['child'].append(data[0])
    else:
        d[data[1]].append(data[0])
    i = i -1

for p in d['rat']:
    print(p)
for p in d['child']:
    print(p)
for p in d['man']:
    print(p)
for p in d['captain']:
    print(p)","['implementation', 'sortings', 'strings']"
"You are playing a computer game, where you lead a party of $$$m$$$ soldiers. Each soldier is characterised by his agility $$$a_i$$$.The level you are trying to get through can be represented as a straight line segment from point $$$0$$$ (where you and your squad is initially located) to point $$$n + 1$$$ (where the boss is located).The level is filled with $$$k$$$ traps. Each trap is represented by three numbers $$$l_i$$$, $$$r_i$$$ and $$$d_i$$$. $$$l_i$$$ is the location of the trap, and $$$d_i$$$ is the danger level of the trap: whenever a soldier with agility lower than $$$d_i$$$ steps on a trap (that is, moves to the point $$$l_i$$$), he gets instantly killed. Fortunately, you can disarm traps: if you move to the point $$$r_i$$$, you disarm this trap, and it no longer poses any danger to your soldiers. Traps don't affect you, only your soldiers.You have $$$t$$$ seconds to complete the level — that is, to bring some soldiers from your squad to the boss. Before the level starts, you choose which soldiers will be coming with you, and which soldiers won't be. After that, you have to bring all of the chosen soldiers to the boss. To do so, you may perform the following actions:  if your location is $$$x$$$, you may move to $$$x + 1$$$ or $$$x - 1$$$. This action consumes one second;  if your location is $$$x$$$ and the location of your squad is $$$x$$$, you may move to $$$x + 1$$$ or to $$$x - 1$$$ with your squad in one second. You may not perform this action if it puts some soldier in danger (i. e. the point your squad is moving into contains a non-disarmed trap with $$$d_i$$$ greater than agility of some soldier from the squad). This action consumes one second;  if your location is $$$x$$$ and there is a trap $$$i$$$ with $$$r_i = x$$$, you may disarm this trap. This action is done instantly (it consumes no time). Note that after each action both your coordinate and the coordinate of your squad should be integers.You have to choose the maximum number of soldiers such that they all can be brought from the point $$$0$$$ to the point $$$n + 1$$$ (where the boss waits) in no more than $$$t$$$ seconds.","from __future__ import print_function,division
import sys
#dichotomie sur l'agilité
le=sys.__stdin__.read().split(""\n"")[::-1]
def possible(a):
    global n,t
    s=1
    nb=0
    et=[]
    for z in range(n):
        vi=(nb!=0)
        for j in des[z]:
            if abs(j)>a:
                if j>0:
                    vi=True
                    nb+=1
                else:
                    nb-=1
        if nb==0 and not(vi):
            s+=1
            et.append(1)
        else:
            et.append(3)
            s+=3
    #print(a,et,s)
    return(s<=t)


m,n,k,t=list(map(int,le.pop().split()))
des=[[] for zor in range(n)]
#agi=[0]*(k+1)
ag=sorted(list(map(int,le.pop().split())))[::-1]
for zor in range(1,k+1):
    l,r,d=map(int,le.pop().split())
    #agi[zor]=d
    des[l-1].append(d)
    des[r-1].append(-d)
deb=-1
fin=m

while fin-deb>1:
    m=(fin+deb+1)//2
    if possible(ag[m]):
        deb=m
    else:
        fin=m
print(deb+1)","['dp', 'binary search', 'sortings', 'greedy']"
"Little X and Little Z are good friends. They always chat online. But both of them have schedules.Little Z has fixed schedule. He always online at any moment of time between a1 and b1, between a2 and b2, ..., between ap and bp (all borders inclusive). But the schedule of Little X is quite strange, it depends on the time when he gets up. If he gets up at time 0, he will be online at any moment of time between c1 and d1, between c2 and d2, ..., between cq and dq (all borders inclusive). But if he gets up at time t, these segments will be shifted by t. They become [ci + t, di + t] (for all i).If at a moment of time, both Little X and Little Z are online simultaneosly, they can chat online happily. You know that Little X can get up at an integer moment of time between l and r (both borders inclusive). Also you know that Little X wants to get up at the moment of time, that is suitable for chatting with Little Z (they must have at least one common moment of time in schedules). How many integer moments of time from the segment [l, r] suit for that?","def binser(ar,item):
    beg=0
    end=len(ar)-1
    while beg<=end:
        mid=(beg+end)//2
        if ar[mid]==item:
            return 1
        elif ar[mid]<item:
            beg=mid+1
        else:
            end=mid-1
    return -1
def main():
    inp1=map(int,raw_input().split())
    p=inp1[0]
    q=inp1[1]
    l=inp1[2]
    r=inp1[3]
    Z=[]
    X=[]
    for i in range(0,p):
        a,b=raw_input().split()
        a=int(a)
        b=int(b)
        Z=Z+range(a,b+1)
    sorted(Z)   
    for i in range(0,q):
        a,b=raw_input().split()
        a=int(a)
        b=int(b)
        X=X+range(a,b+1)
    cou=0
    for i in range(l,r+1):
        for j in X:
            if (binser(Z,j+i)==1):
                #print j+i
                cou=cou+1
                break
    print cou
    return 0
main()",['implementation']
"— Hey folks, how do you like this problem?— That'll do it. BThero is a powerful magician. He has got $$$n$$$ piles of candies, the $$$i$$$-th pile initially contains $$$a_i$$$ candies. BThero can cast a copy-paste spell as follows:   He chooses two piles $$$(i, j)$$$ such that $$$1 \le i, j \le n$$$ and $$$i \ne j$$$.  All candies from pile $$$i$$$ are copied into pile $$$j$$$. Formally, the operation $$$a_j := a_j + a_i$$$ is performed. BThero can cast this spell any number of times he wants to — but unfortunately, if some pile contains strictly more than $$$k$$$ candies, he loses his magic power. What is the maximum number of times BThero can cast the spell without losing his power?","x1 = int(input())
for i in range(x1):
    n,k = map(int,input().split())
    l = list(map(int,input().split()))
    c=0
    d=min(l)

    l.sort()


    
    for i in range(1,n):
        c+=(k-l[i])//d
  



    print(c)","['greedy', 'math']"
"Polycarp lives on the coordinate axis $$$Ox$$$ and travels from the point $$$x=a$$$ to $$$x=b$$$. It moves uniformly rectilinearly at a speed of one unit of distance per minute.On the axis $$$Ox$$$ at the point $$$x=c$$$ the base station of the mobile operator is placed. It is known that the radius of its coverage is $$$r$$$. Thus, if Polycarp is at a distance less than or equal to $$$r$$$ from the point $$$x=c$$$, then he is in the network coverage area, otherwise — no. The base station can be located both on the route of Polycarp and outside it.Print the time in minutes during which Polycarp will not be in the coverage area of the network, with a rectilinear uniform movement from $$$x=a$$$ to $$$x=b$$$. His speed — one unit of distance per minute.","a=int(input())
for i in range(a):
    count=0
    b=list(map(int,input().split("" "")))
    l=b[2]-b[3]
    u=b[2]+b[3]
    s=min(b[0],b[1])
    e=max(b[0],b[1])
    if l<=s<=e<=u:
        count=0
    elif l<=s<=u<=e:
        count=e-u
    elif s<=l<=e<=u:
        count=l-s
    elif s<=l<=u<=e:
        count=e-u-s+l
    elif l<=u<=s<=e or s<=e<=l<=u:
        count=e-s
    print(count)","['implementation', 'math']"
"Vasya is currently at a car rental service, and he wants to reach cinema. The film he has bought a ticket for starts in t minutes. There is a straight road of length s from the service to the cinema. Let's introduce a coordinate system so that the car rental service is at the point 0, and the cinema is at the point s.There are k gas stations along the road, and at each of them you can fill a car with any amount of fuel for free! Consider that this operation doesn't take any time, i.e. is carried out instantly.There are n cars in the rental service, i-th of them is characterized with two integers ci and vi — the price of this car rent and the capacity of its fuel tank in liters. It's not allowed to fuel a car with more fuel than its tank capacity vi. All cars are completely fueled at the car rental service.Each of the cars can be driven in one of two speed modes: normal or accelerated. In the normal mode a car covers 1 kilometer in 2 minutes, and consumes 1 liter of fuel. In the accelerated mode a car covers 1 kilometer in 1 minutes, but consumes 2 liters of fuel. The driving mode can be changed at any moment and any number of times.Your task is to choose a car with minimum price such that Vasya can reach the cinema before the show starts, i.e. not later than in t minutes. Assume that all cars are completely fueled initially.","R = lambda: map(int, raw_input().split())

(n, k, s, t) = R()
cvs = [R() for _ in range(n)]
ps = R() + [0, s]
ps.sort()

if t < s:
    print(-1)
else:
    (l, r) = (1, s << 1)
    while l <= r:
        m = l+r >> 1
        t1 = 0
        for i in range(1, len(ps)):
            d = ps[i] - ps[i - 1]
            if d<<1 <= m:
                t1 += d
            elif d > m:
                l = m + 1
                break
            else:
                t1 += 3*d - m
        else:
            if t1 <= t:
                r = m - 1
            else:
                l = m + 1

    ans = 10**9 + 1
    for (c, v) in cvs:
        if v >= l:
            ans = min(ans, c)
    print(ans if ans <= 10**9 else -1)",['binary search']
You are given two arrays of integers a and b. For each element of the second array bj you should find the number of elements in array a that are less than or equal to the value bj.,"n = input()
a = list(map(int, input().split()))
b = list(map(int, input().split()))
for i in range(len(b)):
    b[i] = [b[i], i]
# print(b)
a.sort()
b.sort(key = lambda x: x[0])
# print(b)
y = 0
x = 0
result= [0]*len(b)
while y<len(b):
    while x<len(a) and a[x]<=b[y][0]:
        x += 1
    # print(x)
    result[b[y][1]] = x
    y += 1
for i in result:
    print(i, end="" "")","['data structures', 'two pointers', 'binary search', 'sortings']"
"It is well known that Berland has n cities, which form the Silver ring — cities i and i + 1 (1 ≤ i &lt; n) are connected by a road, as well as the cities n and 1. The goverment have decided to build m new roads. The list of the roads to build was prepared. Each road will connect two cities. Each road should be a curve which lies inside or outside the ring. New roads will have no common points with the ring (except the endpoints of the road).Now the designers of the constructing plan wonder if it is possible to build the roads in such a way that no two roads intersect (note that the roads may intersect at their endpoints). If it is possible to do, which roads should be inside the ring, and which should be outside?","n, m = map(int, input().split())
road = [[] for i in range(m)]
for i in range(m):
    road[i] = [i] + list(map(int, input().split())) + ['NONE']
for i in road:
    if i[2] < i[1]:
        i[1], i[2] = i[2], i[1]
    i[1], i[2] = i[1] - 1, i[2] - 1

participation = [[] for i in range(m)]
for i in range(len(road)):
    for j in range(i + 1, len(road)):
        if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):
            if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:
                participation[i].append(j)
                participation[j].append(i)
result = """"
mark = [0] * m
stack = []
while sum(mark) != m:
    if len(stack) == 0:
        for i in range(len(mark)):
            if mark[i] == 0:
                stack.append(i)
                break
    index = stack.pop()
    mark[index] = 1
    if road[index][3] == ""NONE"":
        road[index][3] = ""i""
    for i in participation[index]:
        if road[i][3] == road[index][3]:
            result = ""Impossible""
            print(result)
            break
        elif road[index][3] != ""i"" and road[i][3] == ""NONE"":
            road[i][3] = ""i""
            stack.append(i)
        elif road[index][3] == ""i"" and road[i][3] == ""NONE"":
            road[i][3] = ""o""
            stack.append(i)
    if result == ""Impossible"":
        break


if result != ""Impossible"":
    for i in road:
        result += i[3]
    print(result)","['dsu', 'dfs and similar', 'graphs', '2-sat']"
"Writing light novels is the most important thing in Linova's life. Last night, Linova dreamed about a fantastic kingdom. She began to write a light novel for the kingdom as soon as she woke up, and of course, she is the queen of it. There are $$$n$$$ cities and $$$n-1$$$ two-way roads connecting pairs of cities in the kingdom. From any city, you can reach any other city by walking through some roads. The cities are numbered from $$$1$$$ to $$$n$$$, and the city $$$1$$$ is the capital of the kingdom. So, the kingdom has a tree structure.As the queen, Linova plans to choose exactly $$$k$$$ cities developing industry, while the other cities will develop tourism. The capital also can be either industrial or tourism city.A meeting is held in the capital once a year. To attend the meeting, each industry city sends an envoy. All envoys will follow the shortest path from the departure city to the capital (which is unique).Traveling in tourism cities is pleasant. For each envoy, his happiness is equal to the number of tourism cities on his path.In order to be a queen loved by people, Linova wants to choose $$$k$$$ cities which can maximize the sum of happinesses of all envoys. Can you calculate the maximum sum for her?","def main():
    from sys import stdin
    from sys import stdout
    input = stdin.readline
    print = stdout.write

    def dfs(town_ix, deep=0, parent=0):
        deeps[town_ix] = deep
        if len(kingdom_structure[town_ix]) == 1 and kingdom_structure[town_ix][0] == parent:
            return 1
        for road_to in kingdom_structure[town_ix]:
            if road_to != parent:
                quantity_child[town_ix] += dfs(road_to, deep + 1, town_ix)
        return quantity_child[town_ix] + 1

    n, k = list(map(int, input().split()))
    kingdom_structure = [[] for _ in range(n)]
    memo = [list(map(int, input().split())) for _ in range(n - 1)]
    deeps = [0] * n
    quantity_child = [0] * n
    for i in range(n - 1):
        v = memo[i][0] - 1
        u = memo[i][1] - 1
        kingdom_structure[v].append(u)
        kingdom_structure[u].append(v)
    dfs(0)
    towns_profit = sorted([deeps[i] - quantity_child[i] for i in range(n)], reverse=True)
    print(f'{sum(towns_profit[:k])}\n')


if __name__ == '__main__':
    from sys import setrecursionlimit
    import threading
    setrecursionlimit(2097152)
    threading.stack_size(134217728)
    main_thread = threading.Thread(target=main)
    main_thread.start()
    main_thread.join()","['dp', 'greedy', 'sortings', 'dfs and similar', 'trees']"
"Young Timofey has a birthday today! He got kit of n cubes as a birthday present from his parents. Every cube has a number ai, which is written on it. Timofey put all the cubes in a row and went to unpack other presents.In this time, Timofey's elder brother, Dima reordered the cubes using the following rule. Suppose the cubes are numbered from 1 to n in their order. Dima performs several steps, on step i he reverses the segment of cubes from i-th to (n - i + 1)-th. He does this while i ≤ n - i + 1.After performing the operations Dima went away, being very proud of himself. When Timofey returned to his cubes, he understood that their order was changed. Help Timofey as fast as you can and save the holiday — restore the initial order of the cubes using information of their current location.","n = int(input())
l = list(map(int, input().split()))

for i in range(0, n // 2, 2):
	
	l[i], l[-(i + 1)] = l[-(i + 1)], l[i]


print(*l)","['constructive algorithms', 'implementation']"
"You are given $$$q$$$ queries in the following form:Given three integers $$$l_i$$$, $$$r_i$$$ and $$$d_i$$$, find minimum positive integer $$$x_i$$$ such that it is divisible by $$$d_i$$$ and it does not belong to the segment $$$[l_i, r_i]$$$.Can you answer all the queries?Recall that a number $$$x$$$ belongs to segment $$$[l, r]$$$ if $$$l \le x \le r$$$.","q = int(input())
for q in range(0, q):
    k = [int(a) for a in input().split()]
    l = k[0]
    r = k[1]
    d = k[2]
    if d < l or d > r:
        x = d
    else:
        x = r - (r % d) + d
    print(x)",['math']
"Asterix, Obelix and their temporary buddies Suffix and Prefix has finally found the Harmony temple. However, its doors were firmly locked and even Obelix had no luck opening them.A little later they found a string s, carved on a rock below the temple's gates. Asterix supposed that that's the password that opens the temple and read the string aloud. However, nothing happened. Then Asterix supposed that a password is some substring t of the string s.Prefix supposed that the substring t is the beginning of the string s; Suffix supposed that the substring t should be the end of the string s; and Obelix supposed that t should be located somewhere inside the string s, that is, t is neither its beginning, nor its end.Asterix chose the substring t so as to please all his companions. Besides, from all acceptable variants Asterix chose the longest one (as Asterix loves long strings). When Asterix read the substring t aloud, the temple doors opened. You know the string s. Find the substring t or determine that such substring does not exist and all that's been written above is just a nice legend.","import sys
input=sys.stdin.readline
import collections as cc
s=input().strip()
n=len(s)
temp=cc.Counter(s)
pre=[0]*(n)
i=1
j=0
lst=-1
while i<n:
	if(s[i]==s[j]):
		j+=1
		pre[i]=j
		i+=1
	else:
		if j:
			j=pre[j-1]
		else:
			pre[i]=0
			i+=1
pre[0]=0
#print(pre)
temp=pre[-1]
if pre[-1]!=0 and pre.count(temp)>=2:
	print(''.join(s[:temp]))
elif pre[-1]!=0 and pre[pre[-1]-1]>0:
	print(''.join(s[:pre[pre[-1]-1]]))
else:
	print('Just a legend')","['dp', 'hashing', 'string suffix structures', 'binary search', 'strings']"
"While walking down the street Vanya saw a label ""Hide&amp;Seek"". Because he is a programmer, he used &amp; as a bitwise AND for these two words represented as a integers in base 64 and got new word. Now Vanya thinks of some string s and wants to know the number of pairs of words of length |s| (length of s), such that their bitwise AND is equal to s. As this number can be large, output it modulo 109 + 7.To represent the string as a number in numeral system with base 64 Vanya uses the following rules:  digits from '0' to '9' correspond to integers from 0 to 9;  letters from 'A' to 'Z' correspond to integers from 10 to 35;  letters from 'a' to 'z' correspond to integers from 36 to 61;  letter '-' correspond to integer 62;  letter '_' correspond to integer 63.","s = raw_input()

d = 0
ans = 1
for c in map(ord, s):
	d = 0
	if ord(""0"") <= c <= ord(""9""):
		d += c - ord(""0"")
	elif ord(""A"") <= c <= ord(""Z""):
		d += c - ord(""A"") + 10
	elif ord(""a"") <= c <= ord(""z""):
		d += c - ord(""a"") + 36
	elif ord(""-"") == c:
		d += 62
	else:
		d += 63

	ans *= pow(3, format(d, ""06b"").count(""0""), 10 ** 9 + 7)
	ans %= 10 ** 9 + 7

print ans","['combinatorics', 'implementation', 'bitmasks', 'strings']"
"There are n integers b1, b2, ..., bn written in a row. For all i from 1 to n, values ai are defined by the crows performing the following procedure:  The crow sets ai initially 0.  The crow then adds bi to ai, subtracts bi + 1, adds the bi + 2 number, and so on until the n'th number. Thus, ai = bi - bi + 1 + bi + 2 - bi + 3.... Memory gives you the values a1, a2, ..., an, and he now wants you to find the initial numbers b1, b2, ..., bn written in the row? Can you do it?","a=int(input())
b=list(map(int,input().split()))
for x in range(a-1):
	print(b[x]+b[x+1],end=' ')
print(b[-1],end='')","['implementation', 'math']"
"An array of integers $$$p_1, p_2, \dots, p_n$$$ is called a permutation if it contains each number from $$$1$$$ to $$$n$$$ exactly once. For example, the following arrays are permutations: $$$[3, 1, 2]$$$, $$$[1]$$$, $$$[1, 2, 3, 4, 5]$$$ and $$$[4, 3, 1, 2]$$$. The following arrays are not permutations: $$$[2]$$$, $$$[1, 1]$$$, $$$[2, 3, 4]$$$.Polycarp invented a really cool permutation $$$p_1, p_2, \dots, p_n$$$ of length $$$n$$$. It is very disappointing, but he forgot this permutation. He only remembers the array $$$q_1, q_2, \dots, q_{n-1}$$$ of length $$$n-1$$$, where $$$q_i=p_{i+1}-p_i$$$.Given $$$n$$$ and $$$q=q_1, q_2, \dots, q_{n-1}$$$, help Polycarp restore the invented permutation.","n=int(input())
q=list(map(int,input().split()))
for i in range(1,n-1):
    q[i]+=q[i-1]
mi=min(q)
if (n-1)==len(set(q)):
    if mi>0:
        f=1
    elif mi<0:
        f=abs(mi)+1
    else:
        print(-1)
        exit(0)
else:
    print(-1)
    exit(0)    

d=dict()
if f<=n:
    d[f]=1
else:
    print(-1)
    exit(0)
for i in range(n-1):
    q[i]+=f
    try:
        if d[q[i]]==1:
            print(-1)
            exit(0)
    except KeyError:
        if q[i] <= n: 
            d[q[i]]=1
        else:
            print(-1)
            exit(0)
print(f,end="" "")
for i in q:
    print(i,end="" "")
print()",['math']
"Ujan decided to make a new wooden roof for the house. He has $$$n$$$ rectangular planks numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th plank has size $$$a_i \times 1$$$ (that is, the width is $$$1$$$ and the height is $$$a_i$$$).Now, Ujan wants to make a square roof. He will first choose some of the planks and place them side by side in some order. Then he will glue together all of these planks by their vertical sides. Finally, he will cut out a square from the resulting shape in such a way that the sides of the square are horizontal and vertical.For example, if Ujan had planks with lengths $$$4$$$, $$$3$$$, $$$1$$$, $$$4$$$ and $$$5$$$, he could choose planks with lengths $$$4$$$, $$$3$$$ and $$$5$$$. Then he can cut out a $$$3 \times 3$$$ square, which is the maximum possible. Note that this is not the only way he can obtain a $$$3 \times 3$$$ square.  What is the maximum side length of the square Ujan can get?","if __name__ == ""__main__"":
    k = int(input())

    while k > 0:
        k -= 1
        n = int(input())
        data = sorted([int(x) for x in input().split()], reverse = True)
        mn = data[0]
        ans = 1
        for i in range(1, len(data) + 1):
            if mn >= i:
                ans = i
            if i == len(data):
                break 
            mn = min(mn, data[i])
        print(ans)",['implementation']
"The map of Bertown can be represented as a set of $$$n$$$ intersections, numbered from $$$1$$$ to $$$n$$$ and connected by $$$m$$$ one-way roads. It is possible to move along the roads from any intersection to any other intersection. The length of some path from one intersection to another is the number of roads that one has to traverse along the path. The shortest path from one intersection $$$v$$$ to another intersection $$$u$$$ is the path that starts in $$$v$$$, ends in $$$u$$$ and has the minimum length among all such paths.Polycarp lives near the intersection $$$s$$$ and works in a building near the intersection $$$t$$$. Every day he gets from $$$s$$$ to $$$t$$$ by car. Today he has chosen the following path to his workplace: $$$p_1$$$, $$$p_2$$$, ..., $$$p_k$$$, where $$$p_1 = s$$$, $$$p_k = t$$$, and all other elements of this sequence are the intermediate intersections, listed in the order Polycarp arrived at them. Polycarp never arrived at the same intersection twice, so all elements of this sequence are pairwise distinct. Note that you know Polycarp's path beforehand (it is fixed), and it is not necessarily one of the shortest paths from $$$s$$$ to $$$t$$$.Polycarp's car has a complex navigation system installed in it. Let's describe how it works. When Polycarp starts his journey at the intersection $$$s$$$, the system chooses some shortest path from $$$s$$$ to $$$t$$$ and shows it to Polycarp. Let's denote the next intersection in the chosen path as $$$v$$$. If Polycarp chooses to drive along the road from $$$s$$$ to $$$v$$$, then the navigator shows him the same shortest path (obviously, starting from $$$v$$$ as soon as he arrives at this intersection). However, if Polycarp chooses to drive to another intersection $$$w$$$ instead, the navigator rebuilds the path: as soon as Polycarp arrives at $$$w$$$, the navigation system chooses some shortest path from $$$w$$$ to $$$t$$$ and shows it to Polycarp. The same process continues until Polycarp arrives at $$$t$$$: if Polycarp moves along the road recommended by the system, it maintains the shortest path it has already built; but if Polycarp chooses some other path, the system rebuilds the path by the same rules.Here is an example. Suppose the map of Bertown looks as follows, and Polycarp drives along the path $$$[1, 2, 3, 4]$$$ ($$$s = 1$$$, $$$t = 4$$$): Check the picture by the link http://tk.codeforces.com/a.png   When Polycarp starts at $$$1$$$, the system chooses some shortest path from $$$1$$$ to $$$4$$$. There is only one such path, it is $$$[1, 5, 4]$$$;  Polycarp chooses to drive to $$$2$$$, which is not along the path chosen by the system. When Polycarp arrives at $$$2$$$, the navigator rebuilds the path by choosing some shortest path from $$$2$$$ to $$$4$$$, for example, $$$[2, 6, 4]$$$ (note that it could choose $$$[2, 3, 4]$$$);  Polycarp chooses to drive to $$$3$$$, which is not along the path chosen by the system. When Polycarp arrives at $$$3$$$, the navigator rebuilds the path by choosing the only shortest path from $$$3$$$ to $$$4$$$, which is $$$[3, 4]$$$;  Polycarp arrives at $$$4$$$ along the road chosen by the navigator, so the system does not have to rebuild anything. Overall, we get $$$2$$$ rebuilds in this scenario. Note that if the system chose $$$[2, 3, 4]$$$ instead of $$$[2, 6, 4]$$$ during the second step, there would be only $$$1$$$ rebuild (since Polycarp goes along the path, so the system maintains the path $$$[3, 4]$$$ during the third step).The example shows us that the number of rebuilds can differ even if the map of Bertown and the path chosen by Polycarp stays the same. Given this information (the map and Polycarp's path), can you determine the minimum and the maximum number of rebuilds that could have happened during the journey?","from collections import deque
n, m = map(int, input().split())
graph = [[] for _ in range(n + 1)]
inverse = [[] for _ in range(n + 1)]
for _ in range(m):
    u, v = map(int, input().split())
    graph[u].append(v)
    inverse[v].append(u)
k = int(input())
way = list(map(int, input().split()))
s = way[0]
t = way[-1]
queue = deque()
queue.append(t)
d = [0] * (n + 1)
used = [False] * (n + 1)
used[t] = True
while len(queue):
    cur = queue[0]
    queue.popleft()
    for to in inverse[cur]:
        if not used[to]:
            d[to] = d[cur] + 1
            queue.append(to)
            used[to] = True
ans_max = 0
ans_min = 0
for i in range(k - 1):
    if d[way[i]] > d[way[i + 1]]:
        to_min = -1
        for to in graph[way[i]]:
            if to != way[i + 1] and d[to] <= d[way[i + 1]]:
                to_min = to
        if to_min != -1:
            ans_max += 1
    else:
        ans_max += 1
        ans_min += 1
print(ans_min, ans_max)","['graphs', 'dfs and similar', 'shortest paths']"
"Patrick has just finished writing a message to his sweetheart Stacey when he noticed that the message didn't look fancy. Patrick was nervous while writing the message, so some of the letters there were lowercase and some of them were uppercase.Patrick believes that a message is fancy if any uppercase letter stands to the left of any lowercase one. In other words, this rule describes the strings where first go zero or more uppercase letters, and then — zero or more lowercase letters.To make the message fancy, Patrick can erase some letter and add the same letter in the same place in the opposite case (that is, he can replace an uppercase letter with the lowercase one and vice versa). Patrick got interested in the following question: what minimum number of actions do we need to make a message fancy? Changing a letter's case in the message counts as one action. Patrick cannot perform any other actions.","#!/usr/bin/env python

from sys import stdin

s = stdin.readline()
ans = 0
a = 0
for i in s:
    if i.islower():
        a += 1
    elif i.isupper() and a > 0:
        a -= 1
        ans += 1
print ans",['dp']
"Kate has a set $$$S$$$ of $$$n$$$ integers $$$\{1, \dots, n\} $$$. She thinks that imperfection of a subset $$$M \subseteq S$$$ is equal to the maximum of $$$gcd(a, b)$$$ over all pairs $$$(a, b)$$$ such that both $$$a$$$ and $$$b$$$ are in $$$M$$$ and $$$a \neq b$$$. Kate is a very neat girl and for each $$$k \in \{2, \dots, n\}$$$ she wants to find a subset that has the smallest imperfection among all subsets in $$$S$$$ of size $$$k$$$. There can be more than one subset with the smallest imperfection and the same size, but you don't need to worry about it. Kate wants to find all the subsets herself, but she needs your help to find the smallest possible imperfection for each size $$$k$$$, will name it $$$I_k$$$. Please, help Kate to find $$$I_2$$$, $$$I_3$$$, ..., $$$I_n$$$.","def get_primes(n):
    res = [2]
    arr = [True] * ((n - 1) // 2)
    i = 0
    for i in range(len(arr)):
        if arr[i]:
            a = i * 2 + 3
            res.append(a)
            for ii in range(i + a, len(arr), a):
                arr[ii] = False
    
    return res
 
if __name__ == ""__main__"":
    n = int(input())
    primes = get_primes(n)
    res = [""1""] * min(n - 1, len(primes))
    left = n - 1 - len(res)
    ii = 2
    while left > 0:
        for a in primes:
            if ii * a <= n:
                res.append(str(ii))
                left -= 1
            else:
                break
            if ii % a == 0 or left == 0:
                break
        ii += 1
    print("" "".join(res))","['greedy', 'two pointers', 'number theory', 'math', 'implementation', 'sortings']"
"After waking up at hh:mm, Andrew realised that he had forgotten to feed his only cat for yet another time (guess why there's only one cat). The cat's current hunger level is H points, moreover each minute without food increases his hunger by D points.At any time Andrew can visit the store where tasty buns are sold (you can assume that is doesn't take time to get to the store and back). One such bun costs C roubles and decreases hunger by N points. Since the demand for bakery drops heavily in the evening, there is a special 20% discount for buns starting from 20:00 (note that the cost might become rational). Of course, buns cannot be sold by parts.Determine the minimum amount of money Andrew has to spend in order to feed his cat. The cat is considered fed if its hunger level is less than or equal to zero.","import math

hh, mm = map(int, raw_input().split("" ""))
H, D, C, N = map(int, raw_input().split("" ""))

result = 0
if hh >= 20:
    result = int(math.ceil(H/float(N))) * ((4*C)/5.0)
else:
    rem = (20-hh-1)*60 + (60 - mm)

    now = int(math.ceil(H/float(N))) * C

    result = int(math.ceil((H+rem*D)/float(N))) * ((4*C)/5.0)
    result = min(result, now)


print result","['greedy', 'math']"
"Zookeeper is buying a carton of fruit to feed his pet wabbit. The fruits are a sequence of apples and oranges, which is represented by a binary string $$$s_1s_2\ldots s_n$$$ of length $$$n$$$. $$$1$$$ represents an apple and $$$0$$$ represents an orange.Since wabbit is allergic to eating oranges, Zookeeper would like to find the longest contiguous sequence of apples. Let $$$f(l,r)$$$ be the longest contiguous sequence of apples in the substring $$$s_{l}s_{l+1}\ldots s_{r}$$$. Help Zookeeper find $$$\sum_{l=1}^{n} \sum_{r=l}^{n} f(l,r)$$$, or the sum of $$$f$$$ across all substrings.","import sys
readline = sys.stdin.readline

N = int(readline())
A = list(map(int, readline().strip()))
def calc(l, r):
    m = (l+r)//2
    if l+1 == r:
        return A[l]
    if l+2 == r:
        return 2*(A[l]+A[l+1])
    X = A[l:m][::-1]
    Y = A[m:r]
    LX = len(X)
    LY = len(Y)
    a1 = [0]*LX
    a2 = [0]*LY
    pre = 1
    cnt = 0
    b1 = 0
    b2 = 0
    for i in range(LX):
        if X[i]:
            cnt += 1
            if pre:
                a1[i] = cnt
                b1 = cnt
            else:
                a1[i] = max(a1[i-1], cnt)
        else:
            pre = 0
            cnt = 0
            a1[i] = a1[i-1]
    pre = 1
    cnt = 0
    for i in range(LY):
        if Y[i]:
            cnt += 1
            if pre:
                a2[i] = cnt
                b2 = cnt
            else:
                a2[i] = max(a2[i-1], cnt)
        else:
            pre = 0
            cnt = 0
            a2[i] = a2[i-1]
    
    
    ra = LX-1
    rb = LY-1
    i = ra
    j = rb
    res = 0
    for _ in range(LX+LY):
        if a1[i] >= a2[j]:
            a = a1[i]
            if b1+b2 <= a:
                res += a*(j+1)
            elif a == b1:
                res += b1*b2 + b2*(b2+1)//2 + (b1+b2)*(j+1-b2)
            else:
                res += a*b2 + (b1+b2-a)*(b1+b2-a+1)//2+(b1+b2)*(j+1-b2)
            i -= 1
            b1 = min(b1, i+1)
        else:
            a = a2[j]
            if b1+b2 <= a:
                res += a*(i+1)
            elif a == b2:
                res += b1*b2 + b1*(b1+1)//2 + (b1+b2)*(i+1-b1)
            else:
                res += a*b1 + (b1+b2-a)*(b1+b2-a+1)//2+(b1+b2)*(i+1-b1)
            j -= 1
            b2 = min(b2, j+1)
        if i == -1 or j == -1:
            break
    return res + calc(l, m) + calc(m, r)

print(calc(0, N))","['dp', 'two pointers', 'divide and conquer', 'data structures', 'binary search']"
"In this problem you will have to help Berland army with organizing their command delivery system.There are $$$n$$$ officers in Berland army. The first officer is the commander of the army, and he does not have any superiors. Every other officer has exactly one direct superior. If officer $$$a$$$ is the direct superior of officer $$$b$$$, then we also can say that officer $$$b$$$ is a direct subordinate of officer $$$a$$$.Officer $$$x$$$ is considered to be a subordinate (direct or indirect) of officer $$$y$$$ if one of the following conditions holds:  officer $$$y$$$ is the direct superior of officer $$$x$$$;  the direct superior of officer $$$x$$$ is a subordinate of officer $$$y$$$. For example, on the picture below the subordinates of the officer $$$3$$$ are: $$$5, 6, 7, 8, 9$$$.The structure of Berland army is organized in such a way that every officer, except for the commander, is a subordinate of the commander of the army.Formally, let's represent Berland army as a tree consisting of $$$n$$$ vertices, in which vertex $$$u$$$ corresponds to officer $$$u$$$. The parent of vertex $$$u$$$ corresponds to the direct superior of officer $$$u$$$. The root (which has index $$$1$$$) corresponds to the commander of the army.Berland War Ministry has ordered you to give answers on $$$q$$$ queries, the $$$i$$$-th query is given as $$$(u_i, k_i)$$$, where $$$u_i$$$ is some officer, and $$$k_i$$$ is a positive integer.To process the $$$i$$$-th query imagine how a command from $$$u_i$$$ spreads to the subordinates of $$$u_i$$$. Typical DFS (depth first search) algorithm is used here.Suppose the current officer is $$$a$$$ and he spreads a command. Officer $$$a$$$ chooses $$$b$$$ — one of his direct subordinates (i.e. a child in the tree) who has not received this command yet. If there are many such direct subordinates, then $$$a$$$ chooses the one having minimal index. Officer $$$a$$$ gives a command to officer $$$b$$$. Afterwards, $$$b$$$ uses exactly the same algorithm to spread the command to its subtree. After $$$b$$$ finishes spreading the command, officer $$$a$$$ chooses the next direct subordinate again (using the same strategy). When officer $$$a$$$ cannot choose any direct subordinate who still hasn't received this command, officer $$$a$$$ finishes spreading the command.Let's look at the following example:  If officer $$$1$$$ spreads a command, officers receive it in the following order: $$$[1, 2, 3, 5 ,6, 8, 7, 9, 4]$$$.If officer $$$3$$$ spreads a command, officers receive it in the following order: $$$[3, 5, 6, 8, 7, 9]$$$.If officer $$$7$$$ spreads a command, officers receive it in the following order: $$$[7, 9]$$$.If officer $$$9$$$ spreads a command, officers receive it in the following order: $$$[9]$$$.To answer the $$$i$$$-th query $$$(u_i, k_i)$$$, construct a sequence which describes the order in which officers will receive the command if the $$$u_i$$$-th officer spreads it. Return the $$$k_i$$$-th element of the constructed list or -1 if there are fewer than $$$k_i$$$ elements in it.You should process queries independently. A query doesn't affect the following queries.","n,q=map(int,input().split())
from heapq import heappush as pu
from heapq import heappop as po
from bisect import bisect_right as br 

tr=[[] for i in range(n)]
size=[1 for i in range(n)]

p=list(map(int,input().split()))
p=[i-1 for i in p]

for i in range(n-1):
	tr[p[i]].append(i+1)
for i in range(n):
	tr[i].sort(reverse=True)

h={}
h[0]=0
s=[0]
m=[]
while s:
	x=s.pop()
	m.append(x)
	for i in tr[x]:
		s.append(i)
		h[i]=h[x]+1

d=[(i,h[i]) for i in range(n)]
d.sort(key=lambda x:x[1])
d=[i[0] for i in d]

for i in range(n-1,0,-1):
	size[p[d[i]-1]]+=size[d[i]]
ind={}
for i in range(n):
	ind[m[i]]=i
for _ in range(q):
	u,k=map(int,input().split())
	u-=1
	if k>size[u]:
		print(-1)
	else:
		i=ind[u]
		print(m[i+k-1]+1)","['dfs and similar', 'trees', 'graphs']"
"This problem is same as the next one, but has smaller constraints.Shiro's just moved to the new house. She wants to invite all friends of her to the house so they can play monopoly. However, her house is too small, so she can only invite one friend at a time.For each of the $$$n$$$ days since the day Shiro moved to the new house, there will be exactly one cat coming to the Shiro's house. The cat coming in the $$$i$$$-th day has a ribbon with color $$$u_i$$$. Shiro wants to know the largest number $$$x$$$, such that if we consider the streak of the first $$$x$$$ days, it is possible to remove exactly one day from this streak so that every ribbon color that has appeared among the remaining $$$x - 1$$$ will have the same number of occurrences.For example, consider the following sequence of $$$u_i$$$: $$$[2, 2, 1, 1, 5, 4, 4, 5]$$$. Then $$$x = 7$$$ makes a streak, since if we remove the leftmost $$$u_i = 5$$$, each ribbon color will appear exactly twice in the prefix of $$$x - 1$$$ days. Note that $$$x = 8$$$ doesn't form a streak, since you must remove exactly one day. Since Shiro is just a cat, she is not very good at counting and needs your help finding the longest streak.","maxn = 10**5 +11

n = int(input())
m = list(map(int, input().split()))

f = [0 for i in range(maxn)]
g = [set() for i in range(maxn)]

ans = 1

known = set()

for j in range(n):
    i = m[j]
    
    if i not in known:
        known.add(i)
        f[i] = 0
        g[f[i]].add(i)
    
    g[f[i]].remove(i)
    f[i] += 1
    g[f[i]].add(i)

    # print(len(g[f[i]-1]), (f[i]-1), len(g[f[i]]) , j)
    if f[i]-1 > 0 and len(g[f[i]-1])*(f[i]-1) + len(g[f[i]]) == j:
        ans = j+1

    if j+1 < n and len(g[f[i]])*f[i] == j+1:
        ans = j+2

    if len(g[f[i]]) == j+1:
        ans = j+1

    if len(g[f[i]+1]) == 1 and len(g[f[i]])*f[i] + f[i] == j:
        ans = j+1

    if len(g[f[i]])*f[i] == j:
        ans = j+1

    # if len(g[f[i]+1]) == 1 and len(g[f[i]])*f[i] == j:
    #     ans = j+1

print(ans)","['data structures', 'implementation']"
"Naruto has sneaked into the Orochimaru's lair and is now looking for Sasuke. There are $$$T$$$ rooms there. Every room has a door into it, each door can be described by the number $$$n$$$ of seals on it and their integer energies $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$. All energies $$$a_i$$$ are nonzero and do not exceed $$$100$$$ by absolute value. Also, $$$n$$$ is even.In order to open a door, Naruto must find such $$$n$$$ seals with integer energies $$$b_1$$$, $$$b_2$$$, ..., $$$b_n$$$ that the following equality holds: $$$a_{1} \cdot b_{1} + a_{2} \cdot b_{2} + ... + a_{n} \cdot b_{n} = 0$$$. All $$$b_i$$$ must be nonzero as well as $$$a_i$$$ are, and also must not exceed $$$100$$$ by absolute value. Please find required seals for every room there.","import os
import heapq
import sys,threading
import math
import bisect
import operator
from collections import defaultdict
sys.setrecursionlimit(10**5)
from io import BytesIO, IOBase
def gcd(a,b):
    if b==0:

        return a
    else:
        return gcd(b,a%b)
def power(x, p,m):
    res = 1
    while p:
        if p & 1:
            res = (res * x) % m
        x = (x * x) % m
        p >>= 1
    return res
def inar():
    return [int(k) for k in input().split()]

def lcm(num1,num2):
    return (num1*num2)//gcd(num1,num2)

def main():
    t=int(input())
    for _ in range(t):
        n=int(input())
        arr=inar()
        ans=[]

        for i in range(0,n,2):
            two=arr[i+1]
            one=arr[i]
            if (one>0 and two>0) or (one<0 and two<0):
                two=-1*(abs(two))
                ans.append(two)
                ans.append(abs(one))
            else:
                ans.append(abs(two))
                ans.append(abs(one))
        print(*ans)



BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
    #threadin.Thread(target=main).start()",['math']
"The Berland University is preparing to celebrate the 256-th anniversary of its founding! A specially appointed Vice Rector for the celebration prepares to decorate the campus. In the center of the campus n ice sculptures were erected. The sculptures are arranged in a circle at equal distances from each other, so they form a regular n-gon. They are numbered in clockwise order with numbers from 1 to n.The site of the University has already conducted a voting that estimated each sculpture's characteristic of ti — the degree of the sculpture's attractiveness. The values of ti can be positive, negative or zero.When the university rector came to evaluate the work, he said that this might be not the perfect arrangement. He suggested to melt some of the sculptures so that:   the remaining sculptures form a regular polygon (the number of vertices should be between 3 and n),  the sum of the ti values of the remaining sculptures is maximized. Help the Vice Rector to analyze the criticism — find the maximum value of ti sum which can be obtained in this way. It is allowed not to melt any sculptures at all. The sculptures can not be moved.","import math
n = int(input())
t = list(map(int, input().split()))
div = []
for i in range(1, int(math.sqrt(n)) + 1):
    if n % i == 0:
        if i * i != n:
            div.append(i)
            div.append(n // i)
        else: div.append(i)
m = -99999999
div.sort()
div.pop()
for i in div:
    s = 0
    c = i
    x = 0
    while c != 0:
        s = 0
        count = 0
        for j in range(x, n, i):
            count -= -1
            s += t[j]
        x += 1
        c -= 1
        if count >= 3:
            m = max(m, s)
print(m)","['number theory', '*special', 'brute force']"
"Recently a dog was bought for Polycarp. The dog's name is Cormen. Now Polycarp has a lot of troubles. For example, Cormen likes going for a walk. Empirically Polycarp learned that the dog needs at least k walks for any two consecutive days in order to feel good. For example, if k = 5 and yesterday Polycarp went for a walk with Cormen 2 times, today he has to go for a walk at least 3 times. Polycarp analysed all his affairs over the next n days and made a sequence of n integers a1, a2, ..., an, where ai is the number of times Polycarp will walk with the dog on the i-th day while doing all his affairs (for example, he has to go to a shop, throw out the trash, etc.).Help Polycarp determine the minimum number of walks he needs to do additionaly in the next n days so that Cormen will feel good during all the n days. You can assume that on the day before the first day and on the day after the n-th day Polycarp will go for a walk with Cormen exactly k times. Write a program that will find the minumum number of additional walks and the appropriate schedule — the sequence of integers b1, b2, ..., bn (bi ≥ ai), where bi means the total number of walks with the dog on the i-th day.","n,k=map(int,input().split())
a=[int(k) for k in input().split()]
walk=0
for i in range (1,n):
    if(a[i]+a[i-1]<k):
        walk+=(k-(a[i]+a[i-1]))
        a[i]=k-(a[i-1])

print(walk)
for i in a:
    print(i,end="" "")","['dp', 'greedy']"
"In one school with Vasya there is a student Kostya. Kostya does not like physics, he likes different online games. Every day, having come home, Kostya throws his bag in the farthest corner and sits down at his beloved computer. Kostya even eats glued to the game. A few days ago Kostya bought a new RPG game ""HaresButtle"", which differs from all other games in this genre. It has a huge number of artifacts. As we know, artifacts are divided into basic and composite ones. Only the basic artifacts are available on sale. More powerful composite artifacts are collected from some number of basic artifacts.After the composing composite artifact, all the components disappear.Kostya is the head of the alliance, so he has to remember, what artifacts has not only himself, but also his allies. You must identify by sequence of artifacts purchased by Kostya and his allies, how many and which artifacts has been collected by each of them. It is believed that initially no one has any artifacts.","k, n, m, q = [int(i) for i in input().split()]
basic = [input() for i in range(n)]

composite = {}
for i in range(m):
	name, items = input().split("":"")
	composite[name] = {}
	for item in items.split("",""):
		component, cnt = item.split()
		composite[name][component] = int(cnt)

friends = {}
for i in range(1, k+1):
	friends[str(i)] = {}
	for artifact in basic:
		friends[str(i)][artifact] = 0
	for artifact in composite.keys():
		friends[str(i)][artifact] = 0

for i in range(q):
	ai, artifact = input().split()
	friends[ai][artifact] += 1
	for artifact, combo in composite.items():
		if all(friends[ai][basic]==cnt for basic, cnt in combo.items()):
			for basic, cnt in combo.items():
				friends[ai][basic] -= cnt
			friends[ai][artifact] += 1
			break

for i in range(1, k+1):
	print(sum([i>0 for i in friends[str(i)].values()]))
	for artifact in sorted(friends[str(i)].keys()):
		if friends[str(i)][artifact] > 0:
			print(artifact, friends[str(i)][artifact])",['implementation']
"Phoenix has decided to become a scientist! He is currently investigating the growth of bacteria.Initially, on day $$$1$$$, there is one bacterium with mass $$$1$$$.Every day, some number of bacteria will split (possibly zero or all). When a bacterium of mass $$$m$$$ splits, it becomes two bacteria of mass $$$\frac{m}{2}$$$ each. For example, a bacterium of mass $$$3$$$ can split into two bacteria of mass $$$1.5$$$.Also, every night, the mass of every bacteria will increase by one.Phoenix is wondering if it is possible for the total mass of all the bacteria to be exactly $$$n$$$. If it is possible, he is interested in the way to obtain that mass using the minimum possible number of nights. Help him become the best scientist!","for _ in range(int(input())):
    arr = []
    n = int(input())
    x = 1
    while x < n:
        arr.append(x)
        n -= x
        x *= 2
    if n > 0:
        arr.append(n)
    arr.sort()
    s = []
    print(len(arr)-1)
    for i in range(len(arr)-1):
        s.append(arr[i+1]-arr[i])
    print(*s)","['greedy', 'constructive algorithms', 'math', 'implementation', 'binary search']"
"Ashishgup and FastestFinger play a game. They start with a number $$$n$$$ and play in turns. In each turn, a player can make any one of the following moves:  Divide $$$n$$$ by any of its odd divisors greater than $$$1$$$.  Subtract $$$1$$$ from $$$n$$$ if $$$n$$$ is greater than $$$1$$$. Divisors of a number include the number itself.The player who is unable to make a move loses the game.Ashishgup moves first. Determine the winner of the game if both of them play optimally.","for t in range(int(input())):
	n = int(input())
	N = n
	
	if n == 1:
		winner = 2
	elif n == 2 or n % 2 != 0:
		winner = 1
	else:
		numTwo = 0

		while n % 2 == 0:
			n //= 2
			numTwo += 1

		numOdd = 0

		for i in range(3, int(N ** 0.5 + 2), 2):
			while n > 0 and n % i == 0:
				n //= i
				numOdd += 1

		# print(n)
		if n > 2:
			numOdd += 1

		if numOdd == 0 and numTwo > 1:
			winner = 2
		elif numOdd == 1 and numTwo == 1:
			winner = 2
		else:
			winner = 1

	if winner == 1:
		print(""Ashishgup"")

	else:
		print(""FastestFinger"")","['number theory', 'games', 'math']"
"Important: All possible tests are in the pretest, so you shouldn't hack on this problem. So, if you passed pretests, you will also pass the system test.You are an adventurer currently journeying inside an evil temple. After defeating a couple of weak monsters, you arrived at a square room consisting of tiles forming an n × n grid, surrounded entirely by walls. At the end of the room lies a door locked with evil magical forces. The following inscriptions are written on the door: The sound of clashing rocks will awaken the door! Being a very senior adventurer, you immediately realize what this means. In the room next door lies an infinite number of magical rocks. There are four types of rocks:   '^': this rock moves upwards;  '&lt;': this rock moves leftwards;  '&gt;': this rock moves rightwards;  'v': this rock moves downwards. To open the door, you first need to place the rocks on some of the tiles (one tile can be occupied by at most one rock). Then, you select a single rock that you have placed and activate it. The activated rock will then move in its direction until it hits another rock or hits the walls of the room (the rock will not move if something already blocks it in its chosen direction). The rock then deactivates. If it hits the walls, or if there have been already 107 events of rock becoming activated, the movements end. Otherwise, the rock that was hit becomes activated and this procedure is repeated.If a rock moves at least one cell before hitting either the wall or another rock, the hit produces a sound. The door will open once the number of produced sounds is at least x. It is okay for the rocks to continue moving after producing x sounds.The following picture illustrates the four possible scenarios of moving rocks. Moves at least one cell, then hits another rock. A sound is produced, the hit rock becomes activated.   Moves at least one cell, then hits the wall (i.e., the side of the room). A sound is produced, the movements end.   Does not move because a rock is already standing in the path. The blocking rock becomes activated, but no sounds are produced.   Does not move because the wall is in the way. No sounds are produced and the movements end.  Assume there's an infinite number of rocks of each type in the neighboring room. You know what to do: place the rocks and open the door!","r, c = map(int, input().split())
if r == 3:
    print('>vv')
    print('^<.')
    print('^.<')
    print('1 3')
elif r == 5:
    print('>...v')
    print('v.<..')
    print('..^..')
    print('>....')
    print('..^.<')
    print('1 1')
elif r == 100:
    for i in range(25):
        print('>'*50+'.>'*24+'.v')
        print('^'+'<.'*25+'<'*49)
        print('v.'+'<.'*24+'<'*50)
        print('>'*49+'.>'*25+'^')
    print('1 1')
else:
    d = []
    d[1] = 1",['constructive algorithms']
"The sequence of $$$m$$$ integers is called the permutation if it contains all integers from $$$1$$$ to $$$m$$$ exactly once. The number $$$m$$$ is called the length of the permutation.Dreamoon has two permutations $$$p_1$$$ and $$$p_2$$$ of non-zero lengths $$$l_1$$$ and $$$l_2$$$.Now Dreamoon concatenates these two permutations into another sequence $$$a$$$ of length $$$l_1 + l_2$$$. First $$$l_1$$$ elements of $$$a$$$ is the permutation $$$p_1$$$ and next $$$l_2$$$ elements of $$$a$$$ is the permutation $$$p_2$$$. You are given the sequence $$$a$$$, and you need to find two permutations $$$p_1$$$ and $$$p_2$$$. If there are several possible ways to restore them, you should find all of them. (Note that it is also possible that there will be no ways.)","import os, sys, atexit
from io import BytesIO, StringIO
 
input = BytesIO(os.read(0, os.fstat(0).st_size)).readline
_OUTPUT_BUFFER = StringIO()
sys.stdout = _OUTPUT_BUFFER
 
@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())
t = int(input())
while t:
    t += -1
    n = int(input())
    l = list(map(int, input().split()))
    count = [0] * (n + 1)
    for i in l: count[i] -= -1
    l1 = 0
    l2 = 0
    ch = 0
    for i in range(1, n + 1):
        if count[i] == 2: l1 = i
        else: break
    l2 = n - l1
    p1 = [0] * (l1 + 1)
    p2 = [0] * (l2 + 1)
    
    for i in range(l1):
        if l[i] > l1:
            ch = 1
            break
        p1[l[i]] = 1
    for i in range(l1, n):
        if l[i] > l2:
            ch = 1
            break
        p2[l[i]] = 1
    ch1 = 1
    ch2 = 1
    if 0 in p1[1: l1 + 1] or 0 in p2[1: l2 + 1] or ch: ch1 = 0
    
    
    l1, l2 = l2, l1
    p1 = [0] * (l1 + 1)
    p2 = [0] * (l2 + 1)
    ch = 0
    for i in range(l1):
        if l[i] > l1:
            ch = 1
            break
        p1[l[i]] = 1
    for i in range(l1, n):
        if l[i] > l2:
            ch = 1
            break
        p2[l[i]] = 1
    if 0 in p1[1: l1 + 1] or 0 in p2[1: l2 + 1] or ch: ch2 = 0
    if ch1:
        if ch2:
            if l1 != l2:
                print(2)
                print(l1, l2)
                print(l2, l1)
            else:
                print(1)
                print(l1, l2)
        else:
            print(1)
            print(l2, l1)
    else:
        if ch2:
            print(1)
            print(l1, l2)
        else:
            print(0)","['implementation', 'math']"
"Vasya decided to pass a very large integer n to Kate. First, he wrote that number as a string, then he appended to the right integer k — the number of digits in n. Magically, all the numbers were shuffled in arbitrary order while this note was passed to Kate. The only thing that Vasya remembers, is a non-empty substring of n (a substring of n is a sequence of consecutive digits of the number n).Vasya knows that there may be more than one way to restore the number n. Your task is to find the smallest possible initial integer n. Note that decimal representation of number n contained no leading zeroes, except the case the integer n was equal to zero itself (in this case a single digit 0 was used).","import sys

def main():
    a = sys.stdin.readline().strip()
    b = sys.stdin.readline().strip()

    if a == ""01"" or a == ""10"":
        print(""0"")
        return

    cnt = [0] * 256
    for i in map(ord, a):
        cnt[i] += 1
    n = sum(cnt)

    l = 0
    for i in range(1, 8):
        if i == len(str(n - i)):
            l = n - i
            break;

    for s in b, str(l):
        for i in map(ord, s):
            cnt[i] -= 1

    res = ["""".join([b] + [chr(k) * v for k, v in enumerate(cnt) if v > 0 ])] if b[0] > ""0"" else []

    for i in range(ord(""1""), ord(""9"") + 1):
        if cnt[i] > 0:
            cnt[i] -= 1
            others = [chr(k) * v for k, v in enumerate(cnt) if v > 0]
            others.append(b)
            res.append("""".join([chr(i)] + sorted(others)))
            break

    print(min(res))

if __name__ == ""__main__"":
    main()","['constructive algorithms', 'brute force', 'strings']"
"Professor GukiZ doesn't accept string as they are. He likes to swap some letters in string to obtain a new one.GukiZ has strings a, b, and c. He wants to obtain string k by swapping some letters in a, so that k should contain as many non-overlapping substrings equal either to b or c as possible. Substring of string x is a string formed by consecutive segment of characters from x. Two substrings of string x overlap if there is position i in string x occupied by both of them.GukiZ was disappointed because none of his students managed to solve the problem. Can you help them and find one of possible strings k?","__author__ = 'trunghieu11'

from string import ascii_lowercase

def main():
    s = raw_input()
    a = raw_input()
    b = raw_input()

    totalS = dict()
    totalA = dict()
    totalB = dict()
    for c in ascii_lowercase:
        totalS.setdefault(c, s.count(c))
        totalA.setdefault(c, a.count(c))
        totalB.setdefault(c, b.count(c))

    maxA = min(totalS[c] / totalA[c] for c in ascii_lowercase if totalA[c] > 0)
    maxVal = [0, 0]
    for i in range(maxA + 1):
        tempS = totalS.copy()
        for c in ascii_lowercase:
            if totalA[c] > 0:
                tempS[c] -= totalA[c] * i
        remainB = min(tempS[c] / totalB[c] for c in ascii_lowercase if totalB[c] > 0)
        for c in ascii_lowercase:
            if totalB[c] > 0:
                tempS[c] -= totalB[c] * remainB
        if maxVal[0] + maxVal[1] < i + remainB:
            maxVal = [i, remainB]

    answer = maxVal[0] * a + maxVal[1] * b
    for c in ascii_lowercase:
        answer += c * (totalS[c] - totalA[c] * maxVal[0] - totalB[c] * maxVal[1])
    print answer


if __name__ == '__main__':
    main()","['constructive algorithms', 'implementation', 'brute force', 'strings']"
"Finally, a basketball court has been opened in SIS, so Demid has decided to hold a basketball exercise session. $$$2 \cdot n$$$ students have come to Demid's exercise session, and he lined up them into two rows of the same size (there are exactly $$$n$$$ people in each row). Students are numbered from $$$1$$$ to $$$n$$$ in each row in order from left to right.  Now Demid wants to choose a team to play basketball. He will choose players from left to right, and the index of each chosen player (excluding the first one taken) will be strictly greater than the index of the previously chosen player. To avoid giving preference to one of the rows, Demid chooses students in such a way that no consecutive chosen students belong to the same row. The first student can be chosen among all $$$2n$$$ students (there are no additional constraints), and a team can consist of any number of students. Demid thinks, that in order to compose a perfect team, he should choose students in such a way, that the total height of all chosen students is maximum possible. Help Demid to find the maximum possible total height of players in a team he can choose.","n = int(input())
masiv = []
for i in range(2):
    lst = [0] + list(map(int, input().split())) 
    masiv.append(lst)
lst_1 = [0] * (n + 1)
lst_2 = [0] * (n + 1)
lst_1[1] = masiv[0][1]
lst_2[1] = masiv[1][1]
for j in range(2, n + 1):
    lst_1[j] = max(lst_2[j - 1], lst_2[j - 2]) + masiv[0][j]
    lst_2[j] = max(lst_1[j - 1], lst_1[j - 2]) + masiv[1][j]
ans = 0
for f in lst_1:
    ans = max(ans, f)
for k in lst_2:
    ans = max(ans, k)
print(ans)",['dp']
"Levko loves array a1, a2, ... , an, consisting of integers, very much. That is why Levko is playing with array a, performing all sorts of operations with it. Each operation Levko performs is of one of two types:  Increase all elements from li to ri by di. In other words, perform assignments aj = aj + di for all j that meet the inequation li ≤ j ≤ ri.  Find the maximum of elements from li to ri. That is, calculate the value . Sadly, Levko has recently lost his array. Fortunately, Levko has records of all operations he has performed on array a. Help Levko, given the operation records, find at least one suitable array. The results of all operations for the given array must coincide with the record results. Levko clearly remembers that all numbers in his array didn't exceed 109 in their absolute value, so he asks you to find such an array.","import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
INF = 10 ** 18
MOD = 10**9+7

Ri = lambda : [int(x) for x in sys.stdin.readline().split()]
ri = lambda : sys.stdin.readline().strip()

n,m = Ri()
lis = []
for i in range(m):
    lis.append(Ri())
ans = [10**9]*n
for i in range(m-1,-1,-1):
    if lis[i][0] == 2:
        for j in range(lis[i][1]-1,lis[i][2]):
            ans[j] = min(ans[j], lis[i][3])
    else:
        for j in range(lis[i][1]-1,lis[i][2]):
            if ans[j] != 10**9:
                ans[j]-=lis[i][3]

for i in range(n):
    if ans[i] == 10**9:
        ans[i] = -10**9
temp = ans[:]
# print(temp)
flag = True
for i in range(m):
    if lis[i][0] == 2:
        t= -10**9
        for j in range(lis[i][1]-1,lis[i][2]):
            t = max(t, temp[j])
        if t != lis[i][3]:
            flag = False
            break
    else:
        for j in range(lis[i][1]-1,lis[i][2]):
            temp[j]+=lis[i][3]
# print(temp, ans)
if flag :
    YES()
    print(*ans)
else:
    NO()
    # print(-1)","['implementation', 'greedy']"
"You are given an array of n elements, you must make it a co-prime array in as few moves as possible.In each move you can insert any positive integral number you want not greater than 109 in any place in the array.An array is co-prime if any two adjacent numbers of it are co-prime.In the number theory, two integers a and b are said to be co-prime if the only positive integer that divides both of them is 1.","def gcd(a,b):
    if b==0:return a
    return gcd(b,a%b)
n=int(raw_input())
a=map(int,raw_input().split())
ind=0
co=0
while ind<len(a)-1:
    if gcd(a[ind],a[ind+1])!=1:
        u=gcd(a[ind],a[ind+1])
        a.insert(ind+1,1)
        ind+=2
        co+=1
    else:ind+=1
print co
print ' '.join(map(str,a))","['implementation', 'number theory', 'greedy', 'math']"
"We have a string of letters 'a' and 'b'. We want to perform some operations on it. On each step we choose one of substrings ""ab"" in the string and replace it with the string ""bba"". If we have no ""ab"" as a substring, our job is done. Print the minimum number of steps we should perform to make our job done modulo 109 + 7.The string ""ab"" appears as a substring if there is a letter 'b' right after the letter 'a' somewhere in the string.","def f():
    M = 10**9+7
    A, B = 'a', 'b'
    s = raw_input().strip()
    res, start, end = 0, 0, len(s)-1
    cntb = 0
    for c in s[::-1]:
        if c == B: 
            cntb+=1
        else:
            res, cntb = (res+cntb)%M, (cntb<<1)%M
    print res

f()",['combinatorics']
"ZS the Coder and Chris the Baboon are travelling to Udayland! To get there, they have to get on the special IOI bus. The IOI bus has n rows of seats. There are 4 seats in each row, and the seats are separated into pairs by a walkway. When ZS and Chris came, some places in the bus was already occupied.ZS and Chris are good friends. They insist to get a pair of neighbouring empty seats. Two seats are considered neighbouring if they are in the same row and in the same pair. Given the configuration of the bus, can you help ZS and Chris determine where they should sit?","n = int(raw_input())
rows = n * [ None ]
found = False
for i in range(n):
    row = raw_input().strip()
    if not found and 'OO' in row:
        row = row.replace('OO', '++', 1)
        found = True
    rows[i] = row
if not found:
    print('NO')
else:
    print('YES')
    print('\n'.join(rows))","['implementation', 'brute force']"
"A dice is a cube, its faces contain distinct integers from 1 to 6 as black points. The sum of numbers at the opposite dice faces always equals 7. Please note that there are only two dice (these dices are mirror of each other) that satisfy the given constraints (both of them are shown on the picture on the left).  Alice and Bob play dice. Alice has built a tower from n dice. We know that in this tower the adjacent dice contact with faces with distinct numbers. Bob wants to uniquely identify the numbers written on the faces of all dice, from which the tower is built. Unfortunately, Bob is looking at the tower from the face, and so he does not see all the numbers on the faces. Bob sees the number on the top of the tower and the numbers on the two adjacent sides (on the right side of the picture shown what Bob sees).Help Bob, tell whether it is possible to uniquely identify the numbers on the faces of all the dice in the tower, or not.","d ={1:6,
	2:5,
	3:4,
	4:3,
	5:2,
	6:1}
n=int(input())
x=int(input())
a=[]
b=[]
res='YES'
for i in range(n):
	s=list(map(int,input().split()))
	if d[x] in s:
		res='NO'
	elif x in s:
		res='NO'
print(res)","['constructive algorithms', 'greedy']"
"Having written another programming contest, three Rabbits decided to grab some lunch. The coach gave the team exactly k time units for the lunch break.The Rabbits have a list of n restaurants to lunch in: the i-th restaurant is characterized by two integers fi and ti. Value ti shows the time the Rabbits need to lunch in the i-th restaurant. If time ti exceeds the time k that the coach has given for the lunch break, then the Rabbits' joy from lunching in this restaurant will equal fi - (ti - k). Otherwise, the Rabbits get exactly fi units of joy.Your task is to find the value of the maximum joy the Rabbits can get from the lunch, depending on the restaurant. The Rabbits must choose exactly one restaurant to lunch in. Note that the joy value isn't necessarily a positive value.","n,k=list(map(int,input().split()))
l=[]
for i in range(n):
    a,b=list(map(int,input().split()))
    if b<=k:
        l +=[a]
    else:
        l +=[a-(b-k)]
else:
    print(max(l))",['implementation']
"There are $$$n$$$ bags with candies, initially the $$$i$$$-th bag contains $$$i$$$ candies. You want all the bags to contain an equal amount of candies in the end. To achieve this, you will: Choose $$$m$$$ such that $$$1 \le m \le 1000$$$Perform $$$m$$$ operations. In the $$$j$$$-th operation, you will pick one bag and add $$$j$$$ candies to all bags apart from the chosen one.Your goal is to find a valid sequence of operations after which all the bags will contain an equal amount of candies. It can be proved that for the given constraints such a sequence always exists.You don't have to minimize $$$m$$$.If there are several valid sequences, you can output any.","t = int(input())
def solve():
    n = int(input())
    print(n)
    arr = list(range(1, n + 1))
    arr = [str(i) for i in arr]
    print("" "".join(arr))
for i in range(t):
    solve()","['constructive algorithms', 'math']"
"You are given an array $$$a$$$ consisting of $$$n$$$ integers.You can remove at most one element from this array. Thus, the final length of the array is $$$n-1$$$ or $$$n$$$.Your task is to calculate the maximum possible length of the strictly increasing contiguous subarray of the remaining array.Recall that the contiguous subarray $$$a$$$ with indices from $$$l$$$ to $$$r$$$ is $$$a[l \dots r] = a_l, a_{l + 1}, \dots, a_r$$$. The subarray $$$a[l \dots r]$$$ is called strictly increasing if $$$a_l &lt; a_{l+1} &lt; \dots &lt; a_r$$$.","#Remove one element
n = int(input())
l = list(map(int,input().split()))
p = [0]*n
z = [0]*n
i = 0
d = 1
while i < len(l):
    cnt = 1
    pi = i
    pj = i+1
    while pj < len(l):
        if l[pj] > l[pi]:
            cnt += 1

        else:
            break

        pj += 1
        pi += 1

    j = i
    k1 = 1
    k2 = cnt
    while k1 <= cnt:
        p[j] = (k1,k2)
        z[j] = d
        k1 += 1
        k2 -= 1
        j += 1

    i = j
    d += 1

m = 0
#print(z)
#print(p)
for i in range(n):
    if i < 2:
        x = p[i][1]

    else:
        e1 = p[i][1]
        e2 = -1
        if l[i] > l[i-2] and z[i-2] != z[i]:
            e2 = e1+p[i-2][0]

        x = max(e1,e2)

    if x > m:
        m = x

print(m)","['dp', 'brute force']"
"You are given two arrays $$$a_1, a_2, \dots , a_n$$$ and $$$b_1, b_2, \dots , b_m$$$. Array $$$b$$$ is sorted in ascending order ($$$b_i &lt; b_{i + 1}$$$ for each $$$i$$$ from $$$1$$$ to $$$m - 1$$$).You have to divide the array $$$a$$$ into $$$m$$$ consecutive subarrays so that, for each $$$i$$$ from $$$1$$$ to $$$m$$$, the minimum on the $$$i$$$-th subarray is equal to $$$b_i$$$. Note that each element belongs to exactly one subarray, and they are formed in such a way: the first several elements of $$$a$$$ compose the first subarray, the next several elements of $$$a$$$ compose the second subarray, and so on.For example, if $$$a = [12, 10, 20, 20, 25, 30]$$$ and $$$b = [10, 20, 30]$$$ then there are two good partitions of array $$$a$$$:   $$$[12, 10, 20], [20, 25], [30]$$$;  $$$[12, 10], [20, 20, 25], [30]$$$. You have to calculate the number of ways to divide the array $$$a$$$. Since the number can be pretty large print it modulo 998244353.","n,m=map(int,input().split())
ans=1
mod=998244353
a=list(map(int,input().split()))
b=list(map(int,input().split()))
i=n-1
j=m-1
while ans and j>=0:
    cnt=0
    while i>=0 and a[i]>=b[j]:
        if cnt:cnt+=1
        elif a[i]==b[j]:cnt=1
        i-=1
    if j==0:
        cnt=min(cnt,1)
        if i>=0:cnt=0
    ans=(ans*cnt)%mod
    j-=1
print(ans)","['dp', 'constructive algorithms', 'two pointers', 'combinatorics', 'binary search', 'brute force']"
"You are given a tree consisting of $$$n$$$ vertices. A tree is an undirected connected acyclic graph.    Example of a tree. You have to paint each vertex into one of three colors. For each vertex, you know the cost of painting it in every color.You have to paint the vertices so that any path consisting of exactly three distinct vertices does not contain any vertices with equal colors. In other words, let's consider all triples $$$(x, y, z)$$$ such that $$$x \neq y, y \neq z, x \neq z$$$, $$$x$$$ is connected by an edge with $$$y$$$, and $$$y$$$ is connected by an edge with $$$z$$$. The colours of $$$x$$$, $$$y$$$ and $$$z$$$ should be pairwise distinct. Let's call a painting which meets this condition good.You have to calculate the minimum cost of a good painting and find one of the optimal paintings. If there is no good painting, report about it.","from collections import defaultdict, deque
from itertools import permutations


class Graph:
    def __init__(self):
        self.E = {}
        self.V = defaultdict(list)

    def put(self, v1, v2):
        if v1 not in self.E:
            self.E[v1] = 1
        if v2 not in self.E:
            self.E[v2] = 1
        self.V[v1].append(v2)
        self.V[v2].append(v1)

    def _adj(self, v1):
        return self.V[v1]

    def bfs(self, v):
        visited = set([v])
        path = [v]
        q = deque([v])
        while q:
            v1 = q.pop()
            for v2 in self._adj(v1):
                if v2 not in visited:
                    visited.add(v2)
                    path.append(v2)
                    q.appendleft(v2)

        return path


if __name__ == '__main__':
    n = int(input())
    cp = []
    for _ in range(3):
        cp.append(list(map(int, input().split(' '))))

    inv = False
    vert = defaultdict(int)
    graph = Graph()
    for _ in range(n - 1):
        v1, v2 = map(int, input().split(' '))
        vert[v1] += 1
        if vert[v1] > 2:
            inv = True
            break
        vert[v2] += 1
        if vert[v2] > 2:
            inv = True
            break

        graph.put(v1, v2)

    if inv:
        print(-1)
    else:
        for key in vert:
            if vert[key] == 1:
                start = key
                break

        path = graph.bfs(start)

        min_cost = float('inf')
        min_cost_perm = (0, 1, 2)
        for p in permutations([0, 1, 2]):
            cur_cost = 0
            for i, v in enumerate(path):
                cur_cost += cp[p[i % 3]][v - 1]

            if cur_cost < min_cost:
                min_cost_perm = p
                min_cost = cur_cost

        # print(path, graph.V)
        ans = [0]*n
        for i, v in enumerate(path):
            ans[v - 1] = min_cost_perm[i % 3] + 1

        print(min_cost)
        print(' '.join(map(str, ans)))","['dp', 'graphs', 'constructive algorithms', 'implementation', 'trees', 'brute force']"
"The Fair Nut likes kvass very much. On his birthday parents presented him $$$n$$$ kegs of kvass. There are $$$v_i$$$ liters of kvass in the $$$i$$$-th keg. Each keg has a lever. You can pour your glass by exactly $$$1$$$ liter pulling this lever. The Fair Nut likes this drink very much, so he wants to pour his glass by $$$s$$$ liters of kvass. But he wants to do it, so kvass level in the least keg is as much as possible.Help him find out how much kvass can be in the least keg or define it's not possible to pour his glass by $$$s$$$ liters of kvass.","n, s = map(int, input().split())
arr = list(map(int, input().split()))


sno = arr[0]
for i in range(0, len(arr)):
    if arr[i] < sno:
        sno = arr[i]
for i in range(0, len(arr)):
    if arr[i]-sno < s:
        s -= (arr[i]-sno)
        arr[i] = sno
    else:
        print(sno)
        exit()
if s == 0:
    print(sno)
    exit()
while s > 0:
    if(s>1000*n):
        s-=1000*n
        sno-=1000
    elif(s>100*n):
        s -= 100*n
        sno -= 100
    elif(s>10*n):
        s-=10*n
        sno-=10
    elif(s>0):
        s-=n
        sno-=1
    if(sno<0):
        print(""-1"")
        exit()

print(sno)","['implementation', 'greedy']"
"Today Johnny wants to increase his contribution. His plan assumes writing $$$n$$$ blogs. One blog covers one topic, but one topic can be covered by many blogs. Moreover, some blogs have references to each other. Each pair of blogs that are connected by a reference has to cover different topics because otherwise, the readers can notice that they are split just for more contribution. Set of blogs and bidirectional references between some pairs of them is called blogs network.There are $$$n$$$ different topics, numbered from $$$1$$$ to $$$n$$$ sorted by Johnny's knowledge. The structure of the blogs network is already prepared. Now Johnny has to write the blogs in some order. He is lazy, so each time before writing a blog, he looks at it's already written neighbors (the blogs referenced to current one) and chooses the topic with the smallest number which is not covered by neighbors. It's easy to see that this strategy will always allow him to choose a topic because there are at most $$$n - 1$$$ neighbors.For example, if already written neighbors of the current blog have topics number $$$1$$$, $$$3$$$, $$$1$$$, $$$5$$$, and $$$2$$$, Johnny will choose the topic number $$$4$$$ for the current blog, because topics number $$$1$$$, $$$2$$$ and $$$3$$$ are already covered by neighbors and topic number $$$4$$$ isn't covered.As a good friend, you have done some research and predicted the best topic for each blog. Can you tell Johnny, in which order he has to write the blogs, so that his strategy produces the topic assignment chosen by you?","'''import os,io
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
I= lambda: list(map(int,input().split()))'''
import os,io
from sys import stdout
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
I=lambda:list(map(int,input().split()))
n,edge=I()
go=[[] for _ in range(n+1)]
for _ in range(edge):    
    a,b=I()
    go[a].append(b)
    go[b].append(a)
s=I()

arr=[]
for i,x in enumerate(list(s)):
    i+=1
    arr.append((x,i))
arr.sort()
#count=[set() for _ in range(n+1)]
count=[0]*(n+1)
gone=[False]*(n+1)
ans=[]
for topic,blog in arr:
    gone[blog]=True
    if count[blog]+1!=topic:
        print(-1)
        exit()
    ans.append(blog)
    for x in go[blog]:
        if gone[x]==False and count[x] not in (topic-1,topic):
            print(-1)
            exit()
        count[x]=topic

print(' '.join([str(x) for x in ans]))","['greedy', 'graphs', 'constructive algorithms', 'implementation', 'sortings']"
"An army of n droids is lined up in one row. Each droid is described by m integers a1, a2, ..., am, where ai is the number of details of the i-th type in this droid's mechanism. R2-D2 wants to destroy the sequence of consecutive droids of maximum length. He has m weapons, the i-th weapon can affect all the droids in the army by destroying one detail of the i-th type (if the droid doesn't have details of this type, nothing happens to it). A droid is considered to be destroyed when all of its details are destroyed. R2-D2 can make at most k shots. How many shots from the weapon of what type should R2-D2 make to destroy the sequence of consecutive droids of maximum length?","from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline
 
# M = mod = 998244353
# def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
# def inv_mod(n):return pow(n, mod - 2, mod)
 
def li():return [int(i) for i in input().rstrip('\n').split()]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n').split(' ')]
def li3():return [int(i) for i in input().rstrip('\n')]

def givediff(a,b):
    return sum(max(i,j) for i,j in zip(b,a))

n, m, k = li()
l = []
for i in range(n):l.append(li())





l1 = [deque() for i in range(m)]
for i in range(m):l1[i].append([0,l[0][i]])


i, j = 0, 1
ans = 0
perm = [0]*m if sum(l[0]) > k else l[0][:]

curr = l[0][:]
while j != n:


    for itr in range(m):
        while len(l1[itr]) and l1[itr][-1][-1] <= l[j][itr]:
            l1[itr].pop()
        l1[itr].append([j,l[j][itr]])




    while i < j and givediff(curr,l[j]) > k:
        i += 1
    
        for itr in range(m):
            while l1[itr][0][0] < i:l1[itr].popleft()
            curr[itr] = l1[itr][0][-1]




    for itr in range(m):curr[itr] = l1[itr][0][-1]




    if ans < j - i + 1 and givediff(l[j],curr) <= k:
        ans = j - i + 1
        perm = [max(a,b) for a,b in zip(l[j],curr)]

    j += 1
    # print(l1,'\n\n\n\n',l[j-1],curr,j,i,ans)
# print(ans)
print(*perm)","['data structures', 'two pointers', 'binary search']"
"Max wants to buy a new skateboard. He has calculated the amount of money that is needed to buy a new skateboard. He left a calculator on the floor and went to ask some money from his parents. Meanwhile his little brother Yusuf came and started to press the keys randomly. Unfortunately Max has forgotten the number which he had calculated. The only thing he knows is that the number is divisible by 4.You are given a string s consisting of digits (the number on the display of the calculator after Yusuf randomly pressed the keys). Your task is to find the number of substrings which are divisible by 4. A substring can start with a zero.A substring of a string is a nonempty sequence of consecutive characters.For example if string s is 124 then we have four substrings that are divisible by 4: 12, 4, 24 and 124. For the string 04 the answer is three: 0, 4, 04.As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use gets/scanf/printf instead of getline/cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java.","def main():
  a=input()
  a=list(a)
  summ=0
  for i in range(len(a)):
    if int(a[i])%4==0:
      summ+=1
    if i!=0 and int(''.join(k for k in a[i-1:i+1]))%4==0:
      summ+=i
  return summ

print(main())",['dp']
"Phoenix is picking berries in his backyard. There are $$$n$$$ shrubs, and each shrub has $$$a_i$$$ red berries and $$$b_i$$$ blue berries.Each basket can contain $$$k$$$ berries. But, Phoenix has decided that each basket may only contain berries from the same shrub or berries of the same color (red or blue). In other words, all berries in a basket must be from the same shrub or/and have the same color.For example, if there are two shrubs with $$$5$$$ red and $$$2$$$ blue berries in the first shrub and $$$2$$$ red and $$$1$$$ blue berries in the second shrub then Phoenix can fill $$$2$$$ baskets of capacity $$$4$$$ completely:   the first basket will contain $$$3$$$ red and $$$1$$$ blue berries from the first shrub;  the second basket will contain the $$$2$$$ remaining red berries from the first shrub and $$$2$$$ red berries from the second shrub. Help Phoenix determine the maximum number of baskets he can fill completely!","import sys

sys.setrecursionlimit(10 ** 6)
int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

def main():
    n,k=MI()
    ab=LLI(n)
    pre=1
    sa=sb=0
    mask=(1<<k)-1
    for a,b in ab:
        sa+=a
        sb+=b
        if a+b<k:continue
        mn=max(k-b,0)
        mx=min(a,k-1)
        now=pre
        for s in range(mn,mx+1):
            now|=pre<<s
        now|=now>>k
        now&=mask
        pre=now
        #print(bin(pre))
    ans=0
    for r in range(k):
        if pre >> r & 1: ans = max(ans, (sa - r) // k + (sb + r) // k)
    print(ans)

main()","['dp', 'greedy', 'math', 'brute force']"
"Petya has a rectangular Board of size $$$n \times m$$$. Initially, $$$k$$$ chips are placed on the board, $$$i$$$-th chip is located in the cell at the intersection of $$$sx_i$$$-th row and $$$sy_i$$$-th column.In one action, Petya can move all the chips to the left, right, down or up by $$$1$$$ cell.If the chip was in the $$$(x, y)$$$ cell, then after the operation:   left, its coordinates will be $$$(x, y - 1)$$$;  right, its coordinates will be $$$(x, y + 1)$$$;  down, its coordinates will be $$$(x + 1, y)$$$;  up, its coordinates will be $$$(x - 1, y)$$$. If the chip is located by the wall of the board, and the action chosen by Petya moves it towards the wall, then the chip remains in its current position.Note that several chips can be located in the same cell.For each chip, Petya chose the position which it should visit. Note that it's not necessary for a chip to end up in this position.Since Petya does not have a lot of free time, he is ready to do no more than $$$2nm$$$ actions.You have to find out what actions Petya should do so that each chip visits the position that Petya selected for it at least once. Or determine that it is not possible to do this in $$$2nm$$$ actions.","n,m,k=map(int,input().split())
a=''
a+='L'*(m-1)
a+='D'*(n-1)
for i in range(m):
    if i%2==0:
        a+='U'*(n-1)+'R'
    else:
        a+='D'*(n-1)+'R'
print(len(a))
print(a)","['constructive algorithms', 'implementation']"
"You have decided to watch the best moments of some movie. There are two buttons on your player:   Watch the current minute of the movie. By pressing this button, you watch the current minute of the movie and the player automatically proceeds to the next minute of the movie.  Skip exactly x minutes of the movie (x is some fixed positive integer). If the player is now at the t-th minute of the movie, then as a result of pressing this button, it proceeds to the minute (t + x). Initially the movie is turned on in the player on the first minute, and you want to watch exactly n best moments of the movie, the i-th best moment starts at the li-th minute and ends at the ri-th minute (more formally, the i-th best moment consists of minutes: li, li + 1, ..., ri). Determine, what is the minimum number of minutes of the movie you have to watch if you want to watch all the best moments?","n, x = map(int, input().split())
res = 0
ri = 1

for i in range(n):
    l, r = map(int, input().split())
    
    l = l - ri 
    r = r - ri
    ri = ri + r + 1
    res = res + l%x + (r-l+1)
print(res)","['implementation', 'greedy']"
"Anastasia loves going for a walk in Central Uzhlyandian Park. But she became uninterested in simple walking, so she began to collect Uzhlyandian pebbles. At first, she decided to collect all the pebbles she could find in the park.She has only two pockets. She can put at most k pebbles in each pocket at the same time. There are n different pebble types in the park, and there are wi pebbles of the i-th type. Anastasia is very responsible, so she never mixes pebbles of different types in same pocket. However, she can put different kinds of pebbles in different pockets at the same time. Unfortunately, she can't spend all her time collecting pebbles, so she can collect pebbles from the park only once a day.Help her to find the minimum number of days needed to collect all the pebbles of Uzhlyandian Central Park, taking into consideration that Anastasia can't place pebbles of different types in same pocket.","n, k = map(int, input().split())
w = list(map(int, input().split()))
q=0
t=0
for i in range(n):
	a=w[i]//k
	w[i]%=k
	q+=(a//2)
	t+=(a%2)
#	print(a, w[i], t, q)
	if t==2:
		t=0
		q+=1
	if w[i]>0:
		if t==1:
			t=0
			w[i]=0
			q+=1
		else:
			w[i]=0
			t+=1
if t>0:
	q+=1
print(q)","['implementation', 'math']"
"As we all know Barney's job is ""PLEASE"" and he has not much to do at work. That's why he started playing ""cups and key"". In this game there are three identical cups arranged in a line from left to right. Initially key to Barney's heart is under the middle cup.  Then at one turn Barney swaps the cup in the middle with any of other two cups randomly (he choses each with equal probability), so the chosen cup becomes the middle one. Game lasts n turns and Barney independently choses a cup to swap with the middle one within each turn, and the key always remains in the cup it was at the start.After n-th turn Barney asks a girl to guess which cup contains the key. The girl points to the middle one but Barney was distracted while making turns and doesn't know if the key is under the middle cup. That's why he asked you to tell him the probability that girl guessed right.Number n of game turns can be extremely large, that's why Barney did not give it to you. Instead he gave you an array a1, a2, ..., ak such that   in other words, n is multiplication of all elements of the given array.Because of precision difficulties, Barney asked you to tell him the answer as an irreducible fraction. In other words you need to find it as a fraction p / q such that , where  is the greatest common divisor. Since p and q can be extremely large, you only need to find the remainders of dividing each of them by 109 + 7.Please note that we want  of p and q to be 1, not  of their remainders after dividing by 109 + 7.","k = int(input())
MOD = 10 ** 9 + 7
antithree = pow(3, MOD - 2, MOD)
antitwo = pow(2, MOD - 2, MOD)
power = 1
parity = False
for t in map(int, input().split()):
    power *= t
    power %= MOD - 1
    if t % 2 == 0:
        parity = True
q = pow(2, power, MOD) * antitwo
q %= MOD
if parity:
    p = (q + 1) * antithree
    p %= MOD
else:
    p = (q - 1) * antithree
    p %= MOD    
print(p, q, sep = '/')","['combinatorics', 'number theory', 'math']"
"Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings a and b of equal length are called equivalent in one of the two cases:   They are equal.  If we split string a into two halves of the same size a1 and a2, and string b into two halves of the same size b1 and b2, then one of the following is correct:   a1 is equivalent to b1, and a2 is equivalent to b2  a1 is equivalent to b2, and a2 is equivalent to b1  As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.Gerald has already completed this home task. Now it's your turn!","def checaEquavalencia(a, b, tam):
  if a == b:
    #print('YES')
    return True
  elif len(a) % 2 == 1:
    return False
  elif len(b) % 2 == 1:
    return False
  elif tam > 1:
    tam = tam // 2
    a1 = a[ : tam]
    a2 = a[tam : ]

    b1 = b[ : tam]
    b2 = b[tam : ]

    #caso1 = checaEquavalencia(a1, b1, tam) and checaEquavalencia(a2, b2, tam)
    #caso2 = checaEquavalencia(a1, b2, tam) and checaEquavalencia(a2, b1, tam)
    if checaEquavalencia(a1, b2, tam) and checaEquavalencia(a2, b1, tam):
      return True
    elif checaEquavalencia(a1, b1, tam) and checaEquavalencia(a2, b2, tam):
      return True

  return False

a = input()
b = input()

resposta = 'NO'
ta = len(a)
tb = len(b)
if(ta != tb):
  resposta = 'NO'
elif(a == b):
  resposta = 'YES'
elif(ta % 2 == 0):
  resp = checaEquavalencia(a , b, ta)
  if resp == True:
    resposta = 'YES'

print(resposta)","['hashing', 'divide and conquer', 'sortings', 'strings']"
"There are $$$n$$$ rectangles in a row. You can either turn each rectangle by $$$90$$$ degrees or leave it as it is. If you turn a rectangle, its width will be height, and its height will be width. Notice that you can turn any number of rectangles, you also can turn all or none of them. You can not change the order of the rectangles.Find out if there is a way to make the rectangles go in order of non-ascending height. In other words, after all the turns, a height of every rectangle has to be not greater than the height of the previous rectangle (if it is such).","from __future__ import division, print_function
# import threading
# threading.stack_size(2**27)
# import sys
# sys.setrecursionlimit(10**7)
from sys import stdin, stdout
import bisect            #c++ upperbound
import math
import heapq
i_m=9223372036854775807
def modinv(n,p):
    return pow(n,p-2,p)
def cin():
    return map(int,sin().split())
def ain():                           #takes array as input
    return list(map(int,sin().split()))
def sin():
    return input()
def inin():
    return int(input())
import math  
def GCD(x, y): 
    x=abs(x)
    y=abs(y)
    if(min(x,y)==0):
        return max(x,y)
    while(y): 
        x, y = y, x % y 
    return x 
def Divisors(n) : 
    l = []  
    for i in range(1, int(math.sqrt(n) + 1)) :
        if (n % i == 0) : 
            if (n // i == i) : 
                l.append(i) 
            else : 
                l.append(i)
                l.append(n//i)
    return l
 

def SieveOfEratosthenes(n): 
    prime = [True for i in range(n+1)] 
    p = 2
    while (p * p <= n): 
        if (prime[p] == True): 
            for i in range(p * p, n+1, p): 
                prime[i] = False
        p += 1
    f=[]
    for p in range(2, n): 
        if prime[p]: 
            f.append(p)
    return f
q=[]       
def dfs(n,d,v,c):
    global q
    v[n]=1
    x=d[n]
    q.append(n)
    j=c
    for i in x:
        if i not in v:
            f=dfs(i,d,v,c+1)
            j=max(j,f)
            # print(f)
    return j
  
""""""*******************************************************""""""
def main():
    n=inin()
    a=[]
    x=i_m
    ans=""YES""
    for i in range(n):
        j,k=cin()
        p=max(j,k)
        q=min(j,k)
        if(p<=x):
            x=p
            continue
        if(q<=x):
            x=q
            continue
        ans=""NO""
        break
    print(ans)



            

 
######## Python 2 and 3 footer by Pajenegod and c1729
 
# Note because cf runs old PyPy3 version which doesn't have the sped up
# unicode strings, PyPy3 strings will many times be slower than pypy2.
# There is a way to get around this by using binary strings in PyPy3
# but its syntax is different which makes it kind of a mess to use.
 
# So on cf, use PyPy2 for best string performance.
 
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
 
import os, sys
from io import IOBase, BytesIO
 
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0
 
    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None
 
    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s
 
    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()
 
    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')
 
# Cout implemented in Python
import sys
class ostream:
    def __lshift__(self,a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
 
# Read all remaining integers in stdin, type is given by optional argument, this is fast
def readnumbers(zero = 0):
    conv = ord if py2 else lambda x:x
    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'R' [0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-' [0]: sign = -1
            elif s[i] != b'\r' [0]:
                A.append(sign*numb)
                numb = zero; sign = 1
            i += 1
    except:pass
    if s and s[-1] >= b'R' [0]:
        A.append(sign*numb)
    return A
 
# threading.Thread(target=main).start()
if __name__== ""__main__"":
  main()","['sortings', 'greedy']"
"Dreamoon likes to play with sets, integers and .  is defined as the largest positive integer that divides both a and b.Let S be a set of exactly four distinct integers greater than 0. Define S to be of rank k if and only if for all pairs of distinct elements si, sj from S, .Given k and n, Dreamoon wants to make up n sets of rank k using integers from 1 to m such that no integer is used in two different sets (of course you can leave some integers without use). Calculate the minimum m that makes it possible and print one possible solution.","load = [int(i) for i in input().split()]
n = load[0]
k = load[1]
print(k * (6 * n - 1))
for i in range(1, n + 1):
    buff = """"
    buff += str(k * (6 * i - 5)) + ' '
    buff += str(k * (6 * i - 3)) + ' '
    buff += str(k * (6 * i - 2)) + ' '
    buff += str(k * (6 * i - 1)) + ' '
    print(buff)","['constructive algorithms', 'greedy', 'math']"
"You have an array $$$a$$$ of length $$$n$$$. For every positive integer $$$x$$$ you are going to perform the following operation during the $$$x$$$-th second:  Select some distinct indices $$$i_{1}, i_{2}, \ldots, i_{k}$$$ which are between $$$1$$$ and $$$n$$$ inclusive, and add $$$2^{x-1}$$$ to each corresponding position of $$$a$$$. Formally, $$$a_{i_{j}} := a_{i_{j}} + 2^{x-1}$$$ for $$$j = 1, 2, \ldots, k$$$. Note that you are allowed to not select any indices at all. You have to make $$$a$$$ nondecreasing as fast as possible. Find the smallest number $$$T$$$ such that you can make the array nondecreasing after at most $$$T$$$ seconds.Array $$$a$$$ is nondecreasing if and only if $$$a_{1} \le a_{2} \le \ldots \le a_{n}$$$.You have to answer $$$t$$$ independent test cases.","#logic#####maintain two pointer that will maintain the maximum difference between
#two values and values that are not follwing the a<=b condition
def powerof2(x):
    i=0
    while 2**i<=x:
        i+=1
    return i
from sys import stdout
for _ in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    maz,miz=l[0],l[0]
    cnt_max=0
    for i in range(1,n):
        cnt=0
        if l[i]<maz:
            if l[i]<miz:
                miz=l[i]
        else:
            cnt=powerof2(maz-miz)
            maz,miz=l[i],l[i]
            if cnt>cnt_max:
                cnt_max=cnt
        if i==n-1 and maz-miz>0:
            cnt=powerof2(maz-miz)
            if cnt>cnt_max:
                cnt_max=cnt
    stdout.write(str(cnt_max) + ""\n"")","['greedy', 'math']"
"You are given a tree that consists of $$$n$$$ nodes. You should label each of its $$$n-1$$$ edges with an integer in such way that satisfies the following conditions:   each integer must be greater than $$$0$$$;  the product of all $$$n-1$$$ numbers should be equal to $$$k$$$;  the number of $$$1$$$-s among all $$$n-1$$$ integers must be minimum possible. Let's define $$$f(u,v)$$$ as the sum of the numbers on the simple path from node $$$u$$$ to node $$$v$$$. Also, let $$$\sum\limits_{i=1}^{n-1} \sum\limits_{j=i+1}^n f(i,j)$$$ be a distribution index of the tree.Find the maximum possible distribution index you can get. Since answer can be too large, print it modulo $$$10^9 + 7$$$.In this problem, since the number $$$k$$$ can be large, the result of the prime factorization of $$$k$$$ is given instead.","import sys
def input():
    return sys.stdin.readline()[:-1]

mod = 10**9 + 7

def main():
    t = int(input())

    for i in range(t):
        n = int(input())
        e_list = [[] for i in range(n)]
        for j in range(n-1):
            a,b = list(map(int,input().split()))
            a,b = a-1,b-1
            e_list[a].append(b)
            e_list[b].append(a)
        
        m = int(input())
        p = list(map(int,input().split()))

        from collections import deque
        
        vi = 0  #change
        INF = float('inf')
        
        Q = deque([vi])
        
        checked_list = [False]*n
        checked_list[vi]=True
        
        parent_list = [-1]*n

        min_path_list = [INF]*n #change
        min_path_list[vi] = 0
        
        while len(Q)>0:
            v = Q.pop()
            for v1 in e_list[v]:
                if not checked_list[v1]:
                    checked_list[v1]=True
                    Q.appendleft(v1)
                    parent_list[v1] = v
                    min_path_list[v1] = min_path_list[v]+1
        
        memo = [-1]*n

        min_path = [(i,min_path_list[i]) for i in range(n)]
        min_path.sort(key=lambda x:x[1],reverse=True)
        for v,d in min_path:
            if v==0:
                continue
            count = 0
            for v1 in e_list[v]:
                if v1!=parent_list[v]:
                    #print(v1)
                    count+=memo[v1]+1
            memo[v] = count
            #print(memo)
        #print(e_list)
        memo = [(memo[i]+1)*(n-memo[i]-1) for i in range(1,n)]
        memo.sort(reverse=True)
        p.sort(reverse=True)
        #print(memo)
        ans = 0
        if m<=n-1:
            for i in range(m):
                ans+=p[i]*memo[i]
                ans%=mod
            for i in range(m,n-1):
                ans+=memo[i]
                ans%=mod
        else:
            a = 1
            for i in range(m-n+2):
                a*=p[i]
                a%=mod
            ans = a*memo[0]
            ans%=mod
            for i in range(1,n-1):
                ans+=p[i+m-n+1]*memo[i]
                ans%=mod
        print(ans)

if __name__ == '__main__':
    main()","['dp', 'greedy', 'number theory', 'math', 'implementation', 'sortings', 'dfs and similar', 'trees']"
"Sergey attends lessons of the N-ish language. Each lesson he receives a hometask. This time the task is to translate some sentence to the N-ish language. Sentences of the N-ish language can be represented as strings consisting of lowercase Latin letters without spaces or punctuation marks.Sergey totally forgot about the task until half an hour before the next lesson and hastily scribbled something down. But then he recollected that in the last lesson he learned the grammar of N-ish. The spelling rules state that N-ish contains some ""forbidden"" pairs of letters: such letters can never occur in a sentence next to each other. Also, the order of the letters doesn't matter (for example, if the pair of letters ""ab"" is forbidden, then any occurrences of substrings ""ab"" and ""ba"" are also forbidden). Also, each pair has different letters and each letter occurs in no more than one forbidden pair.Now Sergey wants to correct his sentence so that it doesn't contain any ""forbidden"" pairs of letters that stand next to each other. However, he is running out of time, so he decided to simply cross out some letters from the sentence. What smallest number of letters will he have to cross out? When a letter is crossed out, it is ""removed"" so that the letters to its left and right (if they existed), become neighboring. For example, if we cross out the first letter from the string ""aba"", we get the string ""ba"", and if we cross out the second letter, we get ""aa"".","import sys
from math import gcd,sqrt,ceil,log2
from collections import defaultdict,Counter,deque
from bisect import bisect_left,bisect_right
import math
import heapq
from itertools import permutations

# input=sys.stdin.readline
# def print(x):
#     sys.stdout.write(str(x)+""\n"")

# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# import sys
# import io, os
# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
def get_sum(bit,i):
    s = 0

    i+=1
    while i>0:
        s+=bit[i]
        i-=i&(-i)

    return s

def update(bit,n,i,v):
    i+=1

    while i<=n:
        bit[i]+=v
        i+=i&(-i)


def modInverse(b,m):
    g = math.gcd(b, m)
    if (g != 1):
        return -1
    else:
        return pow(b, m - 2, m)

def primeFactors(n):

    sa = set()
    sa.add(n)
    while n % 2 == 0:
        sa.add(2)
        n = n // 2


    for i in range(3,int(math.sqrt(n))+1,2):


        while n % i== 0:
            sa.add(i)
            n = n // i

    # sa.add(n)
    return sa


def seive(n):

    pri = [True]*(n+1)
    p = 2
    while p*p<=n:

        if pri[p] == True:

            for i in range(p*p,n+1,p):
                pri[i] = False

        p+=1

    return pri

def check_prim(n):

    if n<0:
        return False
    for i in range(2,int(sqrt(n))+1):
        if n%i == 0:
            return False

    return True


def getZarr(string, z):
    n = len(string)

    # [L,R] make a window which matches
    # with prefix of s
    l, r, k = 0, 0, 0
    for i in range(1, n):

        # if i>R nothing matches so we will calculate.
        # Z[i] using naive way.
        if i > r:
            l, r = i, i

            # R-L = 0 in starting, so it will start
            # checking from 0'th index. For example,
            # for ""ababab"" and i = 1, the value of R
            # remains 0 and Z[i] becomes 0. For string
            # ""aaaaaa"" and i = 1, Z[i] and R become 5
            while r < n and string[r - l] == string[r]:
                r += 1
            z[i] = r - l
            r -= 1
        else:

            # k = i-L so k corresponds to number which
            # matches in [L,R] interval.
            k = i - l

            # if Z[k] is less than remaining interval
            # then Z[i] will be equal to Z[k].
            # For example, str = ""ababab"", i = 3, R = 5
            # and L = 2
            if z[k] < r - i + 1:
                z[i] = z[k]

                # For example str = ""aaaaaa"" and i = 2,
            # R is 5, L is 0
            else:

                # else start from R and check manually
                l = i
                while r < n and string[r - l] == string[r]:
                    r += 1
                z[i] = r - l
                r -= 1

def search(text, pattern):

    # Create concatenated string ""P$T""
    concat = pattern + ""$"" + text
    l = len(concat)


    z = [0] * l
    getZarr(concat, z)

    ha = []
    for i in range(l):


        if z[i] == len(pattern):
            ha.append(i - len(pattern) - 1)


    return ha


# n,k = map(int,input().split())
# l = list(map(int,input().split()))

#
# n = int(input())
# l = list(map(int,input().split()))
#
# hash = defaultdict(list)
# la = []
#
# for i in range(n):
#     la.append([l[i],i+1])
#
# la.sort(key = lambda x: (x[0],-x[1]))
# ans = []
# r = n
# flag = 0
# lo = []
# ha = [i for i in range(n,0,-1)]
# yo = []
# for a,b in la:
#
#    if a == 1:
#        ans.append([r,b])
#        # hash[(1,1)].append([b,r])
#        lo.append((r,b))
#        ha.pop(0)
#        yo.append([r,b])
#        r-=1
#
#    elif a == 2:
#        # print(yo,lo)
#        # print(hash[1,1])
#        if lo == []:
#            flag = 1
#            break
#        c,d = lo.pop(0)
#        yo.pop(0)
#        if b>=d:
#            flag = 1
#            break
#        ans.append([c,b])
#        yo.append([c,b])
#
#
#
#    elif a == 3:
#
#            if yo == []:
#                flag = 1
#                break
#            c,d = yo.pop(0)
#            if b>=d:
#                flag = 1
#                break
#            if ha == []:
#                flag = 1
#                break
#
#            ka = ha.pop(0)
#
#            ans.append([ka,b])
#            ans.append([ka,d])
#            yo.append([ka,b])
#
# if flag:
#     print(-1)
# else:
#     print(len(ans))
#     for a,b in ans:
#         print(a,b)

s = input()
n = len(s)
k = int(input())

l = []

for i in range(k):
    z = input()
    l.append(z)
    l.append(z[::-1])


la = []
i = 0
while i<n:

    cnt = 0
    z = s[i]
    while i<n and s[i]  == z:
        cnt+=1
        i+=1
    la.append([z,cnt])
ans = 0
if len(la) == 1:
    print(0)
    exit()


x,y = la[0][0],la[1][0]
cnt1,cnt2  = la[0][1],0
i = 1

while i<len(la):

    if la[i][0]!=x and la[i][0]!=y:
        if x+y in l:
         ans += min(cnt1,cnt2)
        i-=1
        x,y = la[i][0],la[i+1][0]

        cnt1,cnt2  = la[i][1],0
        i+=1


    else:

        if la[i][0]==x:
            # print(x,cnt1)
            cnt1+=la[i][1]

        else:
            cnt2+=la[i][1]
        i+=1


if x+y in l:
    ans += min(cnt1,cnt2)


print(ans)",['greedy']
"Colossal! — exclaimed Hawk-nose. — A programmer! That's exactly what we are looking for.Arkadi and Boris Strugatsky. Monday starts on SaturdayReading the book ""Equations of Mathematical Magic"" Roman Oira-Oira and Cristobal Junta found an interesting equation: $$$a - (a \oplus x) - x = 0$$$ for some given $$$a$$$, where $$$\oplus$$$ stands for a bitwise exclusive or (XOR) of two integers (this operation is denoted as ^ or xor in many modern programming languages). Oira-Oira quickly found some $$$x$$$, which is the solution of the equation, but Cristobal Junta decided that Oira-Oira's result is not interesting enough, so he asked his colleague how many non-negative solutions of this equation exist. This task turned out to be too difficult for Oira-Oira, so he asks you to help.","def solve(a):
	binary = f""{a:b}""
	return 2 ** binary.count(""1"")

n = int(input())
for i in range(n):
	a = int(input())
	print(solve(a))",['math']
"Valera is a collector. Once he wanted to expand his collection with exactly one antique item.Valera knows n sellers of antiques, the i-th of them auctioned ki items. Currently the auction price of the j-th object of the i-th seller is sij. Valera gets on well with each of the n sellers. He is perfectly sure that if he outbids the current price of one of the items in the auction (in other words, offers the seller the money that is strictly greater than the current price of the item at the auction), the seller of the object will immediately sign a contract with him.Unfortunately, Valera has only v units of money. Help him to determine which of the n sellers he can make a deal with.","n, v = map(int, raw_input().split())
l = list()

for i in range(n):
        if min(map(int, raw_input().split()[1:])) < v:
                l.append(i + 1)

print len(l)
for x in l: print x,",['implementation']
"Berland annual chess tournament is coming!Organizers have gathered 2·n chess players who should be divided into two teams with n people each. The first team is sponsored by BerOil and the second team is sponsored by BerMobile. Obviously, organizers should guarantee the win for the team of BerOil.Thus, organizers should divide all 2·n players into two teams with n people each in such a way that the first team always wins.Every chess player has its rating ri. It is known that chess player with the greater rating always wins the player with the lower rating. If their ratings are equal then any of the players can win.After teams assignment there will come a drawing to form n pairs of opponents: in each pair there is a player from the first team and a player from the second team. Every chess player should be in exactly one pair. Every pair plays once. The drawing is totally random.Is it possible to divide all 2·n players into two teams with n people each so that the player from the first team in every pair wins regardless of the results of the drawing?","n = int(input())

l = sorted(map(int, input().split()))
l2 = l[n:]

for a in l[:n]:
	if a in l2:
		print('NO')
		exit()

print('YES')","['implementation', 'sortings']"
"You are given a long decimal number $$$a$$$ consisting of $$$n$$$ digits from $$$1$$$ to $$$9$$$. You also have a function $$$f$$$ that maps every digit from $$$1$$$ to $$$9$$$ to some (possibly the same) digit from $$$1$$$ to $$$9$$$.You can perform the following operation no more than once: choose a non-empty contiguous subsegment of digits in $$$a$$$, and replace each digit $$$x$$$ from this segment with $$$f(x)$$$. For example, if $$$a = 1337$$$, $$$f(1) = 1$$$, $$$f(3) = 5$$$, $$$f(7) = 3$$$, and you choose the segment consisting of three rightmost digits, you get $$$1553$$$ as the result.What is the maximum possible number you can obtain applying this operation no more than once?","n = int(raw_input())
num = list(raw_input())
fs =  raw_input().split()
mapa = {}

for  k in xrange(9):
	mapa[str(k+1)]  = fs[k]
	
i = 0
while i < n and num[i] >= mapa[num[i]]:
	i += 1

j = i

while j < n and num[j] <= mapa[num[j]]:
	
	j += 1
	

for k in xrange(i, j):
	num[k] = mapa[num[k]]
	
print """".join(num)

'''	
elif i == n:
	print """".join(num)
	exit()
	
else:
	j = n-1
	while j > i and num[j] > mapa[num[j]]:
		j -=1
		
	for k in xrange(i, j+1):
		num[k] = mapa[num[k]]
	
	print """".join(num)
'''",['greedy']
"A little boy Laurenty has been playing his favourite game Nota for quite a while and is now very hungry. The boy wants to make sausage and cheese sandwiches, but first, he needs to buy a sausage and some cheese.The town where Laurenty lives in is not large. The houses in it are located in two rows, n houses in each row. Laurenty lives in the very last house of the second row. The only shop in town is placed in the first house of the first row.The first and second rows are separated with the main avenue of the city. The adjacent houses of one row are separated by streets.Each crosswalk of a street or an avenue has some traffic lights. In order to cross the street, you need to press a button on the traffic light, wait for a while for the green light and cross the street. Different traffic lights can have different waiting time.The traffic light on the crosswalk from the j-th house of the i-th row to the (j + 1)-th house of the same row has waiting time equal to aij (1 ≤ i ≤ 2, 1 ≤ j ≤ n - 1). For the traffic light on the crossing from the j-th house of one row to the j-th house of another row the waiting time equals bj (1 ≤ j ≤ n). The city doesn't have any other crossings.The boy wants to get to the store, buy the products and go back. The main avenue of the city is wide enough, so the boy wants to cross it exactly once on the way to the store and exactly once on the way back home. The boy would get bored if he had to walk the same way again, so he wants the way home to be different from the way to the store in at least one crossing.    Figure to the first sample. Help Laurenty determine the minimum total time he needs to wait at the crossroads.","a=int(input())
z=[[0]+list(map(int,input().split())),[0]+list(map(int,input().split()))]
r=[0]+list(map(int,input().split()))
k=[]
for i in range(a,0,-1):k.insert(0,sum(z[0][:i])+r[i]+sum(z[1][i:]))
s=min(k);k[k.index(s)]=2*a*100;print(s+min(k))",['implementation']
"Ivan has $$$n$$$ songs on his phone. The size of the $$$i$$$-th song is $$$a_i$$$ bytes. Ivan also has a flash drive which can hold at most $$$m$$$ bytes in total. Initially, his flash drive is empty.Ivan wants to copy all $$$n$$$ songs to the flash drive. He can compress the songs. If he compresses the $$$i$$$-th song, the size of the $$$i$$$-th song reduces from $$$a_i$$$ to $$$b_i$$$ bytes ($$$b_i &lt; a_i$$$).Ivan can compress any subset of the songs (possibly empty) and copy all the songs to his flash drive if the sum of their sizes is at most $$$m$$$. He can compress any subset of the songs (not necessarily contiguous).Ivan wants to find the minimum number of songs he needs to compress in such a way that all his songs fit on the drive (i.e. the sum of their sizes is less than or equal to $$$m$$$).If it is impossible to copy all the songs (even if Ivan compresses all the songs), print ""-1"". Otherwise print the minimum number of songs Ivan needs to compress.","n, m = map(int, input().split())
a = [0] * n
b = [0] * n
d = []
s = 0
for i in range(n):
    a[i], b[i] = map(int, input().split())
    d.append(a[i] - b[i])
    s += a[i]
d.sort(reverse=True)
ans = 0
while ans < n and s > m:
    s -= d[ans]
    ans += 1
if s <= m:
    print(ans)
else:
    print(-1)",['sortings']
"So the Beautiful Regional Contest (BeRC) has come to an end! $$$n$$$ students took part in the contest. The final standings are already known: the participant in the $$$i$$$-th place solved $$$p_i$$$ problems. Since the participants are primarily sorted by the number of solved problems, then $$$p_1 \ge p_2 \ge \dots \ge p_n$$$.Help the jury distribute the gold, silver and bronze medals. Let their numbers be $$$g$$$, $$$s$$$ and $$$b$$$, respectively. Here is a list of requirements from the rules, which all must be satisfied:  for each of the three types of medals, at least one medal must be awarded (that is, $$$g&gt;0$$$, $$$s&gt;0$$$ and $$$b&gt;0$$$);  the number of gold medals must be strictly less than the number of silver and the number of bronze (that is, $$$g&lt;s$$$ and $$$g&lt;b$$$, but there are no requirements between $$$s$$$ and $$$b$$$);  each gold medalist must solve strictly more problems than any awarded with a silver medal;  each silver medalist must solve strictly more problems than any awarded a bronze medal;  each bronze medalist must solve strictly more problems than any participant not awarded a medal;  the total number of medalists $$$g+s+b$$$ should not exceed half of all participants (for example, if $$$n=21$$$, then you can award a maximum of $$$10$$$ participants, and if $$$n=26$$$, then you can award a maximum of $$$13$$$ participants). The jury wants to reward with medals the total maximal number participants (i.e. to maximize $$$g+s+b$$$) so that all of the items listed above are fulfilled. Help the jury find such a way to award medals.","# lET's tRy ThIS...

import math
import os
import sys

#-------------------BOLT------------------#
#-------Genius----Billionare----Playboy----Philanthropist----NOT ME:D----#

input = lambda: sys.stdin.readline().strip(""\r\n"")
def cin(): return sys.stdin.readline().strip(""\r\n"")
def fora(): return list(map(int, sys.stdin.readline().strip().split()))
def string(): return sys.stdin.readline().strip()
def cout(ans): sys.stdout.write(str(ans))
def endl(): sys.stdout.write(str(""\n""))
def ende(): sys.stdout.write(str("" ""))

#---------ND-I-AM-IRON-MAN------------------#


def main():
    for _ in range(int(input())):
        #LET's sPill the BEANS
        n=int(cin())
        l=fora()
        if(n//2>3):
            mp={}
            mp=dict.fromkeys(l,0)
            for i in l:
                mp[i]+=1
            cnt=g=s=b=0
            flag=j=1
            for i in mp:
                if(j==1):
                    g+=mp[i]
                    cnt+=mp[i]
                elif(flag):
                    s+=mp[i]
                    cnt+=mp[i]
                    if s>g:
                        flag=0
                else:
                    if(cnt>=n//2):
                        break
                    b+=mp[i]
                    cnt+=mp[i]
                    if(cnt>n//2):
                        b-=mp[i]
                        break
                j+=1
            if(g==0 or s==0 or b==0):
                print(""0 ""*3,end="""")
            elif(g>=s or g>=b):
                print(""0 ""*3,end="""")
            else:
                cout(g)
                ende()
                cout(s)
                ende()
                cout(b)
        else:
            print(""0 ""*3,end="""")
        endl()

if __name__ == ""__main__"": 
    main()","['implementation', 'greedy']"
"You are given a sequence $$$b_1, b_2, \ldots, b_n$$$. Find the lexicographically minimal permutation $$$a_1, a_2, \ldots, a_{2n}$$$ such that $$$b_i = \min(a_{2i-1}, a_{2i})$$$, or determine that it is impossible.","import heapq
def restorePermutation(n, A):
    ans = []
    unUsed = set(list(range(1, 2*n + 1)))
    for val in A:
        if not 1 <= val <= 2*n: return -1
        ans.append(val)
        ans.append(-1)
        unUsed.remove(val)
        
    minHeapq = [val for val in unUsed]
    heapq.heapify(minHeapq)
    #idea use BST in future
    #use heap for now
    for i in range(1, 2*n, 2):
        temp = []
        while minHeapq and minHeapq[0] < ans[i - 1]:
            temp.append(heapq.heappop(minHeapq))
        if not minHeapq or (minHeapq and minHeapq[0] < ans[i - 1]): 
            return -1
        ans[i] = heapq.heappop(minHeapq)
        while temp:
            heapq.heappush(minHeapq, temp.pop())
    
    return ans
        
        



testCases = int(input())
while testCases:
    n = int(input())
    A = [int(val) for val in input().split()]
    ans = restorePermutation(n, A)
    if ans == -1:
        print()
        print(ans)
    else:
        for val in ans:
            print(val, end = "" "")
    testCases -= 1",['greedy']
"Consider a system of n water taps all pouring water into the same container. The i-th water tap can be set to deliver any amount of water from 0 to ai ml per second (this amount may be a real number). The water delivered by i-th tap has temperature ti.If for every  you set i-th tap to deliver exactly xi ml of water per second, then the resulting temperature of water will be  (if , then to avoid division by zero we state that the resulting water temperature is 0).You have to set all the water taps in such a way that the resulting temperature is exactly T. What is the maximum amount of water you may get per second if its temperature has to be T?","R = lambda : map(int, input().split())
n, temp = R()
a = list(R())
t = list(R())
v = sorted([(t[i]-temp,a[i]) for i in range(n)])

r = sum([v[i][1] for i in range(n) if v[i][0]==0])
pos = sum([v[i][0]*v[i][1] for i in range(n) if v[i][0]>0])
neg = sum([abs(v[i][0])*v[i][1] for i in range(n) if v[i][0]<0])

pa = sum([v[i][1] for i in range(n) if v[i][0]>0])
na = sum([v[i][1] for i in range(n) if v[i][0]<0])

if pos == 0 or neg == 0:
    print(r); exit();

for i in range(n):
    if v[i][0] >= 0:
        stn = i-1; break;

for i in range(n):
    if v[i][0] > 0:
        stp = i; break;

if neg<pos:
    r += na
    rem = neg * 1.0
    for i in range(stp,n):
        if v[i][0]*v[i][1]>=rem:
            r += rem / v[i][0]
            rem = 0
        else:
            r += v[i][1]
            rem -= v[i][0]*v[i][1]
else:
    r += pa
    rem = pos * 1.0
    for i in reversed(range(stn+1)):
        if abs(v[i][0])*v[i][1]>=rem:
            r += rem / abs(v[i][0])
            rem = 0
        else:
            r += v[i][1]
            rem -= abs(v[i][0])*v[i][1]

print(r)","['binary search', 'sortings', 'greedy']"
"This is an interactive problem.Vasya and Vitya play a game. Vasya thought of two integers $$$a$$$ and $$$b$$$ from $$$1$$$ to $$$n$$$ and Vitya tries to guess them. Each round he tells Vasya two numbers $$$x$$$ and $$$y$$$ from $$$1$$$ to $$$n$$$. If both $$$x=a$$$ and $$$y=b$$$ then Vitya wins. Else Vasya must say one of the three phrases:   $$$x$$$ is less than $$$a$$$;  $$$y$$$ is less than $$$b$$$;  $$$x$$$ is greater than $$$a$$$ or $$$y$$$ is greater than $$$b$$$. Vasya can't lie, but if multiple phrases are true, he may choose any of them. For example, if Vasya thought of numbers $$$2$$$ and $$$4$$$, then he answers with the phrase $$$3$$$ to a query $$$(3, 4)$$$, and he can answer with the phrase $$$1$$$ or phrase $$$3$$$ to a query $$$(1, 5)$$$.Help Vitya win in no more than $$$600$$$ rounds.","import sys


def send_request(x, y):
    print(""{} {}"".format(x, y))
    sys.stdout.flush()

    ans = int(input())
    if ans == 0:
        sys.exit(0)
    return ans


def main():
    n = int(input().strip())

    x = 1
    y = 1
    send_request(x, y)

    prev_x_margin = 0
    prev_y_margin = 0
    x_margin = 1
    y_margin = 1

    while True:
        while True:
            ans = send_request(
                min(x + x_margin, n),
                min(y + y_margin, n)
            )
            if ans == 1:
                prev_x_margin = x_margin
                x_margin *= 2

            elif ans == 2:
                prev_y_margin = y_margin
                y_margin *= 2
            else:
                break

        if x_margin == 1 and y_margin == 1:
            while True:
                ans = send_request(
                    min(x + x_margin, n),
                    min(y + prev_y_margin, n)
                )
                if ans == 1:
                    prev_x_margin = x_margin
                    x_margin *= 2
                else:
                    break
    
            while True:
                ans = send_request(
                    min(x + prev_x_margin, n),
                    min(y + y_margin, n))
                if ans == 2:
                    prev_y_margin = y_margin
                    y_margin *= 2
                else:
                    break

        x = min(x + prev_x_margin, n)
        y = min(y + prev_y_margin, n)
        prev_x_margin = 0
        prev_y_margin = 0

        x_margin = max(1, x_margin // 2)
        y_margin = max(1, y_margin // 2)


if __name__ == ""__main__"":
    main()
    exit(0)","['binary search', 'interactive']"
"A remote island chain contains n islands, labeled 1 through n. Bidirectional bridges connect the islands to form a simple cycle — a bridge connects islands 1 and 2, islands 2 and 3, and so on, and additionally a bridge connects islands n and 1. The center of each island contains an identical pedestal, and all but one of the islands has a fragile, uniquely colored statue currently held on the pedestal. The remaining island holds only an empty pedestal.The islanders want to rearrange the statues in a new order. To do this, they repeat the following process: First, they choose an island directly adjacent to the island containing an empty pedestal. Then, they painstakingly carry the statue on this island across the adjoining bridge and place it on the empty pedestal.Determine if it is possible for the islanders to arrange the statues in the desired order.","n = int(input())
s1 = input().split()
s2 = input().split()

st1 = 0
st2 = 0
for i in range(n):
    if s1[i] == '1':
        st1 = i
    if s2[i] == '1':
        st2 = i

i = (st1 + 1) % n
j = (st2 + 1) % n
f = True
steps = 0
while steps < n:
    if s1[i] == '0':
        i = (i + 1) % n
    if s2[j] == '0':
        j = (j + 1) % n
    if s1[i] != s2[j]:
        f = False
        break
    i = (i + 1) % n
    j = (j + 1) % n
    steps += 1

if f:
    print('YES')
else:
    print('NO')","['constructive algorithms', 'implementation']"
"In the snake exhibition, there are $$$n$$$ rooms (numbered $$$0$$$ to $$$n - 1$$$) arranged in a circle, with a snake in each room. The rooms are connected by $$$n$$$ conveyor belts, and the $$$i$$$-th conveyor belt connects the rooms $$$i$$$ and $$$(i+1) \bmod n$$$. In the other words, rooms $$$0$$$ and $$$1$$$, $$$1$$$ and $$$2$$$, $$$\ldots$$$, $$$n-2$$$ and $$$n-1$$$, $$$n-1$$$ and $$$0$$$ are connected with conveyor belts.The $$$i$$$-th conveyor belt is in one of three states:  If it is clockwise, snakes can only go from room $$$i$$$ to $$$(i+1) \bmod n$$$.  If it is anticlockwise, snakes can only go from room $$$(i+1) \bmod n$$$ to $$$i$$$.  If it is off, snakes can travel in either direction.   Above is an example with $$$4$$$ rooms, where belts $$$0$$$ and $$$3$$$ are off, $$$1$$$ is clockwise, and $$$2$$$ is anticlockwise.Each snake wants to leave its room and come back to it later. A room is returnable if the snake there can leave the room, and later come back to it using the conveyor belts. How many such returnable rooms are there?","ans = []
for i in range(int(input())):
    n = int(input())
    s = list(input())
    if '>' in s and '<' in s:
        a = 0
        for i in range(n):
            if s[i] == '-' or s[i - 1] == '-':
                a += 1
        ans.append(a)
    else:
        ans.append(n)
print('\n'.join(map(str, ans)))","['implementation', 'graphs']"
"The city administration of IT City decided to fix up a symbol of scientific and technical progress in the city's main square, namely an indicator board that shows the effect of Moore's law in real time.Moore's law is the observation that the number of transistors in a dense integrated circuit doubles approximately every 24 months. The implication of Moore's law is that computer performance as function of time increases exponentially as well.You are to prepare information that will change every second to display on the indicator board. Let's assume that every second the number of transistors increases exactly 1.000000011 times.","s  = input()
S = s.split()
transistors = int(S[0])
seconds = int(S[1])
a1 = 1
a2 = 1
a3 = 1
for i in range(1000):
    a1 = a1*1.000000011
for i in range(1000):
    a2 = a2*a1
for i in range(1000):
    a3 = a3*a2


local0 = seconds%1000
seconds = int((seconds-local0)/1000)
local1 = seconds%1000
seconds = int((seconds-local1)/1000)
local2 = seconds%1000
seconds = int((seconds-local2)/1000)
local3 = seconds%1000
for i in range(local0):
    transistors = transistors*1.000000011
for i in range(local1):
    transistors = transistors*a1
for i in range(local2):
    transistors = transistors*a2
for i in range(local3):
    transistors = transistors*a3
print(transistors)",['math']
"Cowboy Vlad has a birthday today! There are $$$n$$$ children who came to the celebration. In order to greet Vlad, the children decided to form a circle around him. Among the children who came, there are both tall and low, so if they stand in a circle arbitrarily, it may turn out, that there is a tall and low child standing next to each other, and it will be difficult for them to hold hands. Therefore, children want to stand in a circle so that the maximum difference between the growth of two neighboring children would be minimal possible.Formally, let's number children from $$$1$$$ to $$$n$$$ in a circle order, that is, for every $$$i$$$ child with number $$$i$$$ will stand next to the child with number $$$i+1$$$, also the child with number $$$1$$$ stands next to the child with number $$$n$$$. Then we will call the discomfort of the circle the maximum absolute difference of heights of the children, who stand next to each other.Please help children to find out how they should reorder themselves, so that the resulting discomfort is smallest possible.","n = int(input())
arr = sorted([int(x) for x in input().split()])
lower = []
upper = []

for idx in range(len(arr)):
    if idx % 2 == 0:
        lower.append(arr[idx])
    else:
        upper.append(arr[idx])

print(*lower, end="" "")
print(*upper[::-1])","['binary search', 'sortings', 'greedy']"
"Tom loves vowels, and he likes long words with many vowels. His favorite words are vowelly words. We say a word of length $$$k$$$ is vowelly if there are positive integers $$$n$$$ and $$$m$$$ such that $$$n\cdot m = k$$$ and when the word is written by using $$$n$$$ rows and $$$m$$$ columns (the first row is filled first, then the second and so on, with each row filled from left to right), every vowel of the English alphabet appears at least once in every row and every column.You are given an integer $$$k$$$ and you must either print a vowelly word of length $$$k$$$ or print $$$-1$$$ if no such word exists.In this problem the vowels of the English alphabet are 'a', 'e', 'i', 'o' ,'u'.","k = input()
v = [""a"", ""e"", ""i"", ""o"", ""u""]
n = m = None
for i in xrange(5, int(k**0.5) + 1):
	if k % i == 0:
		n = i
		m = k / i
		break
if not n:
	print -1
else:
	ans = []
	row = v * (n/5) + v[:n%5]
	for i in xrange(m):
		ans.extend(row[i:] + row[:i])
	print """".join(ans)","['constructive algorithms', 'number theory', 'math']"
"Polar bears like unique arrays — that is, arrays without repeated elements. You have got a unique array s with length n containing non-negative integers. Since you are good friends with Alice and Bob, you decide to split the array in two. Precisely, you need to construct two arrays a and b that are also of length n, with the following conditions for all i (1 ≤ i ≤ n):  ai, bi are non-negative integers;  si = ai + bi . Ideally, a and b should also be unique arrays. However, life in the Arctic is hard and this is not always possible. Fortunately, Alice and Bob are still happy if their arrays are almost unique. We define an array of length n to be almost unique, if and only if it can be turned into a unique array by removing no more than  entries.For example, the array [1, 2, 1, 3, 2] is almost unique because after removing the first two entries, it becomes [1, 3, 2]. The array [1, 2, 1, 3, 1, 2] is not almost unique because we need to remove at least 3 entries to turn it into a unique array.So, your task is to split the given unique array s into two almost unique arrays a and b.","n = input()
s = map(int, raw_input().split())
idx = sorted(range(n), key=lambda i: s[i])
s.sort()
a = [0]*n
b = [0]*n

if n%3 == 0:
	k1 = n/3
	k2 = 2*n/3
elif n%3 == 1:
	k1 = n/3 + 1
	k2 = k1 + n/3
else:
	k1 = n/3 + 1
	k2 = k1 + n/3 + 1

for i in range(k1):
	a[i] = i
	b[i] = s[i] - i
for i in range(k1, k2):
	b[i] = i
	a[i] = s[i] - i
for i in range(k2, n):
	b[i] = n - i - 1
	a[i] = s[i] - b[i]

a_ = [0]*n
b_ = [0]*n
for i in range(n):
	a_[idx[i]] = a[i]
	b_[idx[i]] = b[i]

print 'YES'
print ' '.join(map(str, a_))
print ' '.join(map(str, b_))","['constructive algorithms', 'sortings']"
"Appleman has n cards. Each card has an uppercase letter written on it. Toastman must choose k cards from Appleman's cards. Then Appleman should give Toastman some coins depending on the chosen cards. Formally, for each Toastman's card i you should calculate how much Toastman's cards have the letter equal to letter on ith, then sum up all these quantities, such a number of coins Appleman should give to Toastman.Given the description of Appleman's cards. What is the maximum number of coins Toastman can get?","n,k=map(int,raw_input().split())
co=[0 for i in xrange(26)]
for i in raw_input().strip():
    co[ord(i)-ord('A')]+=1
co.sort()
ans=0
for i in co[::-1]:
    take=min(k,i)
    k-=take
    ans+=take*take
print ans",['greedy']
"You are given a sequence of $$$n$$$ pairs of integers: $$$(a_1, b_1), (a_2, b_2), \dots , (a_n, b_n)$$$. This sequence is called bad if it is sorted in non-descending order by first elements or if it is sorted in non-descending order by second elements. Otherwise the sequence is good. There are examples of good and bad sequences:  $$$s = [(1, 2), (3, 2), (3, 1)]$$$ is bad because the sequence of first elements is sorted: $$$[1, 3, 3]$$$;  $$$s = [(1, 2), (3, 2), (1, 2)]$$$ is bad because the sequence of second elements is sorted: $$$[2, 2, 2]$$$;  $$$s = [(1, 1), (2, 2), (3, 3)]$$$ is bad because both sequences (the sequence of first elements and the sequence of second elements) are sorted;  $$$s = [(1, 3), (3, 3), (2, 2)]$$$ is good because neither the sequence of first elements $$$([1, 3, 2])$$$ nor the sequence of second elements $$$([3, 3, 2])$$$ is sorted. Calculate the number of permutations of size $$$n$$$ such that after applying this permutation to the sequence $$$s$$$ it turns into a good sequence. A permutation $$$p$$$ of size $$$n$$$ is a sequence $$$p_1, p_2, \dots , p_n$$$ consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ ($$$1 \le p_i \le n$$$). If you apply permutation $$$p_1, p_2, \dots , p_n$$$ to the sequence $$$s_1, s_2, \dots , s_n$$$ you get the sequence $$$s_{p_1}, s_{p_2}, \dots , s_{p_n}$$$. For example, if $$$s = [(1, 2), (1, 3), (2, 3)]$$$ and $$$p = [2, 3, 1]$$$ then $$$s$$$ turns into $$$[(1, 3), (2, 3), (1, 2)]$$$.","import sys
from collections import Counter

readline = sys.stdin.readline
readlines = sys.stdin.readlines
ns = lambda: readline().rstrip()
ni = lambda: int(readline().rstrip())
nm = lambda: map(int, readline().split())
nl = lambda: list(map(int, readline().split()))
prn = lambda x: print(*x, sep='\n')

n_ = 4 * 10**5
mod = 998244353
fun = [1] * (n_ + 1)
for i in range(1, n_ + 1):
    fun[i] = fun[i - 1] * i % mod
rev = [1] * (n_ + 1)
rev[n_] = pow(fun[n_], mod - 2, mod)
for i in range(n_ - 1, 0, -1):
    rev[i] = rev[i + 1] * (i + 1) % mod


def nCr(n, r):
    if r > n:
        return 0
    return fun[n] * rev[r] % mod * rev[n - r] % mod


def solve():
    n = ni()
    l = [tuple(nm()) for _ in range(n)]
    l.sort()
    ans = fun[n]
    sortab = sorta = sortb = 1
    for i in range(n-1):
        if l[i+1][1] < l[i][1]:
            sortab = 0
            break
    if sortab:
        for x in Counter(l).values():
            sortab = sortab * fun[x] % mod
    for x in Counter([x[0] for x in l]).values():
        sorta = sorta * fun[x] % mod
    for x in Counter([x[1] for x in l]).values():
        sortb = sortb * fun[x] % mod
    # print(ans, sorta, sortb, sortab)
    print((ans - sorta - sortb + sortab) % mod)


solve()

# T = ni()
# for _ in range(T):
#     solve()",['combinatorics']
"Kefa wants to celebrate his first big salary by going to restaurant. However, he needs company. Kefa has n friends, each friend will agree to go to the restaurant if Kefa asks. Each friend is characterized by the amount of money he has and the friendship factor in respect to Kefa. The parrot doesn't want any friend to feel poor compared to somebody else in the company (Kefa doesn't count). A friend feels poor if in the company there is someone who has at least d units of money more than he does. Also, Kefa wants the total friendship factor of the members of the company to be maximum. Help him invite an optimal company!","def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

def solve():
    N, D = getInts()
    #get all the monies in order
    #find out which starting friend allows for the max friendship factor
    friends = []
    prefix_sums = []
    curr_sum = 0
    for n in range(N):
        money, friendship = getInts()
        friends.append((money,friendship))
    friends.sort()
    prefix_sums = []
    for n in range(N):
        curr_sum += friends[n][1]
        prefix_sums.append(curr_sum)
    last_friend = 0
    best = 0
    for first_friend in range(N):
        min_money = friends[first_friend][0]
        last_friend = max(last_friend,first_friend)
        while last_friend < N-1 and friends[last_friend+1][0] < min_money+D:
            last_friend += 1
        if first_friend == 0:
            curr_val = prefix_sums[last_friend]
        else:
            curr_val = prefix_sums[last_friend]-prefix_sums[first_friend-1]
        best = max(best,curr_val)
        if last_friend == N-1:
            return best

ans = solve()
print(ans)","['two pointers', 'binary search', 'sortings']"
"Facetook is a well known social network website, and it will launch a new feature called Facetook Priority Wall. This feature will sort all posts from your friends according to the priority factor (it will be described).This priority factor will be affected by three types of actions:   1. ""X posted on Y's wall"" (15 points),  2. ""X commented on Y's post"" (10 points),  3. ""X likes Y's post"" (5 points). X and Y will be two distinct names. And each action will increase the priority factor between X and Y (and vice versa) by the above value of points (the priority factor between X and Y is the same as the priority factor between Y and X).You will be given n actions with the above format (without the action number and the number of points), and you have to print all the distinct names in these actions sorted according to the priority factor with you.","r={'posted':15,'commented':10,'likes':5}
n=input()
a={}
m=set()
for _ in '0'*int(input()):
	t=input().split()
	s=t[0]
	p=t[3-(t[1]=='likes')][:-2]
	m.add(s)
	m.add(p)
	if s==n:
		a[p]=a.get(p,0)+r[t[1]]
	if p==n:
		a[s]=a.get(s,0)+r[t[1]]
if n in m:
	m.remove(n)
for v in sorted(set(a.values())|set([0]))[::-1]:
	print('\n'.join(sorted(s for s in m if a.get(s,0)==v)))","['implementation', 'expression parsing', 'strings']"
"Welcome to Innopolis city. Throughout the whole year, Innopolis citizens suffer from everlasting city construction. From the window in your room, you see the sequence of n hills, where i-th of them has height ai. The Innopolis administration wants to build some houses on the hills. However, for the sake of city appearance, a house can be only built on the hill, which is strictly higher than neighbouring hills (if they are present). For example, if the sequence of heights is 5, 4, 6, 2, then houses could be built on hills with heights 5 and 6 only.The Innopolis administration has an excavator, that can decrease the height of an arbitrary hill by one in one hour. The excavator can only work on one hill at a time. It is allowed to decrease hills up to zero height, or even to negative values. Increasing height of any hill is impossible. The city administration wants to build k houses, so there must be at least k hills that satisfy the condition above. What is the minimum time required to adjust the hills to achieve the administration's plan?However, the exact value of k is not yet determined, so could you please calculate answers for all k in range ? Here  denotes n divided by two, rounded up.","''' Hey stalker :) '''
INF = 10**10
def main():
    #print = out.append
    ''' Cook your dish here! '''
    n = get_int()
    li = get_list()
    high = []
    high_li = []
    for i in range(n):
        th = high[:]
        thli = high_li[:]
        for j in range((i)//2 + 1):
            k = 0
            hli = li[i] - 1
            if j>0:
                k = low[j-1] + max(0, -li[i] + low_li[j-1] +1)
            elif i>0:
                k = max(0, li[i-1]-li[i]+1)
            if i+1<n:
                k += max(0, li[i+1] - li[i] + 1)
                hli = min(li[i+1], hli)
            #print(i,j,k,hli)
            if j == (i)//2 and i%2==0:
                high.append(k)
                high_li.append(hli)
            else:
                if k<=high[j]:
                    high[j] = k
                    high_li[j] = hli
                else:
                    high_li[j] = li[i+1] if i+1<n else li[i]-1
        low, low_li = th, thli
        #print(i, high, high_li, low, low_li)
    print("" "".join(map(str, high)))





''' Pythonista fLite 1.1 '''
import sys
#from collections import defaultdict, Counter
#from functools import reduce
#import math
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
out = []
get_int = lambda: int(input())
get_list = lambda: list(map(int, input().split()))
main()
#[main() for _ in range(int(input()))]
print(*out, sep='\n')",['dp']
"Berland has n cities, some of them are connected by bidirectional roads. For each road we know whether it is asphalted or not.The King of Berland Valera II wants to asphalt all roads of Berland, for that he gathered a group of workers. Every day Valera chooses exactly one city and orders the crew to asphalt all roads that come from the city. The valiant crew fulfilled the King's order in a day, then workers went home.Unfortunately, not everything is as great as Valera II would like. The main part of the group were gastarbeiters — illegal immigrants who are enthusiastic but not exactly good at understanding orders in Berlandian. Therefore, having received orders to asphalt the roads coming from some of the city, the group asphalted all non-asphalted roads coming from the city, and vice versa, took the asphalt from the roads that had it.Upon learning of this progress, Valera II was very upset, but since it was too late to change anything, he asked you to make a program that determines whether you can in some way asphalt Berlandian roads in at most n days. Help the king.","R=lambda:map(int,raw_input().split())
n,m=R()
g=[[0]*(n+1) for _ in range(n+1)]
w=[[0]*(n+1) for _ in range(n+1)]
for _ in range(m):
  a,b,c=R()
  g[a][b]=g[b][a]=1
  w[a][b]=w[b][a]=c
v=[0]*(n+1)
cc=[0]*(n+1)
def dfs(a,c=0):
  if v[a]:
    return c==cc[a]
  v[a],cc[a]=1,c
  for b in range(1,n+1):
    if g[a][b] and not dfs(b,c if w[a][b] else (1-c)):
      return 0
  return 1
for a in range(1,n+1):
  if not v[a]:
    if not dfs(a):
      print 'Impossible'
      exit()
print sum(cc)
print ' '.join(map(str,(a for a in range(1,n+1) if cc[a])))","['dsu', 'dfs and similar', 'graphs', '2-sat']"
"A Martian boy is named s — he has got this name quite recently from his parents for his coming of age birthday. Now he enjoys looking for his name everywhere. If he sees that he can obtain his name from some string by removing zero or more letters (at that, the remaining letters remain in the same order), he gets happy. For example, if s=«aba», then strings «baobab», «aabbaa», «helloabahello» make him very happy and strings «aab», «baaa» and «helloabhello» do not.However rather than being happy once, he loves twice as much being happy twice! So, when he got string t as a present, he wanted to cut it in two parts (the left part and the right part) so that each part made him happy.Help s determine the number of distinct ways to cut the given string t into two parts in the required manner.","s = input()
t = input()
m = len(s)
n = len(t)
first = 0
last = n
j = 0
flag = 0
i = 0
while i < n and j < m:
    if t[i] == s[j]:
        j += 1
    i += 1
first = i - 1
if j == m:
    flag = 1
i = n - 1
j = m - 1
while i >= 0 and j >= 0:
    if t[i] == s[j]:
        j -= 1
    i -= 1
last = i + 1
# print(first,last)
if flag == 0 or last <= first:
    ans = 0
else:
    ans = last - first
print(ans)","['*special', 'greedy']"
"Some people leave the lights at their workplaces on when they leave that is a waste of resources. As a hausmeister of DHBW, Sagheer waits till all students and professors leave the university building, then goes and turns all the lights off.The building consists of n floors with stairs at the left and the right sides. Each floor has m rooms on the same line with a corridor that connects the left and right stairs passing by all the rooms. In other words, the building can be represented as a rectangle with n rows and m + 2 columns, where the first and the last columns represent the stairs, and the m columns in the middle represent rooms.Sagheer is standing at the ground floor at the left stairs. He wants to turn all the lights off in such a way that he will not go upstairs until all lights in the floor he is standing at are off. Of course, Sagheer must visit a room to turn the light there off. It takes one minute for Sagheer to go to the next floor using stairs or to move from the current room/stairs to a neighboring room/stairs on the same floor. It takes no time for him to switch the light off in the room he is currently standing in. Help Sagheer find the minimum total time to turn off all the lights.Note that Sagheer does not have to go back to his starting position, and he does not have to visit rooms where the light is already switched off.","import sys

n,m = list(map(int,input().split()))
q = 0
k = 0
ans = 0
a = []
for i in range(n):
  a.append(input())
a.reverse()
if n==8 and m==8 and a[3]=='0011010100':
  print(77)
  sys.exit()
for i in range(n):
  if '1' in a[i]:
    q = i
i = 0
j = 1
while True:
  if k==0:
    x = a[i].rfind('1')
    if x<0:
      x=0
    ans += x
  else:
    x = a[i].find('1')
    if x<0:
      x=0
    ans += m+1-x
  #print(ans)
  if i<q:
    pass
  else:
    break
  while ('1' not in a[i+j]) and i+j<q:
    j += 1
  if x+a[i+j].rfind('1')>2*(m+1)-x-a[i+j].find('1'):
    k = 1
    ans += m+1-x+j
    i+=j
  else:
    k = 0
    ans += x+j
    i+=j
  #print(ans)
  j = 1
if ans==-1:
  print(0)
else:
  print(ans)","['dp', 'bitmasks', 'brute force']"
"Alice received a set of Toy Train™ from Bob. It consists of one train and a connected railway network of $$$n$$$ stations, enumerated from $$$1$$$ through $$$n$$$. The train occupies one station at a time and travels around the network of stations in a circular manner. More precisely, the immediate station that the train will visit after station $$$i$$$ is station $$$i+1$$$ if $$$1 \leq i &lt; n$$$ or station $$$1$$$ if $$$i = n$$$. It takes the train $$$1$$$ second to travel to its next station as described.Bob gave Alice a fun task before he left: to deliver $$$m$$$ candies that are initially at some stations to their independent destinations using the train. The candies are enumerated from $$$1$$$ through $$$m$$$. Candy $$$i$$$ ($$$1 \leq i \leq m$$$), now at station $$$a_i$$$, should be delivered to station $$$b_i$$$ ($$$a_i \neq b_i$$$).    The blue numbers on the candies correspond to $$$b_i$$$ values. The image corresponds to the $$$1$$$-st example. The train has infinite capacity, and it is possible to load off any number of candies at a station. However, only at most one candy can be loaded from a station onto the train before it leaves the station. You can choose any candy at this station. The time it takes to move the candies is negligible.Now, Alice wonders how much time is needed for the train to deliver all candies. Your task is to find, for each station, the minimum time the train would need to deliver all the candies were it to start from there.","from collections import defaultdict as dd
n,m=[int(i) for i in input().split(' ')]
a=[]
b=[]

def fnx(i,j):
    if i<j:
        return(j-i)
    else:
        return(n-i+j)

def fnr(r):
    if r%n==0:
        return(n)
    else:
        return(r%n)

for i in range(m):
    x,y=[int(i) for i in input().split(' ')]
    a.append(x)
    b.append(y)
    
ANS=[]

ii=1
s=[[] for i in range(n+1)]
d=dd(list)

r=[ -1 for i in range(n+1)]
y=[-1]

for i in range(m):
    x,yy=a[i],b[i]
    s[x].append([fnx(x,yy),x,yy])    
    d[yy].append(x)
    
for i in range(1,n+1):
    rt=s[i].copy()
    rt.sort()
    r[i]=rt
    y.append(len(s[i]))
#print(r)


p=max(y)
A=(p-2)*n
ans1=[]
ans2=[]
for i in range(1,n+1):
    if y[i]==p:
        if p==1:
            ans2.append(r[i][0])
            continue
        ans1.append(r[i][1])
        ans2.append(r[i][0])
    if y[i]==p-1:
        if p-1==0:
            continue
        ans1.append(r[i][0])



for ij in range(1,n+1):
    tr=0
    for i in range(len(ans1)):
        re=ans1[i][0]+fnr(ans1[i][1]-ij+1)-1
        tr=max(tr,re)
        
    trf=0
    for i in range(len(ans2)):
        re=ans2[i][0]+fnr(ans2[i][1]-ij+1)-1
        trf=max(trf,re)

    er=max(A+tr,A+trf+n)
    #print(er)
    ANS.append(er)
print(*ANS)","['implementation', 'greedy', 'brute force']"
"Let's call a positive integer composite if it has at least one divisor other than $$$1$$$ and itself. For example:  the following numbers are composite: $$$1024$$$, $$$4$$$, $$$6$$$, $$$9$$$;  the following numbers are not composite: $$$13$$$, $$$1$$$, $$$2$$$, $$$3$$$, $$$37$$$. You are given a positive integer $$$n$$$. Find two composite integers $$$a,b$$$ such that $$$a-b=n$$$.It can be proven that solution always exists.","n = int(input())

x = 1000000000

while True:
    if n%2==0:
        if x%2==0 and (x-n)%2==0:
            print(x , x-n)
            break
        else:
            x-=2
    else:
        if x%3 == 0:
            print(x , x-n)
            break
        else:
            x-=1","['brute force', 'math']"
"Today Pari and Arya are playing a game called Remainders.Pari chooses two positive integer x and k, and tells Arya k but not x. Arya have to find the value . There are n ancient numbers c1, c2, ..., cn and Pari has to tell Arya  if Arya wants. Given k and the ancient values, tell us if Arya has a winning strategy independent of value of x or not. Formally, is it true that Arya can understand the value  for any positive integer x?Note, that  means the remainder of x after dividing it by y.","import math

def main():
    n,k = map(int,input().split())
    C = list(map(int,input().split()))
    l=C[0]
    for c in C:
        l = l*c//math.gcd(l,c)%k
        if(l==0):
            print(""Yes"")
            return
    print(""No"")

main()","['number theory', 'chinese remainder theorem', 'math']"
"Anton goes to school, his favorite lessons are arraystudying. He usually solves all the tasks pretty fast, but this time the teacher gave him a complicated one: given two arrays b and c of length n, find array a, such that:where a and b means bitwise AND, while a or b means bitwise OR.Usually Anton is good in arraystudying, but this problem is too hard, so Anton asks you to help.","def f():
    n, = map(int,raw_input().split())
    B = map(int,raw_input().split())
    C = map(int,raw_input().split())
    D = [B[i]+C[i] for i in xrange(n)]
    t = sum(D)
    if n == 1 and B[0] != C[0]:
        print -1
        return
    if t % 2 or t % (n*2):
        print -1
        return
    tA = t / (n*2)
    if any((d-tA)%n for d in D):
        print -1
        return
    A = [(d-tA)//n for d in D]
    mask = [2**i for i in xrange(32)]
    c = [0]*32
    #for i in xrange(32):
        #c[i] = sum(1 if mask[i]&a else 0 for a in A)
    for a in A:
        for i in xrange(32):
            c[i] += 1 if mask[i]&a else 0
    if any(B[i] != sum(c[j]<<j if A[i]&mask[j] else 0 for j in xrange(32)) for i in xrange(n)):
        print -1
        return
    #if C[i] != sum(n<<j if a&mask[j] else c[j]<<j for j in xrange(32)):
    print ' '.join(map(str, A))
 
f()","['constructive algorithms', 'implementation', 'bitmasks', 'math']"
"Recently, you found a bot to play ""Rock paper scissors"" with. Unfortunately, the bot uses quite a simple algorithm to play: he has a string $$$s = s_1 s_2 \dots s_{n}$$$ of length $$$n$$$ where each letter is either R, S or P.While initializing, the bot is choosing a starting index $$$pos$$$ ($$$1 \le pos \le n$$$), and then it can play any number of rounds. In the first round, he chooses ""Rock"", ""Scissors"" or ""Paper"" based on the value of $$$s_{pos}$$$:   if $$$s_{pos}$$$ is equal to R the bot chooses ""Rock"";  if $$$s_{pos}$$$ is equal to S the bot chooses ""Scissors"";  if $$$s_{pos}$$$ is equal to P the bot chooses ""Paper""; In the second round, the bot's choice is based on the value of $$$s_{pos + 1}$$$. In the third round — on $$$s_{pos + 2}$$$ and so on. After $$$s_n$$$ the bot returns to $$$s_1$$$ and continues his game.You plan to play $$$n$$$ rounds and you've already figured out the string $$$s$$$ but still don't know what is the starting index $$$pos$$$. But since the bot's tactic is so boring, you've decided to find $$$n$$$ choices to each round to maximize the average number of wins.In other words, let's suggest your choices are $$$c_1 c_2 \dots c_n$$$ and if the bot starts from index $$$pos$$$ then you'll win in $$$win(pos)$$$ rounds. Find $$$c_1 c_2 \dots c_n$$$ such that $$$\frac{win(1) + win(2) + \dots + win(n)}{n}$$$ is maximum possible.","for _ in range(int(input())):
    n=input();r,s,p=0,0,0
    for i in  n:
        if i==""R"":r+=1 
        elif i==""P"":p+=1 
        else:s+=1 
    if max(r,s,p)==r:
        print(""P""*len(n))
    elif max(r,p,s)==p:
        print(""S""*len(n))
    else:
        print(""R""*len(n))",['greedy']
"Polycarp is very careful. He even types numeric sequences carefully, unlike his classmates. If he sees a sequence without a space after the comma, with two spaces in a row, or when something else does not look neat, he rushes to correct it. For example, number sequence written like ""1,2 ,3,...,   10"" will be corrected to ""1, 2, 3, ..., 10"".In this task you are given a string s, which is composed by a concatination of terms, each of which may be:   a positive integer of an arbitrary length (leading zeroes are not allowed),  a ""comma"" symbol ("",""),  a ""space"" symbol ("" ""),  ""three dots"" (""..."", that is, exactly three points written one after another, also known as suspension points). Polycarp wants to add and remove spaces in the string s to ensure the following:   each comma is followed by exactly one space (if the comma is the last character in the string, this rule does not apply to it),  each ""three dots"" term is preceded by exactly one space (if the dots are at the beginning of the string, this rule does not apply to the term),  if two consecutive numbers were separated by spaces only (one or more), then exactly one of them should be left,  there should not be other spaces. Automate Polycarp's work and write a program that will process the given string s.","ans = input()
while "" ,"" in ans:
    ans = ans.replace("" ,"", "","")
ans = ans.replace(""..."", "" ..."").replace("","", "", "")
while ""  "" in ans:
    ans = ans.replace(""  "", "" "")
for d in ""0123456789"": ans = ans.replace("". "" + d, ""."" + d)
print(ans.strip(), end="""")","['implementation', 'strings']"
"There are $$$n$$$ seats in the train's car and there is exactly one passenger occupying every seat. The seats are numbered from $$$1$$$ to $$$n$$$ from left to right. The trip is long, so each passenger will become hungry at some moment of time and will go to take boiled water for his noodles. The person at seat $$$i$$$ ($$$1 \leq i \leq n$$$) will decide to go for boiled water at minute $$$t_i$$$.Tank with a boiled water is located to the left of the $$$1$$$-st seat. In case too many passengers will go for boiled water simultaneously, they will form a queue, since there can be only one passenger using the tank at each particular moment of time. Each passenger uses the tank for exactly $$$p$$$ minutes. We assume that the time it takes passengers to go from their seat to the tank is negligibly small. Nobody likes to stand in a queue. So when the passenger occupying the $$$i$$$-th seat wants to go for a boiled water, he will first take a look on all seats from $$$1$$$ to $$$i - 1$$$. In case at least one of those seats is empty, he assumes that those people are standing in a queue right now, so he would be better seating for the time being. However, at the very first moment he observes that all seats with numbers smaller than $$$i$$$ are busy, he will go to the tank.There is an unspoken rule, that in case at some moment several people can go to the tank, than only the leftmost of them (that is, seating on the seat with smallest number) will go to the tank, while all others will wait for the next moment.Your goal is to find for each passenger, when he will receive the boiled water for his noodles.","import heapq
n,p = map(int,raw_input().split("" ""))
ti  = map(int,raw_input().split("" ""))
pq  = []
wait = []
for i,v in enumerate(ti):
    heapq.heappush(pq,[v,i])
seq = []
now = 0
ans = [0]*n
while pq:
    v,i = heapq.heappop(pq)
    now = v
    heapq.heappush(wait,[i,v])
    while wait:
        ni,nv = heapq.heappop(wait)
        i = ni
        now = now + p
        ans[i] = now
        while pq and  pq[0][0]<=now:
            nv,ni = heapq.heappop(pq)
            if ni<i:
                now = now+p
                i = ni
                ans[i] = now
            else:
                heapq.heappush(wait,[ni,nv])
print "" "".join(map(str,ans))","['data structures', 'implementation', 'greedy']"
"International Women's Day is coming soon! Polycarp is preparing for the holiday.There are $$$n$$$ candy boxes in the shop for sale. The $$$i$$$-th box contains $$$d_i$$$ candies.Polycarp wants to prepare the maximum number of gifts for $$$k$$$ girls. Each gift will consist of exactly two boxes. The girls should be able to share each gift equally, so the total amount of candies in a gift (in a pair of boxes) should be divisible by $$$k$$$. In other words, two boxes $$$i$$$ and $$$j$$$ ($$$i \ne j$$$) can be combined as a gift if $$$d_i + d_j$$$ is divisible by $$$k$$$.How many boxes will Polycarp be able to give? Of course, each box can be a part of no more than one gift. Polycarp cannot use boxes ""partially"" or redistribute candies between them.","n, k = map(int, input().split(' '))
gifts = sorted(list(map(lambda cnd: int(cnd) % k, input().split())))
equal_classes = [0] * (k)
etalon = gifts[0]
for g in gifts:
    if g == etalon:
        equal_classes[g] += 1
    else:
        etalon = g
        equal_classes[g] += 1
ans = equal_classes[0] - equal_classes[0] % 2
if (k - 1) % 2 == 1:
    equal_classes[k//2] = equal_classes[k//2] - equal_classes[k//2] % 2
for i in range(1, k):
    ans += min(equal_classes[i], equal_classes[k - i])
print(ans)","['number theory', 'math']"
"A lot of frogs want to cross a river. A river is $$$w$$$ units width, but frogs can only jump $$$l$$$ units long, where $$$l &lt; w$$$. Frogs can also jump on lengths shorter than $$$l$$$. but can't jump longer. Hopefully, there are some stones in the river to help them.The stones are located at integer distances from the banks. There are $$$a_i$$$ stones at the distance of $$$i$$$ units from the bank the frogs are currently at. Each stone can only be used once by one frog, after that it drowns in the water.What is the maximum number of frogs that can cross the river, given that then can only jump on the stones?","Q = [int(x) for x in input().split(' ')]
w = Q[0]
l = Q[1]
A = [int(x) for x in input().split(' ')]
B = [0 for i in range(w-1)]
i = 0
j = 0
for i in range(w-1):
	if i<l:
		B[i]=A[i]
	else:
		while j<i:
			if j<i-l:
				j=i-l
			t = min(A[i]-B[i],B[j])
			B[i]+=t
			B[j]-=t
			if B[j]==0:
				j+=1
			else:
				break
	#print(B)
#print(A)
#print(B)
print(sum(B[w-l-1:]))","['two pointers', 'binary search', 'flows', 'greedy']"
"Given two integers $$$n$$$ and $$$x$$$, construct an array that satisfies the following conditions:   for any element $$$a_i$$$ in the array, $$$1 \le a_i&lt;2^n$$$;  there is no non-empty subsegment with bitwise XOR equal to $$$0$$$ or $$$x$$$,  its length $$$l$$$ should be maximized. A sequence $$$b$$$ is a subsegment of a sequence $$$a$$$ if $$$b$$$ can be obtained from $$$a$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.","import sys
input = sys.stdin.readline

n,x=map(int,input().split())

if n==x==1:
    print(0)
    sys.exit()


ANS=[]
for i in range(n):
    if i+1==(x).bit_length():
        continue
    ANS=ANS+[(1<<i)]+ANS

print(len(ANS))
print(*ANS)","['constructive algorithms', 'bitmasks']"
"Imagine that there is a group of three friends: A, B and С. A owes B 20 rubles and B owes C 20 rubles. The total sum of the debts is 40 rubles. You can see that the debts are not organized in a very optimal manner. Let's rearrange them like that: assume that A owes C 20 rubles and B doesn't owe anything to anybody. The debts still mean the same but the total sum of the debts now equals 20 rubles.This task is a generalisation of a described example. Imagine that your group of friends has n people and you know the debts between the people. Optimize the given debts without changing their meaning. In other words, finally for each friend the difference between the total money he should give and the total money he should take must be the same. Print the minimum sum of all debts in the optimal rearrangement of the debts. See the notes to the test samples to better understand the problem.","# -*- coding: utf-8 -*-

n, m = map(int, input().split())
abc = [list(map(int, input().split())) for i in range(m)]

mat = [[0]*n for i in range(n)]
for t in abc:
    mat[t[0]-1][t[1]-1] = t[2]
    
total = 0
for i in range(n):
    s = sum(mat[i][:]) - sum([mat[x][i] for x in range(n)])
    if s < 0:
        continue;
    total += s
print(total)",['implementation']
"Vasiliy is fond of solving different tasks. Today he found one he wasn't able to solve himself, so he asks you to help.Vasiliy is given n strings consisting of lowercase English letters. He wants them to be sorted in lexicographical order (as in the dictionary), but he is not allowed to swap any of them. The only operation he is allowed to do is to reverse any of them (first character becomes last, second becomes one before last and so on).To reverse the i-th string Vasiliy has to spent ci units of energy. He is interested in the minimum amount of energy he has to spent in order to have strings sorted in lexicographical order.String A is lexicographically smaller than string B if it is shorter than B (|A| &lt; |B|) and is its prefix, or if none of them is a prefix of the other and at the first position where they differ character in A is smaller than the character in B.For the purpose of this problem, two equal strings nearby do not break the condition of sequence being sorted lexicographically.","n = int(input())
ref = [int(x) for x in input().split()]
state = [[float('inf')]*2 for x in range(n)]
prev = input()
state[0][0] = 0
state[0][1] = ref[0]
flag = 0
for i in range(1,n):
    cur = input()
    if cur >= prev:
        state[i][0] = min(state[i][0],state[i-1][0])
    if cur >= prev[-1::-1]:
        state[i][0] = min(state[i][0],state[i-1][1])
    if cur[-1::-1] >= prev:
        state[i][1] = min(state[i][1],state[i-1][0]+ref[i])
    if cur[-1::-1] >= prev[-1::-1]:
        state[i][1] = min(state[i][1],state[i-1][1]+ref[i])
    prev = cur
    if state[i][0] >= float('inf') and state[i][1] >= float('inf'):
        flag = 1
        break
if flag == 1:
    print(-1)
else:
    print(min(state[n-1][0],state[n-1][1]))","['dp', 'strings']"
"Sasha and Kolya decided to get drunk with Coke, again. This time they have k types of Coke. i-th type is characterised by its carbon dioxide concentration . Today, on the party in honour of Sergiy of Vancouver they decided to prepare a glass of Coke with carbon dioxide concentration . The drink should also be tasty, so the glass can contain only integer number of liters of each Coke type (some types can be not presented in the glass). Also, they want to minimize the total volume of Coke in the glass.Carbon dioxide concentration is defined as the volume of carbone dioxide in the Coke divided by the total volume of Coke. When you mix two Cokes, the volume of carbon dioxide sums up, and the total volume of Coke sums up as well.Help them, find the minimal natural number of liters needed to create a glass with carbon dioxide concentration . Assume that the friends have unlimited amount of each Coke type.","from collections import deque


MAX_A = 1000


def main():
    n, k = map(int, input().split())
    a = set(int(x) - n for x in input().split())

    visited = [False] * (2 * MAX_A + 1)
    visited[n] = True
    Q = deque()
    Q.append((n, 0))

    result = None
    while Q:
        u, l = Q.popleft()
        l += 1
        for ai in a:
            v = u + ai
            if v == n:
                result = l
                break

            if 0 <= v < len(visited) and not visited[v]:
                visited[v] = True
                Q.append((v, l))

        if result is not None:
            break

    if result is None:
        result = -1

    print(result)


if __name__ == '__main__':
    # import sys
    # sys.stdin = open(""E.txt"")
    main()","['dp', 'graphs', 'shortest paths', 'math', 'graph matchings', 'dfs and similar', 'brute force']"
"Xenia the mathematician has a sequence consisting of n (n is divisible by 3) positive integers, each of them is at most 7. She wants to split the sequence into groups of three so that for each group of three a, b, c the following conditions held:  a &lt; b &lt; c;  a divides b, b divides c. Naturally, Xenia wants each element of the sequence to belong to exactly one group of three. Thus, if the required partition exists, then it has  groups of three.Help Xenia, find the required partition or else say that it doesn't exist.","class CodeforcesTask342ASolution:
    def __init__(self):
        self.result = ''
        self.n = 0
        self.sequence = []

    def read_input(self):
        self.n = int(input())
        self.sequence = [int(x) for x in input().split("" "")]

    def process_task(self):
        counts = [0 for x in range(1, 8)]
        for x in range(self.n):
            counts[self.sequence[x] - 1] += 1
        if max(counts) > self.n // 3:
            self.result = ""-1""
        elif counts[0] != self.n // 3:
            self.result = ""-1""
        elif 7 in self.sequence or 5 in self.sequence:
            self.result = ""-1""
        else:
            self.result = []
            while counts[3]:
                counts[3] -= 1
                if counts[1]:
                    counts[0] -= 1
                    counts[1] -= 1
                    self.result.append(""1 2 4\n"")
            while counts[5]:
                counts[5] -= 1
                if counts[2]:
                    counts[0] -= 1
                    counts[2] -= 1
                    self.result.append(""1 3 6\n"")
                elif counts[1]:
                    counts[0] -= 1
                    counts[1] -= 1
                    self.result.append(""1 2 6\n"")
            if sum(counts):
                self.result = ""-1""
            else:
                for r in self.result:
                    print(r)
                self.result = """"

    def get_result(self):
        return self.result


if __name__ == ""__main__"":
    Solution = CodeforcesTask342ASolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())","['implementation', 'greedy']"
"Little Petya very much likes playing with little Masha. Recently he has received a game called ""Zero-One"" as a gift from his mother. Petya immediately offered Masha to play the game with him.Before the very beginning of the game several cards are lain out on a table in one line from the left to the right. Each card contains a digit: 0 or 1. Players move in turns and Masha moves first. During each move a player should remove a card from the table and shift all other cards so as to close the gap left by the removed card. For example, if before somebody's move the cards on the table formed a sequence 01010101, then after the fourth card is removed (the cards are numbered starting from 1), the sequence will look like that: 0100101. The game ends when exactly two cards are left on the table. The digits on these cards determine the number in binary notation: the most significant bit is located to the left. Masha's aim is to minimize the number and Petya's aim is to maximize it.An unpleasant accident occurred before the game started. The kids spilled juice on some of the cards and the digits on the cards got blurred. Each one of the spoiled cards could have either 0 or 1 written on it. Consider all possible variants of initial arrangement of the digits (before the juice spilling). For each variant, let's find which two cards are left by the end of the game, assuming that both Petya and Masha play optimally. An ordered pair of digits written on those two cards is called an outcome. Your task is to find the set of outcomes for all variants of initial digits arrangement.","a=raw_input()
O,I,Q=[a.count(i)for i in""01?""]
Z=I-O
if Q>Z:print""00""
if-Q<=Z<2+Q:
 if""?"">a[-1]:print""10""[int(a[-1])]+a[-1]
 else:
	if Z<Q:print""01""
	if~Q<1-Z<Q:print 10
if Z+Q>1:print 11","['constructive algorithms', 'greedy', 'games']"
"A and B are preparing themselves for programming contests.After several years of doing sports programming and solving many problems that require calculating all sorts of abstract objects, A and B also developed rather peculiar tastes.A likes lowercase letters of the Latin alphabet. He has assigned to each letter a number that shows how much he likes that letter (he has assigned negative numbers to the letters he dislikes). B likes substrings. He especially likes the ones that start and end with the same letter (their length must exceed one).Also, A and B have a string s. Now they are trying to find out how many substrings t of a string s are interesting to B (that is, t starts and ends with the same letter and its length is larger than one), and also the sum of values of all letters (assigned by A), except for the first and the last one is equal to zero.Naturally, A and B have quickly found the number of substrings t that are interesting to them. Can you do it?","from sys import *
inp = lambda : stdin.readline()

def main():
    cost = list(map(int,inp().split()))
    s = inp()[:-1]
    sum,ans = [0 for i in xrange(len(s))],0
    appears = [[] for i in xrange(26)]

    sum[0] = cost[ord(s[0])-ord('a')]
    appears[ord(s[0])-ord('a')].append(0)
    for i in xrange(1,len(s)):
        sum[i] = sum[i-1] + cost[ord(s[i]) - ord('a')]
        appears[ord(s[i]) - ord('a')].append(i)

    for i in xrange(26):
        now = appears[i]
        d = {}
        for i in xrange(len(now)):
            p = now[i]
            ans += d.get(sum[p-1],0)
            d[sum[p]] = d.get(sum[p],0) + 1
    print(ans)


if __name__ == ""__main__"":
    main()","['dp', 'two pointers', 'data structures']"
"Consider the following problem: given an array $$$a$$$ containing $$$n$$$ integers (indexed from $$$0$$$ to $$$n-1$$$), find $$$\max\limits_{0 \leq l \leq r \leq n-1} \sum\limits_{l \leq i \leq r} (r-l+1) \cdot a_i$$$. In this problem, $$$1 \leq n \leq 2\,000$$$ and $$$|a_i| \leq 10^6$$$.In an attempt to solve the problem described, Alice quickly came up with a blazing-fast greedy algorithm and coded it. Her implementation in pseudocode is as follows:function find_answer(n, a)    # Assumes n is an integer between 1 and 2000, inclusive    # Assumes a is a list containing n integers: a[0], a[1], ..., a[n-1]    res = 0    cur = 0    k = -1    for i = 0 to i = n-1        cur = cur + a[i]        if cur &lt; 0            cur = 0            k = i        res = max(res, (i-k)*cur)    return resAlso, as you can see, Alice's idea is not entirely correct. For example, suppose $$$n = 4$$$ and $$$a = [6, -8, 7, -42]$$$. Then, find_answer(n, a) would return $$$7$$$, but the correct answer is $$$3 \cdot (6-8+7) = 15$$$.You told Alice that her solution is incorrect, but she did not believe what you said.Given an integer $$$k$$$, you are to find any sequence $$$a$$$ of $$$n$$$ integers such that the correct answer and the answer produced by Alice's algorithm differ by exactly $$$k$$$. Note that although the choice of $$$n$$$ and the content of the sequence is yours, you must still follow the constraints earlier given: that $$$1 \leq n \leq 2\,000$$$ and that the absolute value of each element does not exceed $$$10^6$$$. If there is no such sequence, determine so.","k = int(input())
# (s+x)(l+1) - sx = k, s + lx + x = k
a = []
for l in range(1, 2001):
    if 0 <= k + (l+1) < l * 10**6:
        s = k + (l+1)
        a.append(-1)
        a.append(s % 10**6)
        s = s - s % 10**6
        for i in range(1, l):
            a.append(10**6)
        break
print(len(a))
for x in a:
    print(x, end=' ')",['constructive algorithms']
"Vasya came up with a password to register for EatForces — a string $$$s$$$. The password in EatForces should be a string, consisting of lowercase and uppercase Latin letters and digits.But since EatForces takes care of the security of its users, user passwords must contain at least one digit, at least one uppercase Latin letter and at least one lowercase Latin letter. For example, the passwords ""abaCABA12"", ""Z7q"" and ""3R24m"" are valid, and the passwords ""qwerty"", ""qwerty12345"" and ""Password"" are not. A substring of string $$$s$$$ is a string $$$x = s_l s_{l + 1} \dots s_{l + len - 1} (1 \le l \le |s|, 0 \le len \le |s| - l + 1)$$$. $$$len$$$ is the length of the substring. Note that the empty string is also considered a substring of $$$s$$$, it has the length $$$0$$$.Vasya's password, however, may come too weak for the security settings of EatForces. He likes his password, so he wants to replace some its substring with another string of the same length in order to satisfy the above conditions. This operation should be performed exactly once, and the chosen string should have the minimal possible length.Note that the length of $$$s$$$ should not change after the replacement of the substring, and the string itself should contain only lowercase and uppercase Latin letters and digits.","import re

def replace(arr,fr,to):
    index = arr.index(fr)
    arr = arr[0:index]+to+arr[index+1:]
    return arr

t = int(input())

for i in range(t):
    password = str(input().strip())
    lower = re.findall(""[a-z]"",password)
    upper = re.findall(""[A-Z]"",password)
    number = re.findall(""[0-9]"",password)
    l_len = len(lower)
    u_len = len(upper)
    n_len = len(number)

    if(l_len == 0):
        if(u_len >= 2): 
            password = replace(password,upper[0],'a')
            upper = upper[1:]
            u_len -= 1
        elif(n_len >= 2): 
            password = replace(password,number[0],'a')
            number = number[1:]
            n_len -= 1
    
    if(u_len == 0):
        if(l_len >= 2): 
            password = replace(password,lower[0],'A')
            lower = lower[1:]
            l_len -= 1
        elif(n_len >= 2):
            password = replace(password,number[0],'A')
            number = number[1:]
            n_len -= 1
    
    if(n_len == 0):
        if(u_len >= 2): 
            password = replace(password,upper[0],'1')
            upper = upper[1:]
            u_len -= 1
        elif(l_len >= 2): 
            password = replace(password,lower[0],'1')
            lower = lower[1:]
            l_len -= 1
    
    print(password)","['implementation', 'greedy', 'strings']"
"Johnny has just found the new, great tutorial: ""How to become a grandmaster?"". The tutorial tells many strange and unexpected for Johnny things, such as you have to be patient or that very important is solving many harder and harder problems. The boy has found an online judge with tasks divided by topics they cover. He has picked $$$p^{k_i}$$$ problems from $$$i$$$-th category ($$$p$$$ is his favorite number). He wants to solve them in two weeks (the patience condition is too hard for Johnny, so for simplicity, he looks only at easy tasks, which can be solved in such a period). Now our future grandmaster has to decide which topics to cover first and which the second week. Help him assign topics in such a way, that workload is balanced.Formally, given $$$n$$$ numbers $$$p^{k_i}$$$, the boy wants to divide them into two disjoint sets, minimizing the absolute difference between sums of numbers in each set. Find the minimal absolute difference. Output the result modulo $$$10^{9}+7$$$.","from sys import stdin, stdout
import math
from collections import defaultdict

def main():
    MOD7 = 1000000007
    t = int(stdin.readline())
    pw = [0] * 21
    for w in range(20,-1,-1):
        pw[w] = int(math.pow(2,w))
    for ks in range(t):
        n,p = list(map(int, stdin.readline().split()))
        arr = list(map(int, stdin.readline().split()))
        if p == 1:
            if n % 2 ==0:
                stdout.write(""0\n"")
            else:
                stdout.write(""1\n"")
            continue
        arr.sort(reverse=True)
        left = -1
        i = 0
        val = [0] * 21
        tmp = p
        val[0] = p
        slot = defaultdict(int) 
        for x in range(1,21):
            tmp = (tmp * tmp) % MOD7
            val[x] = tmp
        while i < n:
            x = arr[i]
            if left == -1:
                left = x
            else:
                slot[x] += 1
                tmp = x
                if x == left:
                    left = -1
                    slot.pop(x)
                else:
                    while slot[tmp] % p == 0:
                        slot[tmp+1] += 1
                        slot.pop(tmp)
                        tmp += 1
                    if tmp == left:
                        left = -1
                        slot.pop(tmp)
            i+=1
        if left == -1:
             stdout.write(""0\n"")
             continue
        res = 1
        for w in range(20,-1,-1):
            pww = pw[w]
            if pww <= left:
                left -= pww
                res = (res * val[w]) % MOD7
            if left == 0:
                break
        for x,c in slot.items():
            tp = 1
            for w in range(20,-1,-1):
                pww = pw[w]
                if pww <= x:
                    x -= pww
                    tp = (tp * val[w]) % MOD7
                if x == 0:
                    break
            res = (res - tp * c) % MOD7
        stdout.write(str(res)+""\n"")
        

main()","['implementation', 'sortings', 'greedy', 'math']"
"Polycarp is flying in the airplane. Finally, it is his favorite time — the lunchtime. The BerAvia company stewardess is giving food consecutively to all the passengers from the 1-th one to the last one. Polycarp is sitting on seat m, that means, he will be the m-th person to get food.The flight menu has k dishes in total and when Polycarp boarded the flight, he had time to count the number of portions of each dish on board. Thus, he knows values a1, a2, ..., ak, where ai is the number of portions of the i-th dish.The stewardess has already given food to m - 1 passengers, gave Polycarp a polite smile and asked him what he would prefer. That's when Polycarp realized that they might have run out of some dishes by that moment. For some of the m - 1 passengers ahead of him, he noticed what dishes they were given. Besides, he's heard some strange mumbling from some of the m - 1 passengers ahead of him, similar to phrase 'I'm disappointed'. That happened when a passenger asked for some dish but the stewardess gave him a polite smile and said that they had run out of that dish. In that case the passenger needed to choose some other dish that was available. If Polycarp heard no more sounds from a passenger, that meant that the passenger chose his dish at the first try.Help Polycarp to find out for each dish: whether they could have run out of the dish by the moment Polyarp was served or that dish was definitely available.","def ris():
    return map(int, input().split())


def testCase():
    m, k = ris()
    q = 0
    a = list(ris())
    some_is_out = False
    tmp = set()
    for i in range(m - 1):
        t, r = ris()
        t -= 1
        if r == 1 and not some_is_out:
            some_is_out = True
            tmp = tmp.union(set(filter(lambda x: a[x] <= q, range(k))))
        if t == -1:
            q += 1
        else:
            if t in tmp:
                tmp.remove(t)
            a[t] -= 1
            if a[t] < 0:
                a[t] = 0
                q += 1
    if tmp:
        q -= min(map(lambda x: a[x], tmp))
    print("""".join(list(map(lambda x: 'Y' if a[x] - q <= 0 or x in tmp else 'N', range(len(a))))))


for i in range(int(input())):
    input()
    testCase()",['greedy']
"Omkar is playing his favorite pixelated video game, Bed Wars! In Bed Wars, there are $$$n$$$ players arranged in a circle, so that for all $$$j$$$ such that $$$2 \leq j \leq n$$$, player $$$j - 1$$$ is to the left of the player $$$j$$$, and player $$$j$$$ is to the right of player $$$j - 1$$$. Additionally, player $$$n$$$ is to the left of player $$$1$$$, and player $$$1$$$ is to the right of player $$$n$$$.Currently, each player is attacking either the player to their left or the player to their right. This means that each player is currently being attacked by either $$$0$$$, $$$1$$$, or $$$2$$$ other players. A key element of Bed Wars strategy is that if a player is being attacked by exactly $$$1$$$ other player, then they should logically attack that player in response. If instead a player is being attacked by $$$0$$$ or $$$2$$$ other players, then Bed Wars strategy says that the player can logically attack either of the adjacent players.Unfortunately, it might be that some players in this game are not following Bed Wars strategy correctly. Omkar is aware of whom each player is currently attacking, and he can talk to any amount of the $$$n$$$ players in the game to make them instead attack another player  — i. e. if they are currently attacking the player to their left, Omkar can convince them to instead attack the player to their right; if they are currently attacking the player to their right, Omkar can convince them to instead attack the player to their left. Omkar would like all players to be acting logically. Calculate the minimum amount of players that Omkar needs to talk to so that after all players he talked to (if any) have changed which player they are attacking, all players are acting logically according to Bed Wars strategy.","for _ in range(int(input())):
    n=int(input())
    a=list(str(input()))
    ans=0
    flag=0
    c=1
    for i in range(1,n):
        if a[i]!=a[i-1]:
            flag=1
            break
    if i==n-1 and flag==0:
        if a[0]=='R':
            a[0]='L'
        else:
            a[0]='R'
        ans=1
    else:
        a=a[i:n]+a[:i]
    for i in range(1,n):
        if a[i]==a[i-1]:
            c+=1
        else:
            ans+=c//3
            c=1
    print(ans+c//3)","['dp', 'greedy']"
"For an array $$$a$$$ of integers let's denote its maximal element as $$$\max(a)$$$, and minimal as $$$\min(a)$$$. We will call an array $$$a$$$ of $$$k$$$ integers interesting if $$$\max(a) - \min(a) \ge k$$$. For example, array $$$[1, 3, 4, 3]$$$ isn't interesting as $$$\max(a) - \min(a) = 4 - 1 = 3 &lt; 4$$$ while array $$$[7, 3, 0, 4, 3]$$$ is as $$$\max(a) - \min(a) = 7 - 0 = 7 \ge 5$$$.You are given an array $$$a$$$ of $$$n$$$ integers. Find some interesting nonempty subarray of $$$a$$$, or tell that it doesn't exist.An array $$$b$$$ is a subarray of an array $$$a$$$ if $$$b$$$ can be obtained from $$$a$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. In particular, an array is a subarray of itself.","t=int(input())
for o in range(t):
    n=int(input()) 
    l=list(map(int,input().split()))  
    flag=0
    for i in range(n-1):
            if abs(l[i]-l[i+1])>=2: 
                print(""YES"")
                print(str(i+1)+"" ""+str(i+2)) 
                flag=1 
                break
        
                
    if(flag==0):
        print(""NO"")","['constructive algorithms', 'greedy', 'math']"
"Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the 1-st one (in this problem we consider the elements of the array indexed from 1 to n) and ending with the n-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the n-th and ending with the 1-st one. Sasha argues that the two approaches are equivalent.To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from 1 to n, and generated m queries of the form: find element with value bi in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.","n = int(input())
l = list(map(int,input().split()))
d1 = {l[i]:i+1 for i in range(n)}
m = int(input())
queries = list(map(int,input().split()))
count1 = 0
count2 = 0
k1 = set({})
k2 = set({})
for i in queries:
	count1 = count1 + d1[i]
	count2 = count2 + n+1-d1[i]
print(count1,count2)",['implementation']
"Well, here is another math class task. In mathematics, GCD is the greatest common divisor, and it's an easy task to calculate the GCD between two positive integers.A common divisor for two positive numbers is a number which both numbers are divisible by.But your teacher wants to give you a harder task, in this task you have to find the greatest common divisor d between two integers a and b that is in a given range from low to high (inclusive), i.e. low ≤ d ≤ high. It is possible that there is no common divisor in the given range.You will be given the two integers a and b, then n queries. Each query is a range from low to high and you have to answer each query.","a, b = map(int, input().split())
import math
g = math.gcd(a, b)
lis = [i for i in range(1, int(math.sqrt(g)) + 1) if g%i == 0]
for i in lis[::-1]: lis.append(g//i)
n = int(input())
for _ in range(n):
    a, b = map(int , input().split())
    import bisect
    x = bisect.bisect(lis, b) - 1
    if lis[x] < a: print(-1)
    else: print(lis[x])","['binary search', 'number theory']"
"Given an array $$$a$$$, consisting of $$$n$$$ integers, find:$$$$$$\max\limits_{1 \le i &lt; j \le n} LCM(a_i,a_j),$$$$$$where $$$LCM(x, y)$$$ is the smallest positive integer that is divisible by both $$$x$$$ and $$$y$$$. For example, $$$LCM(6, 8) = 24$$$, $$$LCM(4, 12) = 12$$$, $$$LCM(2, 3) = 6$$$.","import sys
from fractions import gcd
input = sys.stdin.readline

n = int(input())
A = map(int, input().split())

divisors = [[] for _ in range(10**5+2)]
mobius = [1 for _ in range(10**5+2)]

for i in range(1,10**5+1):
    for j in range(i,10**5+1,i):
        divisors[j].append(i)

for i in range(1,10**5+1):
    for d in divisors[i]:
        if d == 1: continue
        if i % (d**2) == 0 or mobius[i] == 0: mobius[i] = 0
        elif len(divisors[i]) == 2: mobius[i] = -1
        else: mobius[i] = mobius[d] * mobius[i / d]


numbers = set(A)
for i in A:
    for d in divisors[i]:
        numbers.add(d)


numbers = sorted(list(numbers), reverse=True)
stack = []
cnt = [0] * (10**5+2)
for i in numbers:
    stack.append(i)
    for d in divisors[i]:
        cnt[d] += 1

ans = 0

for x in numbers:
    num_co_prime = sum(cnt[d] * mobius[d] for d in divisors[x])
    while num_co_prime > 0:
        a = stack.pop()
        for d in divisors[a]:
            cnt[d] -= 1
        if gcd(a,x) > 1:
            continue
        ans = max(a*x,ans)
        num_co_prime-=1

print ans","['combinatorics', 'binary search', 'number theory']"
"JATC loves Banh-mi (a Vietnamese food). His affection for Banh-mi is so much that he always has it for breakfast. This morning, as usual, he buys a Banh-mi and decides to enjoy it in a special way.First, he splits the Banh-mi into $$$n$$$ parts, places them on a row and numbers them from $$$1$$$ through $$$n$$$. For each part $$$i$$$, he defines the deliciousness of the part as $$$x_i \in \{0, 1\}$$$. JATC's going to eat those parts one by one. At each step, he chooses arbitrary remaining part and eats it. Suppose that part is the $$$i$$$-th part then his enjoyment of the Banh-mi will increase by $$$x_i$$$ and the deliciousness of all the remaining parts will also increase by $$$x_i$$$. The initial enjoyment of JATC is equal to $$$0$$$.For example, suppose the deliciousness of $$$3$$$ parts are $$$[0, 1, 0]$$$. If JATC eats the second part then his enjoyment will become $$$1$$$ and the deliciousness of remaining parts will become $$$[1, \_, 1]$$$. Next, if he eats the first part then his enjoyment will become $$$2$$$ and the remaining parts will become $$$[\_, \_, 2]$$$. After eating the last part, JATC's enjoyment will become $$$4$$$.However, JATC doesn't want to eat all the parts but to save some for later. He gives you $$$q$$$ queries, each of them consisting of two integers $$$l_i$$$ and $$$r_i$$$. For each query, you have to let him know what is the maximum enjoyment he can get if he eats all the parts with indices in the range $$$[l_i, r_i]$$$ in some order.All the queries are independent of each other. Since the answer to the query could be very large, print it modulo $$$10^9+7$$$.","import sys
input = sys.stdin.readline

n, q = map(int, input().split())
s = input()
pref = [0 for i in range(n + 1)]
for i in range(1, n + 1):
    pref[i] = pref[i - 1] + (s[i - 1] == '1')
mod = 1000000007
ans = []
for i in range(q):
    a, b = map(int, input().split())
    k = pref[b] - pref[a - 1];
    N = b - a + 1
    z = N - k
    
    ans.append((pow(2, k, mod) - 1) * pow(2, z, mod) % mod)
print(*ans)","['implementation', 'greedy', 'math']"
"Allen and Bessie are playing a simple number game. They both know a function $$$f: \{0, 1\}^n \to \mathbb{R}$$$, i. e. the function takes $$$n$$$ binary arguments and returns a real value. At the start of the game, the variables $$$x_1, x_2, \dots, x_n$$$ are all set to $$$-1$$$. Each round, with equal probability, one of Allen or Bessie gets to make a move. A move consists of picking an $$$i$$$ such that $$$x_i = -1$$$ and either setting $$$x_i \to 0$$$ or $$$x_i \to 1$$$.After $$$n$$$ rounds all variables are set, and the game value resolves to $$$f(x_1, x_2, \dots, x_n)$$$. Allen wants to maximize the game value, and Bessie wants to minimize it.Your goal is to help Allen and Bessie find the expected game value! They will play $$$r+1$$$ times though, so between each game, exactly one value of $$$f$$$ changes. In other words, between rounds $$$i$$$ and $$$i+1$$$ for $$$1 \le i \le r$$$, $$$f(z_1, \dots, z_n) \to g_i$$$ for some $$$(z_1, \dots, z_n) \in \{0, 1\}^n$$$. You are to find the expected game value in the beginning and after each change.","R = lambda:list(map(int,input().split()))
sum1 = 0
p1 = 1
a = [0]*263000
b = a
n,r = R()
p1 = 2**n
a = R()
sum1 = sum(a)
p2 = sum1 / p1
for i in range(r):
	z,g=R()
	sum1 = sum1 - a[z] + g
	a[z] = g
	b[i] = sum1/p1
print(p2)
for i in range(r):
	print(b[i])",['math']
"Vasya had a strictly increasing sequence of positive integers a1, ..., an. Vasya used it to build a new sequence b1, ..., bn, where bi is the sum of digits of ai's decimal representation. Then sequence ai got lost and all that remained is sequence bi.Vasya wonders what the numbers ai could be like. Of all the possible options he likes the one sequence with the minimum possible last number an. Help Vasya restore the initial sequence.It is guaranteed that such a sequence always exists.","def getnum(digsum):
    if digsum < 0:
        return 0
    if digsum < 10:
        return digsum
    else:
        nnine = digsum // 9
        res = digsum % 9
        for i in range(nnine):
            res = 10 * res + 9
        return res

def digsumf(n):
    return sum([int(i) for i in str(n)])

def getnext(bnum, last):
    if last == 0:
        return getnum(bnum)

    k = last + 1
    digsum = digsumf(k)
    diff = bnum - digsum
    if diff >= 0 and 9 - k % 10 >= diff:
        return k + diff

    omitsum = 0
    startdigsum = digsumf(last)
    lastl = [int(i) for i in str(last)]
    digsum = digsumf(last)
    l = 10
    i = 1
    while True:
        if i == 1 and len(str(l)) - 1 <= len(lastl):
            omitsum += lastl[-(len(str(l)) - 1)]
        if (last // l) % 10 + i > 9:
            l *= 10
            i = 1
            continue
        k = (last // l) * l + l * i
        digsum = startdigsum - omitsum + i
        diff = bnum - digsum
        r = getnum(diff)
        if diff >= 0 and len(str(r)) <= len(str(l // 10)):
            return r + k
        if diff < 0:
            l *= 10
            i = 1
        else:
            i += 1

n = int(input())
last = 0
for i in range(n):
    last = getnext(int(input()), last)
    print(last)","['dp', 'implementation', 'greedy']"
"Recently, a start up by two students of a state university of city F gained incredible popularity. Now it's time to start a new company. But what do we call it?The market analysts came up with a very smart plan: the name of the company should be identical to its reflection in a mirror! In other words, if we write out the name of the company on a piece of paper in a line (horizontally, from left to right) with large English letters, then put this piece of paper in front of the mirror, then the reflection of the name in the mirror should perfectly match the line written on the piece of paper.There are many suggestions for the company name, so coming up to the mirror with a piece of paper for each name wouldn't be sensible. The founders of the company decided to automatize this process. They asked you to write a program that can, given a word, determine whether the word is a 'mirror' word or not.","n=input();cnt=0;p="""";a=[""A"",""H"",""I"",""M"",""O"",""T"",""U"",""V"",""W"",""X"",""Y""]
for i in range(len(n)-1,-1,-1) :
    p=p+n[i]
    if n[i] in a :
        cnt+=1
if cnt==len(n) and p==n :
    print(""YES"")
else :
    print(""NO"")",['implementation']
"Two people play the following string game. Initially the players have got some string s. The players move in turns, the player who cannot make a move loses. Before the game began, the string is written on a piece of paper, one letter per cell.  An example of the initial situation at s = ""abacaba"" A player's move is the sequence of actions:  The player chooses one of the available pieces of paper with some string written on it. Let's denote it is t. Note that initially, only one piece of paper is available.  The player chooses in the string t = t1t2... t|t| character in position i (1 ≤ i ≤ |t|) such that for some positive integer l (0 &lt; i - l; i + l ≤ |t|) the following equations hold: ti - 1 = ti + 1, ti - 2 = ti + 2, ..., ti - l = ti + l.  Player cuts the cell with the chosen character. As a result of the operation, he gets three new pieces of paper, the first one will contain string t1t2... ti - 1, the second one will contain a string consisting of a single character ti, the third one contains string ti + 1ti + 2... t|t|.   An example of making action (i = 4) with string s = «abacaba» Your task is to determine the winner provided that both players play optimally well. If the first player wins, find the position of character that is optimal to cut in his first move. If there are multiple positions, print the minimal possible one.","from sys import stdin


def task():
    value = stdin.readline()
    games = []
    counter = 0
    for i in xrange(1, len(value)-1):
        if value[i - 1] == value[i + 1]:
            counter += 1
        else:
            if counter > 0:
                games.append(counter)
            counter = 0
    if counter > 0:
        games.append(counter)
    max_game = max(games) if games else 0

    grundi = [0, 1, 1]
    for n in xrange(3, max_game + 1):
        s = {grundi[i] ^ grundi[n - i - 3] for i in xrange(0, n // 2 + 1)}
        s.add(grundi[n - 2])
        for i in xrange(n):
            if i not in s:
                grundi.append(i)
                break

    g = 0
    for game in games:
        g ^= grundi[game]
    print 'First' if g > 0 else 'Second'

    def check(n, g):
        if n < 3:
            return 0 if g == 0 else -1
        else:
            if grundi[n - 2] ^ g == 0:
                return 0
            for i in xrange(0, n - 2):
                if g ^ grundi[i] ^ grundi[n - i - 3] == 0:
                    return i + 1
            return -1

    cache = set()
    counter = 0
    delta = 0
    if g > 0:
        for i in xrange(1, len(value)-1):
            if value[i - 1] == value[i + 1]:
                if not delta:
                    delta = i + 1
                counter += 1
            else:
                if counter > 0:
                    if counter not in cache:
                        p = check(counter, grundi[counter] ^ g)
                        if p >= 0:
                            print delta + p
                            quit()
                        cache.add(counter)
                counter = 0
                delta = 0
        print delta + check(counter, grundi[counter] ^ g)

task()",['games']
"Alyona has recently bought a miniature fridge that can be represented as a matrix with $$$h$$$ rows and $$$2$$$ columns. Initially there is only one shelf at the bottom of the fridge, but Alyona can install arbitrary number of shelves inside the fridge between any two rows. A shelf is two cells wide, does not occupy any space but separates the inside of the fridge to the lower and upper part.  An example of a fridge with $$$h = 7$$$ and two shelves. The shelves are shown in black. The picture corresponds to the first example. Alyona has $$$n$$$ bottles of milk that she wants to put in the fridge. The $$$i$$$-th bottle is $$$a_i$$$ cells tall and $$$1$$$ cell wide. She can put a bottle on some shelf if the corresponding space above the shelf is at least as tall as the bottle. She can not put a bottle on top of another bottle (if there is no shelf between them). Two bottles can not share a cell.Alyona is interested in the largest integer $$$k$$$ such that she can put bottles $$$1$$$, $$$2$$$, ..., $$$k$$$ in the fridge at the same time. Find this largest $$$k$$$.","from sys import stdin

n, h = list(map(int, stdin.readline().split()))
a = list(map(int, stdin.readline().split()))

v = h * 2
sv = sum(a)
k = n
while sv > v:
    k -= 1
    sv -= a[k]

fit = 0
k += 1
while not fit:
    k -= 1
    ff = fr = 1
    ta = sorted(a[:k])
    sh = 0
    sf = 0
    th = 0
    fit = 1
    for b in ta:
        sf += 1
        th = max(th, sh + b)
        if th > h:
            ff = 0
            break
        if sf == 2:
            sh = th
            sf = 0
    ta = sorted(a[:k], reverse=True)
    sh = 0
    sf = 0
    th = 0
    fit = 1
    for b in ta:
        sf += 1
        th = max(th, sh + b)
        if th > h:
            fr = 0
            break
        if sf == 2:
            sh = th
            sf = 0
    fit = ff + fr

print(k)","['binary search', 'flows', 'sortings', 'greedy']"
"You are given n segments on the Ox-axis. You can drive a nail in any integer point on the Ox-axis line nail so, that all segments containing this point, are considered nailed down. If the nail passes through endpoint of some segment, this segment is considered to be nailed too. What is the smallest number of nails needed to nail all the segments down?","#!/usr/bin/env python3

# Read data
n = int(input())
segments = [map(int, input().split()) for i in range(n)]
segments = [(min(a,b), max(a,b)) for (a,b) in segments] # Make sure segments run from low to high

# Sort the end positions
end_pos = [b for (a,b) in segments]
end_pos.sort()

nail_positions = [] # Positions where the nails will be put
while (n != 0):
  # Put the nail at the last position possible before it will miss the (currently) first segment
  nail_pos = end_pos[0]
  nail_positions.append(nail_pos)

  # Find the nailed and remaining segments
  nailed_segments = [(a,b) for (a,b) in segments if ((a <= nail_pos) and (nail_pos <= b))]
  segments = [(a,b) for (a,b) in segments if ((a > nail_pos) or (nail_pos > b))]
  n = len(segments)
  # Update the start and end positions
  for (a,b) in nailed_segments:
    end_pos.remove(b)

print(len(nail_positions))
print("" "".join([""%d"" % pos for pos in nail_positions]))","['sortings', 'greedy']"
"The Bad Luck Island is inhabited by three kinds of species: r rocks, s scissors and p papers. At some moments of time two random individuals meet (all pairs of individuals can meet equiprobably), and if they belong to different species, then one individual kills the other one: a rock kills scissors, scissors kill paper, and paper kills a rock. Your task is to determine for each species what is the probability that this species will be the only one to inhabit this island after a long enough period of time.","from collections import defaultdict
def main():
    r, s, p = map(int, raw_input().split())
    ans = [0.0] * 3
    d = defaultdict(float)
    nd = defaultdict(float)
    d[r,s,p] = 1.0
    for i in xrange(r + s + p):
        for t, v in d.viewitems():
            r, s, p = t
            if not r and not s:
                ans[2] += v
            elif not s and not p:
                ans[0] += v
            elif not p and not r:
                ans[1] += v
            else:
                k = 1.0 / (r * s + s * p + p * r)
                if p and r:
                    nd[r-1,s,p] += v * r * p * k
                if r and s:
                    nd[r,s-1,p] += v * r * s * k
                if s and p:
                    nd[r,s,p-1] += v * s * p * k
        d, nd = nd, d
        nd.clear()
    print ""%.12f %.12f %.12f"" % (ans[0], ans[1], ans[2])
main()","['dp', 'probabilities']"
"Petya has n integers: 1, 2, 3, ..., n. He wants to split these integers in two non-empty groups in such a way that the absolute difference of sums of integers in each group is as small as possible. Help Petya to split the integers. Each of n integers should be exactly in one group.","n=int(input())
f=[]
f1=s1=0
for i in range(n,0,-1):
    if f1<=s1:
        f1+=i
        f.append(i)
    else:
        s1+=i
print(abs(f1-s1))
print(str(len(f)),*f)","['constructive algorithms', 'graphs', 'math']"
"Monocarp had a tree which consisted of $$$n$$$ vertices and was rooted at vertex $$$1$$$. He decided to study BFS (Breadth-first search), so he ran BFS on his tree, starting from the root. BFS can be described by the following pseudocode:a = [] # the order in which vertices were processedq = Queue()q.put(1) # place the root at the end of the queuewhile not q.empty():    k = q.pop() # retrieve the first vertex from the queue    a.append(k) # append k to the end of the sequence in which vertices were visited    for y in g[k]: # g[k] is the list of all children of vertex k, sorted in ascending order        q.put(y)Monocarp was fascinated by BFS so much that, in the end, he lost his tree. Fortunately, he still has a sequence of vertices, in which order vertices were visited by the BFS algorithm (the array a from the pseudocode). Monocarp knows that each vertex was visited exactly once (since they were put and taken from the queue exactly once). Also, he knows that all children of each vertex were viewed in ascending order.Monocarp knows that there are many trees (in the general case) with the same visiting order $$$a$$$, so he doesn't hope to restore his tree. Monocarp is okay with any tree that has minimum height.The height of a tree is the maximum depth of the tree's vertices, and the depth of a vertex is the number of edges in the path from the root to it. For example, the depth of vertex $$$1$$$ is $$$0$$$, since it's the root, and the depth of all root's children are $$$1$$$.Help Monocarp to find any tree with given visiting order $$$a$$$ and minimum height.","for _ in range(int(input())):
	n = int(input())
	l = list(map(int, input().split()))
	d,c = [0]*n,0
	for i in range(1,n):
		if l[i-1] > l[i]:
			c += 1
		d[i] = d[c] + 1
	print(d[n-1])
'''
5

1 2 5 4 3

'''","['greedy', 'graphs', 'trees', 'shortest paths']"
"Petya and Vasya are playing a game. Petya's got n non-transparent glasses, standing in a row. The glasses' positions are indexed with integers from 1 to n from left to right. Note that the positions are indexed but the glasses are not.First Petya puts a marble under the glass in position s. Then he performs some (possibly zero) shuffling operations. One shuffling operation means moving the glass from the first position to position p1, the glass from the second position to position p2 and so on. That is, a glass goes from position i to position pi. Consider all glasses are moving simultaneously during one shuffling operation. When the glasses are shuffled, the marble doesn't travel from one glass to another: it moves together with the glass it was initially been put in.After all shuffling operations Petya shows Vasya that the ball has moved to position t. Vasya's task is to say what minimum number of shuffling operations Petya has performed or determine that Petya has made a mistake and the marble could not have got from position s to position t.","import sys

values = [int(x) for x in sys.stdin.readline().split()]
n_glasses, start, end = values[0], values[1], values[2]
positions = [int(x) for x in sys.stdin.readline().split()]
used = {}
min_swaps = 0

start -= 1

while start != end-1:
    if start in used:
        print(""-1"")
        sys.exit(0)
    min_swaps += 1
    used[start] = True
    start = positions[start]-1
    
print(min_swaps)",['implementation']
"You are given a string $$$s$$$ consisting of exactly $$$n$$$ characters, and each character is either '0', '1' or '2'. Such strings are called ternary strings.Your task is to replace minimum number of characters in this string with other characters to obtain a balanced ternary string (balanced ternary string is a ternary string such that the number of characters '0' in this string is equal to the number of characters '1', and the number of characters '1' (and '0' obviously) is equal to the number of characters '2').Among all possible balanced ternary strings you have to obtain the lexicographically (alphabetically) smallest.Note that you can neither remove characters from the string nor add characters to the string. Also note that you can replace the given characters only with characters '0', '1' and '2'.It is guaranteed that the answer exists.","n = int(input())
s = list(input())
d = {i:0 for i in '012'}
for i in s:
    d[i] += 1
eq = n // 3
i = 0
while d['0'] < eq:
    if s[i] != '0':
        if d[s[i]] > eq:
            d[s[i]] -= 1
            d['0'] += 1
            s[i] = '0'
    i += 1
i = n - 1
while d['2'] < eq:
    if s[i] != '2':
        if d[s[i]] > eq:
            d[s[i]] -= 1
            d['2'] += 1
            s[i] = '2'
    i -= 1
i = n - 1
while d['1'] < eq and i >= 0:
    if s[i] == '0':
        if d[s[i]] > eq:
            d[s[i]] -= 1
            d['1'] += 1
            s[i] = '1'
    i -= 1
i = 0
while d['1'] < eq and i < n:
    if s[i] == '2':
        if d[s[i]] > eq:
            d[s[i]] -= 1
            d['1'] += 1
            s[i] = '1'
    i += 1
print(*s, sep = '')","['greedy', 'strings']"
"You are given an array $$$a_1, a_2, \dots, a_n$$$. You can perform the following operation any number of times:  Choose a pair of two neighboring equal elements $$$a_i = a_{i + 1}$$$ (if there is at least one such pair).  Replace them by one element with value $$$a_i + 1$$$. After each such operation, the length of the array will decrease by one (and elements are renumerated accordingly). What is the minimum possible length of the array $$$a$$$ you can get?","from sys import stdin, gettrace

if not gettrace():
    def input():
        return next(stdin)[:-1]


# def input():
#    return stdin.buffer.readline()

INF = 10000


def main():
    n = int(input())
    aa = [int(a) for a in input().split()]

    dp = [[0] * (n+1) for _ in range(n)]

    def calc_dp(i, j):
        if i + 1 == j:
            dp[i][j] = aa[i]
        if dp[i][j] != 0:
            return dp[i][j]
        dp[i][j] = -1
        for k in range(i+1, j):
            lf = calc_dp(i, k)
            rg = calc_dp(k, j)
            if lf > 0 and lf == rg:
                dp[i][j] = lf + 1
                break
        return dp[i][j]

    dp2 = list(range(0,n+1))
    for i in range(n):
        for j in range(i+1, n+1):
            if calc_dp(i, j) > 0:
                dp2[j] = min(dp2[j], dp2[i] + 1)
    print(dp2[n])





if __name__ == ""__main__"":
    main()","['dp', 'greedy']"
"Find an n × n matrix with different numbers from 1 to n2, so the sum in each row, column and both main diagonals are odd.","#n = input()
n = input()
odds = [i for i in range(1,n*n+1) if i % 2 == 1]
evens = [i for i in range(1,n*n+1) if i % 2 == 0]
#print(odds)
#print(evens)
magic = []
for i in range(int(n/2)):
    magic.append(2*i+1)
    
magic2 = magic[::-1]
magic = magic + [n] + magic2
#print(magic)    

result = []
for i in range(n):
    temp = []
    #2i + 1 odds
    # (n - 2i -1) / 2
    numEvens = int((n-magic[i])/2)
    numOdds = magic[i]
    #print(""numEvens ="", numEvens)
    temp += evens[:numEvens]
    evens = evens[numEvens:]
    temp += odds[:numOdds]
    odds = odds[numOdds:]
    temp += evens[:numEvens]
    evens = evens[numEvens:]
    result += temp
    #print(result)
    
#print(result)
print("" "".join([str(x) for x in result]))
#for l in result:
    #for j in l:
        #print(j,)
    #print()","['constructive algorithms', 'math']"
"Eugene likes working with arrays. And today he needs your help in solving one challenging task.An array $$$c$$$ is a subarray of an array $$$b$$$ if $$$c$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.Let's call a nonempty array good if for every nonempty subarray of this array, sum of the elements of this subarray is nonzero. For example, array $$$[-1, 2, -3]$$$ is good, as all arrays $$$[-1]$$$, $$$[-1, 2]$$$, $$$[-1, 2, -3]$$$, $$$[2]$$$, $$$[2, -3]$$$, $$$[-3]$$$ have nonzero sums of elements. However, array $$$[-1, 2, -1, -3]$$$ isn't good, as his subarray $$$[-1, 2, -1]$$$ has sum of elements equal to $$$0$$$.Help Eugene to calculate the number of nonempty good subarrays of a given array $$$a$$$.","n = int(input())
seen = dict()
seen[0] = 0
out = 0
l = list(map(int,input().split()))
curr = 0
bestCurr = 0
for i in range(n):
    curr += l[i]
    if curr in seen:
        bestCurr = min(bestCurr + 1, i - seen[curr])
    else:
        bestCurr += 1
    out += bestCurr
    seen[curr] = i + 1
print(out)","['data structures', 'two pointers', 'implementation', 'binary search']"
"You've got a undirected graph G, consisting of n nodes. We will consider the nodes of the graph indexed by integers from 1 to n. We know that each node of graph G is connected by edges with at least k other nodes of this graph. Your task is to find in the given graph a simple cycle of length of at least k + 1.A simple cycle of length d (d &gt; 1) in graph G is a sequence of distinct graph nodes v1, v2, ..., vd such, that nodes v1 and vd are connected by an edge of the graph, also for any integer i (1 ≤ i &lt; d) nodes vi and vi + 1 are connected by an edge of the graph.","r = lambda: map(int, raw_input().split())

n, m, k = r()
e = [[] for _ in xrange(n + 1)]
for _ in xrange(m):
    a, b = r()
    e[a].append(b)
    e[b].append(a)
flag = [-1] * (n + 1)
path = []

x, l = 1, 0
while True:
    path.append(x)
    flag[x] = l
    l += 1
    for y in e[x]:
        if flag[y] == -1:
            x = y
            break
    else:
        id = path.index(min(e[x], key = lambda s: flag[s]))
        print len(path) - id
        print ' '.join(map(str, path[id:]))
        break","['dfs and similar', 'graphs']"
"Volodya and Vlad play the following game. There are k pies at the cells of n  ×  m board. Each turn Volodya moves one pie to the neighbouring (by side) cell. If the pie lies at the border of the board then Volodya can move it outside the board, get the pie and win. After Volodya's move, Vlad bans some edge at the border of the board of length 1 (between two knots of the board) so that Volodya is not able to move the pie outside the board through this edge anymore. The question is: will Volodya win this game? We suppose both players follow the optimal strategy.","n, m, k = map(int, input().split())
win = False
for i in range(k):
    x, y = map(int, input().split())
    if abs(x - 1) <= 4 or abs(y - 1) <= 4 or \
            abs(n - x) <= 4 or abs(m - y) <= 4:
        win = True

print('YES' if win else 'NO')",['games']
"It can be shown that any positive integer x can be uniquely represented as x = 1 + 2 + 4 + ... + 2k - 1 + r, where k and r are integers, k ≥ 0, 0 &lt; r ≤ 2k. Let's call that representation prairie partition of x.For example, the prairie partitions of 12, 17, 7 and 1 are:  12 = 1 + 2 + 4 + 5,17 = 1 + 2 + 4 + 8 + 2,7 = 1 + 2 + 4,1 = 1. Alice took a sequence of positive integers (possibly with repeating elements), replaced every element with the sequence of summands in its prairie partition, arranged the resulting numbers in non-decreasing order and gave them to Borys. Now Borys wonders how many elements Alice's original sequence could contain. Find all possible options!","from collections import Counter
from math import log2, ceil

MAX = ceil(log2(10 ** 12))


def can():
    seqs_cp = Counter(seqs)
    for num in set(nums):
        cnt = nums[num]
        while cnt != 0 and num < 2 ** 63:
            dif = min(cnt, seqs_cp[num])
            cnt -= dif
            seqs_cp[num] -= dif
            num *= 2
        if cnt > 0:
            return False
    return True


n = int(input())

seq = list(map(int, input().split()))
cnt = Counter(seq)
nums = Counter(seq)

seqs = Counter()
cur_cnt = cnt[1]
cur_pow = 1
while cur_cnt != 0:
    nums[cur_pow] -= cur_cnt
    cur_pow *= 2
    if cur_cnt > cnt[cur_pow]:
        seqs[cur_pow // 2] = cur_cnt - cnt[cur_pow]
        cur_cnt = cnt[cur_pow]

for num in set(nums):
    addition = nums[num]
    nums[num] = 0
    nums[2 ** int(log2(num))] += addition

# remove elements with zero count
nums -= Counter()
seqs -= Counter()

cur_len = sum(seqs[num] for num in set(seqs))
res = []
cur_pow = 1

while can():
    res.append(cur_len)
    while seqs[cur_pow] == 0 and cur_pow <= 2 ** 63:
        cur_pow *= 2
    if cur_pow > 2 ** 63:
        break
    other_pow = 1
    while other_pow <= cur_pow:
        nums[other_pow] += 1
        other_pow *= 2
    seqs[cur_pow] -= 1
    cur_len -= 1

print(-1 if len(res) == 0 else ' '.join(map(str, reversed(res))))","['binary search', 'greedy']"
"Gleb ordered pizza home. When the courier delivered the pizza, he was very upset, because several pieces of sausage lay on the crust, and he does not really like the crust.The pizza is a circle of radius r and center at the origin. Pizza consists of the main part — circle of radius r - d with center at the origin, and crust around the main part of the width d. Pieces of sausage are also circles. The radius of the i -th piece of the sausage is ri, and the center is given as a pair (xi, yi).Gleb asks you to help determine the number of pieces of sausage caught on the crust. A piece of sausage got on the crust, if it completely lies on the crust.","#RAVENS
#TEAM_2
#ESSI-DAYI_MOHSEN-LORENZO

from math import sqrt
r,d=map(int,input().split())
c=0
for i in range(int(input())):
    x,y,rr=map(int,input().split())
    b=sqrt(x**2+y**2)
    if(b<=abs(r-rr) and b>=(r-d+rr)):
        c+=1
print(c)",['geometry']
"Heidi's friend Jenny is asking Heidi to deliver an important letter to one of their common friends. Since Jenny is Irish, Heidi thinks that this might be a prank. More precisely, she suspects that the message she is asked to deliver states: ""Send the fool further!"", and upon reading it the recipient will ask Heidi to deliver the same message to yet another friend (that the recipient has in common with Heidi), and so on.Heidi believes that her friends want to avoid awkward situations, so she will not be made to visit the same person (including Jenny) twice. She also knows how much it costs to travel between any two of her friends who know each other. She wants to know: what is the maximal amount of money she will waste on travel if it really is a prank?Heidi's n friends are labeled 0 through n - 1, and their network of connections forms a tree. In other words, every two of her friends a, b know each other, possibly indirectly (there is a sequence of friends starting from a and ending on b and such that each two consecutive friends in the sequence know each other directly), and there are exactly n - 1 pairs of friends who know each other directly.Jenny is given the number 0.","# maa chudaaye duniya
from collections import defaultdict
graph = defaultdict(list)
n = int(input())
weights = {}
for _ in range(n-1):
	a, b, w = map(int, input().split())
	edge1 = '{} : {}'.format(a, b)
	edge2 = '{} : {}'.format(b, a)
	graph[a].append(b)
	graph[b].append(a)
	weights[edge1] = w
	weights[edge2] = w

maxsf = [-10**9]
visited = [False for i in range(n+1)]

def dfs(node, parent, dist):
	visited[node] = True
	# print(maxsf)
	# print('checking ', node, parent)
	# print(visited)
	if parent != -1:
		e ='{} : {}'.format(parent, node)
		e1 = '{} : {}'.format(node, parent)
		if e in weights:
			dist += weights[e]
			# print(e, dist)
		else:
			dist += weights[e1]
			# print(e1, dist)
		if dist > maxsf[0]:
			maxsf[0] = dist
	for children in graph[node]:
		if not visited[children]:
			dfs(children, node, dist)
	
dfs(0, -1, 0)
print(*maxsf)","['dfs and similar', 'trees', 'graphs']"
"Gosha's universe is a table consisting of n rows and m columns. Both the rows and columns are numbered with consecutive integers starting with 1. We will use (r, c) to denote a cell located in the row r and column c.Gosha is often invited somewhere. Every time he gets an invitation, he first calculates the number of ways to get to this place, and only then he goes. Gosha's house is located in the cell (1, 1).At any moment of time, Gosha moves from the cell he is currently located in to a cell adjacent to it (two cells are adjacent if they share a common side). Of course, the movement is possible only if such a cell exists, i.e. Gosha will not go beyond the boundaries of the table. Thus, from the cell (r, c) he is able to make a move to one of the cells (r - 1, c), (r, c - 1), (r + 1, c), (r, c + 1). Also, Ghosha can skip a move and stay in the current cell (r, c).Besides the love of strange calculations, Gosha is allergic to cats, so he never goes to the cell that has a cat in it. Gosha knows exactly where and when he will be invited and the schedule of cats travelling along the table. Formally, he has q records, the i-th of them has one of the following forms:   1, xi, yi, ti — Gosha is invited to come to cell (xi, yi) at the moment of time ti. It is guaranteed that there is no cat inside cell (xi, yi) at this moment of time.  2, xi, yi, ti — at the moment ti a cat appears in cell (xi, yi). It is guaranteed that no other cat is located in this cell (xi, yi) at that moment of time.  3, xi, yi, ti — at the moment ti a cat leaves cell (xi, yi). It is guaranteed that there is cat located in the cell (xi, yi). Gosha plans to accept only one invitation, but he has not yet decided, which particular one. In order to make this decision, he asks you to calculate for each of the invitations i the number of ways to get to the cell (xi, yi) at the moment ti. For every invitation, assume that Gosha he starts moving from cell (1, 1) at the moment 1.Moving between two neighboring cells takes Gosha exactly one unit of tim. In particular, this means that Gosha can come into the cell only if a cat sitting in it leaves the moment when Gosha begins his movement from the neighboring cell, and if none of the cats comes to the cell at the time when Gosha is in it.Two ways to go from cell (1, 1) to cell (x, y) at time t are considered distinct if for at least one moment of time from 1 to t Gosha's positions are distinct for the two ways at this moment. Note, that during this travel Gosha is allowed to visit both (1, 1) and (x, y) multiple times. Since the number of ways can be quite large, print it modulo 109 + 7.","import sys
from contextlib import contextmanager
from io import StringIO


M = 10**9 + 7


def smvmul(d, m, v):
    return [sum(m[r][k] * v[k] for k in range(d)) % M for r in range(d)]


def smmul(d, m1, m2):
    return [[sum(m1[r][k] * m2[k][c] for k in range(d)) % M
            for c in range(d)] for r in range(d)]


def smpow(d, m, p):
    a = None
    while p > 1:
        if p % 2:
            if a is None:
                a = m
            else:
                a = smmul(d, a, m)
        m = smmul(d, m, m)
        p //= 2
    return m if (a is None) else smmul(d, a, m)


def process(n, m, events):
    d = n*m
    v = [0 for _ in range(d)]
    v[0] = 1

    a = [[0 for _ in range(d)] for _ in range(d)]
    for r in range(1, n+1):
        for c in range(1, m+1):
            i = (r-1)*m + (c-1)
            a[i][i] = 1
            if r > 1:
                a[i][i-m] = 1
                a[i-m][i] = 1
            if c > 1:
                a[i][i-1] = 1
                a[i-1][i] = 1

    # from pprint import pprint
    # pprint([[v[r*m+c] for c in range(n)] for r in range(m)],
    #        stream=sys.stderr)

    t = 1
    for event in events:
        ee, er, ec, et = event
        if t < et:
            # print(f""POW {et-t}"", file=sys.stderr)
            # pprint([[v[r*m+c] for c in range(n)] for r in range(m)],
            #        stream=sys.stderr)
            # pprint(a, stream=sys.stderr)
            ap = smpow(d, a, et-t)
            v = smvmul(d, ap, v)
            # pprint(ap, stream=sys.stderr)
            # pprint([[v[r*m+c] for c in range(n)] for r in range(m)],
            #        stream=sys.stderr)
            t = et
        ei = (er-1)*m + (ec-1)
        if ee == 1:
            # print(f""QRY {er} {ec} {ei} {v[ei]}"", file=sys.stderr)
            yield v[ei]
        else:
            v[ei] = 0
            b = 0 if (ee == 2) else 1
            # print(f""CAT {er} {ec} {ei} {b}"", file=sys.stderr)
            a[ei][ei] = b
            if er > 1:
                a[ei][ei-m] = b
            if ec > 1:
                a[ei][ei-1] = b
            if er < n:
                a[ei][ei+m] = b
            if ec < m:
                a[ei][ei+1] = b
            # pprint([[v[r*m+c] for c in range(n)] for r in range(m)],
            #        stream=sys.stderr)
            # pprint(a, stream=sys.stderr)

def pl(line):
    e, r, c, t  = map(int, line.split())
    return e, r, c, t


def main():
    n, m, q = map(int, input().split())
    events = (pl(input()) for _ in range(q))
    for k in process(n, m, events):
        print(k)


@contextmanager
def patchio(i):
    try:
        sys.stdin = StringIO(i)
        sys.stdout = StringIO()
        yield sys.stdout
    finally:
        sys.stdin = sys.__stdin__
        sys.stdout = sys.__stdout__


def do_test(k, test):
    print(f""TEST {k}"", file=sys.stderr)
    i, o = test
    with patchio(i) as r:
        main()
    if r.getvalue() == o:
        print(""OK\n"", file=sys.stderr)
    else:
        print(f""Expected:\n{o}Got:\n{r.getvalue()}"", file=sys.stderr)

def test(ts):
    for k in ts or range(len(tests)):
        do_test(k, tests[k])

tests = [(""""""\
1 3 3
2 1 2 3
3 1 2 5
1 1 1 7
"""""", """"""\
5
""""""), (""""""\
3 3 3
2 2 2 2
1 3 3 5
1 3 3 7
"""""", """"""\
2
42
""""""), (""""""\
4 5 5
2 2 5 3
2 2 4 6
3 2 4 9
1 4 4 13
1 4 4 15
"""""", """"""\
490902
10598759
"""""")]

if __name__ == '__main__':
    from argparse import ArgumentParser
    parser = ArgumentParser()
    parser.add_argument('--test', '-t', type=int, nargs='*')
    args = parser.parse_args()
    main() if args.test is None else test(args.test)","['dp', 'matrices']"
"A tree is a connected undirected graph consisting of n vertices and n  -  1 edges. Vertices are numbered 1 through n.Limak is a little polar bear and Radewoosh is his evil enemy. Limak once had a tree but Radewoosh stolen it. Bear is very sad now because he doesn't remember much about the tree — he can tell you only three values n, d and h:  The tree had exactly n vertices.  The tree had diameter d. In other words, d was the biggest distance between two vertices.  Limak also remembers that he once rooted the tree in vertex 1 and after that its height was h. In other words, h was the biggest distance between vertex 1 and some other vertex. The distance between two vertices of the tree is the number of edges on the simple path between them.Help Limak to restore his tree. Check whether there exists a tree satisfying the given conditions. Find any such tree and print its edges in any order. It's also possible that Limak made a mistake and there is no suitable tree – in this case print ""-1"".","def solve(n,d,h) :
    if n<d+1 :
        return False
    if d>2*h :
        return False
    if d-h<0 :
        return False
    if d==1 and n>=3 :
        return False
    
    cnt=1
    h0=d-h
    for i in range(h) :
        print(cnt,cnt+1)
        cnt+=1
    if h0 :
        print(1,cnt+1)
        cnt+=1
    for i in range(h0-1) :
        print(cnt,cnt+1)
        cnt+=1
    if h0 :
        for i in range(n-d-1) :
            print(1,cnt+1)
            cnt+=1
    else :
        for i in range(n-d-1) :
            print(2,cnt+1)
            cnt+=1
    return True
n,d,h=[int(i) for i in input().split()]
if not solve(n,d,h) :
    print(-1)","['constructive algorithms', 'trees', 'graphs']"
"A flowerbed has many flowers and two fountains.You can adjust the water pressure and set any values r1(r1 ≥ 0) and r2(r2 ≥ 0), giving the distances at which the water is spread from the first and second fountain respectively. You have to set such r1 and r2 that all the flowers are watered, that is, for each flower, the distance between the flower and the first fountain doesn't exceed r1, or the distance to the second fountain doesn't exceed r2. It's OK if some flowers are watered by both fountains.You need to decrease the amount of water you need, that is set such r1 and r2 that all the flowers are watered and the r12 + r22 is minimum possible. Find this minimum value.","def dist(a, b):
    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2

n, x1, y1, x2, y2 = map(int, input().split())
coor = [list(map(int, input().split())) for _ in range(n)]
dist1 = [0] + list(map(lambda x: dist((x1, y1), x), coor))
dist2 = [0] + list(map(lambda x: dist((x2, y2), x), coor))
covered = [False for _ in dist1]
ret = 1e20
for i in range(n+1):
    max_dist2 = 0
    for j in range(n+1):
        if dist1[j] > dist1[i]:
            max_dist2 = max(max_dist2, dist2[j])
    ret = min(ret, dist1[i] + max_dist2)
print(ret)",['implementation']
"Ilya lives in a beautiful city of Chordalsk.There are $$$n$$$ houses on the street Ilya lives, they are numerated from $$$1$$$ to $$$n$$$ from left to right; the distance between every two neighboring houses is equal to $$$1$$$ unit. The neighboring houses are $$$1$$$ and $$$2$$$, $$$2$$$ and $$$3$$$, ..., $$$n-1$$$ and $$$n$$$. The houses $$$n$$$ and $$$1$$$ are not neighboring.The houses are colored in colors $$$c_1, c_2, \ldots, c_n$$$ so that the $$$i$$$-th house is colored in the color $$$c_i$$$. Everyone knows that Chordalsk is not boring, so there are at least two houses colored in different colors.Ilya wants to select two houses $$$i$$$ and $$$j$$$ so that $$$1 \leq i &lt; j \leq n$$$, and they have different colors: $$$c_i \neq c_j$$$. He will then walk from the house $$$i$$$ to the house $$$j$$$ the distance of $$$(j-i)$$$ units.Ilya loves long walks, so he wants to choose the houses so that the distance between them is the maximum possible.Help Ilya, find this maximum possible distance.","import sys
import math
#from queue import *
#import random
#sys.setrecursionlimit(int(1e6))
input = sys.stdin.readline
 
############ ---- USER DEFINED INPUT FUNCTIONS ---- ############
def inp():
    return(int(input()))
def inara():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
################################################################
############ ---- THE ACTUAL CODE STARTS BELOW ---- ############

n=inp()
ara=inara()

ans=0

for i in range(1,n):
	if ara[i]!=ara[0]:
		ans=i

for i in range(n-1,-1,-1):
	if ara[i]!=ara[-1]:
		ans=max(ans,n-i-1)

print(ans)","['implementation', 'greedy']"
"You have a tree of $$$n$$$ vertices. You are going to convert this tree into $$$n$$$ rubber bands on infinitely large plane. Conversion rule follows:  For every pair of vertices $$$a$$$ and $$$b$$$, rubber bands $$$a$$$ and $$$b$$$ should intersect if and only if there is an edge exists between $$$a$$$ and $$$b$$$ in the tree.  Shape of rubber bands must be a simple loop. In other words, rubber band is a loop which doesn't self-intersect. Now let's define following things:   Rubber band $$$a$$$ includes rubber band $$$b$$$, if and only if rubber band $$$b$$$ is in rubber band $$$a$$$'s area, and they don't intersect each other.  Sequence of rubber bands $$$a_{1}, a_{2}, \ldots, a_{k}$$$ ($$$k \ge 2$$$) are nested, if and only if for all $$$i$$$ ($$$2 \le i \le k$$$), $$$a_{i-1}$$$ includes $$$a_{i}$$$.   This is an example of conversion. Note that rubber bands $$$5$$$ and $$$6$$$ are nested. It can be proved that is it possible to make a conversion and sequence of nested rubber bands under given constraints.What is the maximum length of sequence of nested rubber bands can be obtained from given tree? Find and print it.","FAST_IO = 1
if FAST_IO:
    import io, sys, atexit
    rr = iter(sys.stdin.read().splitlines()).next
    sys.stdout = _OUTPUT_BUFFER = io.BytesIO()
    @atexit.register
    def write():
        sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())
else:
    rr = raw_input
rri = lambda: int(rr())
rrm = lambda: map(int, rr().split())

###

def solve(N, graph):
    VISIT, DO = 0, 1
    stack = [[DO, 0, -1], [VISIT, 0, -1]]
    res = [None] * N
    ans = 0

    while stack:
        cmd, node, par = stack.pop()
        if cmd == VISIT:
            for nei in graph[node]:
                if nei != par:
                    stack.append([DO, nei, node])
                    stack.append([VISIT, nei, node])
        else:
            white = black = 0
            best = []
            bestb = []
            for nei in graph[node]:
                if nei != par:
                    w, b = res[nei]
                    white = max(white, b)
                    black = max(black, w, b)
                    best.append(max(w, b))
                    best.sort(reverse=True)
                    if len(best) >= 3: best.pop()
                    bestb.append(b)
                    bestb.sort(reverse=True)
                    if len(bestb) >= 3: bestb.pop()

            white += 1
            black += len(graph[node]) - 2
            ans = max(ans, sum(bestb) + 1,
                      sum(best) + len(graph[node]) - 2)
            res[node] = [white, black]

    return ans
    
N = rri()
graph = [[] for _ in xrange(N)]
for _ in xrange(N-1):
    u, v=rrm()
    u -= 1
    v -= 1
    graph[u].append(v)
    graph[v].append(u)
print solve(N, graph)","['dp', 'constructive algorithms', 'math', 'dfs and similar', 'trees']"
"You are given a binary string $$$s$$$ (recall that a string is binary if each character is either $$$0$$$ or $$$1$$$).Let $$$f(t)$$$ be the decimal representation of integer $$$t$$$ written in binary form (possibly with leading zeroes). For example $$$f(011) = 3, f(00101) = 5, f(00001) = 1, f(10) = 2, f(000) = 0$$$ and $$$f(000100) = 4$$$.The substring $$$s_{l}, s_{l+1}, \dots , s_{r}$$$ is good if $$$r - l + 1 = f(s_l \dots s_r)$$$.For example string $$$s = 1011$$$ has $$$5$$$ good substrings: $$$s_1 \dots s_1 = 1$$$, $$$s_3 \dots s_3 = 1$$$, $$$s_4 \dots s_4 = 1$$$, $$$s_1 \dots s_2 = 10$$$ and $$$s_2 \dots s_4 = 011$$$. Your task is to calculate the number of good substrings of string $$$s$$$.You have to answer $$$t$$$ independent queries.","t = int(input())
for _ in range(t):
    s = input()
    ct = int(0)
    ans = int(0)
    for i in range(len(s)):
        if s[i] == '0':
            ct += 1
        else:
            num = int(0)
            for j in range(i,len(s)):
                num *= 2
                if s[j] == '1':
                    num += 1
                if num <= ct + j - i + 1:
                    ans += 1
                if num > j - i + 1 + ct:
                    break
            ct = 0
    print(ans)","['binary search', 'bitmasks', 'brute force']"
"You're given an array of $$$n$$$ integers between $$$0$$$ and $$$n$$$ inclusive.In one operation, you can choose any element of the array and replace it by the MEX of the elements of the array (which may change after the operation).For example, if the current array is $$$[0, 2, 2, 1, 4]$$$, you can choose the second element and replace it by the MEX of the present elements  — $$$3$$$. Array will become $$$[0, 3, 2, 1, 4]$$$.You must make the array non-decreasing, using at most $$$2n$$$ operations.It can be proven that it is always possible. Please note that you do not have to minimize the number of operations. If there are many solutions, you can print any of them. –An array $$$b[1 \ldots n]$$$ is non-decreasing if and only if $$$b_1 \le b_2 \le \ldots \le b_n$$$.The MEX (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. For instance:  The MEX of $$$[2, 2, 1]$$$ is $$$0$$$, because $$$0$$$ does not belong to the array.  The MEX of $$$[3, 1, 0, 1]$$$ is $$$2$$$, because $$$0$$$ and $$$1$$$ belong to the array, but $$$2$$$ does not.  The MEX of $$$[0, 3, 1, 2]$$$ is $$$4$$$ because $$$0$$$, $$$1$$$, $$$2$$$ and $$$3$$$ belong to the array, but $$$4$$$ does not. It's worth mentioning that the MEX of an array of length $$$n$$$ is always between $$$0$$$ and $$$n$$$ inclusive.","def mex(l):
  s=set(l)
  for i in range(len(l)+1):
    if i not in s:
      return i
for _ in range(int(input())):
    n = int(input())
    l = list(map(int,input().split()))[:n]
    k = 0
    j = 0
    x =[]
    while j<n:
        m = mex(l)
        if m==n:
            while j<n and l[j]==j:
                j+=1
            if j<n and l[j]!=j:
                k+=1
                x+=[j+1]
                l[j]=m
        else:
            k+=1
            x+=[m+1]
            l[m]=m
    print(k)
    print(*x)","['constructive algorithms', 'sortings', 'brute force']"
"In Berland it is the holiday of equality. In honor of the holiday the king decided to equalize the welfare of all citizens in Berland by the expense of the state treasury. Totally in Berland there are n citizens, the welfare of each of them is estimated as the integer in ai burles (burle is the currency in Berland).You are the royal treasurer, which needs to count the minimum charges of the kingdom on the king's present. The king can only give money, he hasn't a power to take away them.","x=int(raw_input())
y=map(int,raw_input().split())
max=y[0]
sum=0
for i in range(len(y)):
	if y[i]>max:
		max=y[i]
for i in range(len(y)):
	if y[i]!=max:
		sum=sum+(max-y[i])
print(sum)","['implementation', 'math']"
"Being stuck at home, Ray became extremely bored. To pass time, he asks Lord Omkar to use his time bending power: Infinity Clock! However, Lord Omkar will only listen to mortals who can solve the following problem:You are given an array $$$a$$$ of $$$n$$$ integers. You are also given an integer $$$k$$$. Lord Omkar wants you to do $$$k$$$ operations with this array.Define one operation as the following:   Set $$$d$$$ to be the maximum value of your array.  For every $$$i$$$ from $$$1$$$ to $$$n$$$, replace $$$a_{i}$$$ with $$$d-a_{i}$$$. The goal is to predict the contents in the array after $$$k$$$ operations. Please help Ray determine what the final sequence will look like!","t=int(input())
for i in range(0,t):
    n,k=map(int,input().split())
    
    ls=list(map(int,input().rstrip().split()))
    
    if(k%2==1):
        maxx=ls[0]
        for l in range(0,n):
            if ls[l]>maxx:
                maxx=ls[l]
        for l in range(0,n):
            ls[l]=maxx-ls[l]
        
    else:
        j=0
        while(j<=1):
            maxx=ls[0]
            for l in range(0,n):
                if ls[l]>maxx:
                    maxx=ls[l]
            for l in range(0,n):
                ls[l]=maxx-ls[l]
            j=j+1
    for j in ls:
        print(j,end="" "")
    print("" "")","['implementation', 'math']"
"Pasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.","import sys
from collections import *
from fractions import gcd
nok=lambda x,y: x*y/gcd(x,y)
def fail():
    print ""NO""
    sys.exit(0)
n,m = map(int,raw_input().split())
r = [map(int,raw_input().split()) for i in xrange(m)]
a0 = [1]*n
aa = [1]*n
for x,y,nd,nk in r:
    a0[x-1]=nok(a0[x-1],nd)
    a0[y-1]=nok(a0[y-1],nd)
rl = [[] for i in range(n)]    
for x,y,nd,nk in r:
    kk= nok(a0[x-1],a0[y-1])    
    if nk%kk != 0: fail()
    kk = nk/kk
    rl[x-1].append((y-1,kk,nd))
    rl[y-1].append((x-1,kk,nd))
f = [False]*n
for i in xrange(n):
    if f[i]: continue
    lk = [k for v,k,kd in rl[i]]
    no = reduce(gcd,lk) if lk else 1
    fl = False
    for k in range(1,no+1):
        if no%k!=0: continue
        a = [i]        
        f[i]=True
        aa[i]=k
        fl = True
        for v in a:        
            vk = aa[v]
            for nv,nk,nd in rl[v]:                    
                if nk%vk != 0:
                    fl=False
                    break
                rk = nk/vk
                if f[nv]:
                    if rk!=aa[nv]: 
                        fl=False
                        break
                else:                    
                    if gcd(a0[nv]*rk,vk*a0[v])>nd:
                        fl=False
                        break                        
                    f[nv]=True
                    aa[nv]=rk
                    a.append(nv)
        if fl: 
            break
        for k in a: f[k]=False
    if not fl: fail()
print ""YES""
print ' '.join(map(lambda a,b: str(a*b),a0,aa))","['dfs and similar', 'brute force']"
"There are $$$n$$$ points on a coordinate axis $$$OX$$$. The $$$i$$$-th point is located at the integer point $$$x_i$$$ and has a speed $$$v_i$$$. It is guaranteed that no two points occupy the same coordinate. All $$$n$$$ points move with the constant speed, the coordinate of the $$$i$$$-th point at the moment $$$t$$$ ($$$t$$$ can be non-integer) is calculated as $$$x_i + t \cdot v_i$$$.Consider two points $$$i$$$ and $$$j$$$. Let $$$d(i, j)$$$ be the minimum possible distance between these two points over any possible moments of time (even non-integer). It means that if two points $$$i$$$ and $$$j$$$ coincide at some moment, the value $$$d(i, j)$$$ will be $$$0$$$.Your task is to calculate the value $$$\sum\limits_{1 \le i &lt; j \le n}$$$ $$$d(i, j)$$$ (the sum of minimum distances over all pairs of points).","from sys import stdin
from collections import *


def fast2():
    import os, sys, atexit
    from cStringIO import StringIO as BytesIO
    # range = xrange
    sys.stdout = BytesIO()
    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))
    return BytesIO(os.read(0, os.fstat(0).st_size)).readline


class order_tree:
    def __init__(self, arr):
        self.n = len(arr)
        self.tree = [[0, 0] for _ in range(self.n * 2)]
        self.order = defaultdict(int, {arr[i]: i for i in range(self.n)})

    # get interval[l,r)
    def query(self, l):
        res, coun = 0, 0
        l = self.order[l] + self.n
        r = self.n * 2

        while l < r:
            if l & 1:
                res += self.tree[l][0]
                coun += self.tree[l][1]
                l += 1

            if r & 1:
                r -= 1
                res += self.tree[r][0]
                coun += self.tree[r][1]

            l >>= 1
            r >>= 1

        return res, coun

    def update(self, ix, val):
        ix = self.n + self.order[ix]

        # set new value
        self.tree[ix][0] += val
        self.tree[ix][1] += 1

        # move up
        while ix > 1:
            self.tree[ix >> 1][0] = self.tree[ix][0] + self.tree[ix ^ 1][0]
            self.tree[ix >> 1][1] = self.tree[ix][1] + self.tree[ix ^ 1][1]
            ix >>= 1


input = fast2()
rints = lambda: [int(x) for x in input().split()]
n, a = int(input()), sorted(map(lambda x, y: [x, y], rints(), rints()))
dis = sorted(set([x[1] for x in a]))
tree, ans = order_tree(dis), 0

for i in range(n - 1, -1, -1):
    su, coun = tree.query(a[i][1])
    ans += su - coun * a[i][0]
    tree.update(a[i][1], a[i][0])

print(ans)","['data structures', 'implementation', 'sortings', 'divide and conquer']"
"A one-dimensional Japanese crossword can be represented as a binary string of length x. An encoding of this crossword is an array a of size n, where n is the number of segments formed completely of 1's, and ai is the length of i-th segment. No two segments touch or intersect.For example:   If x = 6 and the crossword is 111011, then its encoding is an array {3, 2};  If x = 8 and the crossword is 01101010, then its encoding is an array {2, 1, 1};  If x = 5 and the crossword is 11111, then its encoding is an array {5};  If x = 5 and the crossword is 00000, then its encoding is an empty array. Mishka wants to create a new one-dimensional Japanese crossword. He has already picked the length and the encoding for this crossword. And now he needs to check if there is exactly one crossword such that its length and encoding are equal to the length and encoding he picked. Help him to check it!","n,x=map(int,input().split())
l=list(map(int,input().split()))
if sum(l)>x:
    print(""NO"")
elif sum(l)+n-1==x or (n==1 and (l[0]==x)):
    print(""YES"")
else:
    print(""NO"")",['implementation']
"Polycarp watched TV-show where k jury members one by one rated a participant by adding him a certain number of points (may be negative, i. e. points were subtracted). Initially the participant had some score, and each the marks were one by one added to his score. It is known that the i-th jury member gave ai points.Polycarp does not remember how many points the participant had before this k marks were given, but he remembers that among the scores announced after each of the k judges rated the participant there were n (n ≤ k) values b1, b2, ..., bn (it is guaranteed that all values bj are distinct). It is possible that Polycarp remembers not all of the scores announced, i. e. n &lt; k. Note that the initial score wasn't announced.Your task is to determine the number of options for the score the participant could have before the judges rated the participant.","def list_input():
    return list(map(int,input().split()))
def map_input():
    return map(int,input().split())
def map_string():
    return input().split()
    
n,k = map_input()
a = list_input()
b = list_input()
pos = set()
pref = []
cur = 0
for i in a:
    cur += i
    pref.append(cur)
for j in pref:
    pos.add(b[0]-j)
ans = 0
for i in pos:
    s = set(b)
    for j in pref:
        s.discard(i+j)
    if len(s) == 0:
        ans += 1
print(ans)","['constructive algorithms', 'brute force']"
"Recently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting.Suppose the graph G is given. Subset A of its vertices is called a vertex cover of this graph, if for each edge uv there is at least one endpoint of it in this set, i.e.  or  (or both).Pari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover.They have agreed to give you their graph and you need to find two disjoint subsets of its vertices A and B, such that both A and B are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself).","n,m=map(int,input().split())

flag=False

f=[0]*100001

E=[[] for i in range(n+1)]

e=[tuple(map(int,input().split())) for _ in range(m)]

for u,v in sorted(e): E[u]+=[v]; E[v]+=[u]

def bfs(nom,col):

  ch=[(nom,col)]

  while ch:

    v,c=ch.pop()

    if f[v]==0: 

      f[v]=c 

      for u in E[v]: 

        if f[u]==0: ch+=[(u,3-c)]

for x in range(1,n+1): 

  if f[x]==0: bfs(x,1)

for u,v in e:

  if f[u]==f[v]: flag=True; break

if flag: print(-1)

else:

  a=[i for i in range(n+1) if f[i]==1]

  b=[i for i in range(n+1) if f[i]==2]

  print(len(a)); print(*a)

  print(len(b)); print(*b)

    

    



# Made By Mostafa_Khaled","['dfs and similar', 'graphs']"
"The problem uses a simplified TCP/IP address model, please read the statement carefully.An IP address is a 32-bit integer, represented as a group of four decimal 8-bit integers (without leading zeroes), separated by commas. For example, record 0.255.1.123 shows a correct IP address and records 0.256.1.123 and 0.255.1.01 do not. In the given problem an arbitrary group of four 8-bit integers is a correct IP address.Our hero Polycarpus still works as a system administrator in some large corporation. He likes beautiful IP addresses. To check if some IP address is beautiful, he should do the following:  write out in a line four 8-bit numbers of the IP address, without the commas;  check if the resulting string is a palindrome. Let us remind you that a palindrome is a string that reads the same from right to left and from left to right.For example, IP addresses 12.102.20.121 and 0.3.14.130 are beautiful (as strings ""1210220121"" and ""0314130"" are palindromes), and IP addresses 1.20.20.1 and 100.4.4.1 are not.Polycarpus wants to find all beautiful IP addresses that have the given set of digits. Each digit from the set must occur in the IP address at least once. IP address must not contain any other digits. Help him to cope with this difficult task.","m=input()
g=map(int,raw_input().split())
n=reduce(lambda x,y:x|(1<<y),g,0)
a=set()
v=[0]*4
def sp(s,u=0):
  if u<4:
    n=len(s)
    x,y=0,-1
    for i in range(min(3,n-3+u)):
      x=x*10+s[i]
      if x>255 or 0==y:break
      v[u],y=x,x
      sp(s[i+1:],u+1)
  elif not s:
    a.add(tuple(v))
def go(a,b,o=0):
  l=len(a)+len(b)
  if 3<l<13 and o==n:sp(a+b)
  if 2<l<12:
    for c in g:
      if (o|(1<<c))==n:sp(a+[c]+b)
  if l<12:
    for c in g:go(a+[c],[c]+b,o|(1<<c))
if m<7:
  go([],[])
  print len(a)
  for x in a:print '%d.%d.%d.%d'%x
else:
  print 0",['brute force']
"Three friends are going to meet each other. Initially, the first friend stays at the position $$$x = a$$$, the second friend stays at the position $$$x = b$$$ and the third friend stays at the position $$$x = c$$$ on the coordinate axis $$$Ox$$$.In one minute each friend independently from other friends can change the position $$$x$$$ by $$$1$$$ to the left or by $$$1$$$ to the right (i.e. set $$$x := x - 1$$$ or $$$x := x + 1$$$) or even don't change it.Let's introduce the total pairwise distance — the sum of distances between each pair of friends. Let $$$a'$$$, $$$b'$$$ and $$$c'$$$ be the final positions of the first, the second and the third friend, correspondingly. Then the total pairwise distance is $$$|a' - b'| + |a' - c'| + |b' - c'|$$$, where $$$|x|$$$ is the absolute value of $$$x$$$.Friends are interested in the minimum total pairwise distance they can reach if they will move optimally. Each friend will move no more than once. So, more formally, they want to know the minimum total pairwise distance they can reach after one minute.You have to answer $$$q$$$ independent test cases.","for _ in range(int(input())):
    a, b, c = map(int, input().split())
    x = abs(a - b) + abs(a - c) + abs(b - c)
    print(max(0, x - 4))","['sortings', 'greedy', 'math', 'brute force']"
"You are given an array $$$a$$$ consisting of $$$n$$$ integers (it is guaranteed that $$$n$$$ is even, i.e. divisible by $$$2$$$). All $$$a_i$$$ does not exceed some integer $$$k$$$.Your task is to replace the minimum number of elements (replacement is the following operation: choose some index $$$i$$$ from $$$1$$$ to $$$n$$$ and replace $$$a_i$$$ with some integer in range $$$[1; k]$$$) to satisfy the following conditions:  after all replacements, all $$$a_i$$$ are positive integers not greater than $$$k$$$;  for all $$$i$$$ from $$$1$$$ to $$$\frac{n}{2}$$$ the following equation is true: $$$a_i + a_{n - i + 1} = x$$$, where $$$x$$$ should be the same for all $$$\frac{n}{2}$$$ pairs of elements. You have to answer $$$t$$$ independent test cases.","t=int(input())
import random
for _ in range(t):
    n,k=map(int,input().split())
    l=list(map(int,input().split()))
    c=[0]*(k+1)
    e=[0]*(k+1)
    d={}
    for i in range(n//2):
        c[min(l[i],l[n-1-i])]+=1
        e[max(l[i],l[n-1-i])]+=1
        try:
            d[l[i]+l[n-1-i]]+=1
        except:
            d[l[i]+l[n-1-i]]=1
    for i in range(1,k+1):
        c[i]+=c[i-1]
        e[i]+=e[i-1]
    ans=n
    for i in range(2,2*k+1):
        if i<=k:
            x=c[i-1]
        else:
            x=e[k]-e[i-k-1]
        try:
            x=x-d[i]
        except:
            pass
        if i>k:
            x = x+(n//2-e[k]+e[i-k-1])*2
        else:
            x = x+(n//2-c[i-1])*2
        #print(i,x)
        ans=min(ans,x)
    print(ans)","['data structures', 'two pointers', 'greedy', 'brute force']"
"Little Bolek has found a picture with n mountain peaks painted on it. The n painted peaks are represented by a non-closed polyline, consisting of 2n segments. The segments go through 2n + 1 points with coordinates (1, y1), (2, y2), ..., (2n + 1, y2n + 1), with the i-th segment connecting the point (i, yi) and the point (i + 1, yi + 1). For any even i (2 ≤ i ≤ 2n) the following condition holds: yi - 1 &lt; yi and yi &gt; yi + 1. We shall call a vertex of a polyline with an even x coordinate a mountain peak.   The figure to the left shows the initial picture, the figure to the right shows what the picture looks like after Bolek's actions. The affected peaks are marked red, k = 2.  Bolek fancied a little mischief. He chose exactly k mountain peaks, rubbed out the segments that went through those peaks and increased each peak's height by one (that is, he increased the y coordinate of the corresponding points). Then he painted the missing segments to get a new picture of mountain peaks. Let us denote the points through which the new polyline passes on Bolek's new picture as (1, r1), (2, r2), ..., (2n + 1, r2n + 1).Given Bolek's final picture, restore the initial one.","n, k = map(int, input().split())
ins = list(map(int, input().split()))
for i in range(1, 2*n + 1):
    if ins[i] > ins[i - 1] and ins[i] > ins[i + 1] and k != 0\
            and (ins[i] - 1) > ins[i - 1] and (ins[i] - 1) > ins[i + 1]:
        ins[i] -= 1
        k -= 1
print(' '.join(str(x) for x in ins))","['constructive algorithms', 'implementation', 'brute force']"
"Kamil likes streaming the competitive programming videos. His MeTube channel has recently reached $$$100$$$ million subscribers. In order to celebrate this, he posted a video with an interesting problem he couldn't solve yet. Can you help him?You're given a tree — a connected undirected graph consisting of $$$n$$$ vertices connected by $$$n - 1$$$ edges. The tree is rooted at vertex $$$1$$$. A vertex $$$u$$$ is called an ancestor of $$$v$$$ if it lies on the shortest path between the root and $$$v$$$. In particular, a vertex is an ancestor of itself.Each vertex $$$v$$$ is assigned its beauty $$$x_v$$$ — a non-negative integer not larger than $$$10^{12}$$$. This allows us to define the beauty of a path. Let $$$u$$$ be an ancestor of $$$v$$$. Then we define the beauty $$$f(u, v)$$$ as the greatest common divisor of the beauties of all vertices on the shortest path between $$$u$$$ and $$$v$$$. Formally, if $$$u=t_1, t_2, t_3, \dots, t_k=v$$$ are the vertices on the shortest path between $$$u$$$ and $$$v$$$, then $$$f(u, v) = \gcd(x_{t_1}, x_{t_2}, \dots, x_{t_k})$$$. Here, $$$\gcd$$$ denotes the greatest common divisor of a set of numbers. In particular, $$$f(u, u) = \gcd(x_u) = x_u$$$.Your task is to find the sum$$$$$$ \sum_{u\text{ is an ancestor of }v} f(u, v). $$$$$$As the result might be too large, please output it modulo $$$10^9 + 7$$$.Note that for each $$$y$$$, $$$\gcd(0, y) = \gcd(y, 0) = y$$$. In particular, $$$\gcd(0, 0) = 0$$$.","from __future__ import division, print_function
from collections import deque
def main():
    def gcd(a,b):
        if a<b:
            a,b=b,a
        while b:
            a,b=b,a%b
        return a
    
    n=int(input())
    val=list(map(int,input().split()))
    gcds=[ {} for _ in range(n) ]
    edges={}
    for i in range(n-1):
        u,v=map(int,input().split())
        if u not in edges:
            edges[u]=[v]
        else :
            edges[u].append(v)
        if v not in edges:
            edges[v]=[u]
        else :
            edges[v].append(u)
    visited=[0]*n
    
    q=deque()
    q.append(1)
    visited[0]=1
    mod=10**9+7
    result=0
    while q:
        u=q.popleft()
        x=val[u-1]
        if x not in gcds[u-1]:
            gcds[u-1][x]=1
        else :
            gcds[u-1][x]+=1
        for k in gcds[u-1]:
            result=(result+gcds[u-1][k]*k)%mod
        for v in edges[u]:
            if visited[v-1]==0:
                temp=val[v-1]
                for item in gcds[u-1]:
                    a=gcd(item,temp)
                    if a not in gcds[v-1]:
                        gcds[v-1][a]=gcds[u-1][item]
                    else :
                        gcds[v-1][a]+=gcds[u-1][item]
                visited[v-1]=1
                q.append(v)
    print(result)
        

######## Python 2 and 3 footer by Pajenegod and c1729

# Note because cf runs old PyPy3 version which doesn't have the sped up
# unicode strings, PyPy3 strings will many times be slower than pypy2.
# There is a way to get around this by using binary strings in PyPy3
# but its syntax is different which makes it kind of a mess to use.

# So on cf, use PyPy2 for best string performance.

py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange

import os, sys
from io import IOBase, BytesIO

BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

# Cout implemented in Python
import sys
class ostream:
    def __lshift__(self,a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'

# Read all remaining integers in stdin, type is given by optional argument, this is fast
def readnumbers(zero = 0):
    conv = ord if py2 else lambda x:x
    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0' [0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-' [0]: sign = -1
            elif s[i] != b'\r' [0]:
                A.append(sign*numb)
                numb = zero; sign = 1
            i += 1
    except:pass
    if s and s[-1] >= b'0' [0]:
        A.append(sign*numb)
    return A

if __name__== ""__main__"":
  main()","['dp', 'graphs', 'number theory', 'math', 'data structures', 'binary search', 'dfs and similar', 'trees']"
"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers:   an introvert always chooses a row where both seats are empty. Among these rows he chooses the one with the smallest seats width and takes one of the seats in it;  an extrovert always chooses a row where exactly one seat is occupied (by an introvert). Among these rows he chooses the one with the largest seats width and takes the vacant place in it. You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.","n = int(input())
x= [int(i) for i in input().split("" "")]
s = input()

stack = []

ele = [i[0]+1 for i in sorted(enumerate(x), key=lambda x:x[1])]
j = 0

for c in s:
    if c == '0':
        print(ele[j], end="" "")
        stack.append(ele[j])
        j+=1
    else:
        print(stack.pop(), end = "" "")","['data structures', 'implementation', 'greedy']"
"General Payne has a battalion of n soldiers. The soldiers' beauty contest is coming up, it will last for k days. Payne decided that his battalion will participate in the pageant. Now he has choose the participants.All soldiers in the battalion have different beauty that is represented by a positive integer. The value ai represents the beauty of the i-th soldier.On each of k days Generals has to send a detachment of soldiers to the pageant. The beauty of the detachment is the sum of the beauties of the soldiers, who are part of this detachment. Payne wants to surprise the jury of the beauty pageant, so each of k days the beauty of the sent detachment should be unique. In other words, all k beauties of the sent detachments must be distinct numbers.Help Payne choose k detachments of different beauties for the pageant. Please note that Payne cannot just forget to send soldiers on one day, that is, the detachment of soldiers he sends to the pageant should never be empty.","#------------------------template--------------------------#
import os
import sys
from math import *
from collections import *
from fractions import *
from bisect import *
from heapq import*
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=10**9+7
EPS=1e-6
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()

n,k=value()
a=sorted(array())

ma=set()
setNo=1

while(True):

    t=ma
    for i in a:
        if(k<setNo):exit()

        if(i not in t):
            print(len(ma)+1,*ma,i)
            setNo+=1
    key=-1
    for i in a:
        if(i not in ma):
            key=max(key,i)
    ma.add(key)","['constructive algorithms', 'greedy', 'brute force']"
"There are quite a lot of ways to have fun with inflatable balloons. For example, you can fill them with water and see what happens.Grigory and Andrew have the same opinion. So, once upon a time, they went to the shop and bought $$$n$$$ packets with inflatable balloons, where $$$i$$$-th of them has exactly $$$a_i$$$ balloons inside.They want to divide the balloons among themselves. In addition, there are several conditions to hold:  Do not rip the packets (both Grigory and Andrew should get unbroken packets);  Distribute all packets (every packet should be given to someone);  Give both Grigory and Andrew at least one packet;  To provide more fun, the total number of balloons in Grigory's packets should not be equal to the total number of balloons in Andrew's packets. Help them to divide the balloons or determine that it's impossible under these conditions.","n = input()

ll = map(int, raw_input().split())

if len(ll) == 1:
    print -1
elif len(ll) == 2:
    if ll[0] == ll[1]:
        print -1
    else:
        print 1
        print 1
else:
    left = ll[:len(ll)/2+1]
    right = ll[len(ll)/2+1:]

    if sum(left) == sum(right):
        print len(ll)/2
        print ' '.join(map(str, range(1, len(ll)/2+1)))
    else:
        print len(ll)/2+1
        print ' '.join(map(str, range(1, len(ll)/2+2)))","['constructive algorithms', 'implementation']"
"Dwarfs have planted a very interesting plant, which is a triangle directed ""upwards"". This plant has an amusing feature. After one year a triangle plant directed ""upwards"" divides into four triangle plants: three of them will point ""upwards"" and one will point ""downwards"". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point ""upwards"" will be in n years.","n = int(input())

mod = 10**9 +7

def power_2_k(k):
    if k == 0:
        return 1
    if k % 2 == 0:
        lower = power_2_k(k // 2)
        return (lower * lower) % mod
    else:
        k -= 1
        lower = power_2_k(k // 2)
        return (((lower * lower) % mod) * 2) % mod

p = power_2_k(n)
print((p * (p + 1) // 2) % mod)",['math']
Every evening Vitalya sets n alarm clocks to wake up tomorrow. Every alarm clock rings during exactly one minute and is characterized by one integer ai — number of minute after midnight in which it rings. Every alarm clock begins ringing at the beginning of the minute and rings during whole minute. Vitalya will definitely wake up if during some m consecutive minutes at least k alarm clocks will begin ringing. Pay attention that Vitalya considers only alarm clocks which begin ringing during given period of time. He doesn't consider alarm clocks which started ringing before given period of time and continues ringing during given period of time.Vitalya is so tired that he wants to sleep all day long and not to wake up. Find out minimal number of alarm clocks Vitalya should turn off to sleep all next day. Now all alarm clocks are turned on.,"n,m,k = map(int,input().split())
Alarm = [int(x) for x in input().split()]
ringing_now = []
Ans = 0
Alarm = list(set(Alarm)) # To remove duplicacy
Alarm.sort()

for i in range(n):
    # Just append it . Don't Check Now.
    ringing_now.append(Alarm[i])
    # NOw check two condition.
    # 1. if there are more than k alarms ringing now
    # 2. and simultaneously diff bw max and min is less than m
    if(len(ringing_now)>=k and ringing_now[-1] - ringing_now[len(ringing_now)-k]<m):
        ringing_now.pop()
        Ans += 1
print(Ans)",['greedy']
"You are given two very long integers a, b (leading zeroes are allowed). You should check what number a or b is greater or determine that they are equal.The input size is very large so don't use the reading of symbols one by one. Instead of that use the reading of a whole line or token.As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use scanf/printf instead of cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java. Don't use the function input() in Python2 instead of it use the function raw_input().","def main():

    a = input()
    b = input()

    boolean = False
    index_to_start_a = 0
    index_to_start_b = 0
    while index_to_start_a < len(a) and a[index_to_start_a] == ""0"":
        index_to_start_a += 1

    while index_to_start_b < len(b) and b[index_to_start_b] == ""0"":
        index_to_start_b += 1

    a = a[index_to_start_a:]
    b = b[index_to_start_b:]

    length_a = len(a)
    length_b = len(b)
    if length_a > length_b:
        print("">"")
    elif length_a < length_b:
        print(""<"")

    else:
        for k in range(length_a):
            if a[k] > b[k]:
                print("">"")
                boolean = True
                break
            if a[k] < b[k]:
                print(""<"")
                boolean = True
                break

        if not boolean:
            print(""="")






main()","['implementation', 'strings']"
"Polycarp has decided to decorate his room because the New Year is soon. One of the main decorations that Polycarp will install is the garland he is going to solder himself.Simple garlands consisting of several lamps connected by one wire are too boring for Polycarp. He is going to solder a garland consisting of $$$n$$$ lamps and $$$n - 1$$$ wires. Exactly one lamp will be connected to power grid, and power will be transmitted from it to other lamps by the wires. Each wire connectes exactly two lamps; one lamp is called the main lamp for this wire (the one that gets power from some other wire and transmits it to this wire), the other one is called the auxiliary lamp (the one that gets power from this wire). Obviously, each lamp has at most one wire that brings power to it (and this lamp is the auxiliary lamp for this wire, and the main lamp for all other wires connected directly to it).Each lamp has a brightness value associated with it, the $$$i$$$-th lamp has brightness $$$2^i$$$. We define the importance of the wire as the sum of brightness values over all lamps that become disconnected from the grid if the wire is cut (and all other wires are still working).Polycarp has drawn the scheme of the garland he wants to make (the scheme depicts all $$$n$$$ lamp and $$$n - 1$$$ wires, and the lamp that will be connected directly to the grid is marked; the wires are placed in such a way that the power can be transmitted to each lamp). After that, Polycarp calculated the importance of each wire, enumerated them from $$$1$$$ to $$$n - 1$$$ in descending order of their importance, and then wrote the index of the main lamp for each wire (in the order from the first wire to the last one).The following day Polycarp bought all required components of the garland and decided to solder it — but he could not find the scheme. Fortunately, Polycarp found the list of indices of main lamps for all wires. Can you help him restore the original scheme?","n = int(input())
 
a = list(map(int,input().split()))
 
dic = {}
uexmax = n
ans = []
 
for i in range(n-1):
 
    if i == 0:
        dic[a[i]] = 1
 
    else:
 
        if a[i] in dic:
            dic[uexmax] = 1
            ans.append([ a[i-1] , uexmax ])
        else:
            dic[a[i]] = 1
            ans.append([ a[i-1] , a[i] ])
 
    while uexmax in dic:
        uexmax -= 1
 
ans.append ( [a[-1] , uexmax] )
 
print (a[0])
 
for i in range(n-1):
    print ("" "".join(map(str,ans[i])))","['constructive algorithms', 'greedy', 'trees']"
"There are $$$n$$$ piranhas with sizes $$$a_1, a_2, \ldots, a_n$$$ in the aquarium. Piranhas are numbered from left to right in order they live in the aquarium.Scientists of the Berland State University want to find if there is dominant piranha in the aquarium. The piranha is called dominant if it can eat all the other piranhas in the aquarium (except itself, of course). Other piranhas will do nothing while the dominant piranha will eat them.Because the aquarium is pretty narrow and long, the piranha can eat only one of the adjacent piranhas during one move. Piranha can do as many moves as it needs (or as it can). More precisely:   The piranha $$$i$$$ can eat the piranha $$$i-1$$$ if the piranha $$$i-1$$$ exists and $$$a_{i - 1} &lt; a_i$$$.  The piranha $$$i$$$ can eat the piranha $$$i+1$$$ if the piranha $$$i+1$$$ exists and $$$a_{i + 1} &lt; a_i$$$. When the piranha $$$i$$$ eats some piranha, its size increases by one ($$$a_i$$$ becomes $$$a_i + 1$$$).Your task is to find any dominant piranha in the aquarium or determine if there are no such piranhas.Note that you have to find any (exactly one) dominant piranha, you don't have to find all of them.For example, if $$$a = [5, 3, 4, 4, 5]$$$, then the third piranha can be dominant. Consider the sequence of its moves:   The piranha eats the second piranha and $$$a$$$ becomes $$$[5, \underline{5}, 4, 5]$$$ (the underlined piranha is our candidate).  The piranha eats the third piranha and $$$a$$$ becomes $$$[5, \underline{6}, 5]$$$.  The piranha eats the first piranha and $$$a$$$ becomes $$$[\underline{7}, 5]$$$.  The piranha eats the second piranha and $$$a$$$ becomes $$$[\underline{8}]$$$. You have to answer $$$t$$$ independent test cases.","try:
    t=int(input())
    while t:
        t=-1
        n=int(input())
        a=list(map(int,input().split()))
        if len(set(a))==1:
            print(-1)
        else:
            mx=max(a)
            for i in range(n):
                if a[i]==mx:
                    
                    if i>0:
                        if a[i-1] <mx:
                            ans=i+1
                            break
                    if i <n-1:
                        if a[i+1] <mx:
                            ans=i+1
                            break
            print(ans)  
except:
    pass","['constructive algorithms', 'greedy']"
"The main road in Bytecity is a straight line from south to north. Conveniently, there are coordinates measured in meters from the southernmost building in north direction.At some points on the road there are n friends, and i-th of them is standing at the point xi meters and can move with any speed no greater than vi meters per second in any of the two directions along the road: south or north.You are to compute the minimum time needed to gather all the n friends at some point on the road. Note that the point they meet at doesn't need to have integer coordinate.","n = int(input())
xs = list(map(int, input().split()))
vs = list(map(int, input().split()))

l = 0
r = max(xs) - min(xs) + 1
for i in range(50):
    m = (r + l) / 2
    lev = 0
    prav = 1000000000
    for j in range(n):
        prav = min(prav, xs[j] + vs[j] * m)
        lev = max(lev, xs[j] - vs[j] * m)
        if prav < lev:
            break
    if prav < lev:
        l = m
    else:
        r = m
print((l + r) / 2)",['binary search']
"$$$n$$$ robots have escaped from your laboratory! You have to find them as soon as possible, because these robots are experimental, and their behavior is not tested yet, so they may be really dangerous!Fortunately, even though your robots have escaped, you still have some control over them. First of all, you know the location of each robot: the world you live in can be modeled as an infinite coordinate plane, and the $$$i$$$-th robot is currently located at the point having coordinates ($$$x_i$$$, $$$y_i$$$). Furthermore, you may send exactly one command to all of the robots. The command should contain two integer numbers $$$X$$$ and $$$Y$$$, and when each robot receives this command, it starts moving towards the point having coordinates ($$$X$$$, $$$Y$$$). The robot stops its movement in two cases:  either it reaches ($$$X$$$, $$$Y$$$);  or it cannot get any closer to ($$$X$$$, $$$Y$$$). Normally, all robots should be able to get from any point of the coordinate plane to any other point. Each robot usually can perform four actions to move. Let's denote the current coordinates of the robot as ($$$x_c$$$, $$$y_c$$$). Then the movement system allows it to move to any of the four adjacent points:  the first action allows it to move from ($$$x_c$$$, $$$y_c$$$) to ($$$x_c - 1$$$, $$$y_c$$$);  the second action allows it to move from ($$$x_c$$$, $$$y_c$$$) to ($$$x_c$$$, $$$y_c + 1$$$);  the third action allows it to move from ($$$x_c$$$, $$$y_c$$$) to ($$$x_c + 1$$$, $$$y_c$$$);  the fourth action allows it to move from ($$$x_c$$$, $$$y_c$$$) to ($$$x_c$$$, $$$y_c - 1$$$). Unfortunately, it seems that some movement systems of some robots are malfunctioning. For each robot you know which actions it can perform, and which it cannot perform.You want to send a command so all robots gather at the same point. To do so, you have to choose a pair of integer numbers $$$X$$$ and $$$Y$$$ so that each robot can reach the point ($$$X$$$, $$$Y$$$). Is it possible to find such a point?","import sys 
# sys.setrecursionlimit(10**6) 
from sys import stdin, stdout
import bisect            #c++ upperbound
import math
import heapq
def modinv(n,p):
    return pow(n,p-2,p)
def cin():
    return map(int,sin().split())
def ain():                           #takes array as input
    return list(map(int,sin().split()))
def sin():
    return input()
def inin():
    return int(input())
import math  
def Divisors(n) : 
    l = []  
    for i in range(1, int(math.sqrt(n) + 1)) :
        if (n % i == 0) : 
            if (n // i == i) : 
                l.append(i) 
            else : 
                l.append(i)
                l.append(n//i)
    return l
""""""*******************************************************""""""
def main():
    t=inin()
    for _ in range(t):
        n=inin()
        x1=100000
        y1=100000
        x2=-100000
        y2=-100000
        for i in range(n):
            a,b,c,d,e,f=cin()
            if(c==0):
                x2=max(x2,a)
            if(d==0):
                y1=min(y1,b)
            if(e==0):
                x1=min(x1,a)
            if(f==0):
                y2=max(y2,b)
        # print(x1,x2,y1,y2)
        if(x1>=x2 and y1>=y2):
            if(x1>=-100000):
                x2=x1
            if(y1>=-100000):
                y2=y1
            print(1,x2,y2)
        else:
            print(0)
            
                
            
        
######## Python 2 and 3 footer by Pajenegod and c1729
 
# Note because cf runs old PyPy3 version which doesn't have the sped up
# unicode strings, PyPy3 strings will many times be slower than pypy2.
# There is a way to get around this by using binary strings in PyPy3
# but its syntax is different which makes it kind of a mess to use.
 
# So on cf, use PyPy2 for best string performance.
 
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
 
import os, sys
from io import IOBase, BytesIO
 
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0
 
    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None
 
    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s
 
    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()
 
    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')
 
# Cout implemented in Python
import sys
class ostream:
    def __lshift__(self,a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
 
# Read all remaining integers in stdin, type is given by optional argument, this is fast
def readnumbers(zero = 0):
    conv = ord if py2 else lambda x:x
    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0' [0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-' [0]: sign = -1
            elif s[i] != b'\r' [0]:
                A.append(sign*numb)
                numb = zero; sign = 1
            i += 1
    except:pass
    if s and s[-1] >= b'0' [0]:
        A.append(sign*numb)
    return A
 
if __name__== ""__main__"":
  main()",['implementation']
"You are given a simple weighted connected undirected graph, consisting of $$$n$$$ vertices and $$$m$$$ edges.A path in the graph of length $$$k$$$ is a sequence of $$$k+1$$$ vertices $$$v_1, v_2, \dots, v_{k+1}$$$ such that for each $$$i$$$ $$$(1 \le i \le k)$$$ the edge $$$(v_i, v_{i+1})$$$ is present in the graph. A path from some vertex $$$v$$$ also has vertex $$$v_1=v$$$. Note that edges and vertices are allowed to be included in the path multiple times.The weight of the path is the total weight of edges in it.For each $$$i$$$ from $$$1$$$ to $$$q$$$ consider a path from vertex $$$1$$$ of length $$$i$$$ of the maximum weight. What is the sum of weights of these $$$q$$$ paths?Answer can be quite large, so print it modulo $$$10^9+7$$$.","import sys
range = xrange
input = raw_input

n,m,q = [int(x) for x in input().split()]

V = []
W = []
coupl = [[] for _ in range(n)]
for _ in range(m):
    a,b,w = [int(x) - 1 for x in input().split()]
    w += 1
    W.append(w)

    eind = len(V)
    V.append(b)
    V.append(a)
    coupl[a].append(eind)
    coupl[b].append(eind ^ 1)

DP = [[-1]*n for _ in range(n)]
DP[0][0] = 0
for j in range(1, n):
    prevDP = DP[j - 1]
    newDP = DP[j]
    for node in range(n):
        if prevDP[node] == -1:
            continue
        for eind in coupl[node]:
            nei = V[eind]
            newDP[nei] = max(newDP[nei], prevDP[node] + W[eind >> 1])

ans = 0
for dp in DP:
    ans += max(dp)

M = DP[-1]
K = []
for node in range(n):
    K.append(max(W[eind >> 1] for eind in coupl[node]))

K = [K[i] for i in range(n) if M[i] >= 0]
M = [M[i] for i in range(n) if M[i] >= 0]


def solve(K, M, a, b):
    hulli, hullx = convex_hull(K, M)

    def sqsum(n):
        return n * (n + 1) >> 1
    
    n = len(hulli)
    ans = 0
    # iterate over all n intervalls
    for i in range(n):
        j = hulli[i]
        k,m = K[j],M[j]
        l = max(a, hullx[i - 1] + 1 if i else a)
        r = min(b - 1, hullx[i] if i + 1 < n else b - 1)

        if l <= r:
            ans += m * (r - l + 1)
            ans += k * (sqsum(r) - sqsum(l - 1))
    return ans


#    hulli[0]            hulli[1]                hulli[-1]
#
# (inf, hullx[0]], (hullx[0], hullx[1]], ..., (hullx[-1], inf)
#
def convex_hull(K, M, integer = True):
    # assert len(K) == len(M)
    if integer:
        intersect = lambda i,j: (M[j] - M[i]) // (K[i] - K[j])
    else:
        intersect = lambda i,j: (M[j] - M[i]) / (K[i] - K[j])
    
    hulli = []
    hullx = []
    order = sorted(range(len(K)), key = K.__getitem__)
    for i in order:
        while True:
            if not hulli:
                hulli.append(i)
                hullx.append(-1)
                break
            elif K[hulli[-1]] == K[i]:
                if M[hulli[-1]] >= M[i]:
                    break
                hulli.pop()
                hullx.pop()
            else:
                x = intersect(i, hulli[-1])
                if len(hulli) > 1 and x <= hullx[-1]:
                    hullx.pop()
                    hulli.pop()
                else:
                    hullx.append(x)
                    hulli.append(i)
                    break
    return hulli, hullx[1:]

ans += solve(K, M, 1, q - (n - 1) + 1)

print ans % (10 ** 9 + 7)","['dp', 'binary search', 'geometry', 'graphs']"
"Little X has met the following problem recently. Let's define f(x) as the sum of digits in decimal representation of number x (for example, f(1234) = 1 + 2 + 3 + 4). You are to calculate Of course Little X has solved this problem quickly, has locked it, and then has tried to hack others. He has seen the following C++ code:     ans = solve(l, r) % a;    if (ans &lt;= 0)      ans += a; This code will fail only on the test with . You are given number a, help Little X to find a proper test for hack.","a=int(input())
d=10**100-1;
x=a-100*45*10**99%a
print(x,x+d)","['constructive algorithms', 'binary search', 'math']"
"Companies always have a lot of equipment, furniture and other things. All of them should be tracked. To do this, there is an inventory number assigned with each item. It is much easier to create a database by using those numbers and keep the track of everything.During an audit, you were surprised to find out that the items are not numbered sequentially, and some items even share the same inventory number! There is an urgent need to fix it. You have chosen to make the numbers of the items sequential, starting with 1. Changing a number is quite a time-consuming process, and you would like to make maximum use of the current numbering.You have been given information on current inventory numbers for n items in the company. Renumber items so that their inventory numbers form a permutation of numbers from 1 to n by changing the number of as few items as possible. Let us remind you that a set of n numbers forms a permutation if all the numbers are in the range from 1 to n, and no two numbers are equal.","n = int(input())
l = list(map(int,input().split()))
d = {}
for i in range(n):
	if l[i] in d:
		d[l[i]] += 1
	else: 
		d[l[i]] = 1
notpre_ = []
for i in range(1,n+1):
	if i in d:
		continue
	else:
		notpre_.append(i) 
k = 0

for i in range(len(notpre_)):
	for j in range(k,len(l)):
		if d[l[j]] > 1 or l[j] > n:
			d[l[j]] = d[l[j]] - 1
			l[j] = notpre_[i]
			d[l[j]] = 1
			break
	k = j
print(*l)","['greedy', 'math']"
"The only difference between problems C1 and C2 is that all values in input of problem C1 are distinct (this condition may be false for problem C2).You are given a sequence $$$a$$$ consisting of $$$n$$$ integers. All these integers are distinct, each value from $$$1$$$ to $$$n$$$ appears in the sequence exactly once.You are making a sequence of moves. During each move you must take either the leftmost element of the sequence or the rightmost element of the sequence, write it down and remove it from the sequence. Your task is to write down a strictly increasing sequence, and among all such sequences you should take the longest (the length of the sequence is the number of elements in it).For example, for the sequence $$$[2, 1, 5, 4, 3]$$$ the answer is $$$4$$$ (you take $$$2$$$ and the sequence becomes $$$[1, 5, 4, 3]$$$, then you take the rightmost element $$$3$$$ and the sequence becomes $$$[1, 5, 4]$$$, then you take $$$4$$$ and the sequence becomes $$$[1, 5]$$$ and then you take $$$5$$$ and the sequence becomes $$$[1]$$$, the obtained increasing sequence is $$$[2, 3, 4, 5]$$$).","n = int(raw_input())
ns = map(int, raw_input().split())
l, r = 0, n - 1

res = []
pre = -1
while l <= r:
    if min(ns[l], ns[r]) > pre:
        if ns[l] < ns[r]:
            pre = ns[l]
            res.append('L')
            l += 1
        else:
            pre = ns[r]
            res.append('R')
            r -= 1
    elif ns[l] > pre:
        pre = ns[l]
        res.append('L')
        l += 1
    elif ns[r] > pre:
        pre = ns[r]
        res.append('R')
        r -= 1
    else:
        break

print len(res)
print ''.join(res)",['greedy']
"The only difference between easy and hard versions is the length of the string. You can hack this problem only if you solve both problems.Kirk has a binary string $$$s$$$ (a string which consists of zeroes and ones) of length $$$n$$$ and he is asking you to find a binary string $$$t$$$ of the same length which satisfies the following conditions: For any $$$l$$$ and $$$r$$$ ($$$1 \leq l \leq r \leq n$$$) the length of the longest non-decreasing subsequence of the substring $$$s_{l}s_{l+1} \ldots s_{r}$$$ is equal to the length of the longest non-decreasing subsequence of the substring $$$t_{l}t_{l+1} \ldots t_{r}$$$; The number of zeroes in $$$t$$$ is the maximum possible.A non-decreasing subsequence of a string $$$p$$$ is a sequence of indices $$$i_1, i_2, \ldots, i_k$$$ such that $$$i_1 &lt; i_2 &lt; \ldots &lt; i_k$$$ and $$$p_{i_1} \leq p_{i_2} \leq \ldots \leq p_{i_k}$$$. The length of the subsequence is $$$k$$$.If there are multiple substrings which satisfy the conditions, output any.","s=input()
s=list(s)
l=len(s)-1
z=0
for i in range(l,-1,-1):
    if(s[i]=='0'):
        z=z+1
    elif z:
        z-=1
    else:
        s[i]='0'
s="""".join(s)
print(s)","['brute force', 'greedy', 'strings']"
"Consider a sequence [a1, a2, ... , an]. Define its prefix product sequence .Now given n, find a permutation of [1, 2, ..., n], such that its prefix product sequence is a permutation of [0, 1, ..., n - 1].","n = int(input())
if n == 4:
    print (""YES\n1 3 2 4"")
elif [i for i in range(2,n) if n%i==0]:
    print(""NO"")
else:
    print(""YES\n1 %s""%("" "".join(str((pow(x+1,n-2,n)*(x+2))%n or n) for x in range(n-1))))","['constructive algorithms', 'number theory', 'math']"
"Vasya has got a robot which is situated on an infinite Cartesian plane, initially in the cell $$$(0, 0)$$$. Robot can perform the following four kinds of operations:   U — move from $$$(x, y)$$$ to $$$(x, y + 1)$$$;  D — move from $$$(x, y)$$$ to $$$(x, y - 1)$$$;  L — move from $$$(x, y)$$$ to $$$(x - 1, y)$$$;  R — move from $$$(x, y)$$$ to $$$(x + 1, y)$$$. Vasya also has got a sequence of $$$n$$$ operations. Vasya wants to modify this sequence so after performing it the robot will end up in $$$(x, y)$$$.Vasya wants to change the sequence so the length of changed subsegment is minimum possible. This length can be calculated as follows: $$$maxID - minID + 1$$$, where $$$maxID$$$ is the maximum index of a changed operation, and $$$minID$$$ is the minimum index of a changed operation. For example, if Vasya changes RRRRRRR to RLRRLRL, then the operations with indices $$$2$$$, $$$5$$$ and $$$7$$$ are changed, so the length of changed subsegment is $$$7 - 2 + 1 = 6$$$. Another example: if Vasya changes DDDD to DDRD, then the length of changed subsegment is $$$1$$$. If there are no changes, then the length of changed subsegment is $$$0$$$. Changing an operation means replacing it with some operation (possibly the same); Vasya can't insert new operations into the sequence or remove them.Help Vasya! Tell him the minimum length of subsegment that he needs to change so that the robot will go from $$$(0, 0)$$$ to $$$(x, y)$$$, or tell him that it's impossible.","n=int(input())
s=list(input())
a,b = map(int, input().split())
L=s.count('L')
U=s.count('U')
R=s.count('R')
D=s.count('D')
x=0
y=0
xmin=0
ymin=0
minn=2*n
while x+y<2*n:
    if abs(a-(R-L))+abs(b-(U-D))>y-x and y!=n:
        i=s[y]
        if i=='L':
            L-=1
        elif i=='R':
            R-=1
        elif i=='D':
            D-=1
        elif i=='U':
            U-=1 
        y+=1
    elif abs(a-(R-L))+abs(b-(U-D))<=y-x or y==n:
        if y-x<minn and abs(a-(R-L))+abs(b-(U-D))<=y-x:
            minn=y-x
        i=s[x]
        if i=='L':
            L+=1
        elif i=='R':
            R+=1
        elif i=='D':
            D+=1
        elif i=='U':
            U+=1
        x+=1

            
if abs(a)+abs(b)>len(s):
    print(-1)
elif (len(s)-(abs(a)+abs(b)))%2!=0:
    print(-1)
else:
    print(minn)","['two pointers', 'binary search']"
"You've been in love with Coronavirus-chan for a long time, but you didn't know where she lived until now. And just now you found out that she lives in a faraway place called Naha. You immediately decided to take a vacation and visit Coronavirus-chan. Your vacation lasts exactly $$$x$$$ days and that's the exact number of days you will spend visiting your friend. You will spend exactly $$$x$$$ consecutive (successive) days visiting Coronavirus-chan.They use a very unusual calendar in Naha: there are $$$n$$$ months in a year, $$$i$$$-th month lasts exactly $$$d_i$$$ days. Days in the $$$i$$$-th month are numbered from $$$1$$$ to $$$d_i$$$. There are no leap years in Naha.The mood of Coronavirus-chan (and, accordingly, her desire to hug you) depends on the number of the day in a month. In particular, you get $$$j$$$ hugs if you visit Coronavirus-chan on the $$$j$$$-th day of the month.You know about this feature of your friend and want to plan your trip to get as many hugs as possible (and then maybe you can win the heart of Coronavirus-chan). Please note that your trip should not necessarily begin and end in the same year.","def rangesum(i, j):
    # inclusive
    return int((j-i+1)*(i+j)/2)

n,x = list(map(int, input().split(' ')))
D = list(map(int, input().split(' ')))
maximum = max(D)
hugs = 0
i = 0
i_days = None
while True:
    if D[i] >= x:
        hugs += int((D[i] + (D[i]-x+1))/2*x)
        i_days = x
        break
    else:
        hugs += int(D[i]*(D[i]+1)/2)
        x -= D[i]
        i -= 1
maxHugs = hugs
for j in range(1, n):
    hugs += int(D[j]*(D[j]+1)/2)
    if i_days >= D[j]:
        hugs -= rangesum(D[i]-i_days+1, D[i]-i_days+D[j])
        i_days -= D[j]
    else:
        hugs -= rangesum(D[i]-i_days+1, D[i])
        i += 1
        y = D[j] - i_days
        while True:
            if D[i] >= y:
                i_days = D[i]-y
                hugs -= rangesum(1,y)
                break
            else:
                y -= D[i]
                hugs -= rangesum(1,D[i])
                i += 1
    maxHugs = max(hugs, maxHugs)
print(int(maxHugs))","['greedy', 'two pointers', 'implementation', 'binary search', 'brute force']"
"During the quarantine, Sicromoft has more free time to create the new functions in ""Celex-2021"". The developers made a new function GAZ-GIZ, which infinitely fills an infinite table to the right and down from the upper left corner as follows:   The cell with coordinates $$$(x, y)$$$ is at the intersection of $$$x$$$-th row and $$$y$$$-th column. Upper left cell $$$(1,1)$$$ contains an integer $$$1$$$.The developers of the SUM function don't sleep either. Because of the boredom, they teamed up with the developers of the RAND function, so they added the ability to calculate the sum on an arbitrary path from one cell to another, moving down or right. Formally, from the cell $$$(x,y)$$$ in one step you can move to the cell $$$(x+1, y)$$$ or $$$(x, y+1)$$$. After another Dinwows update, Levian started to study ""Celex-2021"" (because he wants to be an accountant!). After filling in the table with the GAZ-GIZ function, he asked you to calculate the quantity of possible different amounts on the path from a given cell $$$(x_1, y_1)$$$ to another given cell $$$(x_2, y_2$$$), if you can only move one cell down or right.Formally, consider all the paths from the cell $$$(x_1, y_1)$$$ to cell $$$(x_2, y_2)$$$ such that each next cell in the path is located either to the down or to the right of the previous one. Calculate the number of different sums of elements for all such paths.","import sys
# sys.setrecursionlimit(10**6) 
input=sys.stdin.readline
t=int(input())
import math
def f(a,b):
    z2=min(a-1,b-1)
    
        
    z4=math.pow(2,z2)
    return int(z4) 
for t1 in range(t):
    
    x,y,a,b=list(map(int,input().split("" "")))
    # z1=min(x-1,y-1)
    x-=1
    y-=1
    a-=x
    b-=y
    ans=0
    if(a==1 or b==1):
        ans=1
    else:
        ans=1+(a-1)*(b-1)
    print(ans)",['math']
"This is an interactive problem.You're given a tree consisting of $$$n$$$ nodes, rooted at node $$$1$$$. A tree is a connected graph with no cycles.We chose a hidden node $$$x$$$. In order to find this node, you can ask queries of two types:   d $$$u$$$ ($$$1 \le u \le n$$$). We will answer with the distance between nodes $$$u$$$ and $$$x$$$. The distance between two nodes is the number of edges in the shortest path between them.  s $$$u$$$ ($$$1 \le u \le n$$$). We will answer with the second node on the path from $$$u$$$ to $$$x$$$. However, there's a plot twist. If $$$u$$$ is not an ancestor of $$$x$$$, you'll receive ""Wrong answer"" verdict! Node $$$a$$$ is called an ancestor of node $$$b$$$ if $$$a \ne b$$$ and the shortest path from node $$$1$$$ to node $$$b$$$ passes through node $$$a$$$. Note that in this problem a node is not an ancestor of itself.Can you find $$$x$$$ in no more than $$$36$$$ queries? The hidden node is fixed in each test beforehand and does not depend on your queries.","def sec(tup):
    return -tup[1]
def do(graph,top,level):
    if level==0:
        print(""!"",top)
        return None
    curr=top
    for i in range(level):
        curr=graph[curr]
    print(""d"",curr)
    dist=int(input())
    if dist==0:
        print(""!"",curr)
        return None
    newt=top
    for i in range(level-dist//2):
        newt=graph[newt]
    print(""s"",newt)
    v=int(input())
    newt=v
    newl=dist//2-1
    do(graph,newt,newl)
    return None
def main():
    n=int(input())
    graph=[[] for i in range(n+1)]
    for i in range(n-1):
        u,v=map(int,input().split())
        graph[u].append(v)
        graph[v].append(u)
    print(""d"",1)
    d=int(input())
    layers=[[1]]
    layer=[1]
    lays=[None]*(n+1)
    lays[1]=0
    for i in range(d):
        newlayer=[]
        for guy in layer:
            for neigh in graph[guy]:
                graph[neigh].remove(guy)
                newlayer.append(neigh)
                lays[neigh]=i+1
        layers.append(newlayer)
        layer=newlayer
    des=[0]*(n+1)
    for guy in layers[-1]:
        des[guy]=1
    for i in range(d):
        for guy in layers[-i-2]:
            des[guy]=sum(des[boi] for boi in graph[guy])
    for guy in range(1,n+1):
        for i in range(len(graph[guy])):
            graph[guy][i]=(graph[guy][i],des[graph[guy][i]])
        graph[guy].sort(key=sec)
    best=[0]*(n+1)
    for i in range(1,n+1):
        if len(graph[i])>0:
            best[i]=graph[i][0][0]
    do(best,1,d)
main()","['graphs', 'constructive algorithms', 'implementation', 'divide and conquer', 'interactive', 'trees']"
"Masha lives in a country with $$$n$$$ cities numbered from $$$1$$$ to $$$n$$$. She lives in the city number $$$1$$$. There is a direct train route between each pair of distinct cities $$$i$$$ and $$$j$$$, where $$$i \neq j$$$. In total there are $$$n(n-1)$$$ distinct routes. Every route has a cost, cost for route from $$$i$$$ to $$$j$$$ may be different from the cost of route from $$$j$$$ to $$$i$$$.Masha wants to start her journey in city $$$1$$$, take exactly $$$k$$$ routes from one city to another and as a result return to the city $$$1$$$. Masha is really careful with money, so she wants the journey to be as cheap as possible. To do so Masha doesn't mind visiting a city multiple times or even taking the same route multiple times.Masha doesn't want her journey to have odd cycles. Formally, if you can select visited by Masha city $$$v$$$, take odd number of routes used by Masha in her journey and return to the city $$$v$$$, such journey is considered unsuccessful.Help Masha to find the cheapest (with minimal total cost of all taken routes) successful journey.","import sys
range = xrange
input = raw_input

n,k = [int(x) for x in input().split()]
inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

mat = [[] for _ in range(n)]
for i in range(n):
    for j in range(n):
        mat[j].append(inp[i*n + j])

inf = 10**9 + 100

def randomer(odd, even):
    best = [inf]*n
    best[0] = 0
    best2 = [inf]*n
    for _ in range(k):
        for j in odd:
            opti = inf
            matj = mat[j]
            for i in even:
                val = best[i] + matj[i]
                if opti > val:
                    opti = val
            best2[j] = opti
        best, best2, odd, even = best2, best, even, odd
    return best[0]

sys.modules[""hashlib""] = sys.sha512 = sys
import random
best = inf
for _ in range(10 * 2**k):
    odd = []
    even = [0]
    for _ in range(1, n):
        (odd if random.randint(0,1) else even).append(_) 
    best = min(best, randomer(odd, even))
print best","['dp', 'probabilities', 'graphs', 'brute force']"
"— Oh my sweet Beaverette, would you fancy a walk along a wonderful woodland belt with me?   — Of course, my Smart Beaver! Let us enjoy the splendid view together. How about Friday night? At this point the Smart Beaver got rushing. Everything should be perfect by Friday, so he needed to prepare the belt to the upcoming walk. He needed to cut down several trees.Let's consider the woodland belt as a sequence of trees. Each tree i is described by the esthetic appeal ai — some trees are very esthetically pleasing, others are 'so-so', and some trees are positively ugly!The Smart Beaver calculated that he needed the following effects to win the Beaverette's heart:   The first objective is to please the Beaverette: the sum of esthetic appeal of the remaining trees must be maximum possible;  the second objective is to surprise the Beaverette: the esthetic appeal of the first and the last trees in the resulting belt must be the same;  and of course, the walk should be successful: there must be at least two trees in the woodland belt left. Now help the Smart Beaver! Which trees does he need to cut down to win the Beaverette's heart?","import sys
fin = sys.stdin

n = int(fin.readline())
a = list(map(int, fin.readline().split()))

table = dict()
s = [0] * (n + 1)
for i in range(n):
    rec = table.setdefault(a[i], { 'begin' : i, 'end' : i, 'sum' : a[i] })
    rec['end'] = i
    if a[i] >= 0:
        s[i + 1] = s[i] + a[i]
        rec['sum'] = s[rec['end'] + 1] - s[rec['begin']]
    else:
        s[i + 1] += s[i]
        rec['sum'] = s[rec['end'] + 1] - s[rec['begin']] + 2 * a[i]

ms = max(v['sum'] for v in table.values() if v['begin'] != v['end'])
for mi in table.keys():
    if table[mi]['sum'] == ms:
        break
mr = [i + 1 for i in range(n) if i < table[mi]['begin'] or i > table[mi]['end'] or table[mi]['begin'] < i < table[mi]['end'] and a[i] < 0]
    
print(ms, len(mr))
print(' '.join(map(str, mr)))","['implementation', 'brute force']"
"Childan is making up a legendary story and trying to sell his forgery — a necklace with a strong sense of ""Wu"" to the Kasouras. But Mr. Kasoura is challenging the truth of Childan's story. So he is going to ask a few questions about Childan's so-called ""personal treasure"" necklace.This ""personal treasure"" is a multiset $$$S$$$ of $$$m$$$ ""01-strings"".A ""01-string"" is a string that contains $$$n$$$ characters ""0"" and ""1"". For example, if $$$n=4$$$, strings ""0110"", ""0000"", and ""1110"" are ""01-strings"", but ""00110"" (there are $$$5$$$ characters, not $$$4$$$) and ""zero"" (unallowed characters) are not.Note that the multiset $$$S$$$ can contain equal elements.Frequently, Mr. Kasoura will provide a ""01-string"" $$$t$$$ and ask Childan how many strings $$$s$$$ are in the multiset $$$S$$$ such that the ""Wu"" value of the pair $$$(s, t)$$$ is not greater than $$$k$$$. Mrs. Kasoura and Mr. Kasoura think that if $$$s_i = t_i$$$ ($$$1\leq i\leq n$$$) then the ""Wu"" value of the character pair equals to $$$w_i$$$, otherwise $$$0$$$. The ""Wu"" value of the ""01-string"" pair is the sum of the ""Wu"" values of every character pair. Note that the length of every ""01-string"" is equal to $$$n$$$.For example, if $$$w=[4, 5, 3, 6]$$$, ""Wu"" of (""1001"", ""1100"") is $$$7$$$ because these strings have equal characters only on the first and third positions, so $$$w_1+w_3=4+3=7$$$.You need to help Childan to answer Mr. Kasoura's queries. That is to find the number of strings in the multiset $$$S$$$ such that the ""Wu"" value of the pair is not greater than $$$k$$$.","import sys
from collections import Counter

n,m,q=map(int,sys.stdin.readline().split())
w=list(map(int,sys.stdin.readline().split()))
S=[int(sys.stdin.readline(),2) for i in range(m)]
Q=[tuple(sys.stdin.readline().split()) for i in range(q)]
counter=Counter(S)
stmax=100
re=2**n
w.reverse()

score=[None]*(re)

for i in range(re):
    ANS=0
    for j in range(n):
        if i &(1<<j)==0:
            ANS+=w[j]

    score[i]=ANS

STN=[[0 for j in range(stmax+1)] for i in range(re)]

for i in range(re):
    for j in range(re):
        if score[i^j]<=stmax:
            STN[i][score[i^j]]+=counter[j]

    for j in range(1,stmax+1):
        STN[i][j]=STN[i][j]+STN[i][j-1]

for q in Q:
    sys.stdout.write(str(STN[int(q[0],2)][int(q[1])])+""\n"")","['data structures', 'bitmasks', 'brute force']"
"You are given n positive integers a1, a2, ..., an.For every ai you need to find a positive integer ki such that the decimal notation of 2ki contains the decimal notation of ai as a substring among its last min(100, length(2ki)) digits. Here length(m) is the length of the decimal notation of m.Note that you don't have to minimize ki. The decimal notations in this problem do not contain leading zeros.","#Power substring 913G
def dlog(x, n):
  bigMod = 5 ** n
  ans = [None, 0, 1, 3, 2][x % 5]
  val = 2 ** ans % bigMod
  mod, phi = 5, 4
  pval = 2 ** phi % bigMod
  for i in range(2, n + 1):
    nextMod = mod * 5
    while val % nextMod != x % nextMod:
      val = val * pval % bigMod
      ans += phi
    phi *= 5
    pval = (pval * pval % bigMod * pval % bigMod *
              pval % bigMod *
              pval % bigMod)
    mod = nextMod
  return ans

def main():
  inp = input()
  n = len(inp)
  a = int(inp)
  for m in range(n + 1):
    l = a * 10 ** m
    x, mod = l, 2 ** (n + m)
    if x % mod != 0:
      x += mod - x % mod
    if x % 5 == 0:
      x += mod
    if x < l + 10 ** m:
      assert x % mod == 0 and x % 5 != 0
      x = x // mod
      mod = 5 ** (n + m)
      print(n + m + dlog(x % mod, n + m))
      return
  assert False

if __name__ == '__main__':
  cnt = int(input())
  for i in range(cnt):
    main()","['number theory', 'math']"
"Arseny likes to organize parties and invite people to it. However, not only friends come to his parties, but friends of his friends, friends of friends of his friends and so on. That's why some of Arseny's guests can be unknown to him. He decided to fix this issue using the following procedure.At each step he selects one of his guests A, who pairwise introduces all of his friends to each other. After this action any two friends of A become friends. This process is run until all pairs of guests are friends.Arseny doesn't want to spend much time doing it, so he wants to finish this process using the minimum number of steps. Help Arseny to do it.","from collections import defaultdict
def count(x):
    c=0
    while x > 0:
        c+=1
        x &= (x-1)
    return c

n,m=map(int,input().split())
g=defaultdict(list)
for _ in range(m):
    u, v = map(int,input().split())
    u-=1;v-=1
    g[u].append(v)
    g[v].append(u)

mask1=0;mask2=0;MAX=(1<<n)-1
a=[0]*(1 << n)
dp=[MAX]*(1 << n)
if m == (n*(n-1))//2:
    print(0)
    exit(0)
for i,j in g.items():
    mask1  = (1 << i);mask2=0;mask2 |= mask1
    for k in j:
        mask2 |= (1 << k)
        
    dp[mask2]=mask1
    a[mask1]=mask2
    
for i in range(0,(1 << n)-1):
    if dp[i] != MAX:
        #print('HEllo')
        temp = dp[i] ^ i 
        for j in range(n):
            if temp & (1 << j) != 0:
                nmask = i | a[(1 << j)]
                dp[nmask]=dp[i] | (1 << j) if count(dp[i] | (1 << j)) < count(dp[nmask]) else dp[nmask]
                
ans = []
for i in range(n):
    if dp[-1] & (1 << i) != 0:
        ans.append(i+1)
print(len(ans))
print(*ans)","['dp', 'bitmasks', 'brute force', 'graphs']"
"As you know, the most intelligent beings on the Earth are, of course, cows. This conclusion was reached long ago by the Martian aliens, as well as a number of other intelligent civilizations from outer space. Sometimes cows gather into cowavans. This seems to be seasonal. But at this time the cows become passive and react poorly to external stimuli. A cowavan is a perfect target for the Martian scientific saucer, it's time for large-scale abductions, or, as the Martians say, raids. Simply put, a cowavan is a set of cows in a row. If we number all cows in the cowavan with positive integers from 1 to n, then we can formalize the popular model of abduction, known as the (a, b)-Cowavan Raid: first they steal a cow number a, then number a + b, then — number a + 2·b, and so on, until the number of an abducted cow exceeds n. During one raid the cows are not renumbered. The aliens would be happy to place all the cows on board of their hospitable ship, but unfortunately, the amount of cargo space is very, very limited. The researchers, knowing the mass of each cow in the cowavan, made p scenarios of the (a, b)-raid. Now they want to identify the following thing for each scenario individually: what total mass of pure beef will get on board of the ship. All the scenarios are independent, in the process of performing the calculations the cows are not being stolen.","import sys
range = xrange
input = raw_input

inp = [int(x) for x in sys.stdin.read().split()]
ii = 0

n = inp[ii]
ii += 1

A = [float(x) for x in inp[ii:ii + n]]
ii += n

queries = [[] for _ in range(n)]

q = inp[ii]
ii += 1

m = 500

ans = [0]*q
B = []
for _ in range(q):
    a = inp[ii] - 1
    ii += 1
    b = inp[ii]
    ii += 1
    B.append(b)
    
    if b >= m:
        i = a
        s = 0.0
        while i < n:
            s += A[i]
            i += b
        ans[_] = s
    else:
        queries[a].append(_)

buckets = [[0.0]*i for i in range(1, m)]
modvals = [n%b for b in range(1, m)]

for a in reversed(range(n)):
    val = A[a]
    for b in range(m - 1):
        if modvals[b] == 0:
            modvals[b] += b
        else:
            modvals[b] -= 1
        buckets[b][modvals[b]] += val 
    #for b,bucket in enumerate(buckets):
    #    bucket[a % (b + 1)] += val
    
    for qind in queries[a]:
        ans[qind] = buckets[B[qind] - 1][a % B[qind]] 

print '\n'.join(str(int(x)) for x in ans)","['data structures', 'sortings', 'brute force']"
"Lee is used to finish his stories in a stylish way, this time he barely failed it, but Ice Bear came and helped him. Lee is so grateful for it, so he decided to show Ice Bear his new game called ""Critic""...The game is a one versus one game. It has $$$t$$$ rounds, each round has two integers $$$s_i$$$ and $$$e_i$$$ (which are determined and are known before the game begins, $$$s_i$$$ and $$$e_i$$$ may differ from round to round). The integer $$$s_i$$$ is written on the board at the beginning of the corresponding round. The players will take turns. Each player will erase the number on the board (let's say it was $$$a$$$) and will choose to write either $$$2 \cdot a$$$ or $$$a + 1$$$ instead. Whoever writes a number strictly greater than $$$e_i$$$ loses that round and the other one wins that round.Now Lee wants to play ""Critic"" against Ice Bear, for each round he has chosen the round's $$$s_i$$$ and $$$e_i$$$ in advance. Lee will start the first round, the loser of each round will start the next round.The winner of the last round is the winner of the game, and the loser of the last round is the loser of the game.Determine if Lee can be the winner independent of Ice Bear's moves or not. Also, determine if Lee can be the loser independent of Ice Bear's moves or not.","def win(s, e):
    if e == s:return False
    elif e == s + 1:return True
    elif e & 1:return s & 1 == 0
    elif e // 2 < s:return s & 1 == 1
    elif e // 4 < s:return True
    else:return win(s, e // 4)    
def lose(s, e):return (True if e // 2 < s else win(s, e // 2))       
def main():
    res = [False, True]
    for _ in range(int(input())):
        s, e = [int(x) for x in input().split()]
        if res == [True, True]:continue
        if res == [False, False]:continue
        cur = [win(s, e), lose(s, e)]
        if res[0]:cur = [not x for x in cur]
        res = cur
    print(*[int(x) for x in res])
main()","['dp', 'dfs and similar', 'games']"
"All our characters have hobbies. The same is true for Fedor. He enjoys shopping in the neighboring supermarket. The goods in the supermarket have unique integer ids. Also, for every integer there is a product with id equal to this integer. Fedor has n discount coupons, the i-th of them can be used with products with ids ranging from li to ri, inclusive. Today Fedor wants to take exactly k coupons with him.Fedor wants to choose the k coupons in such a way that the number of such products x that all coupons can be used with this product x is as large as possible (for better understanding, see examples). Fedor wants to save his time as well, so he asks you to choose coupons for him. Help Fedor!","from heapq import heappop, heappush

n, k = [int(x) for x in input().split()]
cs = []
for i in range(n):
    l, r = [int(x) for x in input().split()]
    cs.append((l, r, i+1))
cs.sort()
h = []

for i in range(k-1):
    heappush(h, [cs[i][1], cs[i][2]])
lcs = h[:]
l = -1
push_i = k-1
for i in range(k-1, n):
    heappush(h, [cs[i][1], cs[i][2]])
    d = h[0][0] - cs[i][0]
    if d > l:
        l = d
        if push_i != k-1:
            heappop(lcs)
        for j in range(push_i, i):
            heappush(lcs, [cs[j][1], cs[j][2]])
            heappop(lcs)
        heappush(lcs, [cs[i][1], cs[i][2]])
        push_i = i+1
    heappop(h)

print(l+1)
if l == -1:
    for i in range(1, k+1):
        print(i, end=' ')

else:
    for r, i in lcs:
        print(i, end=' ')","['data structures', 'binary search', 'sortings', 'greedy']"
"Let's introduce the designation , where x is a string, n is a positive integer and operation "" + "" is the string concatenation operation. For example, [abc, 2] = abcabc.We'll say that string s can be obtained from string t, if we can remove some characters from string t and obtain string s. For example, strings ab and aсba can be obtained from string xacbac, and strings bx and aaa cannot be obtained from it.Sereja has two strings, w = [a, b] and q = [c, d]. He wants to find such maximum integer p (p &gt; 0), that [q, p] can be obtained from string w.","from itertools import repeat,chain
from fractions import gcd

def eternal(c,d, n = None):


    while True:

        yield chain.from_iterable(repeat(c,d))



        


def cyclic_array(arr):

    n = len(arr)
    def cyclar(i):

        return arr[i % n]

    return cyclar
def find_repeat(enum,q_r_gen, a_n):

    ac_count =0
    a_count = 0
    remainders ={}
    tempq=''
    tempa = ''
    for q,q_r in enumerate(q_r_gen):

        tempq=''
        for c_c in q_r:
            tempq= tempq +c_c
            for a_count,a_c in enum:
                if a_c == c_c:
                    tempa = tempa +a_c
                    ac_count+=1
                    break
            #print len(tempa),len(tempq)
        if (a_count % a_n) in remainders:

            #print tempq[:20],tempa[:20]
            break
        else:

            remainders[(a_count % a_n)]=(a_count,q)

    repeat_length = a_count - remainders[a_count % a_n][0]
    q_count = q-remainders[a_count % a_n][1]

    return remainders[a_count % a_n][0],repeat_length,q_count
    


    
def main(a,b,c,d):
  

    
    #print a, c


    a_r = chain.from_iterable(repeat(a,b))

    #print """".join(chain.from_iterable(repeat(a,b)))


    enum =enumerate(a_r)

    q_r_gen = eternal(c,d)

    i = 0
    flag = True


    if len(a) > len(c)*d:
        multiplier =1
        start,repeat_length,q_count = find_repeat(enum,q_r_gen, len(a))

    else:
        multiplier =((len(c)*d)//len(a))+1
        #print ""Multi"",multiplier
        enum2 = enumerate(chain.from_iterable(repeat(a*multiplier,b//multiplier)))
        start,repeat_length,q_count =find_repeat(enum2,q_r_gen, multiplier*len(a))
        
    if repeat_length >0:
        advance_n = (((len(a)*multiplier)*(b//multiplier))//repeat_length)-1
        advance = repeat_length * advance_n

        sofar = q_count * advance_n
    else:
        advance_n =0
        advance = 0
        sofar = 0

    #print advance_n,advance, repeat_length, len(a)*b, sofar , len(c)*d
        
    ca = cyclic_array(a)

    ra = iter(range(advance,len(a)*b))

    ac_count =0
    for q_r in q_r_gen:
        for i,c_c in enumerate(q_r):

            flag = False
            for a_count in ra:
                #print a_count

                if ca(a_count) == c_c:
                    ac_count+=1
                    flag = True
                    break
                
        if not flag:
            break

    
    print sofar + (ac_count // (len(c)*d))


    
if __name__ == ""__main__"":
    b,d = [int(s) for s in (raw_input()).split()]

    a = raw_input()

    c = raw_input()

    aset = set(a)
    cset = set(c)

    if cset.difference(aset):
        print 0

    elif a == c:

        print b // d
        
    else:
        
        main(a,b,c,d)","['binary search', 'dfs and similar', 'strings']"
"You are given a forest — an undirected graph with $$$n$$$ vertices such that each its connected component is a tree.The diameter (aka ""longest shortest path"") of a connected undirected graph is the maximum number of edges in the shortest path between any pair of its vertices.You task is to add some edges (possibly zero) to the graph so that it becomes a tree and the diameter of the tree is minimal possible.If there are multiple correct answers, print any of them.","import sys,math
from collections import defaultdict
from io import BytesIO

sys.stdin = BytesIO(sys.stdin.read())
input = lambda: sys.stdin.readline().rstrip('\r\n')
#n = int(input())
n,k = [int(x) for x in input().split(' ')]
#arr = [int(x) for x in input().split(' ')]

def makesv(v):
    s = {v}
    sviaz[v] = nsv
    while len(s):
        cur = s.pop()
        for el in ds[cur]:
            if sviaz[el] == 0:
                sviaz[el] = nsv
                s.add(el)
                

sviaz = [0] * n
ds = defaultdict(set)
dcop = defaultdict(set)
for _ in range(k):
    s,f = [int(x)-1 for x in input().split(' ')]
    ds[s].add(f)
    ds[f].add(s)
    dcop[s].add(f)
    dcop[f].add(s)
nsv = 0
for i in range(n):
    if sviaz[i] > 0:
        continue
    else:
        nsv += 1
        makesv(i)
#print(ds,sviaz)

def countmain(ind):
    sc = set()
    for i in range(len(sviaz)):
        if sviaz[i] == ind:
            sc.add(i)
    curl = 0
    while len(sc) > 2:
        leaves = set()
        for el in sc:
            if len(ds[el]) < 2:
                leaves.add(el)
        while len(sc) > 2:
            curl += 1
            newleaves = set()
            for v in leaves:
                sc.remove(v)
                for el in ds[v]:
                    ds[el].remove(v)
                    if len(ds[el]) < 2:
                        newleaves.add(el)
            leaves = newleaves
    if len(sc) == 2:
        return (curl+1,curl,sc.pop())
    elif len(sc) == 1:
        return (curl,curl,sc.pop())
re = list()
for ind in range(1,nsv+1):
    fdist,sdist,curv = countmain(ind)
    re.append((fdist,sdist,curv))


re.sort(reverse = True)
#print(re)
md = re[0][0]
sd = re[0][1]
newv = list()
for i in range(1,len(re)):
    newv.append((str(re[0][2]+1),str(re[i][2]+1)))
    newmd = re[i][0]
    newsd = re[i][1]
    if newmd+1 > md:
        sd = md
        md = newmd + 1
    elif newmd + 1 > sd:
        sd = newmd + 1
print(md + sd)
for el in newv:
    print(' '.join(el))","['constructive algorithms', 'greedy', 'dfs and similar', 'trees']"
"Mike has always been thinking about the harshness of social inequality. He's so obsessed with it that sometimes it even affects him while solving problems. At the moment, Mike has two sequences of positive integers A = [a1, a2, ..., an] and B = [b1, b2, ..., bn] of length n each which he uses to ask people some quite peculiar questions.To test you on how good are you at spotting inequality in life, he wants you to find an ""unfair"" subset of the original sequence. To be more precise, he wants you to select k numbers P = [p1, p2, ..., pk] such that 1 ≤ pi ≤ n for 1 ≤ i ≤ k and elements in P are distinct. Sequence P will represent indices of elements that you'll select from both sequences. He calls such a subset P ""unfair"" if and only if the following conditions are satisfied: 2·(ap1 + ... + apk) is greater than the sum of all elements from sequence A, and 2·(bp1 + ... + bpk) is greater than the sum of all elements from the sequence B. Also, k should be smaller or equal to  because it will be to easy to find sequence P if he allowed you to select too many elements!Mike guarantees you that a solution will always exist given the conditions described above, so please help him satisfy his curiosity!","from sys import stdin, stdout
import random


        
n = int(stdin.readline().rstrip())
a = stdin.readline().rstrip().split()
a = [int(x) for x in a]
b = stdin.readline().rstrip().split()
b = [int(x) for x in b]


currentSeq = [(a[0],b[0],1)]
stock=0
i=1
seqTotal = [a[0],b[0]]
listTotal = [a[0],b[0]]

while i<n:
    if i%2==1:
        stock+=1
    listTotal[0]+=a[i]; listTotal[1]+=b[i]
    if (2*seqTotal[0]<=listTotal[0] or 2*seqTotal[1]<=listTotal[1]) and stock>0:
        stock-=1
        seqTotal[0]+=a[i]; seqTotal[1]+=b[i]
        currentSeq.append((a[i],b[i],i+1))
    elif 2*seqTotal[0]<=listTotal[0] or 2*seqTotal[1]<=listTotal[1]:
        seqTotal[0]+=a[i]; seqTotal[1]+=b[i]
        currentSeq.append((a[i],b[i],i+1))
        random.shuffle(currentSeq)
        for j in range(len(currentSeq)):
            if 2*(seqTotal[0]-currentSeq[j][0])>listTotal[0] and 2*(seqTotal[1]-currentSeq[j][1])>listTotal[1]:
                seqTotal[0]-=currentSeq[j][0]
                seqTotal[1]-=currentSeq[j][1]
                currentSeq.pop(j)
                break
    i+=1

c = [str(x[2]) for x in currentSeq]
print(len(c))
print(' '.join(c))","['constructive algorithms', 'sortings']"
"In some country live wizards. They love playing with numbers. The blackboard has two numbers written on it — a and b. The order of the numbers is not important. Let's consider a ≤ b for the sake of definiteness. The players can cast one of the two spells in turns:  Replace b with b - ak. Number k can be chosen by the player, considering the limitations that k &gt; 0 and b - ak ≥ 0. Number k is chosen independently each time an active player casts a spell.  Replace b with b mod a. If a &gt; b, similar moves are possible.If at least one of the numbers equals zero, a player can't make a move, because taking a remainder modulo zero is considered somewhat uncivilized, and it is far too boring to subtract a zero. The player who cannot make a move, loses.To perform well in the magic totalizator, you need to learn to quickly determine which player wins, if both wizards play optimally: the one that moves first or the one that moves second.","import sys
from math import *

def win(a,b):
    if (a==0):
        return False
    if (b==0):
        return False
    if (not win(b%a,a)):
        return True
    ans=b//a
    ans%=a+1
    ans%=2
    if (ans%2==1):
        return False
    else:
        return True

try:
    fi = open(""input.txt"", ""r"")
    fo = open(""output.txt"", ""w"")
except:
    fi = sys.stdin
    fo = sys.stdout

tests=int(fi.readline())
for test in range(tests):
    a,b=map(int,fi.readline().split())
    if (win(min(a,b),max(a,b))):
        fo.write(""First\n"")
    else:
        fo.write(""Second\n"")","['games', 'math']"
"A permutation p is an ordered group of numbers p1,   p2,   ...,   pn, consisting of n distinct positive integers, each is no more than n. We'll define number n as the length of permutation p1,   p2,   ...,   pn.Simon has a positive integer n and a non-negative integer k, such that 2k ≤ n. Help him find permutation a of length 2n, such that it meets this equation: .","import math
import sys

#imgur.com/Pkt7iIf.png

#n, m = map(int, input().split())
#n = int(input())
#d = list(map(int, input().split()))

n, k = map(int, input().split())
s = list(range(1, 2*n+1))

j = 0
for i in range(k):
    s[j], s[j+1] = s[j+1], s[j]
    j += 2

print(' '.join(str(x) for x in s))","['dp', 'constructive algorithms', 'math']"
"On the math lesson a teacher asked each pupil to come up with his own lucky numbers. As a fan of number theory Peter chose prime numbers. Bob was more original. He said that number t is his lucky number, if it can be represented as: t = a2 + b2,  where a, b are arbitrary positive integers.Now, the boys decided to find out how many days of the interval [l, r] (l ≤ r) are suitable for pair programming. They decided that the day i (l ≤ i ≤ r) is suitable for pair programming if and only if the number i is lucky for Peter and lucky for Bob at the same time. Help the boys to find the number of such days.","f = lambda x: int(x**.5)+1
h,z = map(bytearray,'1\0')

L,R = map(int,raw_input().split())

n = f(R); b = n/2*h; b[0] = 0
for k in xrange(1,f(n)/2):
    if b[k]: p = 2*k+1; s = k*(p+1); b[s::p] = z*len(b[s::p])

g = ((i*(i+1),2*i+1) for i,v in enumerate(b) if v)

r = (R+3)/4*h; r[0] = 0
for s,p in g:
    r[s::p] = z*len(r[s::p])

print r.count(h,(L+2)/4)+(L<=2<=R)","['number theory', 'brute force', 'math']"
"You're given an undirected graph with $$$n$$$ nodes and $$$m$$$ edges. Nodes are numbered from $$$1$$$ to $$$n$$$.The graph is considered harmonious if and only if the following property holds:  For every triple of integers $$$(l, m, r)$$$ such that $$$1 \le l &lt; m &lt; r \le n$$$, if there exists a path going from node $$$l$$$ to node $$$r$$$, then there exists a path going from node $$$l$$$ to node $$$m$$$. In other words, in a harmonious graph, if from a node $$$l$$$ we can reach a node $$$r$$$ through edges ($$$l &lt; r$$$), then we should able to reach nodes $$$(l+1), (l+2), \ldots, (r-1)$$$ too.What is the minimum number of edges we need to add to make the graph harmonious?","from sys import stdin
from itertools import repeat
def main():
    n, m = map(int, stdin.readline().split())
    dat = map(int, stdin.read().split(), repeat(10, 2 * m))
    par = range(n + 1)
    st = []
    pu = st.append
    for i in xrange(m):
        x, y = dat[i*2], dat[i*2+1]
        while x != par[x]:
            pu(x)
            x = par[x]
        pu(x)
        while y != par[y]:
            pu(y)
            y = par[y]
        for x in st:
            par[x] = y
        del st[:]
    l = range(n + 1)
    r = range(n + 1)
    c = [0] * (n + 1)
    s = set()
    for i in xrange(1, n + 1):
        x = i
        while x != par[x]:
            pu(x)
            x = par[x]
        for y in st:
            par[y] = x
        del st[:]
        if l[x] > i:
            l[x] = i
        if r[x] < i:
            r[x] = i
        c[x] += 1
        if x == i:
            s.add(x)
    ans = 0
    f = 1
    while f:
        f = 0
        t = s.copy()
        for i in s:
            if c[i] == r[i] - l[i] + 1 or i not in t:
                continue
            for j in xrange(l[i], r[i] + 1):
                x = j
                while x != par[x]:
                    pu(x)
                    x = par[x]
                if x != i:
                    f = 1
                    if l[i] > l[x]:
                        l[i] = l[x]
                    if r[i] < r[x]:
                        r[i] = r[x]
                    c[i] += c[x]
                    pu(x)
                    ans += 1
                    t.remove(x)
                for y in st:
                    par[y] = i
                del st[:]
        s = t
    print ans
main()","['greedy', 'graphs', 'constructive algorithms', 'dsu', 'sortings', 'dfs and similar']"
"The School №0 of the capital of Berland has n children studying in it. All the children in this school are gifted: some of them are good at programming, some are good at maths, others are good at PE (Physical Education). Hence, for each child we know value ti:  ti = 1, if the i-th child is good at programming,  ti = 2, if the i-th child is good at maths,  ti = 3, if the i-th child is good at PE Each child happens to be good at exactly one of these three subjects.The Team Scientific Decathlon Olympias requires teams of three students. The school teachers decided that the teams will be composed of three children that are good at different subjects. That is, each team must have one mathematician, one programmer and one sportsman. Of course, each child can be a member of no more than one team.What is the maximum number of teams that the school will be able to present at the Olympiad? How should the teams be formed for that?","n = int(input())
my_input = raw_input()
words = my_input.split()
l = map(int, words)
c1 = 0
c2 = 0
c3 = 0
c1_ = []
c2_ = []
c3_ = []

for i in range(len(l)):
    if(l[i] == 1):
        c1 += 1
        c1_.append(i+1)
    if(l[i] == 2):
        c2 += 1
        c2_.append(i+1)
    if(l[i] == 3):
        c3 += 1
        c3_.append(i+1)
if(min(c1,c2,c3) == 0):
    print(0)
else:
    print(min((c1,c2,c3)))
    for i in range(min((c1,c2,c3))):
        print c1_[i],c2_[i],c3_[i]","['implementation', 'sortings', 'greedy']"
"Whereas humans nowadays read fewer and fewer books on paper, book readership among marmots has surged. Heidi has expanded the library and is now serving longer request sequences.","import sys
import heapq
from collections import namedtuple

Record = namedtuple('Record', ['index', 'book_id'])

l1 = sys.stdin.readline()
l2 = sys.stdin.readline()

n, k = map(int, l1.split(' '))
books = list(map(int, l2.split(' ')))

cost = 0
cache = set()
prev = dict() # book_id -> index
next = [n+1] * n # index of next with the same value
inactive_ids = set() # set of inactive object id()s
book_to_record = dict()


def serve_book(book_id, i):
	cache.add(book_id)
	record = Record(-next[i], book_id)
	heapq.heappush(h, record)
	book_to_record[book_id] = record

h = []
for i, book_id in enumerate(books):
	if book_id in prev:
		next[prev[book_id]] = i
	prev[book_id] = i

for i, book_id in enumerate(books):
	# print(""book_id=%s, h=%s, inactive=%s"" %(book_id, h, inactive_ids))
	if book_id in cache:
		previous_record = book_to_record[book_id]
		inactive_ids.add(id(previous_record))
		serve_book(book_id, i)
		# print('--> Serve book from library ', book_id)
		continue

	if len(cache) < k:
		cost += 1
		serve_book(book_id, i)
		# print('--> Buy book', book_id)
		continue

	while True:
		item = heapq.heappop(h)
		if id(item) in inactive_ids:
			# print(""--> Ignore record"", item)
			inactive_ids.remove(id(item))
			continue
		cache.remove(item.book_id)
		serve_book(book_id, i)
		cost += 1
		# print('--> Throw away book', item.book_id)
		# print('--> Add book to libary', book_id)
		break
	# print(""To evict %s"" % to_evict)
	

print(cost)","['data structures', 'greedy']"
"Vitya is studying in the third grade. During the last math lesson all the pupils wrote on arithmetic quiz. Vitya is a clever boy, so he managed to finish all the tasks pretty fast and Oksana Fillipovna gave him a new one, that is much harder.Let's denote a flip operation of an integer as follows: number is considered in decimal notation and then reverted. If there are any leading zeroes afterwards, they are thrown away. For example, if we flip 123 the result is the integer 321, but flipping 130 we obtain 31, and by flipping 31 we come to 13.Oksana Fillipovna picked some number a without leading zeroes, and flipped it to get number ar. Then she summed a and ar, and told Vitya the resulting value n. His goal is to find any valid a.As Oksana Fillipovna picked some small integers as a and ar, Vitya managed to find the answer pretty fast and became interested in finding some general algorithm to deal with this problem. Now, he wants you to write the program that for given n finds any a without leading zeroes, such that a + ar = n or determine that such a doesn't exist.","#!/usr/bin/python3

def can(s, n):
    if n == 0:
        return """"
    
    cs = list(map(int, s))
    was_over = [False for i in range(n)]
    ans = [0 for i in range(n)]
    i, j = 0, n - 1
    last = int(n == len(cs) - 1)
    while i < j:
        need_a = last * 10 + cs[i]
        need_b = last * 10 + cs[j]
        if last == 1 and cs[i] == 9 and cs[j] == 0:
            need_a = 9
            need_b = 10
        if abs(need_a - need_b) > 1:
            return """"
        if need_a == need_b + 1:
            return """"
        if need_a == need_b == 19:
            return """"

        if need_a >= 10:
            ans[j] = 9
            ans[i] = need_a - 9
        else:
            ans[j] = need_a
            ans[i] = 0

        if need_a >= 10 or was_over[i]:
            cs[i + 1] = (cs[i + 1] - 1) % 10
            if cs[i + 1] == 9:
                was_over[i + 1] = True
            
        last = (need_b == need_a + 1)
        
        i += 1
        j -= 1

    if i == j:
        need = last * 10 + cs[i]
        if need % 2 != 0:
            return """"
        ans[i] = need // 2

    if int("""".join(map(str, ans))) + int("""".join(map(str, reversed(ans)))) != int("""".join(map(str, reversed(s)))):
        return """"
        
    return """".join(map(str, reversed(ans)))


s = """".join(reversed(input()))
if s[0] != '0':
    t = can(s, len(s))
    if t != """":
        print(t)
        exit(0)
if s[-1] == '1':
    t = can(s, len(s) - 1)
    if t != """":
        print(t)
        exit(0)

print(0)","['constructive algorithms', 'implementation', 'math']"
"On a history lesson the teacher asked Vasya to name the dates when n famous events took place. He doesn't remembers the exact dates but he remembers a segment of days [li, ri] (inclusive) on which the event could have taken place. However Vasya also remembers that there was at most one event in one day. Help him choose such n dates of famous events that will fulfill both conditions. It is guaranteed that it is possible.","import collections

def process(input):
	dates = []
	n = int(next(input))
	for i, line in enumerate(input):
		line = line.rstrip(""\r\n"")
		start, end = line.split("" "")
		dates.append([int(start), int(end), i])

	d = {}
	for i in xrange(n):
		start, index = min_date(dates)
		d[index] = start
	keys = sorted(d)
	return "" "".join(str(d[key]) for key in keys)

	
def min_date(dates):
	start_min, end_min, j_min = dates[0]
	i_min = 0
	for i, date in enumerate(dates):
		start, end, j = date
		if start < start_min or (start == start_min and end < end_min):
			start_min, end_min, i_min, j_min = start, end, i, j
		
	dates.pop(i_min)
	
	for date in dates:
		date[0] = max(date[0], start_min + 1)

	return start_min, j_min


#~ if __name__ == ""__main__"":
	#~ for i in range(1, 8):
		#~ expected = next(open(""output"" + str(i))).rstrip(""\r\n"")
		#~ actual = process(open(""input"" + str(i))).rstrip(""\r\n"")
		#~ print ""test %s"" % i,
		#~ try:
			#~ assert actual == expected
		#~ except:
			#~ print actual
		#~ else:
			#~ print ""ok""
import sys
print process(sys.stdin)","['meet-in-the-middle', 'sortings', 'greedy']"
"Shuseki Kingdom is the world's leading nation for innovation and technology. There are n cities in the kingdom, numbered from 1 to n.Thanks to Mr. Kitayuta's research, it has finally become possible to construct teleportation pipes between two cities. A teleportation pipe will connect two cities unidirectionally, that is, a teleportation pipe from city x to city y cannot be used to travel from city y to city x. The transportation within each city is extremely developed, therefore if a pipe from city x to city y and a pipe from city y to city z are both constructed, people will be able to travel from city x to city z instantly.Mr. Kitayuta is also involved in national politics. He considers that the transportation between the m pairs of city (ai, bi) (1 ≤ i ≤ m) is important. He is planning to construct teleportation pipes so that for each important pair (ai, bi), it will be possible to travel from city ai to city bi by using one or more teleportation pipes (but not necessarily from city bi to city ai). Find the minimum number of teleportation pipes that need to be constructed. So far, no teleportation pipe has been constructed, and there is no other effective transportation between cities.","def main():
    n, m = map(int, input().split())
    n += 1
    cluster, dest, ab = list(range(n)), [0] * n, [[] for _ in range(n)]

    def root(x):
        if x != cluster[x]:
            cluster[x] = x = root(cluster[x])
        return x

    for _ in range(m):
        a, b = map(int, input().split())
        ab[a].append(b)
        dest[b] += 1
        cluster[root(a)] = root(b)
    pool = [a for a, f in enumerate(dest) if not f]
    for a in pool:
        for b in ab[a]:
            dest[b] -= 1
            if not dest[b]:
                pool.append(b)
    ab = [True] * n
    for a, f in enumerate(dest):
        if f:
            ab[root(a)] = False
    print(n - sum(f and a == c for a, c, f in zip(range(n), cluster, ab)))


if __name__ == '__main__':
    from sys import setrecursionlimit

    setrecursionlimit(100500)
    main()",['dfs and similar']
"Serge came to the school dining room and discovered that there is a big queue here. There are $$$m$$$ pupils in the queue. He's not sure now if he wants to wait until the queue will clear, so he wants to know which dish he will receive if he does. As Serge is very tired, he asks you to compute it instead of him.Initially there are $$$n$$$ dishes with costs $$$a_1, a_2, \ldots, a_n$$$. As you already know, there are the queue of $$$m$$$ pupils who have $$$b_1, \ldots, b_m$$$ togrogs respectively (pupils are enumerated by queue order, i.e the first pupil in the queue has $$$b_1$$$ togrogs and the last one has $$$b_m$$$ togrogs)Pupils think that the most expensive dish is the most delicious one, so every pupil just buys the most expensive dish for which he has money (every dish has a single copy, so when a pupil has bought it nobody can buy it later), and if a pupil doesn't have money for any dish, he just leaves the queue (so brutal capitalism...)But money isn't a problem at all for Serge, so Serge is buying the most expensive dish if there is at least one remaining.Moreover, Serge's school has a very unstable economic situation and the costs of some dishes or number of togrogs of some pupils can change. More formally, you must process $$$q$$$ queries:  change $$$a_i$$$ to $$$x$$$. It means that the price of the $$$i$$$-th dish becomes $$$x$$$ togrogs.  change $$$b_i$$$ to $$$x$$$. It means that the $$$i$$$-th pupil in the queue has $$$x$$$ togrogs now. Nobody leaves the queue during those queries because a saleswoman is late.After every query, you must tell Serge price of the dish which he will buy if he has waited until the queue is clear, or $$$-1$$$ if there are no dishes at this point, according to rules described above.","#!/usr/bin/env pypy
from __future__ import division, print_function

import os
import sys
from __builtin__ import xrange as range
from cStringIO import StringIO
from future_builtins import ascii, filter, hex, map, oct, zip
from io import IOBase
import __pypy__

MAXN = 10**6 + 1


def main():
    n, m = map(int, input().split())
    a = [int(x) for x in input().split()]
    b = [int(x) for x in input().split()]

    c = [0] * MAXN
    for ai in a:
        c[ai] += 1
    for bi in b:
        c[bi] -= 1

    suff_sum = [0] * (MAXN + 1)
    for i in reversed(range(MAXN)):
        suff_sum[i] = suff_sum[i + 1] + c[i]
    segtree = LazySegmentTree(suff_sum)

    q = int(input())
    for _ in range(q):
        f, i, x = map(int, input().split())
        i -= 1

        if f == 1:
            segtree.add(0, a[i] + 1, -1)
            segtree.add(0, x + 1, 1)
            a[i] = x
        else:
            segtree.add(0, b[i] + 1, 1)
            segtree.add(0, x + 1, -1)
            b[i] = x

        print(segtree.bisect(0, lambda x, y: x > y))


class LazySegmentTree:
    def __init__(self, data, default=0, func=max):
        """"""maximum segment tree""""""
        self._len = _len = len(data)
        self._size = _size = 1 << (_len - 1).bit_length()
        self._data = _data = [default] * (2 * _size)
        self._lazy = [0] * (2 * _size)
        self._default = default
        self._func = func
        _data[_size:_size + _len] = data
        for i in reversed(range(_size)):
            _data[i] = func(_data[i + i], _data[i + i + 1])

    def push(self, seg_ind):
        """"""push query on seg_ind to its children""""""
        # Let the children know of the queries
        q = self._lazy[seg_ind]

        self._lazy[2 * seg_ind] += q
        self._lazy[2 * seg_ind + 1] += q

        self._data[2 * seg_ind] += q
        self._data[2 * seg_ind + 1] += q

        # Remove queries from seg_ind
        self._data[seg_ind] = self._func(self._data[2 * seg_ind], self._data[2 * seg_ind + 1])
        self._lazy[seg_ind] = 0

    def update(self, seg_ind):
        """"""updates the node seg_ind to know of all queries applied to it via its ancestors""""""
        # Find all indecies to be updated
        seg_ind >>= 1
        inds = []
        while seg_ind > 0:
            inds.append(seg_ind)
            seg_ind >>= 1

        # Push the queries down the segment tree
        for ind in reversed(inds):
            self.push(ind)

    def build(self, seg_ind):
        """"""make the changes to seg_ind be known to its ancestors""""""
        seg_ind >>= 1
        while seg_ind > 0:
            self._data[seg_ind] = self._func(self._data[2 * seg_ind], self._data[2 * seg_ind + 1]) + self._lazy[seg_ind]
            seg_ind >>= 1

    def add(self, begin, end, value):
        """"""lazily add value to [begin, end)""""""
        begin += self._size
        end += self._size
        _start, _end = begin, end

        while _start < _end:
            if _start & 1:
                self._lazy[_start] += value
                self._data[_start] += value
                _start += 1

            if _end & 1:
                _end -= 1
                self._lazy[_end] += value
                self._data[_end] += value

            _start >>= 1
            _end >>= 1

        # Tell all nodes above of the updated area of the updates
        self.build(begin)
        self.build(end - 1)

    def bisect(self, val, cmp):
        if not cmp(self._data[1], val):
            return -1

        begin = 1
        while begin < self._size:
            self.push(begin)
            begin <<= 1
            if cmp(self._data[begin + 1], val):
                begin += 1

        return begin - self._size

    def query(self, begin, end):
        """"""func of data[begin, end)""""""
        begin += self._size
        end += self._size

        # Apply all the lazily stored queries
        self.update(begin)
        self.update(end - 1)
        res = self._default
        while begin < end:
            if begin & 1:
                res = self._func(res, self._data[begin])
                begin += 1
            if end & 1:
                end -= 1
                res = self._func(res, self._data[end])
            begin >>= 1
            end >>= 1

        return res


# region fastio

BUFSIZE = 8192


class FastI(IOBase):
    def __init__(self, file):
        self._fd = file.fileno()
        self._buffer = StringIO()
        self.newlines = 0

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(""\n"") + (not b)
            ptr = self._buffer.tell()
            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)
        self.newlines -= 1
        return self._buffer.readline()


class FastO(IOBase):
    def __init__(self, file):
        self._fd = file.fileno()
        self._buffer = __pypy__.builders.StringBuilder()
        self.write = lambda s: self._buffer.append(s)

    def flush(self):
        os.write(self._fd, self._buffer.build())
        self._buffer = __pypy__.builders.StringBuilder()


def print(*args, **kwargs):
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


sys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()","['data structures', 'math']"
"Geometric progression with the first element a and common ratio b is a sequence of numbers a, ab, ab2, ab3, ....You are given n integer geometric progressions. Your task is to find the smallest integer x, that is the element of all the given progressions, or else state that such integer does not exist.","def primes(n):
	size = n/3 + (n%6==2)
	plist = size * [True]
	plist[0] = False
	for i in xrange(int(n**0.5)/3+1):
		if plist[i]:
			k=3*i+1|1
			for j in xrange((k*k)/3,size,2*k):
				plist[j] = False
			for j in xrange((k*k+4*k-2*k*(i&1))/3,size,2*k):
				plist[j] = False
	ans = [2,3]
	for i in xrange(size):
		if plist[i]:
			ans.append(3*i+1|1)
	return ans

def solve():
	mod = 1000000007
	plist = primes(31700)

	instring = """"""2
	2 2
	4 1""""""

	n = int(raw_input())

	alist = []
	blist = []

	for i in xrange(n):
		a,b = [int(x) for x in raw_input().split()]
		alist.append(a)
		blist.append(b)

	# break down the primes
	amaps = []
	bmaps = []

	for i in xrange(n):
		a,b = alist[i], blist[i]
		amap = dict()
		bmap = dict()
		for p in plist:
			if p*p > a:
				if a > 1:
					amap[a] = 1
					bmap[a] = 0
				break
			if a%p == 0:
				count = 1
				a /= p
				while a%p == 0:
					count += 1
					a /= p
				amap[p] = count
				bmap[p] = 0
		for p in plist:
			if p*p > b:
				if b > 1:
					if b not in bmap:
						amap[b] = 0
					bmap[b] = 1
				break
			if b%p == 0:
				count = 1
				b /= p
				while b%p == 0:
					count += 1
					b /= p
				if p not in bmap:
					amap[p] = 0
				bmap[p] = count
		amaps.append(amap)
		bmaps.append(bmap)

	#print amaps
	#print bmaps
	
	# check each a, see if any works
	for i in xrange(n):
		a = alist[i]
		amap = amaps[i]

		works = True
		for j in xrange(n):
			if alist[j] == a:
				continue
			constrained = -1
			amapj = amaps[j]

			for p in amapj:
				if p not in amap:
					works = False
			if not works:
				break

			bmapj = bmaps[j]

			for (p,c) in amap.iteritems():
				need = c
				if p in amapj:
					need -= amapj[p]
				add = 0
				if p in bmapj:
					add = bmapj[p]
				if need == 0 and add == 0:
					continue
				if need < 0 or (add==0 and need>0) or need%add != 0:
					works = False
					break
				index = need / add
				if constrained == -1:
					constrained = index
				elif constrained != index:
					works = False
					break

		if works:
			print a
			return True

	#print ""Looks like no a works...""

	# make sure all seqs use same primes
	for i in xrange(n):
		for j in xrange(i+1,n):
			if amaps[i].keys() != amaps[j].keys():
				return False

	#print ""All them primes check out dude""

	# look for a diff in prime alloc in two b's (ratio diff), use to solve equation
	pkeys = amaps[0].keys()

	for i in xrange(len(pkeys)):
		p1 = pkeys[i]
		for j in xrange(i+1,len(pkeys)):
			p2 = pkeys[j]
			for k in xrange(n):
				for l in xrange(k+1,n):
					#diff1 = bmaps[k][p1] - bmaps[l][p1]
					#diff2 = bmaps[k][p2] - bmaps[l][p2]

					a1p1 = amaps[k][p1]
					b1p1 = bmaps[k][p1]
					a1p2 = amaps[k][p2]
					b1p2 = bmaps[k][p2]
					a2p1 = amaps[l][p1]
					b2p1 = bmaps[l][p1]
					a2p2 = amaps[l][p2]
					b2p2 = bmaps[l][p2]
					q = b1p1
					s = b2p1
					r = b1p2
					t = b2p2
					c1 = a2p1 - a1p1
					c2 = a2p2 - a1p2

					if q*t == r*s:
						if r*c1 == q*c2:
							continue
						else:
							return False

					x3 = s*r - q*t
					c3 = q*c2 - r*c1

					if c3 % x3 != 0:
						return False

					sol_l = c3 / x3

					# check if it works for all sequences 
					pmap = dict(amaps[l])
					for key, value in bmaps[l].iteritems():
						pmap[key] += sol_l*value

					for o in xrange(n):
						amap = amaps[o]
						bmap = bmaps[o]
						index = -1
						for key, value in pmap.iteritems():
							need = value - amap[key]
							add = bmap[key]
							if need == 0 and add == 0:
								continue
							if need < 0 or (need > 0 and add == 0):
								return False
							if need % add != 0:
								return False
							mustbe = need / add
							if index == -1:
								index = mustbe
							elif index != mustbe:
								return False

					print alist[l] * pow(blist[l],sol_l,mod) % mod
					return True
					'''
					if diff1 != diff2:
						print ""We got one!""
						
						a1p1 = amaps[k][p1]
						b1p1 = bmaps[k][p1]
						a1p2 = amaps[k][p2]
						b1p2 = bmaps[k][p2]
						a2p1 = amaps[l][p1]
						b2p1 = bmaps[l][p1]
						a2p2 = amaps[l][p2]
						b2p2 = bmaps[l][p2]
						#print ""%d + %d*i = %d + %d*j"" % (a1p1,b1p1,a2p1,b2p1)
						#print ""%d + %d*i = %d + %d*j"" % (a1p2,b1p2,a2p2,b2p2)
						q = b1p1
						s = b2p1
						r = b1p2
						t = b2p2
						c1 = a2p1 - a1p1
						c2 = a2p2 - a1p2
						
						#print ""%d*i-%d*j = %d"" % (q,s,c1)
						#print ""%d*i-%d*j = %d"" % (r,t,c2)
						if (r*c1)%q != 0 or (r*s)%q != 0:
							#print ""Non integer solution to cross""
							return False
						c3 = c2 - (r*c1)/q
						x3 = (r*s)/q - t
						if c3%x3 != 0:
							#print ""Non integer solution to cross""
							return False
						sol_l = c3 / x3
						#print p1, p2, sol_l, (c1+s)*sol_l/q

						# check if it works for all sequences 
						pmap = dict(amaps[l])
						for key, value in bmaps[l].iteritems():
							pmap[key] += value

						for o in xrange(n):
							amap = amaps[o]
							bmap = bmaps[o]
							index = -1
							for key, value in pmap.iteritems():
								need = value - amap[key]
								add = bmap[key]
								if need == 0 and add == 0:
									continue
								if need < 0 or (need > 0 and add == 0):
									return False
								if need % add != 0:
									return False
								mustbe = need / add
								if index == -1:
									index = mustbe
								elif index != mustbe:
									return False

						print alist[l] * pow(blist[l],sol_l,mod) % mod
						return True
						'''

	# if no diffs, use mod sys solver
	eea = lambda b,s,w=1,x=0,y=0,z=1:(b,w,x)if s==0 else eea(s,b%s,y,z,w-b/s*y,x-b/s*z)

	def solve_mod_sys(eqs):
		if len(eqs) == 1: return eqs
		a,m1 = eqs.pop()
		b,m2 = eqs.pop()
		lhs,rhs = m1,b-a
		gcd, m1inv = eea(m1,m2)[:2]
		if (gcd > 1):
			if rhs%gcd == 0:
				rhs/=gcd
				m1/=gcd
				m2/=gcd
				m1inv = eea(m1,m2)[1]
			else:
				return False
		rhs = m1inv*rhs%m2
		c = a + rhs*lhs
		m3 = m2*lhs
		eqs.append((c,m3))
		return solve_mod_sys(eqs)

	pkey = amaps[0].keys()[0]
	equations = []

	for i in xrange(n):
		start = amaps[i][pkey]
		step = bmaps[i][pkey]
		equations.append((start,step))

	res = solve_mod_sys(equations)
	if res == False:
		return False
	else:
		x,m = res[0]

	x /= bmaps[0][pkey]

	solution = alist[0]
	for p in bmaps[0]:
		solution *= pow(p,x*bmaps[0][p],mod)
	print solution % mod
	return True


if not solve():
	print -1",['math']
"Demiurges Shambambukli and Mazukta love to watch the games of ordinary people. Today, they noticed two men who play the following game.There is a rooted tree on n nodes, m of which are leaves (a leaf is a nodes that does not have any children), edges of the tree are directed from parent to children. In the leaves of the tree integers from 1 to m are placed in such a way that each number appears exactly in one leaf.Initially, the root of the tree contains a piece. Two players move this piece in turns, during a move a player moves the piece from its current nodes to one of its children; if the player can not make a move, the game ends immediately. The result of the game is the number placed in the leaf where a piece has completed its movement. The player who makes the first move tries to maximize the result of the game and the second player, on the contrary, tries to minimize the result. We can assume that both players move optimally well.Demiurges are omnipotent, so before the game they can arbitrarily rearrange the numbers placed in the leaves. Shambambukli wants to rearrange numbers so that the result of the game when both players play optimally well is as large as possible, and Mazukta wants the result to be as small as possible. What will be the outcome of the game, if the numbers are rearranged by Shambambukli, and what will it be if the numbers are rearranged by Mazukta? Of course, the Demiurges choose the best possible option of arranging numbers.","def readlist(f): return map(f, raw_input().split())
def readint(): return int(raw_input())
def printlist(l): print ' '.join(map(str, l))

N = readint()
E = [[] for i in range(N)]
for i in range(N-1):
  u, v = readlist(int)
  u -= 1
  v -= 1
  E[u].append(v)
  E[v].append(u)

F = [None]*N
C = [[] for i in range(N)]
S = [0]
while len(S) > 0:
  u = S.pop()
  for v in E[u]:
    if v != F[u]:
      F[v] = u
      C[u].append(v)
      S.append(v)

pol = [0]*N
pol[0] = 1
S.append(0)
while len(S) > 0:
  u = S.pop()
  for v in C[u]:
    pol[v] = -pol[u]
    S.append(v)

NB = [0]*N
M = 0
for i in range(N):
  if len(C[i]) == 0:
    M += 1
    S.append(i)
    NB[i] = 1

done = [0]*N
res1 = [0]*N
res2 = [0]*N

while len(S) > 0:
  u = S.pop()

  if len(C[u]) > 0:
    if pol[u] > 0:
      res2[u] = 0
      for v in C[u]:
        res2[u] += res2[v] + 1
      res2[u] -= 1
      res1[u] = 0
      for v in C[u]:
        res1[u] = max(res1[u], NB[u] - (NB[v] - res1[v]))
    else:
      res1[u] = NB[u] - 1
      for v in C[u]:
        res1[u] -= (NB[v] - res1[v])
      res1[u] += 1
      res2[u] = N-1
      for v in C[u]:
        res2[u] = min(res2[u], res2[v])
  if F[u] != None:
    done[F[u]] += 1
    NB[F[u]] += NB[u]
    if done[F[u]] == len(C[F[u]]):
      S.append(F[u])
print res1[0]+1, res2[0]+1","['dp', 'dfs and similar', 'trees', 'math']"
"Note that the only difference between the easy and hard version is the constraint on the number of queries. You can make hacks only if all versions of the problem are solved.This is an interactive problem.You are given a tree consisting of $$$n$$$ nodes numbered with integers from $$$1$$$ to $$$n$$$. Ayush and Ashish chose two secret distinct nodes in the tree. You need to find out both the nodes. You can make the following query:   Provide a list of nodes and you will receive a node from that list whose sum of distances to both the hidden nodes is minimal (if there are multiple such nodes in the list, you will receive any one of them). You will also get the sum of distances of that node to the hidden nodes. Recall that a tree is a connected graph without cycles. The distance between two nodes is defined as the number of edges in the simple path between them.More formally, let's define two hidden nodes as $$$s$$$ and $$$f$$$. In one query you can provide the set of nodes $$$\{a_1, a_2, \ldots, a_c\}$$$ of the tree. As a result, you will get two numbers $$$a_i$$$ and $$$dist(a_i, s) + dist(a_i, f)$$$. The node $$$a_i$$$ is any node from the provided set, for which the number $$$dist(a_i, s) + dist(a_i, f)$$$ is minimal.You can ask no more than $$$11$$$ queries.","from collections import defaultdict
import sys

int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def MI1(): return map(int1, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

def ask(aa):
    print(""?"",len(aa),*aa,flush=True)
    node,dist=MI()
    return node-1,dist

def main():
    for _ in range(II()):
        n=II()
        to=[[] for _ in range(n)]
        for _ in range(n-1):
            u,v=MI1()
            to[u].append(v)
            to[v].append(u)

        root,dist=ask(list(range(1,n+1)))
        dtou=defaultdict(list)
        par=[-1]*n

        stack=[(root,-1,0)]
        while stack:
            u,pu,dep=stack.pop()
            dtou[dep].append(u+1)
            par[u]=pu
            for v in to[u]:
                if v==pu:continue
                stack.append((v,u,dep+1))
        #print(dtou)

        l=(dist+1)//2
        r=min(len(dtou),dist+1)
        #print(l,r)
        u2=-1
        while l+1<r:
            dep=(l+r)//2
            u,d=ask(dtou[dep])
            if d==dist:
                l=dep
                u2=u
            else:r=dep
        if u2==-1:u2,_=ask(dtou[l])
        #print(u2)

        dep=l
        ng=u2
        while dep!=dist-l:
            ng=par[ng]
            dep-=1

        uu=[u for u in dtou[dist-l] if u!=ng+1]
        if uu:u1,_=ask(uu)
        else:u1=root

        print(""!"",u1+1,u2+1,flush=True)

        if SI()==""Incorrect"":break

main()","['graphs', 'shortest paths', 'interactive', 'binary search', 'dfs and similar', 'trees']"
"Ari the monster is not an ordinary monster. She is the hidden identity of Super M, the Byteforces’ superhero. Byteforces is a country that consists of n cities, connected by n - 1 bidirectional roads. Every road connects exactly two distinct cities, and the whole road system is designed in a way that one is able to go from any city to any other city using only the given roads. There are m cities being attacked by humans. So Ari... we meant Super M have to immediately go to each of the cities being attacked to scare those bad humans. Super M can pass from one city to another only using the given roads. Moreover, passing through one road takes her exactly one kron - the time unit used in Byteforces.   However, Super M is not on Byteforces now - she is attending a training camp located in a nearby country Codeforces. Fortunately, there is a special device in Codeforces that allows her to instantly teleport from Codeforces to any city of Byteforces. The way back is too long, so for the purpose of this problem teleportation is used exactly once.You are to help Super M, by calculating the city in which she should teleport at the beginning in order to end her job in the minimum time (measured in krons). Also, provide her with this time so she can plan her way back to Codeforces.","from heapq import *
INF = float('inf')
n, m = map(int, input().split())
adj = [[] for _ in range(n+1)]
wg= ng = [0 for _ in range(n+1)]

for _ in range(n-1):
    a, b = map(int, input().split())
    adj[a].append(b)
    adj[b].append(a)

aaa = set(map(int, input().split()))
if len(aaa) == 1:print(min(aaa));print(0);exit()
rm = []
for i in range(n+1):
    ng[i] = len(adj[i])
    if i not in aaa and ng[i] == 1: rm.append(i)

for a in aaa: ng[a] = 0

def remove_node(index):
    while adj[index]:
        nx = adj[index].pop()
        adj[nx].remove(index)
        ng[nx] -= 1
        if ng[nx] == 1: rm.append(nx)

    ng[index] = 0

while rm: remove_node(rm.pop())

state = [0 for _ in range(n+1)]
que = [(min(aaa), None)]
res = 0
for _ in range(2):
    deep = [0 for _ in range(n + 1)]
    while que:
        res += 1
        root, proot = que.pop()
        for nx in adj[root]:
            if proot == nx:
                continue
            if _: state[nx] = root
            deep[nx] = deep[root] + 1
            que.append((nx, root))
    if _: break

    start = max(1,deep.index(max(deep)))
    que = [(start, None)]

end = max(1, deep.index(max(deep)))
i = end
path = 1
while i != start:
    path += 1
    i = state[i]

print(min(start,end))
print(res -1 -path)","['dp', 'dfs and similar', 'trees', 'graphs']"
"One very important person has a piece of paper in the form of a rectangle a × b.Also, he has n seals. Each seal leaves an impression on the paper in the form of a rectangle of the size xi × yi. Each impression must be parallel to the sides of the piece of paper (but seal can be rotated by 90 degrees).A very important person wants to choose two different seals and put them two impressions. Each of the selected seals puts exactly one impression. Impressions should not overlap (but they can touch sides), and the total area occupied by them should be the largest possible. What is the largest area that can be occupied by two seals?","n, a, b = map(int, input().split())
xy = [list(map(int, input().split())) for _ in range(n)]

mx = 0
for i in range(n):
    for j in range(i + 1, n):
        if xy[i][0] + xy[j][0] <= a and max(xy[i][1], xy[j][1]) <= b or \
            xy[i][1] + xy[j][0] <= a and max(xy[i][0], xy[j][1]) <= b or \
            xy[i][1] + xy[j][1] <= a and max(xy[i][0], xy[j][0]) <= b or \
            xy[i][0] + xy[j][1] <= a and max(xy[i][1], xy[j][0]) <= b or \
            xy[i][0] + xy[j][0] <= b and max(xy[i][1], xy[j][1]) <= a or \
            xy[i][1] + xy[j][0] <= b and max(xy[i][0], xy[j][1]) <= a or \
            xy[i][1] + xy[j][1] <= b and max(xy[i][0], xy[j][0]) <= a or \
            xy[i][0] + xy[j][1] <= b and max(xy[i][1], xy[j][0]) <= a :
            mx = max(xy[i][0] * xy[i][1] + xy[j][0] * xy[j][1], mx)
print(mx)","['implementation', 'brute force']"
"Alexey, a merry Berland entrant, got sick of the gray reality and he zealously wants to go to university. There are a lot of universities nowadays, so Alexey is getting lost in the diversity — he has not yet decided what profession he wants to get. At school, he had bad grades in all subjects, and it's only thanks to wealthy parents that he was able to obtain the graduation certificate.The situation is complicated by the fact that each high education institution has the determined amount of voluntary donations, paid by the new students for admission — ni berubleys. He cannot pay more than ni, because then the difference between the paid amount and ni can be regarded as a bribe!Each rector is wearing the distinctive uniform of his university. Therefore, the uniform's pockets cannot contain coins of denomination more than ri. The rector also does not carry coins of denomination less than li in his pocket — because if everyone pays him with so small coins, they gather a lot of weight and the pocket tears. Therefore, a donation can be paid only by coins of denomination x berubleys, where li ≤ x ≤ ri (Berland uses coins of any positive integer denomination). Alexey can use the coins of different denominations and he can use the coins of the same denomination any number of times. When Alexey was first confronted with such orders, he was puzzled because it turned out that not all universities can accept him! Alexey is very afraid of going into the army (even though he had long wanted to get the green uniform, but his dad says that the army bullies will beat his son and he cannot pay to ensure the boy's safety). So, Alexey wants to know for sure which universities he can enter so that he could quickly choose his alma mater.Thanks to the parents, Alexey is not limited in money and we can assume that he has an unlimited number of coins of each type.In other words, you are given t requests, each of them contains numbers ni, li, ri. For each query you need to answer, whether it is possible to gather the sum of exactly ni berubleys using only coins with an integer denomination from li to ri berubleys. You can use coins of different denominations. Coins of each denomination can be used any number of times.","def possible(numbers):
        if int(numbers[0])//int(numbers[1])!=0 and int(numbers[0])%int(numbers[1])//(int(numbers[0])//int(numbers[1]))<=int(numbers[2])-int(numbers[1]) and int(numbers[0])%int(numbers[1])%int(numbers[0])//int(numbers[1])+int(numbers[0])%int(numbers[1])%(int(numbers[0])//int(numbers[1]))<=(int(numbers[2])-int(numbers[1]))*(int(numbers[0])//int(numbers[1])-int(numbers[0])//int(numbers[2])):
            return 'Yes'
        return 'No'
for i in range(0,int(input())):
    numbers=input().split(' ')
    if i == -1 and int(numbers[0])!=2 and int(numbers[0])!=912247143:
        print(numbers)
    print(possible(numbers))","['constructive algorithms', 'implementation', 'math']"
"As Famil Door’s birthday is coming, some of his friends (like Gabi) decided to buy a present for him. His friends are going to buy a string consisted of round brackets since Famil Door loves string of brackets of length n more than any other strings!The sequence of round brackets is called valid if and only if:   the total number of opening brackets is equal to the total number of closing brackets;  for any prefix of the sequence, the number of opening brackets is greater or equal than the number of closing brackets. Gabi bought a string s of length m (m ≤ n) and want to complete it to obtain a valid sequence of brackets of length n. He is going to pick some strings p and q consisting of round brackets and merge them in a string p + s + q, that is add the string p at the beginning of the string s and string q at the end of the string s.Now he wonders, how many pairs of strings p and q exists, such that the string p + s + q is a valid sequence of round brackets. As this number may be pretty large, he wants to calculate it modulo 109 + 7.","n, m = map(int, input().split())
s = input()
mod = 10 ** 9 + 7
c, b, ans, d, k = 0, 0, 0, [[1]], n - m
for i in s:
    c += (i == '(') * 2 - 1
    b = min(c, b)
for i in range(n - m):
    nd = d[-1][1:] + [0] * 2
    for j in range(1, i + 2):
        nd[j] = (nd[j] + d[-1][j - 1]) % mod
    d.append(nd)
for i in range(k + 1):
    for j in range(-b, min(k - i - c, i) + 1):
        ans = (ans + d[i][j] * d[k - i][j + c]) % mod
print(ans)","['dp', 'strings']"
"You've got an n × m pixel picture. Each pixel can be white or black. Your task is to change the colors of as few pixels as possible to obtain a barcode picture.A picture is a barcode if the following conditions are fulfilled:   All pixels in each column are of the same color.  The width of each monochrome vertical line is at least x and at most y pixels. In other words, if we group all neighbouring columns of the pixels with equal color, the size of each group can not be less than x or greater than y.","import math
n,m,x,y=map(int,input().split())
cost=[[0 for i in range(m)] for i in range(2)]
#one denotes converting to .
#zero denotes converting # 
for i in range(n):
    s=input()
    for i in range(len(s)):
        if(s[i]=='#'):
            cost[1][i]+=1
        else:
            cost[0][i]+=1


fin=[[math.inf for i in range(m+1)] for i in range(2)]
pre=[[0 for i in range(m+1)] for i in range(2)]
fin[0][0]=0
fin[1][0]=0
for i in range(1,m+1):
    if(i==1):
        pre[0][i]=cost[0][i-1]
        pre[1][i]=cost[1][i-1]
    else:
        pre[0][i]=pre[0][i-1]+cost[0][i-1]
        pre[1][i]=pre[1][i-1]+cost[1][i-1]

for i in range(1,m+1):
    if(i<2*x):
        fin[0][i]=pre[0][i]
        fin[1][i]=pre[1][i]
    
        
    else:
        cont=x
        
        while(cont<=y):
            if(i<=y):
                fin[0][i]=min(fin[0][i],pre[0][i])
                fin[1][i]=min(fin[1][i],pre[1][i])
            if(i-cont<x):
                break;
            fin[0][i]=min(fin[0][i],fin[1][i-cont]+pre[0][i]-pre[0][i-cont])
          
            fin[1][i]=min(fin[1][i],fin[0][i-cont]+pre[1][i]-pre[1][i-cont])
            cont+=1    
            

print(min(fin[0][-1],fin[1][-1]))","['dp', 'matrices']"
"The hero of the Cut the Rope game is a little monster named Om Nom. He loves candies. And what a coincidence! He also is the hero of today's problem.  One day, Om Nom visited his friend Evan. Evan has n candies of two types (fruit drops and caramel drops), the i-th candy hangs at the height of hi centimeters above the floor of the house, its mass is mi. Om Nom wants to eat as many candies as possible. At the beginning Om Nom can make at most x centimeter high jumps. When Om Nom eats a candy of mass y, he gets stronger and the height of his jump increases by y centimeters.What maximum number of candies can Om Nom eat if he never eats two candies of the same type in a row (Om Nom finds it too boring)?","n, x = (int(x) for x in input().split())

cs = []
for i in range(n):
    cs.append([int(x) for x in input().split()])
    if cs[-1][0] > 0:
        cs[-1][0] = 1

def try_eat(t0):
    h0 = x
    used = set()
    while True:
        m0 = 0
        i0 = -1
        for i, (t, h, m) in enumerate(cs):
            if t != t0 and h <= h0 and m > m0 and i not in used:
                m0 = m
                i0 = i
        if i0 == -1:
            break

        used.add(i0)
        h0 += cs[i0][2]
        t0 = 1 - t0

    return len(used)

print(max(try_eat(0), try_eat(1)))",['greedy']
"All of us love treasures, right? That's why young Vasya is heading for a Treasure Island.Treasure Island may be represented as a rectangular table $$$n \times m$$$ which is surrounded by the ocean. Let us number rows of the field with consecutive integers from $$$1$$$ to $$$n$$$ from top to bottom and columns with consecutive integers from $$$1$$$ to $$$m$$$ from left to right. Denote the cell in $$$r$$$-th row and $$$c$$$-th column as $$$(r, c)$$$. Some of the island cells contain impassable forests, and some cells are free and passable. Treasure is hidden in cell $$$(n, m)$$$.Vasya got off the ship in cell $$$(1, 1)$$$. Now he wants to reach the treasure. He is hurrying up, so he can move only from cell to the cell in next row (downwards) or next column (rightwards), i.e. from cell $$$(x, y)$$$ he can move only to cells $$$(x+1, y)$$$ and $$$(x, y+1)$$$. Of course Vasya can't move through cells with impassable forests.Evil Witch is aware of Vasya's journey and she is going to prevent him from reaching the treasure. Before Vasya's first move she is able to grow using her evil magic impassable forests in previously free cells. Witch is able to grow a forest in any number of any free cells except cells $$$(1, 1)$$$ where Vasya got off his ship and $$$(n, m)$$$ where the treasure is hidden.Help Evil Witch by finding out the minimum number of cells she has to turn into impassable forests so that Vasya is no longer able to reach the treasure.","from sys import stdin


def main():
    n, m = map(int, input().split())
    field = stdin.read()
    if n == 1 or m == 1:
        return print('10'['#' in field])
    field = [c == '.' for c in field]
    field += (False,) * (m + 2)
    visited1, visited2 = ([False] * len(field) for _ in '12')
    cnt = [0] * (n + m)
    m += 1
    visited1[0] = visited2[n * m - 2] = True
    for i in range(n * m - 2, 0, -1):
        if field[i] and (visited2[i + 1] or visited2[i + m]):
            visited2[i] = True
    for i in range(n * m):
        if field[i] and (visited1[i - 1] or visited1[i - m]):
            visited1[i] = True
            if visited2[i]:
                cnt[i // m + i % m] += 1
    print(min(cnt[1:-2]))


if __name__ == '__main__':
    main()","['dp', 'flows', 'hashing', 'dfs and similar']"
"The Free Meteor Association (FMA) has got a problem: as meteors are moving, the Universal Cosmic Descriptive Humorous Program (UCDHP) needs to add a special module that would analyze this movement. UCDHP stores some secret information about meteors as an n × m table with integers in its cells. The order of meteors in the Universe is changing. That's why the main UCDHP module receives the following queries:  The query to swap two table rows;  The query to swap two table columns;  The query to obtain a secret number in a particular table cell. As the main UCDHP module is critical, writing the functional of working with the table has been commissioned to you.","""Template made by : https://codeforces.com/profile/c1729 , github repo : https://github.com/cheran-senthil/PyRival""
from __future__ import division, print_function
import bisect
import math
import itertools
import sys
from atexit import register

if sys.version_info[0] < 3:
    from io import BytesIO as stream
else:
    from io import StringIO as stream


if sys.version_info[0] < 3:
    class dict(dict):
        """"""dict() -> new empty dictionary""""""
        def items(self):
            """"""D.items() -> a set-like object providing a view on D's items""""""
            return dict.iteritems(self)

        def keys(self):
            """"""D.keys() -> a set-like object providing a view on D's keys""""""
            return dict.iterkeys(self)

        def values(self):
            """"""D.values() -> an object providing a view on D's values""""""
            return dict.itervalues(self)

    input = raw_input
    range = xrange

    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip


def sync_with_stdio(sync=True):
    """"""Set whether the standard Python streams are allowed to buffer their I/O.

    Args:
        sync (bool, optional): The new synchronization setting.

    """"""
    global input, flush

    if sync:
        flush = sys.stdout.flush
    else:
        sys.stdin = stream(sys.stdin.read())
        input = lambda: sys.stdin.readline().rstrip('\r\n')

        sys.stdout = stream()
        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))

def main():
    n,m,k=map(int,input().split())
    d1={}
    d2={}
    for i in range(1,n+1):
        d1[i]=i
    for i in range(1,m+1):
        d2[i]=i
    l1=[]
    l2=[]
    for i in range(0,n):
        l2=list(map(int,input().split()))
        l1.append(l2)
    for i in range(0,k):
        a,b,c=input().split()
        b=int(b)
        c=int(c)
        if a=='g':
            x=d1[b]
            y=d2[c]
            print(l1[x-1][y-1])
        if a=='c':
            temp=d2[b]
            d2[b]=d2[c]
            d2[c]=temp
        if a=='r':
            temp=d1[b]
            d1[b]=d1[c]
            d1[c]=temp
        
if __name__ == '__main__':
    sync_with_stdio(False)
    main()","['data structures', 'implementation']"
"Mike and !Mike are old childhood rivals, they are opposite in everything they do, except programming. Today they have a problem they cannot solve on their own, but together (with you) — who knows? Every one of them has an integer sequences a and b of length n. Being given a query of the form of pair of integers (l, r), Mike can instantly tell the value of  while !Mike can instantly tell the value of .Now suppose a robot (you!) asks them all possible different queries of pairs of integers (l, r) (1 ≤ l ≤ r ≤ n) (so he will make exactly n(n + 1) / 2 queries) and counts how many times their answers coincide, thus for how many pairs  is satisfied.How many occasions will the robot count?","from bisect import bisect

HISENTINEL = 10**9 + 1
LOSENTINEL = -HISENTINEL

def main():
    length = int(input())
    a = [int(fld) for fld in input().strip().split()]
    b = [int(fld) for fld in input().strip().split()]
    print(countmaxminsubseq(a, b))
    
def countmaxminsubseq(a, b):
    leq, lgt = getleftbounds(a, b, 0)
    req, rgt = getleftbounds(reversed(a), reversed(b), 1)
    req = reverseindex(req)
    rgt = reverseindex(rgt)
    count = 0
    for i, (leq1, lgt1, req1, rgt1) in enumerate(zip(leq, lgt, req, rgt)):
        count += (leq1 - lgt1)*(rgt1 - i) + (i - leq1)*(rgt1 - req1)
    return count
    
def getleftbounds(a, b, bias):
    astack = [(HISENTINEL, -1)]
    bstack = [(LOSENTINEL, -1)]
    leqarr, lgtarr = [], []
    for i, (aelt, belt) in enumerate(zip(a, b)):
        while astack[-1][0] < aelt + bias:
            astack.pop()
        lgt = astack[-1][1]
        while bstack[-1][0] > belt:
            bstack.pop()
        if belt < aelt:
            leq = lgt = i
        elif belt == aelt:
            leq = i
            istack = bisect(bstack, (aelt, -2)) - 1
            lgt = max(lgt, bstack[istack][1])
        else:
            istack = bisect(bstack, (aelt, i)) - 1
            val, pos = bstack[istack]
            if val < aelt:
                lgt = leq = max(lgt, pos)
            else:
                leq = pos
                istack = bisect(bstack, (aelt, -2)) - 1
                val, pos = bstack[istack]
                lgt = max(lgt, pos)
                leq = max(leq, lgt)
                
        leqarr.append(leq)
        lgtarr.append(lgt)
        astack.append((aelt, i))
        bstack.append((belt, i))
    return leqarr, lgtarr
    
def reverseindex(rind):
    pivot = len(rind) - 1
    return [pivot - i for i in reversed(rind)]
    
   
main()","['data structures', 'binary search']"
"Your friend Mishka and you attend a calculus lecture. Lecture lasts n minutes. Lecturer tells ai theorems during the i-th minute.Mishka is really interested in calculus, though it is so hard to stay awake for all the time of lecture. You are given an array t of Mishka's behavior. If Mishka is asleep during the i-th minute of the lecture then ti will be equal to 0, otherwise it will be equal to 1. When Mishka is awake he writes down all the theorems he is being told — ai during the i-th minute. Otherwise he writes nothing.You know some secret technique to keep Mishka awake for k minutes straight. However you can use it only once. You can start using it at the beginning of any minute between 1 and n - k + 1. If you use it on some minute i then Mishka will be awake during minutes j such that  and will write down all the theorems lecturer tells.You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.","n,k=map(int,input().split())
l=list(map(int,input().split()))
s=list(map(int,input().split()))
sum1=0
dic={}
for i in range(n):
    if s[i]!=0:
        sum1=sum1+l[i]
    else:
        dic[i]=l[i]
#print('sum1',sum1)
#print(dic)
if len(dic)!=0:
    l2=list(dic.values())
    s2=list(dic.keys())
    m=len(l2)
    sum2=l2[0]
    strt=0
    end=1
    max=0
    #print(l2)
    #print(s2)
    while strt<m and end<m:
        if s2[end]-s2[strt]<=k-1:
            sum2=sum2+l2[end]
            end=end+1
            #print('end',end)
        else:
            if sum2>max:
                max=sum2

            #print('strt',strt)
            sum2=sum2-l2[strt]
            strt=strt+1


        #print('sum',sum2)
    #print(sum1)
    if sum2>max:
        max=sum2
    print(sum1+max)
else:
    print(sum1)","['dp', 'two pointers', 'implementation', 'data structures']"
"In one one-dimensional world there are n platforms. Platform with index k (platforms are numbered from 1) is a segment with coordinates [(k - 1)m, (k - 1)m + l], and l &lt; m. Grasshopper Bob starts to jump along the platforms from point 0, with each jump he moves exactly d units right. Find out the coordinate of the point, where Bob will fall down. The grasshopper falls down, if he finds himself not on the platform, but if he finds himself on the edge of the platform, he doesn't fall down.","#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading




BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------game starts now-----------------------------------------------------
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
#-------------------------------------------------------------------------
n,d,m,l=map(int,input().split())
ch=1
for i in range (1,10**6+1):
    x=i*d
    k=x//m+1
    x1=(k-1)*m
    if x1+l<x or k>n:
        print(x)
        ch=0
        break
if ch:
    f=math.ceil(((n-1)*m+l+1)/d)
    f=f*d
    print(f)","['brute force', 'math']"
"As you know, an undirected connected graph with n nodes and n - 1 edges is called a tree. You are given an integer d and a tree consisting of n nodes. Each node i has a value ai associated with it.We call a set S of tree nodes valid if following conditions are satisfied: S is non-empty. S is connected. In other words, if nodes u and v are in S, then all nodes lying on the simple path between u and v should also be presented in S. .Your task is to count the number of valid sets. Since the result can be very large, you must print its remainder modulo 1000000007 (109 + 7).","f = lambda: map(int, input().split())
m = 1000000007

d, n = f()
t = list(f())
p = [[] for i in range(n)]
for j in range(n - 1):
    u, v = f()
    u -= 1
    v -= 1
    p[u].append(v)
    p[v].append(u)

def g(u, x, a, b, q):
    k = 1
    for v in p[u]:
        if a < t[v] <= b or t[v] == a and v > q:
            if v != x: k += k * g(v, u, a, b, q) % m
    return k


s = 0
for q in range(n):
    a = t[q]
    b = a + d
    s += g(q, -1, a, b, q)

print(s % m)","['dp', 'dfs and similar', 'trees', 'math']"
"Peter decided to lay a parquet in the room of size n × m, the parquet consists of tiles of size 1 × 2. When the workers laid the parquet, it became clear that the tiles pattern looks not like Peter likes, and workers will have to re-lay it.The workers decided that removing entire parquet and then laying it again is very difficult task, so they decided to make such an operation every hour: remove two tiles, which form a 2 × 2 square, rotate them 90 degrees and put them back on the same place.  They have no idea how to obtain the desired configuration using these operations, and whether it is possible at all.Help Peter to make a plan for the workers or tell that it is impossible. The plan should contain at most 100 000 commands.","#!/usr/bin/env python3

board = []
n, m = 0, 0

def rotate(x, y):
    if board[x][y] == 'L':
        board[x][y] = board[x][y+1] = 'U'
        board[x+1][y] = board[x+1][y+1] = 'D'
    else:
        board[x][y] = board[x+1][y] = 'L'
        board[x][y+1] = board[x+1][y+1] = 'R'

def fix(x, y, moves):
    if board[x+1][y] == 'U':
        if board[x+1][y+1] == 'L':
            fix(x+1, y+1, moves)
        rotate(x+1, y)
        moves.append((x+2, y+1))
    rotate(x, y)
    moves.append((x+1, y+1))

def solve_board(moves):
    global board, n, m
    board = []
    for _ in range(n):
        board.append(list(input()))
    for i in range(n-1):
        for j in range(m):
            if board[i][j] == 'L':
                fix(i, j, moves)

def main():
    global n, m
    n, m = map(int, input().split())
    moves1 = []; moves2 = []
    solve_board(moves1)
    solve_board(moves2)
    print(len(moves1) + len(moves2))
    for move in moves1:
        print(str(move[0]) + ' ' + str(move[1]))
    for move in reversed(moves2):
        print(str(move[0]) + ' ' + str(move[1]))

if  __name__ == '__main__':
    main()",['constructive algorithms']
"Shakespeare is a widely known esoteric programming language in which programs look like plays by Shakespeare, and numbers are given by combinations of ornate epithets. In this problem we will have a closer look at the way the numbers are described in Shakespeare.Each constant in Shakespeare is created from non-negative powers of 2 using arithmetic operations. For simplicity we'll allow only addition and subtraction and will look for a representation of the given number which requires a minimal number of operations.You are given an integer n. You have to represent it as n = a1 + a2 + ... + am, where each of ai is a non-negative power of 2, possibly multiplied by -1. Find a representation which minimizes the value of m.","s=list(raw_input()[::-1])
neg=[]
car=0
for i in xrange(len(s)):
	if car==1:
		if s[i]==""0"":
			car=0
			s[i]=""1""
		else:
			s[i]=""0""
	elif i!=0 and s[i]==s[i-1]==""1"":
		neg.append(i-1)	
		s[i]=s[i-1]=""0""
		car=1
if car==1: s.append(""1"")
print s.count(""1"")+len(neg)
for i,c in enumerate(s):
	if c==""1"":
		print ""+2^""+repr(i)
for i in neg:
	print ""-2^""+repr(i)","['dp', 'constructive algorithms', 'greedy']"
"You are given a circular array with n elements. The elements are numbered from some element with values from 1 to n in clockwise order. The i-th cell contains the value ai. The robot Simba is in cell s.Each moment of time the robot is in some of the n cells (at the begin he is in s). In one turn the robot can write out the number written in current cell or move to the adjacent cell in clockwise or counterclockwise direction. To write out the number from the cell Simba doesn't spend any time, but to move to adjacent cell Simba spends one unit of time.Simba wants to write the number from each cell one time, so the numbers will be written in a non decreasing order. Find the least number of time units to write out all numbers.","from heapq import heappush, heappop
from collections import defaultdict

def solve(start, lt):
    n = len(lt)
    ii = list(sorted(set(lt)))
    maxlt = max(ii)
    right = {}
    left = {}
    leftn = {}
    rightn = {}
    last = {}

    for i in range(2 * n):
        l = lt[i % n]
        if l in last:
            right[last[l]] = i % n
            left[i % n] = last[l]
        last[l] = i % n

    hole = defaultdict(lambda: - 10**10)
    _mindst = {}
    mindstb = {}
    mindste = {}
    for i in range(n):
        hole[lt[i]] = max(hole[lt[i]], (right[i] - i) % n)
    for i in range(n):
        _mindst[lt[i]] = n - hole[lt[i]]
    last = 0
    for i in reversed(ii):
        mindste[i] = last
        last += _mindst[i]
        mindstb[i] = last

    def np(state):
        pos, boe = state
        if boe == 'begin':
            if left[pos] == pos:
                yield (0, (pos, 'end'), (('>', pos),))
            l = pos
            while True:
                ll = left[l]
                if ll == pos:
                    break
                distance = 2 * ((pos - l) % n) + (ll - pos) % n
                path = (('<', l), ('>', ll))
                yield (distance, (ll, 'end'), path)
                l = left[l]
            r = pos
            while True:
                rr = right[r]
                if rr == pos:
                    break
                distance = 2 * ((r - pos) % n) + (pos - rr) % n
                path = (('>', r), ('<', rr))
                yield (distance, (rr, 'end'), path)
                r = right[r]
        if boe == 'end' or boe == 'start':
            if boe == 'start':
                nxtl = ii[0]
            else:
                nxtl = ii[ii.index(lt[pos]) + 1]
            p = pos
            while lt[p] != nxtl:
                p = (p + 1) % n
            yield ((p - pos) % n, (p, 'begin'), (('up', '>', p),))
            p = pos
            while lt[p] != nxtl:
                p = (p - 1) % n
            yield ((pos - p) % n, (p, 'begin'), (('up', '<', p),))

    def dijkstra(beg):
        border = []
        heappush(border, (mindstb[lt[beg[0]]], 0, beg, None, None))
        fin = {}
        while True:
            asd, verd, ver, parent, path = heappop(border)
            if ver not in fin:
                fin[ver] = verd, parent, path
                pos, boe = ver
                if boe == 'end' and lt[pos] == maxlt:
                    cur = ver
                    gpath = []
                    while cur != beg:
                        _, parent, path = fin[cur]
                        gpath.extend(reversed(path))
                        cur = parent
                    return verd, list(reversed(gpath))
                for d, neigh, path in np(ver):
                    pos, boe = neigh
                    if boe == 'start' or boe == 'begin':
                        asd = d + verd + mindstb[lt[pos]]
                    else:
                        asd = d + verd + mindste[lt[pos]]
                    heappush(border, (asd,(d + verd), neigh, ver, path))

    def reconstruct(path):
        cur = start
        res = []
        done = set()
        for ps in path:
            #print('ps', ps, 'cur', cur)
            if len(ps) == 3:
                _, direction, pos = ps
                dst = (pos - cur) % n if direction == '>' else (cur - pos) % n
                sign = '+' if dst == 0 or direction == '>' else '-'
                res.append('%s%d'%(sign, dst))
                cur = pos
                done.add(pos)
            else:
                direction, pos = ps
                if direction == '>':
                    last = cur
                    while cur != pos:
                        cur = right[cur]
                        if cur not in done:
                            done.add(cur)
                            res.append('+%d'%((cur-last)%n))
                            last = cur
                if direction == '<':
                    last = cur
                    while cur != pos:
                        cur = left[cur]
                        if cur not in done:
                            done.add(cur)
                            res.append('-%d'%((last-cur)%n))
                            last = cur
        return res

    dst, path = dijkstra((start, 'start'))
    return dst, reconstruct(path)

def check(start, lt, sol, dst):
    cmp_dst, path = sol
    ltcur = -10**10
    n = len(lt)
    assert(cmp_dst == dst)
    done = set()
    cur = start
    for move in path:
        cur += {'+': 1, '-': -1}[move[0]] * int(move[1:])
        cur %= n
        assert(cur not in done)
        done.add(cur)
        assert(lt[cur] >= ltcur)
        ltcur = lt[cur]
    assert(len(done) == len(lt))

n, start = tuple(map(int, raw_input().split()))
lt = tuple(map(int, raw_input().split()))
dst, rpath = solve(start - 1, lt)
print(dst)
for p in rpath:
    print(p)",['dp']
"Genos recently installed the game Zuma on his phone. In Zuma there exists a line of n gemstones, the i-th of which has color ci. The goal of the game is to destroy all the gemstones in the line as quickly as possible.In one second, Genos is able to choose exactly one continuous substring of colored gemstones that is a palindrome and remove it from the line. After the substring is removed, the remaining gemstones shift to form a solid line again. What is the minimum number of seconds needed to destroy the entire line?Let us remind, that the string (or substring) is called palindrome, if it reads same backwards or forward. In our case this means the color of the first gemstone is equal to the color of the last one, the color of the second gemstone is equal to the color of the next to last and so on.","def ni():
    return int(raw_input())

def nis():
    return tuple(map(int, raw_input().split()))

n = ni()
a = nis()

dp = [[1] * n for _ in range(n)]

for k in range(1, n):
    for i in range(n - k):
        ik = i + k
        dp[i][ik] = min(dp[i][j] + dp[j + 1][ik] for j in range(i, ik))
        if a[i] == a[ik]:
            dp[i][ik] = min(dp[i][ik], dp[i + 1][ik - 1])

print dp[0][n - 1]",['dp']
"It is Borya's eleventh birthday, and he has got a great present: n cards with numbers. The i-th card has the number ai written on it. Borya wants to put his cards in a row to get one greater number. For example, if Borya has cards with numbers 1, 31, and 12, and he puts them in a row in this order, he would get a number 13112.He is only 11, but he already knows that there are n! ways to put his cards in a row. But today is a special day, so he is only interested in such ways that the resulting big number is divisible by eleven. So, the way from the previous paragraph is good, because 13112 = 1192 × 11, but if he puts the cards in the following order: 31, 1, 12, he would get a number 31112, it is not divisible by 11, so this way is not good for Borya. Help Borya to find out how many good ways to put the cards are there.Borya considers all cards different, even if some of them contain the same number. For example, if Borya has two cards with 1 on it, there are two good ways.Help Borya, find the number of good ways to put the cards. This number can be large, so output it modulo 998244353.","mod = 998244353
f0 = [ [0 for i in range(11)] for j in range(2010) ]
f1 = [ [0 for i in range(11)] for j in range(2010) ]
fac = [0 for i in range(2010)]
tab = [0 for i in range(11)]
C = [ [0 for i in range(2010)] for j in range(2010) ]

def Init() :
    fac[0] = 1
    for i in range(2010) :
        if i > 0 : fac[i] = fac[i - 1] * i % mod
        C[i][0] = 1
        for j in range(1, 2010) :
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod

def len(x) :
    res = 0
    while x > 0 :
        res += 1
        x = x // 10
    return res
            
def solve() :
    n = int(input())
    f0[0][0] = f1[0][0] = 1
    a = list(map(int, input().split()))
    c0, c1 = 0, 0
    s0, s1 = 0, 0
    for nu in a :
        m = nu % 11
        if len(nu) & 1 :
            c1 += 1
            s1 += m
            for i in range(11) :
                f1[c1][i] = 0
            for i in range(c1 - 1, -1, -1) :
                for j in range(11) :
                    if f1[i][j] == 0 : continue
                    f1[i + 1][(j + m) % 11] += f1[i][j]
                    f1[i + 1][(j + m) % 11] %= mod
        else :
            c0 += 1
            s0 += m
            for i in range(11) :
                f0[c0][i] = 0
            for i in range(c0 - 1, -1, -1) :
                for j in range(11) :
                    if f0[i][j] == 0 : continue
                    f0[i + 1][(j + m) % 11] += f0[i][j]
                    f0[i + 1][(j + m) % 11] %= mod
    s1 %= 11
    s0 %= 11
    part = c1 // 2
    for i in range(11) :
        tab[i] = 0
    for i in range(11) :
        tab[(i + i + 11 - s1) % 11] = f1[c1 - part][i]
    for i in range(11) :
        tab[i] = tab[i] * fac[part] % mod * fac[c1 - part] % mod

    ans = 0
    if c1 == 0 :
        ans = f0[c0][0] * fac[c0]
    elif c0 == 0 :
        ans = tab[0]
    else :
        for i in range(c0 + 1) :
            for j in range(11) :
                if f0[i][j] == 0 : continue
                # print(f0[i][j], tab[(j + j + 11 - s0) % 11] \
                # , fac[i] % mod * fac[c0 - i] % mod, C[j + (c1 - part) - 1][(c1 - part) - 1] % mod * C[part + c0 - i][part] % mod )
                ans = ( ans \
                        + fac[i] % mod * fac[c0 - i] % mod \
                        * f0[i][j] * tab[(j + j + 11 - s0) % 11] % mod \
                        * C[i + (c1 - part) - 1][(c1 - part) - 1] % mod \
                        * C[part + c0 - i][part]
 ) % mod
    print(ans)

Init()
T = int(input())
for ttt in range(T) : solve()","['dp', 'combinatorics', 'math']"
"Nikita likes tasks on order statistics, for example, he can easily find the $$$k$$$-th number in increasing order on a segment of an array. But now Nikita wonders how many segments of an array there are such that a given number $$$x$$$ is the $$$k$$$-th number in increasing order on this segment. In other words, you should find the number of segments of a given array such that there are exactly $$$k$$$ numbers of this segment which are less than $$$x$$$.Nikita wants to get answer for this question for each $$$k$$$ from $$$0$$$ to $$$n$$$, where $$$n$$$ is the size of the array.","from math import pi
from cmath import exp
def fft(a, lgN, rot=1): # rot=-1 for ifft
  N = 1<<lgN
  assert len(a)==N
  rev = [0]*N
  for i in range(N):
    rev[i] = (rev[i>>1]>>1)+(i&1)*(N>>1)
  A = [a[rev[i]] for i in range(N)]
  h = 1
  while h<N:
    w_m = exp((0+1j) * rot * (pi / h))
    for k in range(0, N, h<<1):
      w = 1
      for j in range(h):
        t = w * A[k+j+h]
        A[k+j+h] = A[k+j]-t
        A[k+j] = A[k+j]+t
        w *= w_m
    h = h<<1
  return A if rot==1 else [x/N for x in A]


import sys
ints = (int(x) for x in sys.stdin.read().split())

n, x = (next(ints) for i in range(2))
r = [next(ints) for i in range(n)]
ac = [0]*(n+1)
for i in range(n): ac[i+1] = (r[i]<x) + ac[i]

# Multiset addition
min_A, min_B = 0, -ac[-1]
max_A, max_B = ac[-1], 0
N, lgN, m = 1, 0, 2*max(max_A-min_A+1, max_B-min_B+1)
while N<m: N,lgN = N<<1,lgN+1
a, b = [0]*N, [0]*N
for x in ac:
  a[x-min_A] += 1
  b[-x-min_B] += 1
c = zip(fft(a, lgN), fft(b, lgN))
c = fft([x*y for x,y in c], lgN, rot=-1)
c = [round(x.real) for x in c][-min_A-min_B:][:n+1]
c[0] = sum((x*(x-1))//2 for x in a)
print(*c, *(0 for i in range(n+1-len(c))), flush=True)","['chinese remainder theorem', 'fft', 'math']"
"This problem is different with easy version only by constraints on total answers lengthIt is an interactive problemVenya joined a tour to the madhouse, in which orderlies play with patients the following game. Orderlies pick a string $$$s$$$ of length $$$n$$$, consisting only of lowercase English letters. The player can ask two types of queries:   ? l r – ask to list all substrings of $$$s[l..r]$$$. Substrings will be returned in random order, and in every substring, all characters will be randomly shuffled.  ! s – guess the string picked by the orderlies. This query can be asked exactly once, after that the game will finish. If the string is guessed correctly, the player wins, otherwise he loses. The player can ask no more than $$$3$$$ queries of the first type.To make it easier for the orderlies, there is an additional limitation: the total number of returned substrings in all queries of the first type must not exceed $$$\left\lceil 0.777(n+1)^2 \right\rceil$$$ ($$$\lceil x \rceil$$$ is $$$x$$$ rounded up).Venya asked you to write a program, which will guess the string by interacting with the orderlies' program and acting by the game's rules.Your program should immediately terminate after guessing the string using a query of the second type. In case your program guessed the string incorrectly, or it violated the game rules, it will receive verdict Wrong answer.Note that in every test case the string is fixed beforehand and will not change during the game, which means that the interactor is not adaptive.","from sys import stdout


class String2:
    def __init__(self, s, b=None):
        if b is not None:
            self.b = b
            return
        self.b = [0] * 26
        for i in s:
            self.b[ord(i) - ord('a')] += 1

    def __add__(self, other):
        b = self.b.copy()
        for i in range(26):
            b[i] += other.b[i]
        return String2('', b)

    def __sub__(self, other):
        b = self.b.copy()
        for i in range(26):
            b[i] -= other.b[i]
        return b

    def __mul__(self, other):
        ans = String2('', self.b)
        for i in range(26):
            ans.b[i] *= other
        return ans



def req(l, r, k=0):
    print('?', l, r)
    v = [''.join(sorted(input())) for i in range((r - l + 1) * (r - l + 2) // 2)]
    stdout.flush()
    return v


def compute(v):
    bukvi = [[0] * (n + 2) for _ in range(26)]
    for el in v:
        cur = len(el)
        for e in el:
            bukvi[ord(e) - ord('a')][cur] += 1
    return bukvi


def compute2(bukvi):
    bukvis = [set() for i in range(n + 2)]
    for i in range(26):
        prev = bukvi[i][1]
        for j in range(1, n // 2 + n % 2 + 1):
            while bukvi[i][j] != prev:
                bukvis[j].add(chr(ord('a') + i))
                prev += 1
    return bukvis


def solve(va, va2):
    for i in va2:
        va.remove(i)
    va.sort(key=len)
    s = va[0]
    for i in range(1, len(va)):
        for j in range(26):
            if va[i].count(chr(ord('a') + j)) != va[i - 1].count(chr(ord('a') + j)):
                s += chr(ord('a') + j)
    return s


def check(v, s, s2, f):
    s3 = String2(v[0])
    for i in range(1, len(v)):
        s3 = s3 + String2(v[i])
    le = len(v[0])
    cur = String2('', String2('', f - String2(s)) - String2(s2)) * le
    for i in range(le - 2):
        cur = cur + (String2(s[i]) * (i + 1)) + (String2(s2[-i-1]) * (i + 1))
    cur = cur + (String2(s[le - 2]) * (le - 1)) + (String2(s[le - 1:]) * le)
    e = cur - s3
    for i in range(26):
        if e[i]:
            return chr(ord('a') + i)


def main():
    if n == 1:
        va = req(1, 1)
        print('!', va[0])
        return
    elif n == 2:
        va2 = req(1, 1)
        va3 = req(2, 2)
        print('!', va2[0] + va3[0])
        return
    elif n == 3:
        va = req(1, 1)
        va2 = req(2, 2)
        va3 = req(3, 3)
        print('!', va[0] + va2[0] + va3[0])
        return
    va = req(1, n)
    va2 = req(1, max(n // 2 + n % 2, 2))
    va3 = req(2, max(n // 2 + n % 2, 2))
    # bukvi2 = compute(va2)
    # bukvi3 = compute(va3)
    ma = [[] for i in range(n * 2)]
    for i in va:
        ma[len(i)].append(i)
    a = String2(''.join(ma[1]))
    s = solve(va2, va3)
    s2 = ''
    for i in range(2, n // 2 + 1):
        s2 = check(ma[i], s, s2, a) + s2
    se = String2('', a - String2(s)) - String2(s2)
    for i in range(len(se)):
        if se[i]:
            s += chr(ord('a') + i)
            break
    print('!', s + s2)


n = int(input())
main()","['hashing', 'constructive algorithms', 'math', 'interactive', 'brute force']"
"You are given an array $$$a$$$, consisting of $$$n$$$ positive integers.Let's call a concatenation of numbers $$$x$$$ and $$$y$$$ the number that is obtained by writing down numbers $$$x$$$ and $$$y$$$ one right after another without changing the order. For example, a concatenation of numbers $$$12$$$ and $$$3456$$$ is a number $$$123456$$$.Count the number of ordered pairs of positions $$$(i, j)$$$ ($$$i \neq j$$$) in array $$$a$$$ such that the concatenation of $$$a_i$$$ and $$$a_j$$$ is divisible by $$$k$$$.","from sys import stdin, stdout
ti = lambda : stdin.readline().strip()
os = lambda i : stdout.write(str(i) + '\n')
ma = lambda fxn, ti : map(fxn, ti.split())
ol = lambda arr : stdout.write(' '.join(element for element in arr) + '\n')
olws = lambda arr : stdout.write(''.join(element for element in arr) + '\n')



class Digit:
	def __init__(self):
		self.count = {}

	def increment(self, k):
		if self.count.has_key(k):
			got = self.count[k]
			self.count[k] += 1
		else:
			self.count[k] = 1

	def found(self, k):
		if self.count.has_key(k):
			return self.count[k]
		else:
			return 0

n, mod = ma(int, ti())
array = ma(int, ti())


ans = 0
digits = [None]*11
for i in range(11):
	digits[i] = Digit()

for i in range(n):
	temp = array[i]%mod

	for j in range(10):
		temp *= 10
		temp %= mod

		digits[j+1].increment(temp)

for i in range(n):
	temp = array[i]
	count = 0
	while temp>0:
		temp /= 10
		count += 1

	find = mod-array[i]%mod
	find %= mod
	ans += digits[count].found(find)

for i in range(n):
	temp1 = array[i]%mod
	temp2 = array[i]

	while temp2 > 0:
		temp2 /= 10
		temp1 *= 10
		temp1 %= mod

	if ((temp1 + array[i])%mod == 0):
		ans -= 1

os(ans)","['implementation', 'math']"
"This is the hard version of the problem. The difference between the versions is that the easy version has no swap operations. You can make hacks only if all versions of the problem are solved.Pikachu is a cute and friendly pokémon living in the wild pikachu herd.But it has become known recently that infamous team R wanted to steal all these pokémon! Pokémon trainer Andrew decided to help Pikachu to build a pokémon army to resist.First, Andrew counted all the pokémon — there were exactly $$$n$$$ pikachu. The strength of the $$$i$$$-th pokémon is equal to $$$a_i$$$, and all these numbers are distinct.As an army, Andrew can choose any non-empty subsequence of pokemons. In other words, Andrew chooses some array $$$b$$$ from $$$k$$$ indices such that $$$1 \le b_1 &lt; b_2 &lt; \dots &lt; b_k \le n$$$, and his army will consist of pokémons with forces $$$a_{b_1}, a_{b_2}, \dots, a_{b_k}$$$.The strength of the army is equal to the alternating sum of elements of the subsequence; that is, $$$a_{b_1} - a_{b_2} + a_{b_3} - a_{b_4} + \dots$$$.Andrew is experimenting with pokémon order. He performs $$$q$$$ operations. In $$$i$$$-th operation Andrew swaps $$$l_i$$$-th and $$$r_i$$$-th pokémon.Andrew wants to know the maximal stregth of the army he can achieve with the initial pokémon placement. He also needs to know the maximal strength after each operation.Help Andrew and the pokémon, or team R will realize their tricky plan!","from sys import stdin, stdout
input = stdin.readline

c = 0
a = []
b = []

def f(i):
	if a[i] == 0:
		return 0
	if a[i - 1] < a[i] > a[i + 1]:
		return 1
	if a[i - 1] > a[i] < a[i + 1]:
		return -1
	return 0

def relax(i):
	global c
	c += (f(i) - b[i]) * a[i]
	b[i] = f(i)
	
def relax1(i):
	global c
	c -= b[i] * a[i]
	b[i] = 0
	#print(a[i], a[i - 1] < i)
for _ in range(int(input())):
	c = 0
	n, q = map(int, input().split())
	*a, = map(int, input().split())
	a = [0] + a + [0]
	b = [0] * (n + 2)
	for i in range(1, n + 1):
		relax(i)
	print(c)
	for i in range(q):
		l, r = map(int, input().split())
		relax1(l)
		relax1(l - 1)
		relax1(l + 1)
		relax1(r)
		relax1(r - 1)
		relax1(r + 1)
		a[l], a[r] = a[r], a[l]
		relax(l)
		relax(l - 1)
		relax(l + 1)
		relax(r)
		relax(r - 1)
		relax(r + 1)
		print(c)","['dp', 'greedy', 'implementation', 'divide and conquer', 'data structures']"
"There are $$$n$$$ people in a row. The height of the $$$i$$$-th person is $$$a_i$$$. You can choose any subset of these people and try to arrange them into a balanced circle.A balanced circle is such an order of people that the difference between heights of any adjacent people is no more than $$$1$$$. For example, let heights of chosen people be $$$[a_{i_1}, a_{i_2}, \dots, a_{i_k}]$$$, where $$$k$$$ is the number of people you choose. Then the condition $$$|a_{i_j} - a_{i_{j + 1}}| \le 1$$$ should be satisfied for all $$$j$$$ from $$$1$$$ to $$$k-1$$$ and the condition $$$|a_{i_1} - a_{i_k}| \le 1$$$ should be also satisfied. $$$|x|$$$ means the absolute value of $$$x$$$. It is obvious that the circle consisting of one person is balanced.Your task is to choose the maximum number of people and construct a balanced circle consisting of all chosen people. It is obvious that the circle consisting of one person is balanced so the answer always exists.","import sys
range = xrange
input = raw_input

n = int(input())
A = [int(x) for x in input().split()]

big = 2*10**5+10
count = [0]*big
for a in A:
    count[a] += 1

best = -1
bestl = -1
bestr = -1

i = 0
while i<big:
    while i<big and count[i]==0:
        i += 1
    if i==big:break
    s = count[i]

    j = i+1
    while j<big and count[j]>=2:
        s += count[j]
        j += 1

    maybe = j
    if maybe<big and count[maybe]==1:
        s += count[maybe]
        maybe += 1

    if s>best:
        best = s
        bestl = i
        bestr = maybe
    i = j


heights = []
for i in range(bestl,bestr):
    heights += [i]*count[i]

out = heights[::2] + heights[1::2][::-1]
print len(out)
print ' '.join(str(x) for x in out)","['dp', 'constructive algorithms', 'two pointers', 'greedy']"
"Vova promised himself that he would never play computer games... But recently Firestorm — a well-known game developing company — published their newest game, World of Farcraft, and it became really popular. Of course, Vova started playing it.Now he tries to solve a quest. The task is to come to a settlement named Overcity and spread a rumor in it.Vova knows that there are n characters in Overcity. Some characters are friends to each other, and they share information they got. Also Vova knows that he can bribe each character so he or she starts spreading the rumor; i-th character wants ci gold in exchange for spreading the rumor. When a character hears the rumor, he tells it to all his friends, and they start spreading the rumor to their friends (for free), and so on.The quest is finished when all n characters know the rumor. What is the minimum amount of gold Vova needs to spend in order to finish the quest?Take a look at the notes if you think you haven't understood the problem completely.","n, m = map(int, input().split())
vs = list(map(int, input().split()))
if m == 0:
    print(sum(vs))
    exit()
# n = 100000
# m = n - 1
# vs = [0] * n
es = {i: [] for i in range(n)}
visited = {i: False for i in range(n)}
comps = []


# def dfs(vv, compp):
#     # global visited, es
#     if visited[vv]:
#         return
#     visited[vv] = True
#     compp.append(vv)
#     neighs = es[vv]
#     for neigh in neighs:
#         if visited[neigh] or neigh == vv:
#             continue
#         dfs(neigh, compp)


for i in range(m):
    f, t = map(int, input().split())
    # f, t = i + 1, i + 2
    es[f-1].append(t-1)
    es[t-1].append(f-1)

for v in range(n):
    if visited[v]:
        continue
    comp = []
    deque = [v]
    while deque:
        v_temp = deque.pop(0)
        if visited[v_temp]:
            continue
        visited[v_temp] = True
        comp.append(v_temp)
        for neigh in es[v_temp]:
            if visited[neigh] or neigh == v_temp:
                continue
            deque.append(neigh)
    comps.append(comp)
# print(es)
res = 0
for comp in comps:
    if not comp:
        continue
    res += min(vs[i] for i in comp)

print(res)","['dfs and similar', 'greedy', 'graphs']"
"Æsir - CHAOS Æsir - V.""Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.The time right now...... 00:01:12......It's time.""The emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.The system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($$$1, 2, 3, \ldots$$$). The node with a number $$$x$$$ ($$$x &gt; 1$$$), is directly connected with a node with number $$$\frac{x}{f(x)}$$$, with $$$f(x)$$$ being the lowest prime divisor of $$$x$$$.Vanessa's mind is divided into $$$n$$$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $$$i$$$-th fragment is now located at the node with a number $$$k_i!$$$ (a factorial of $$$k_i$$$).To maximize the chance of successful awakening, Ivy decides to place the samples in a node $$$P$$$, so that the total length of paths from each fragment to $$$P$$$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $$$P$$$ needs to be counted multiple times.In the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.But for a mere human like you, is this still possible?For simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $$$P$$$.","from sys import stdin, stdout

prime = list()
factor = list()
count = list()
dist = list()
N = 0

def find_prime():
    global prime
    for i in range(2, 5010):
        is_prime = True
        for j in prime:
            if i % j == 0:
                is_prime = False
                break
        if is_prime is True:
            prime.append(i)

def calculate_factor(max):
    global prime
    global factor
    global dist
    factor = [[0 for x in range(len(prime))] for y in range(5010)] 
    dist = [0] * (max+1)
    d = 0
    for i in range(1, max+1):
        temp = i
        factor[i] = list(factor[i-1])
        for j,x in enumerate(prime):
            while temp % x == 0:
                factor[i][j] +=1
                temp = temp / x
                d += 1
            if temp == 1:
                dist[i] = d 
                break
            
def dynamic_count():
    global count
    for i in range (1,len(count)):
        count[i] += count[i-1]

def moving(i, left, right, d, current_factor):
    global count
    global prime
    global factor
    global N
    while (factor[left][i] == factor[right][i]):
        d += ((2 * (count[right] - count[left-1])) - N) * (factor[right][i] - current_factor[i])
        current_factor[i] = factor[right][i]
        i -= 1
        if i < 0:
            return d
    d += ((2 * (count[right] - count[left-1])) - N) * (factor[left][i] - current_factor[i])
    current_factor[i] = factor[left][i]
    
    
    temp_left = right
    while temp_left >= left:
        if (factor[temp_left-1][i] != factor[right][i] or temp_left == left ) and count[right] - count[temp_left-1] > int(N/2):
            if (temp_left > left):
                d += ((2 * (count[temp_left-1] - count[left-1]))) * (factor[left][i] - current_factor[i]) 
            return moving(i, temp_left, right, d, current_factor)
        elif factor[temp_left-1][i] != factor[right][i]:
            i -= 1
            right = temp_left - 1
            if i < 0:
                return d
        temp_left -= 1
    return d

def unanem():
    global prime
    global count
    global N
    
    if count[1] > int(N/2):
        return 0
    current_factor = [0] * 5010
    if count[5000] - count[4998] > int(N/2):
        return moving(len(prime)-3, 4999, 5000, 0, current_factor)
    for i,x in enumerate(prime):
        counter = 0
        if i == 0:
            counter = count[1]
        else:
            counter = count[prime[i] - 1] - count[prime[i-1] - 1]
        if counter>int(N/2):
            return moving (i, prime[i-1], prime[i] - 1, 0 , current_factor)
    return 0

def main():
    global prime
    global factor
    global count
    global N
    global debugs
    N = int(stdin.readline())
    num_list = list(map(int, stdin.readline().split()))
    max = 0
    for i in num_list:
        if max < i:
            max = i
    
    
    count = [0] * (5010)
    for i in num_list:
        count[i] += 1
            
    find_prime()
    calculate_factor(max)
    dynamic_count()
    
    d = unanem()
    overall_dist = 0
    for i,c in enumerate(count):
        if i == max + 1:
            break
        if i == 0:
            continue
        overall_dist += (count[i] - count[i-1])*dist[i]
    print(overall_dist - d)
    

main()","['dp', 'greedy', 'graphs', 'number theory', 'math', 'trees']"
"There are less than 60 years left till the 900-th birthday anniversary of a famous Italian mathematician Leonardo Fibonacci. Of course, such important anniversary needs much preparations.Dima is sure that it'll be great to learn to solve the following problem by the Big Day: You're given a set A, consisting of numbers l, l + 1, l + 2, ..., r; let's consider all its k-element subsets; for each such subset let's find the largest common divisor of Fibonacci numbers with indexes, determined by the subset elements. Among all found common divisors, Dima is interested in the largest one.Dima asked to remind you that Fibonacci numbers are elements of a numeric sequence, where F1 = 1, F2 = 1, Fn = Fn - 1 + Fn - 2 for n ≥ 3.Dima has more than half a century ahead to solve the given task, but you only have two hours. Count the residue from dividing the sought largest common divisor by m.","def recfib(n,m):
    if n==0: return (0,1,)
    a, b = recfib(n / 2,m)
    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)
m,l,r,k = map(long, raw_input().split())
D = (r-l)/(k-1)
while D > 1 and (1+(r/D)-((l+D-1)/D))<k:
    N = 1 + (r/D)
    D -= ( ((N*D)-r) + (N-1) ) / N
print(recfib(D, m)[0])","['number theory', 'math', 'matrices', 'implementation', 'data structures']"
"Nikephoros and Polycarpus play rock-paper-scissors. The loser gets pinched (not too severely!).Let us remind you the rules of this game. Rock-paper-scissors is played by two players. In each round the players choose one of three items independently from each other. They show the items with their hands: a rock, scissors or paper. The winner is determined by the following rules: the rock beats the scissors, the scissors beat the paper and the paper beats the rock. If the players choose the same item, the round finishes with a draw.Nikephoros and Polycarpus have played n rounds. In each round the winner gave the loser a friendly pinch and the loser ended up with a fresh and new red spot on his body. If the round finished in a draw, the players did nothing and just played on.Nikephoros turned out to have worked out the following strategy: before the game began, he chose some sequence of items A = (a1, a2, ..., am), and then he cyclically showed the items from this sequence, starting from the first one. Cyclically means that Nikephoros shows signs in the following order: a1, a2, ..., am, a1, a2, ..., am, a1, ... and so on. Polycarpus had a similar strategy, only he had his own sequence of items B = (b1, b2, ..., bk).Determine the number of red spots on both players after they've played n rounds of the game. You can consider that when the game began, the boys had no red spots on them.","n = int(input())
a = input()
b = input()
ai = 0
alen = len(a)
bi = 0
blen = len(b)
nik = 0
pol = 0
if alen == blen: rnd = alen
else: rnd = alen*blen
numofrounds = 0
for i in range(n):
    #print(i,rnd)
    if i == rnd:
        numofrounds = n//rnd
        # print(numofrounds)
        nik *= numofrounds
        pol *= numofrounds
        break
        #print(a[ai%alen], b[bi%blen])
    if a[ai] == b[bi]: pass
    elif (a[ai] == 'R' and b[bi] == 'S') or (a[ai] == 'S'
        and b[bi] == 'P') or (a[ai] == 'P' and b[bi] == 'R'):
        pol += 1
    else: nik += 1
    ai = (ai+1)%alen
    bi = (bi+1)%blen
if n%rnd != 0 and numofrounds != 0:
    n -= rnd*numofrounds
    ai = 0
    bi = 0
    for i in range(n):
        if a[ai] == b[bi]: pass
        elif (a[ai] == 'R' and b[bi] == 'S') or (a[ai] == 'S'
        and b[bi] == 'P') or (a[ai] == 'P' and b[bi] == 'R'):
            pol += 1
        else: nik += 1
        ai = (ai+1)%alen
        bi = (bi+1)%blen
print(nik, pol)","['implementation', 'math']"
"There is a system of n vessels arranged one above the other as shown in the figure below. Assume that the vessels are numbered from 1 to n, in the order from the highest to the lowest, the volume of the i-th vessel is ai liters.  Initially, all the vessels are empty. In some vessels water is poured. All the water that overflows from the i-th vessel goes to the (i + 1)-th one. The liquid that overflows from the n-th vessel spills on the floor.Your task is to simulate pouring water into the vessels. To do this, you will need to handle two types of queries:  Add xi liters of water to the pi-th vessel;  Print the number of liters of water in the ki-th vessel. When you reply to the second request you can assume that all the water poured up to this point, has already overflown between the vessels.","'''input
2
5 10
6
1 1 4
2 1
1 2 5
1 1 4
2 1
2 2
'''
# its dsu 
from sys import stdin, setrecursionlimit
import math
from collections import defaultdict, deque

setrecursionlimit(15000)


def process_query(node, x, max_capacity, cur_capacity, link):
		i = node
		while  link[i] != n + 1 and x > 0 :
			if cur_capacity[link[i]] + x < max_capacity[link[i]]:
				cur_capacity[link[i]] += x
				break
			
			diff = max_capacity[link[i]] - cur_capacity[link[i]]
			cur_capacity[link[i]] = max_capacity[link[i]]
			x -= diff
			link[i] = link[i + 1]
			i = link[i]
		link[node] = link[i]


def convert_to_dict(max_capacity):
	mydict1, mydict2 = dict(), dict()
	link = dict()
	
	for i in range(len(max_capacity)):
		mydict1[i + 1] = max_capacity[i]
		mydict2[i + 1] = 0
		link[i+ 1] = i + 1
	mydict1[len(max_capacity) + 1] = float('inf')
	mydict2[len(max_capacity )+ 1] = float('inf')
	link[len(max_capacity) + 1] = len(max_capacity) + 1
	return mydict1, mydict2, link


# main starts
n = int(stdin.readline().strip())
max_capacity = list(map(int, stdin.readline().split()))
max_capacity, cur_capacity, link = convert_to_dict(max_capacity)
m = int(stdin.readline().strip())
for _ in range(m):
	query = list(map(int, stdin.readline().split()))
	if len(query) == 3:
		process_query(query[1], query[2], max_capacity, cur_capacity, link)
		#print(link)
	else:
		print(cur_capacity[query[1]])","['data structures', 'dsu', 'implementation', 'trees']"
"Every day Ruslan tried to count sheep to fall asleep, but this didn't help. Now he has found a more interesting thing to do. First, he thinks of some set of circles on a plane, and then tries to choose a beautiful set of points, such that there is at least one point from the set inside or on the border of each of the imagined circles.Yesterday Ruslan tried to solve this problem for the case when the set of points is considered beautiful if it is given as (xt = f(t), yt = g(t)), where argument t takes all integer values from 0 to 50. Moreover, f(t) and g(t) should be correct functions.Assume that w(t) and h(t) are some correct functions, and c is an integer ranging from 0 to 50. The function s(t) is correct if it's obtained by one of the following rules:  s(t) = abs(w(t)), where abs(x) means taking the absolute value of a number x, i.e. |x|; s(t) = (w(t) + h(t)); s(t) = (w(t) - h(t)); s(t) = (w(t) * h(t)), where  *  means multiplication, i.e. (w(t)·h(t)); s(t) = c; s(t) = t;Yesterday Ruslan thought on and on, but he could not cope with the task. Now he asks you to write a program that computes the appropriate f(t) and g(t) for any set of at most 50 circles.In each of the functions f(t) and g(t) you are allowed to use no more than 50 multiplications. The length of any function should not exceed 100·n characters. The function should not contain spaces.Ruslan can't keep big numbers in his memory, so you should choose f(t) and g(t), such that for all integer t from 0 to 50 value of f(t) and g(t) and all the intermediate calculations won't exceed 109 by their absolute value.","def f(x):
        if x == n:
                return ""0""
        if x == 0:
                return ""("" + str(X[0]) + ""+"" + f(1) + "")""
        ss = ""(abs((t-"" + str(x-1) + ""))-abs((t-"" + str(x)  + "")))""
        tmp = (X[x] - X[x - 1]) // 2
        re = (X[x] - X[x - 1]) -  2 * tmp
        X[x] -= re
        if tmp < 0:
                tmp = ""(0"" +str(tmp)+"")""
        ss = ""(("" + str(tmp) + ""*"" + ss + "")"" + ""+"" + str(tmp) + "")""
        return ""("" + ss + ""+"" + f(x + 1) + "")""

n = int(input())
#c = [(int(_) for _ in input().split()) for i in range(n)]
c = [[int(x) for x in input().split()] for i in range(n)]
#print(n, c)
X = [c[i][0] for i in range(n)]
Y = [c[i][1] for i in range(n)]
#print(X)
#print(Y)
print(f(0))
#print(X)
X = Y
print(f(0))","['constructive algorithms', 'math']"
"It has been noted that if some ants are put in the junctions of the graphene integer lattice then they will act in the following fashion: every minute at each junction (x, y) containing at least four ants a group of four ants will be formed, and these four ants will scatter to the neighbouring junctions (x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1) — one ant in each direction. No other ant movements will happen. Ants never interfere with each other.Scientists have put a colony of n ants into the junction (0, 0) and now they wish to know how many ants will there be at some given junctions, when the movement of the ants stops.","from sys import *
f = lambda: map(int, stdin.readline().split())
n, t = f()

m = 65
r = range(1, m)
p = [[0] * m for i in range(m)]
p[1][0] = n // 4
p[0][0] = n % 4

s = k = 1
while s:
    s = 0

    for x in r[:k]:
        if p[x][0] > 3:
            s = 1
            d = p[x][0] // 4
            p[x][0] %= 4

            p[x + 1][0] += d
            p[x][1] += d

            if x != 1:
                p[x - 1][0] += d
            else:
                p[1][1] += d
                p[1][0] += d
        for y in r[:x - 1]:
            if p[x][y] > 3:
                s = 1
                d = p[x][y] // 4
                p[x][y] %= 4

                p[x + 1][y] += d
                p[x - 1][y] += d
                p[x][y + 1] += d
                p[x][y - 1] += d

                if x == y + 1:
                    p[x][x] += d
                    p[y][y] += d
                if y == 1: p[x][0] += d
        if p[x][x] > 3:
            s = 1
            d = p[x][x] // 4
            p[x][x] %= 4

            p[x + 1][x] += d
            p[x][x - 1] += d

            if x == 1: p[1][0] += d
    k += 1

s = []
for j in range(t):
    x, y = f()
    x, y = abs(x), abs(y)
    if x < y: x, y = y, x
    s.append(p[x][y] if x < m else 0)

stdout.write('\n'.join(map(str, s)))",['dfs and similar']
"An electrical grid in Berland palaces consists of 2 grids: main and reserve. Wires in palaces are made of expensive material, so selling some of them would be a good idea!Each grid (main and reserve) has a head node (its number is $$$1$$$). Every other node gets electricity from the head node. Each node can be reached from the head node by a unique path. Also, both grids have exactly $$$n$$$ nodes, which do not spread electricity further.In other words, every grid is a rooted directed tree on $$$n$$$ leaves with a root in the node, which number is $$$1$$$. Each tree has independent enumeration and nodes from one grid are not connected with nodes of another grid.Also, the palace has $$$n$$$ electrical devices. Each device is connected with one node of the main grid and with one node of the reserve grid. Devices connect only with nodes, from which electricity is not spread further (these nodes are the tree's leaves). Each grid's leaf is connected with exactly one device.    In this example the main grid contains $$$6$$$ nodes (the top tree) and the reserve grid contains $$$4$$$ nodes (the lower tree). There are $$$3$$$ devices with numbers colored in blue. It is guaranteed that the whole grid (two grids and $$$n$$$ devices) can be shown in this way (like in the picture above):  main grid is a top tree, whose wires are directed 'from the top to the down',  reserve grid is a lower tree, whose wires are directed 'from the down to the top',  devices — horizontal row between two grids, which are numbered from $$$1$$$ to $$$n$$$ from the left to the right,  wires between nodes do not intersect. Formally, for each tree exists a depth-first search from the node with number $$$1$$$, that visits leaves in order of connection to devices $$$1, 2, \dots, n$$$ (firstly, the node, that is connected to the device $$$1$$$, then the node, that is connected to the device $$$2$$$, etc.).Businessman wants to sell (remove) maximal amount of wires so that each device will be powered from at least one grid (main or reserve). In other words, for each device should exist at least one path to the head node (in the main grid or the reserve grid), which contains only nodes from one grid.","from __future__ import print_function,division
import sys#log min est tolérable
n=int(input())
def f():
    global n
    co=[[0]*n for k in range(n)]
    a=int(input())
    p=[0]+list(map(int,raw_input().split()))
    d=[0]*a
    s=[1]*a
    s[0]=0
    mi=[n]*a#plus peit
    ma=[-1]*a#le plus tard
    for k in p[1:]:
        d[k-1]+=1
    x=list(map(int,raw_input().split()))
    for k in range(n):
        mi[x[k]-1]=k
        ma[x[k]-1]=k
    pi=[k for k in range(a) if d[k]==0]
    for k in range(a-1):
        v=pi.pop()
        p[v]-=1
        d[p[v]]-=1
        if d[p[v]]==0:
            pi.append(p[v])
        s[p[v]]+=s[v]
        ma[p[v]] =max(ma[p[v]],ma[v])
        mi[p[v]] =min(mi[p[v]],mi[v])
    for v in range(a):
        co[ma[v]][mi[v]]=max(s[v],co[ma[v]][mi[v]])
    return co
l1=f()
l2=f()
be=[0]*(n+1)
for k in range(n):
    be[k]=max([be[k-1],max(be[i-1]+l1[k][i] for i in range(k+1)),max(be[i-1]+l2[k][i] for i in range(k+1))])
print(be[n-1])","['dp', 'graphs', 'flows', 'data structures', 'dfs and similar', 'trees']"
"Polycarp likes arithmetic progressions. A sequence $$$[a_1, a_2, \dots, a_n]$$$ is called an arithmetic progression if for each $$$i$$$ ($$$1 \le i &lt; n$$$) the value $$$a_{i+1} - a_i$$$ is the same. For example, the sequences $$$[42]$$$, $$$[5, 5, 5]$$$, $$$[2, 11, 20, 29]$$$ and $$$[3, 2, 1, 0]$$$ are arithmetic progressions, but $$$[1, 0, 1]$$$, $$$[1, 3, 9]$$$ and $$$[2, 3, 1]$$$ are not.It follows from the definition that any sequence of length one or two is an arithmetic progression.Polycarp found some sequence of positive integers $$$[b_1, b_2, \dots, b_n]$$$. He agrees to change each element by at most one. In the other words, for each element there are exactly three options: an element can be decreased by $$$1$$$, an element can be increased by $$$1$$$, an element can be left unchanged.Determine a minimum possible number of elements in $$$b$$$ which can be changed (by exactly one), so that the sequence $$$b$$$ becomes an arithmetic progression, or report that it is impossible.It is possible that the resulting sequence contains element equals $$$0$$$.","import sys

n = raw_input()
a = map(int,raw_input().split())

ans = sys.maxint


if len(a) > 2:
    check = [(0,0,0),
            (1,0,1),
            (0,1,1),
            (-1,0,1),
            (0,-1,1),
            (1,-1,2),
            (-1,1,2),
            (1,1,2),
            (-1,-1,2)]

    for e in check:
        diff = (a[1]+e[1]) - (a[0]+e[0]) 
        chg = e[2]
        state = [e[0],e[1]]
        valid = True 
        for i in range(2,len(a)):
            if a[i] - (a[i-1]+state[i-1]) - diff >= 2 or a[i] - (a[i-1]+state[i-1]) - diff <= -2:
                valid = False
                break
            else:
                state.append(diff - (a[i] - (a[i-1]+state[i-1])) )
                chg += abs(a[i] - (a[i-1]+state[i-1]) - diff)

        if valid:
            ans = min(chg,ans)
else:
    ans = 0

        

print -1 if ans == sys.maxint else ans","['implementation', 'brute force', 'math']"
There are n cities on a two dimensional Cartesian plane. The distance between two cities is equal to the Manhattan distance between them (see the Notes for definition). A Hamiltonian cycle of the cities is defined as a permutation of all n cities. The length of this Hamiltonian cycle is defined as the sum of the distances between adjacent cities in the permutation plus the distance between the first and final city in the permutation. Please compute the longest possible length of a Hamiltonian cycle of the given cities.,"import sys
 
n = int(raw_input())
coordinates = []
xs = []
ys = []
for i in range(n):
  x, y = map(int, raw_input().split())
  coordinates.append(((x, i), (y, i)))
  xs.append((x, i))
  ys.append((y, i))
 
xs = sorted(xs)
ys = sorted(ys)
 
amt = [[0] * 2 for _ in range(2)]
 
medians = 0
 
for x, y in coordinates:
  if n % 2 and x == xs[n/2]:
    # median
    medians += 1
    continue
  if n % 2 and y == ys[n/2]:
    # median
    medians += 1
    continue
  amt[x < xs[n/2]][y < ys[n/2]] += 1
 
def CalcuHalf(arr):
  res = 0
  for a, _ in arr[len(arr)/2:]:
    res += a
  for a, _ in arr[:len(arr)/2]:
    res -= a
  return res
 
def PossibleAll():
  def CalculateMax(arr):
    woot = arr + arr
    woot = sorted(woot)
    return CalcuHalf(woot)
  print CalculateMax(xs) + CalculateMax(ys)
  sys.exit(0)
 
if amt[0][0] + amt[1][1] == 0 or amt[1][0] + amt[0][1] == 0:
  PossibleAll()
if medians == 2:
  PossibleAll()
if medians == 0:
  def Proc(arr):
    zs = sorted(arr + arr)
    zs[n-1], zs[n] = zs[n], zs[n-1]
    return CalcuHalf(zs)
  print max([Proc(xs) + CalcuHalf(sorted(ys+ys)),
             Proc(ys) + CalcuHalf(sorted(xs+xs))])
else:
  def Proc(arr):
    zs = sorted(arr + arr)
    zs[n-2], zs[n] = zs[n], zs[n-2]
    az = sorted(arr + arr)
    az[n-1], az[n+1] = az[n+1], az[n-1]
    return max([CalcuHalf(zs), CalcuHalf(az)])
  print max([Proc(xs) + CalcuHalf(sorted(ys+ys)),
             Proc(ys) + CalcuHalf(sorted(xs+xs))])",['math']
"Why I have to finish so many assignments???Jamie is getting very busy with his school life. He starts to forget the assignments that he has to do. He decided to write the things down on a to-do list. He assigns a value priority for each of his assignment (lower value means more important) so he can decide which he needs to spend more time on.After a few days, Jamie finds out the list is too large that he can't even manage the list by himself! As you are a good friend of Jamie, help him write a program to support the following operations on the to-do list:  set ai xi — Add assignment ai to the to-do list if it is not present, and set its priority to xi. If assignment ai is already in the to-do list, its priority is changed to xi.  remove ai — Remove assignment ai from the to-do list if it is present in it.  query ai — Output the number of assignments that are more important (have a smaller priority value) than assignment ai, so Jamie can decide a better schedule. Output  - 1 if ai is not in the to-do list.  undo di — Undo all changes that have been made in the previous di days (not including the day of this operation) At day 0, the to-do list is empty. In each of the following q days, Jamie will do exactly one out of the four operations. If the operation is a query, you should output the result of the query before proceeding to the next day, or poor Jamie cannot make appropriate decisions.","import sys, os, __pypy__
from collections import defaultdict
from cStringIO import StringIO
from io import IOBase
range = xrange
input = raw_input
 
L = []
R = []
A = [0]

__pypy__.resizelist_hint(L, 50*10**5)
__pypy__.resizelist_hint(R, 50*10**5)
__pypy__.resizelist_hint(A, 50*10**5)


def create():
    L.append(-1)
    R.append(-1)
    A.append(0)
    return len(L) - 1
 
def copy(ind):
    L.append(L[ind])
    R.append(R[ind])
    A[-1] = A[ind]
    A.append(0)
    return len(L) - 1
 
def adder(i, n, ind, x):
    ind0 = ind = copy(ind) if ind >= 0 else create()
    while n != 1:
        A[ind] += x
        n = n >> 1
        if i < n:
            L[ind] = ind = copy(L[ind]) if L[ind] >= 0 else create()
        else:
            R[ind] = ind = copy(R[ind]) if R[ind] >= 0 else create()
            i -= n
    A[ind] += x
    return ind0
 
def getter(l, r, n, ind):
    ans = 0
    while ind >= 0 and 0 < r and l < n:
        if l <= 0 and r >= n:
            ans += A[ind]
            break
        n = n >> 1
        ans += getter(l - n, r - n, n, R[ind])
        ind = L[ind]
    return ans

def getteri(i, n, ind):
    ans = 0
    while ind >= 0:
        if n == 1:
            return A[ind]
        n = n >> 1
        if i < n:
            ind = L[ind]
        else:
            i -= n
            ind = R[ind]
    return 0
 
mapper = {'set':0, 'remove':1, 'query':2, 'undo':3}
N = 1 << 30
M = 1 << 17
 
def main():
    curbucket = -1
    curprio   = -1
    Tbucket = [curbucket]
    Tprio   = [curprio]
    identifier = defaultdict(lambda: len(identifier))
 
    q = int(input())
    for curd in range(q):
        inp = sys.stdin.readline().split(); ii = 0
        cas = mapper[inp[ii]]; ii += 1
        if cas == 0:
            aind = identifier[inp[ii]]; ii += 1
            new_prio = int(inp[ii]); ii += 1
 
            prio = getteri(aind, M, curprio)
            curprio = adder(aind, M, curprio, new_prio - prio)
            if prio:
                curbucket = adder(prio, N, curbucket, -1)
            if new_prio:
                curbucket = adder(new_prio, N, curbucket, 1)
        elif cas == 1:
            aind = identifier[inp[ii]]; ii += 1
            prio = getteri(aind, M, curprio)
            if prio:
                curbucket = adder(prio, N, curbucket, -1)
                curprio = adder(aind, M, curprio, -prio)
        elif cas == 2:
            aind = identifier[inp[ii]]; ii += 1
            prio = getteri(aind, M, curprio)
            ans = getter(0, prio, N, curbucket) if prio else -1
            os.write(1, str(ans) + '\n')
        else: #  cas == 3
            d = int(inp[ii]); ii += 1
            curbucket = Tbucket[curd - d]
            curprio   = Tprio[curd - d]
        Tbucket.append(curbucket)
        Tprio.append(curprio)
 
# region fastio
 
BUFSIZE = 8192
 
class FastI(IOBase):
    def __init__(self, file):
        self._fd = file.fileno()
        self._buffer = StringIO()
        self.newlines = 0
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(""\n"") + (not b)
            ptr = self._buffer.tell()
            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)
        self.newlines -= 1
        return self._buffer.readline()
 
 
class FastO(IOBase):
    def __init__(self, file):
        self._fd = file.fileno()
        self._buffer = __pypy__.builders.StringBuilder()
        self.write = lambda s: self._buffer.append(s)
 
    def flush(self):
        os.write(self._fd, self._buffer.build())
        self._buffer = __pypy__.builders.StringBuilder()
 
sys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
if __name__ == ""__main__"":
    main()","['data structures', 'trees', 'interactive']"
"You are given a text consisting of $$$n$$$ space-separated words. There is exactly one space character between any pair of adjacent words. There are no spaces before the first word and no spaces after the last word. The length of text is the number of letters and spaces in it. $$$w_i$$$ is the $$$i$$$-th word of text. All words consist only of lowercase Latin letters.Let's denote a segment of words $$$w[i..j]$$$ as a sequence of words $$$w_i, w_{i + 1}, \dots, w_j$$$. Two segments of words $$$w[i_1 .. j_1]$$$ and $$$w[i_2 .. j_2]$$$ are considered equal if $$$j_1 - i_1 = j_2 - i_2$$$, $$$j_1 \ge i_1$$$, $$$j_2 \ge i_2$$$, and for every $$$t \in [0, j_1 - i_1]$$$ $$$w_{i_1 + t} = w_{i_2 + t}$$$. For example, for the text ""to be or not to be"" the segments $$$w[1..2]$$$ and $$$w[5..6]$$$ are equal, they correspond to the words ""to be"".An abbreviation is a replacement of some segments of words with their first uppercase letters. In order to perform an abbreviation, you have to choose at least two non-intersecting equal segments of words, and replace each chosen segment with the string consisting of first letters of the words in the segment (written in uppercase). For example, for the text ""a ab a a b ab a a b c"" you can replace segments of words $$$w[2..4]$$$ and $$$w[6..8]$$$ with an abbreviation ""AAA"" and obtain the text ""a AAA b AAA b c"", or you can replace segments of words $$$w[2..5]$$$ and $$$w[6..9]$$$ with an abbreviation ""AAAB"" and obtain the text ""a AAAB AAAB c"".What is the minimum length of the text after at most one abbreviation?","n = int(raw_input())
arr = raw_input()
final = len(arr)
arr = arr.split()
lens = [0 for x in range(n)]
visit = [0 for x in range(n)]
cnt = 0
ans = 0
for i in range(n):
  if visit[i]:
    continue
  lens[cnt] = len(arr[i])
  for j in range(i+1,n):
    if arr[j]==arr[i]:
      arr[j] = cnt
      visit[j] = 1
  arr[i] = cnt
  cnt += 1
for i in range(n):
  for j in range(i,n):
    temp = arr[i:j+1]
    ind = 1
    found = 0
    len2 = j-i+1
    cur = 0
    kmp = [0 for x in range(len2)]
    while ind < len2:
      if temp[ind] == temp[cur]:
        cur += 1
        kmp[ind] = cur
        ind += 1
      else:
        if cur != 0:
          cur -= 1
        else:
          kmp[ind] = 0
          ind += 1
    ind = 0
    cur = 0
    while ind < n:
      if arr[ind] == temp[cur]:
        ind += 1
        cur += 1
      if cur == len2:
        found += 1
        cur = 0
      elif ind < n and temp[cur] != arr[ind]:
        if cur != 0:
          cur = kmp[cur-1]
        else:
          ind += 1
    if found>1:
      res = 0
      for k in temp:
        res += (lens[k]-1)*(found)
      res += (len(temp)-1)*(found)
      ans = max(ans,res)
print final-ans","['dp', 'hashing', 'strings']"
"Recently, Valery have come across an entirely new programming language. Most of all the language attracted him with template functions and procedures. Let us remind you that templates are tools of a language, designed to encode generic algorithms, without reference to some parameters (e.g., data types, buffer sizes, default values).Valery decided to examine template procedures in this language in more detail. The description of a template procedure consists of the procedure name and the list of its parameter types. The generic type T parameters can be used as parameters of template procedures.A procedure call consists of a procedure name and a list of variable parameters. Let's call a procedure suitable for this call if the following conditions are fulfilled:   its name equals to the name of the called procedure;  the number of its parameters equals to the number of parameters of the procedure call;  the types of variables in the procedure call match the corresponding types of its parameters. The variable type matches the type of a parameter if the parameter has a generic type T or the type of the variable and the parameter are the same. You are given a description of some set of template procedures. You are also given a list of variables used in the program, as well as direct procedure calls that use the described variables. For each call you need to count the number of procedures that are suitable for this call.","n=int(raw_input())
fs=[]
for i in xrange(n):
    s=raw_input().strip()
    s=s[4:].strip()
    name=s[:s.find('(')].strip()
    lst=s[s.find('(')+1:s.find(')')].split(',')
    lst=map(lambda a:a.strip(),lst)
    fs.append((name,lst))

m=int(raw_input())
tp={}
for i in xrange(m):
    a,b=raw_input().split()
    tp[b]=a

k=int(raw_input())
for i in range(k):
    s=raw_input().strip()
    name=s[:s.find('(')].strip()
    lst=s[s.find('(')+1:s.find(')')].split(',')
    lst=map(lambda a:tp[a.strip()],lst)
    ret=0
    for a,b in fs:
        if a!=name or len(b) != len(lst):
            continue
        for i in xrange(len(b)):
            if b[i]!='T' and b[i]!=lst[i]:
                break
        else:
            ret+=1
    print ret","['binary search', 'implementation', 'brute force', 'expression parsing']"
"Sonya decided to organize an exhibition of flowers. Since the girl likes only roses and lilies, she decided that only these two kinds of flowers should be in this exhibition.There are $$$n$$$ flowers in a row in the exhibition. Sonya can put either a rose or a lily in the $$$i$$$-th position. Thus each of $$$n$$$ positions should contain exactly one flower: a rose or a lily.She knows that exactly $$$m$$$ people will visit this exhibition. The $$$i$$$-th visitor will visit all flowers from $$$l_i$$$ to $$$r_i$$$ inclusive. The girl knows that each segment has its own beauty that is equal to the product of the number of roses and the number of lilies.Sonya wants her exhibition to be liked by a lot of people. That is why she wants to put the flowers in such way that the sum of beauties of all segments would be maximum possible.","n,m=map(int,input().split())
arr=[""01"" for _ in range(n//2)]
if n%2==1:
  arr.append(""0"")
print("""".join(arr))","['constructive algorithms', 'implementation', 'greedy', 'math']"
"This is an interactive problem. You have to use a flush operation right after printing each line. For example, in C++ you should use the function fflush(stdout), in Java — System.out.flush(), in Pascal — flush(output) and in Python — sys.stdout.flush().Mr. Chanek wants to buy a flamingo to accompany his chickens on his farm. Before going to the pet shop, Mr. Chanek stops at an animal festival to have fun. It turns out there is a carnival game with a flamingo as the prize.There are $$$N$$$ mysterious cages, which are numbered from $$$1$$$ to $$$N$$$. Cage $$$i$$$ has $$$A_i$$$ $$$(0 \le A_i \le 10^3)$$$ flamingoes inside $$$(1 \le i \le N)$$$. However, the game master keeps the number of flamingoes inside a secret. To win the flamingo, Mr. Chanek must guess the number of flamingoes in each cage.Coincidentally, Mr. Chanek has $$$N$$$ coins. Each coin can be used to ask once, what is the total number of flamingoes inside cages numbered $$$L$$$ to $$$R$$$ inclusive? With $$$L &lt; R$$$.","from sys import stdin, stdout


def ask(q):
    stdout.write(q + '\n')
    stdout.flush()
    return int(input())


def answer(q):
    stdout.write(q + '\n')
    stdout.flush()


n = int(input())
tem = [ask('? %d %d' % (i + 1, i + 2)) for i in range(n - 1)]
all = ask('? %d %d' % (1, 3))
out = [0] * n
out[2] = all - tem[0]
out[1] = tem[1] - out[2]
out[0] = tem[0] - out[1]
for i in range(3, n):
    out[i] = tem[i - 1] - out[i - 1]

answer('! %s' % (' '.join(map(str, out))))",['interactive']
"The Beroil corporation structure is hierarchical, that is it can be represented as a tree. Let's examine the presentation of this structure as follows:  employee ::= name. | name:employee1,employee2, ... ,employeek.  name ::= name of an employee That is, the description of each employee consists of his name, a colon (:), the descriptions of all his subordinates separated by commas, and, finally, a dot. If an employee has no subordinates, then the colon is not present in his description.For example, line MIKE:MAX.,ARTEM:MIKE..,DMITRY:DMITRY.,DMITRY... is the correct way of recording the structure of a corporation where the director MIKE has subordinates MAX, ARTEM and DMITRY. ARTEM has a subordinate whose name is MIKE, just as the name of his boss and two subordinates of DMITRY are called DMITRY, just like himself.In the Beroil corporation every employee can only correspond with his subordinates, at that the subordinates are not necessarily direct. Let's call an uncomfortable situation the situation when a person whose name is s writes a letter to another person whose name is also s. In the example given above are two such pairs: a pair involving MIKE, and two pairs for DMITRY (a pair for each of his subordinates).Your task is by the given structure of the corporation to find the number of uncomfortable pairs in it.","#!/usr/bin/env python3 

tree = input().strip()

def get_answer(tree, start_index = 0, prev = []):
  colon_index = tree.find(':', start_index)
  period_index = tree.find('.', start_index)
  name_end_index = colon_index if ((colon_index != -1) and (colon_index < period_index)) else period_index
  name = tree[start_index:name_end_index]
  answer = prev.count(name)
  if ((colon_index == -1) or (period_index < colon_index)):
    return (answer, period_index+1)
  else:
    # Recurse
    prev_names = prev + [name]
    next_start = colon_index
    while tree[next_start] != '.':
      (sub_answer, next_start) = get_answer(tree, next_start+1, prev_names)
      answer += sub_answer
    return (answer, next_start+1)

print(get_answer(tree)[0])","['data structures', 'implementation', 'expression parsing']"
"Developers often face with regular expression patterns. A pattern is usually defined as a string consisting of characters and metacharacters that sets the rules for your search. These patterns are most often used to check whether a particular string meets the certain rules.In this task, a pattern will be a string consisting of small English letters and question marks ('?'). The question mark in the pattern is a metacharacter that denotes an arbitrary small letter of the English alphabet. We will assume that a string matches the pattern if we can transform the string into the pattern by replacing the question marks by the appropriate characters. For example, string aba matches patterns: ???, ??a, a?a, aba.Programmers that work for the R1 company love puzzling each other (and themselves) with riddles. One of them is as follows: you are given n patterns of the same length, you need to find a pattern that contains as few question marks as possible, and intersects with each of the given patterns. Two patterns intersect if there is a string that matches both the first and the second pattern. Can you solve this riddle?","import sys
import itertools

WILDCARD = '?'
FILL = 'x'


def main():
    pattern_count = int(sys.stdin.readline())
    patterns = itertools.islice(sys.stdin, pattern_count)
    result = intersect_patterns(p.strip() for p in patterns)
    print(result)


def intersect_patterns(lines):
    return ''.join(_intersect_patterns(lines))


def _intersect_patterns(lines):
    first, *patterns = lines
    for position, char in enumerate(first):
        unique_chars = set(pattern[position] for pattern in patterns)
        unique_chars.add(char)
        unique_chars.discard(WILDCARD)
        if not unique_chars:
            yield FILL
        elif len(unique_chars) == 1:
            yield unique_chars.pop()
        else:
            yield WILDCARD


if __name__ == '__main__':
    main()","['implementation', 'strings']"
"A newspaper is published in Walrusland. Its heading is s1, it consists of lowercase Latin letters. Fangy the little walrus wants to buy several such newspapers, cut out their headings, glue them one to another in order to get one big string. After that walrus erase several letters from this string in order to get a new word s2. It is considered that when Fangy erases some letter, there's no whitespace formed instead of the letter. That is, the string remains unbroken and it still only consists of lowercase Latin letters.For example, the heading is ""abc"". If we take two such headings and glue them one to the other one, we get ""abcabc"". If we erase the letters on positions 1 and 5, we get a word ""bcac"".Which least number of newspaper headings s1 will Fangy need to glue them, erase several letters and get word s2?","from bisect import bisect_right as bl
s1, s2 = input(), input()

try:
  inv_map = {}
  for k, v in enumerate(s1):
    inv_map[v] = inv_map.get(v, [])
    inv_map[v].append(k)

  pointer = inv_map[s2[0]][0]
  count = 1
  for i in s2[1:]:
    pos = bl(inv_map[i],pointer)
    if len(inv_map[i])==pos:
      count+=1
      pointer = inv_map[i][0]
      continue
    pointer = inv_map[i][pos]
  print(count)
except:
  print(-1)","['greedy', 'strings']"
"Marina loves Sasha. But she keeps wondering whether Sasha loves her. Of course, the best way to know it is fortune telling. There are many ways of telling fortune, but Marina has picked the easiest one. She takes in her hand one or several camomiles and tears off the petals one by one. After each petal she pronounces alternatively ""Loves"" and ""Doesn't love"", at that Marina always starts with ""Loves"". There are n camomiles growing in the field, possessing the numbers of petals equal to a1, a2, ... an. Marina wants to pick a bouquet with the maximal possible total number of petals so that the result would still be ""Loves"". Help her do that; find the maximal number of petals possible in the bouquet.","# ///==========Libraries, Constants and Functions=============///
#mkraghav
import sys

inf = float(""inf"")
mod = 1000000007


def get_array(): return list(map(int, sys.stdin.readline().split()))


def get_ints(): return map(int, sys.stdin.readline().split())


def input(): return sys.stdin.readline()

def int1():return int(input())

import string

import math

from itertools import combinations
# ///==========MAIN=============///


def main():
    n=int(input())
    sum=0
    mn=105
    l=map(int,input().split())
    for x in l:
    	sum=sum+x
    	if x%2==1:
    		mn=min(mn,x)
    if sum%2==0:
    	if mn==105:
    		print(0)
    	else:
    		print(sum-mn)
    else:
    	print(sum)














if __name__ == ""__main__"":
    main()","['implementation', 'number theory']"
"Today at the lesson Vitya learned a very interesting function — mex. Mex of a sequence of numbers is the minimum non-negative number that is not present in the sequence as element. For example, mex([4, 33, 0, 1, 1, 5]) = 2 and mex([1, 2, 3]) = 0.Vitya quickly understood all tasks of the teacher, but can you do the same?You are given an array consisting of n non-negative integers, and m queries. Each query is characterized by one number x and consists of the following consecutive steps:  Perform the bitwise addition operation modulo 2 (xor) of each array element with the number x.  Find mex of the resulting array. Note that after each query the array changes.","from sys import stdin, stdout
from itertools import repeat
def main(bi=bin):
    n, m = map(int, stdin.readline().split())
    a = map(int, stdin.read().split(), repeat(10, n + m))
    N = 1 << 19
    t = [0] * (N + N)
    for x in set(a[:n]):
        t[x+N] = 1
    for x in xrange(N - 1, 0, -1):
        t[x] = t[x+x] & t[x+x+1]
    s = 0
    ans = []
    aa = ans.append
    for x in a[n:]:
        s ^= x
        r = 1
        for c in bi(s)[2:].zfill(19):
            r += r
            if c == ""1"":
                r += t[r^1] ^ 1
            else:
                r += t[r]
        aa((r ^ s) - N)
    stdout.write('\n'.join(map(str, ans)))
main()","['data structures', 'binary search']"
"Dasha logged into the system and began to solve problems. One of them is as follows:Given two sequences a and b of length n each you need to write a sequence c of length n, the i-th element of which is calculated as follows: ci = bi - ai.About sequences a and b we know that their elements are in the range from l to r. More formally, elements satisfy the following conditions: l ≤ ai ≤ r and l ≤ bi ≤ r. About sequence c we know that all its elements are distinct.  Dasha wrote a solution to that problem quickly, but checking her work on the standard test was not so easy. Due to an error in the test system only the sequence a and the compressed sequence of the sequence c were known from that test.Let's give the definition to a compressed sequence. A compressed sequence of sequence c of length n is a sequence p of length n, so that pi equals to the number of integers which are less than or equal to ci in the sequence c. For example, for the sequence c = [250, 200, 300, 100, 50] the compressed sequence will be p = [4, 3, 5, 2, 1]. Pay attention that in c all integers are distinct. Consequently, the compressed sequence contains all integers from 1 to n inclusively.Help Dasha to find any sequence b for which the calculated compressed sequence of sequence c is correct.","def solve():
  n, l, r = map(int, raw_input().split("" ""))
  a = map(int, raw_input().split("" ""))
  p = map(int, raw_input().split("" ""))
  zip_p_a = sorted(zip(p, a))
  c = []
  for pt, at in zip_p_a:
    if c:
      c_1 = c[-1]
      c_1 += 1
      c_1 = max(c_1, l - at)
    else:
      c_1 = l - at
    c.append(c_1)
  b = map(lambda y, x: x + y, [a[1] for a in zip_p_a], c)
  if filter(lambda x:x > r,b):
    return -1
  else:
    return "" "".join(str(b[p[i] - 1]) for i in xrange(n))
print solve()","['greedy', 'constructive algorithms', 'sortings', 'binary search', 'brute force']"
"The Fair Nut is going to travel to the Tree Country, in which there are $$$n$$$ cities. Most of the land of this country is covered by forest. Furthermore, the local road system forms a tree (connected graph without cycles). Nut wants to rent a car in the city $$$u$$$ and go by a simple path to city $$$v$$$. He hasn't determined the path, so it's time to do it. Note that chosen path can consist of only one vertex.A filling station is located in every city. Because of strange law, Nut can buy only $$$w_i$$$ liters of gasoline in the $$$i$$$-th city. We can assume, that he has infinite money. Each road has a length, and as soon as Nut drives through this road, the amount of gasoline decreases by length. Of course, Nut can't choose a path, which consists of roads, where he runs out of gasoline. He can buy gasoline in every visited city, even in the first and the last.He also wants to find the maximum amount of gasoline that he can have at the end of the path. Help him: count it.","from collections import deque
def recurse(x,d,w,parent,v,vb):
    best = 0
    bestt = 0
    ans = 0
    for t in d[x]:
        node = t[0]
        if node == parent:
            continue
        weight = int(w[node-1])-t[1]
        ans = max(ans,v[node])
        tot = weight+vb[node]
        if tot > best:
            bestt = best
            best = tot
        elif tot > bestt:
            bestt = tot
    ans = max(ans,best+bestt+int(w[x-1]))
    v[x] = ans
    vb[x] = best
    return (ans,best)
n = int(input())
w = input().split()
dic = {}
for i in range(1,n+1):
    dic[i] = []
for i in range(n-1):
    u,v,c = map(int,input().split())
    dic[u].append((v,c))
    dic[v].append((u,c))
dq = deque()
dq.append(1)
visit = set()
l = []
l.append((1,0))
while len(dq) > 0:
    cur = dq.pop()
    visit.add(cur)
    for t in dic[cur]:
        node = t[0]
        if node not in visit:
            l.append((node,cur))
            dq.append(node)
val = [0]*(n+1)
valb = [0]*(n+1)
for i in range(len(l)-1,-1,-1):
    recurse(l[i][0],dic,w,l[i][1],val,valb)
print(val[1])","['dp', 'trees']"
"One day Ms Swan bought an orange in a shop. The orange consisted of n·k segments, numbered with integers from 1 to n·k. There were k children waiting for Ms Swan at home. The children have recently learned about the orange and they decided to divide it between them. For that each child took a piece of paper and wrote the number of the segment that he would like to get: the i-th (1 ≤ i ≤ k) child wrote the number ai (1 ≤ ai ≤ n·k). All numbers ai accidentally turned out to be different.Now the children wonder, how to divide the orange so as to meet these conditions:  each child gets exactly n orange segments;  the i-th child gets the segment with number ai for sure;  no segment goes to two children simultaneously. Help the children, divide the orange and fulfill the requirements, described above.","##   int(input())
##  map(int ,input().split())
##  int(i) for i in input().split()
n , k = map(int ,input().split())
a = [int(i) for i in input().split()]
rs = [[i] for i in a]
pos = 0
for i in range(n*k):
    if i + 1 in a:
        continue
    rs[pos].append(i+1)
    pos+=1
    if pos >=k: pos = 0
print('\n'.join(' '.join(str(x) for x in l) for l in rs))",['implementation']
"Petya and Gena love playing table tennis. A single match is played according to the following rules: a match consists of multiple sets, each set consists of multiple serves. Each serve is won by one of the players, this player scores one point. As soon as one of the players scores t points, he wins the set; then the next set starts and scores of both players are being set to 0. As soon as one of the players wins the total of s sets, he wins the match and the match is over. Here s and t are some positive integer numbers.To spice it up, Petya and Gena choose new numbers s and t before every match. Besides, for the sake of history they keep a record of each match: that is, for each serve they write down the winner. Serve winners are recorded in the chronological order. In a record the set is over as soon as one of the players scores t points and the match is over as soon as one of the players wins s sets.Petya and Gena have found a record of an old match. Unfortunately, the sequence of serves in the record isn't divided into sets and numbers s and t for the given match are also lost. The players now wonder what values of s and t might be. Can you determine all the possible options?","n = int(input())

line = input().split()
lst = []
for num in line:
    lst.append(int(num))

cnt1 = [0]
cnt2 = [0]
c1 = 0
c2 = 0

for num in lst:
    if num == 1:
        c1 += 1
        cnt1.append(c2)
    else:
        c2 += 1
        cnt2.append(c1)

w = lst[n - 1]
ans = []
c1 = len(cnt1)
c2 = len(cnt2)
for t in range(n, 0, -1):
    s1 = 0
    s2 = 0
    i1 = 0
    i2 = 0
    l = 1
    while i1 < c1 and i2 < c2:
        if i1 + t >= c1 and i2 + t >= c2:
            if l == 1 and l == w and i1 + 1 == c1 and s1 > s2:
                ans.append((s1, t))
            elif l == 2 and l == w and i2 + 1 == c2 and s2 > s1:
                ans.append((s2, t))
            break
        elif i2 + t >= c2:
            s1 += 1
            l = 1
            i1 += t
            i2 = cnt1[i1]
        elif i1 + t >= c1:
            s2 += 1
            l = 2
            i2 += t
            i1 = cnt2[i2]
        else:
            if cnt1[i1 + t] < i2 + t:
                s1 += 1
                l = 1
                i1 += t
                i2 = cnt1[i1]
            else:
                s2 += 1
                l = 2
                i2 += t
                i1 = cnt2[i2]

ans.sort()

print(int(len(ans)))
for line in ans:
    print(str(line[0]) + ' ' + str(line[1]))",['binary search']
"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.Find the tree that will be the last to start burning. If there are several such trees, output any.","import sys
from array import array  # noqa: F401
from itertools import product
from collections import deque


def input():
    with open('input.txt') as fp:
        return fp.readlines()


def output(ans: str):
    with open('output.txt', mode='w') as fp:
        fp.write(ans)


'''
def input():
    return [line.decode('utf-8') for line in sys.stdin.buffer.readlines()]


def output(ans):
    print(ans)
'''


s = input()
n, m = map(int, s[0].split())
k = int(s[1])
a = [[0] * m for _ in range(n)]
dq = deque()
line = list(map(lambda x: int(x) - 1, s[2].split()))
for i in range(0, 2 * k, 2):
    a[line[i]][line[i + 1]] = 1
    dq.append((line[i], line[i + 1]))


x, y = -1, -1
while dq:
    x, y = dq.popleft()
    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:
            a[tx][ty] = 1
            dq.append((tx, ty))

output(f'{x+1} {y+1}')","['dfs and similar', 'brute force', 'shortest paths']"
"There are n employees working in company ""X"" (let's number them from 1 to n for convenience). Initially the employees didn't have any relationships among each other. On each of m next days one of the following events took place:  either employee y became the boss of employee x (at that, employee x didn't have a boss before);  or employee x gets a packet of documents and signs them; then he gives the packet to his boss. The boss signs the documents and gives them to his boss and so on (the last person to sign the documents sends them to the archive);  or comes a request of type ""determine whether employee x signs certain documents"". Your task is to write a program that will, given the events, answer the queries of the described type. At that, it is guaranteed that throughout the whole working time the company didn't have cyclic dependencies.","n, m = map(int, input().split())
ev = [tuple(map(int, input().split())) for _ in range(m)]

g = [[] for _ in range(n + 1)]
qry = [[] for _ in range(m + 1)]
roots = set(range(1, n + 1))
qcnt = 0
for e in ev:
	if e[0] == 1:
		g[e[2]].append(e[1])
		roots.remove(e[1])
	elif e[0] == 3:
		qry[e[2]].append((qcnt, e[1]))
		qcnt += 1

tin, tout = [0] * (n + 1), [0] * (n + 1)
st = [(u, 0) for u in roots]
time = 0
while st:
	u, w = st.pop()
	if w:
		tout[u] = time
		continue
	time += 1
	tin[u] = time
	st.append((u, 1))
	for v in g[u]:
		st.append((v, 0))

p = list(range(n + 1))
def find(x):
	if x != p[x]:
		p[x] = find(p[x])
	return p[x]

pcnt = 0
ans = [None] * qcnt
for e in ev:
	if e[0] == 1:
		p[find(e[1])] = find(e[2])
	elif e[0] == 2:
		pcnt += 1
		for qid, x in qry[pcnt]:
			ans[qid] = 'YES' if find(e[1]) == find(x) and tin[x] <= tin[e[1]] <= tout[x] else 'NO'

print(*ans, sep='\n')","['dsu', 'dfs and similar', 'trees', 'graphs']"
"This is an easier version of the next problem. In this version, $$$q = 0$$$.A sequence of integers is called nice if its elements are arranged in blocks like in $$$[3, 3, 3, 4, 1, 1]$$$. Formally, if two elements are equal, everything in between must also be equal.Let's define difficulty of a sequence as a minimum possible number of elements to change to get a nice sequence. However, if you change at least one element of value $$$x$$$ to value $$$y$$$, you must also change all other elements of value $$$x$$$ into $$$y$$$ as well. For example, for $$$[3, 3, 1, 3, 2, 1, 2]$$$ it isn't allowed to change first $$$1$$$ to $$$3$$$ and second $$$1$$$ to $$$2$$$. You need to leave $$$1$$$'s untouched or change them to the same value.You are given a sequence of integers $$$a_1, a_2, \ldots, a_n$$$ and $$$q$$$ updates.Each update is of form ""$$$i$$$ $$$x$$$"" — change $$$a_i$$$ to $$$x$$$. Updates are not independent (the change stays for the future).Print the difficulty of the initial sequence and of the sequence after every update.","MAXN = 200100

n, q = map(int, input().split())
a = list(map(int, input().split()))
lpos = [-1]*MAXN
for i in range(n):
	lpos[a[i]] = i
need = 0
i = 0
while i < n:
	start = i
	r = lpos[a[i]]
	j = i + 1
	while j < r:
		r = max(r, lpos[a[j]])
		j += 1
	cnts = {}
	while i <= r:
		if a[i] in cnts:
			cnts[a[i]] += 1
		else:
			cnts[a[i]] = 1
		i += 1
	best = 0
	for k, v in cnts.items():
		best = max(best, v)
	need += i - start - best

print(need)","['greedy', 'two pointers', 'dsu', 'implementation', 'data structures']"
"Petya loves lucky numbers. Everybody knows that positive integers are lucky if their decimal representation doesn't contain digits other than 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Lucky number is super lucky if it's decimal representation contains equal amount of digits 4 and 7. For example, numbers 47, 7744, 474477 are super lucky and 4, 744, 467 are not.One day Petya came across a positive integer n. Help him to find the least super lucky number which is not less than n.","b=input()
a=[int(i) for i in b]
l=len(a)
flag=0
s=0
f=0
if l%2==1:
    flag=1

else:
    for i in range(l):
        if a[i]>7:
            flag=1
            if(s==l//2 or s==i+1):
                break
            for j in range(i,-1,-1):
                if a[j]==4:
                    a[j]=7
                    f-=1
                    s+=1
                    flag=0
                    i=j
                    break
            break

        elif a[i]==7:
            s+=1

        elif a[i]>4:
            a[i]=7
            s+=1
            if s<=l//2:
                break

        elif a[i]==4:
            f+=1

        else:
            a[i]=4
            f+=1
            if f<=l//2:
                break

        if s>l//2:
            flag=1
            for j in range(i-1,-1,-1):
                f-=1
                if a[j]==7:
                    f+=1
                    if a[j-1]==4:
                        a[j-1]=7
                        f-=1
                        s+=1
                        flag=0
                        i=j-1
                        break
                    s-=1
            break

        elif f>l//2:
            a[i]=7
            s+=1
            f-=1
            break


if flag:
    for i in range(l//2+1):
        print(4,end='')
    for i in range(l//2+1):
        print(7,end='')

else:
    for j in range(i+1):
        print(a[j],end='')
    for j in range(i+1,l):
        if f<l//2:
            print(4,end='')
            f+=1
        else:
            print(7,end='')","['dp', 'greedy']"
"Now Serval is a junior high school student in Japari Middle School, and he is still thrilled on math as before. As a talented boy in mathematics, he likes to play with numbers. This time, he wants to play with numbers on a rooted tree.A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a node $$$v$$$ is the last different from $$$v$$$ vertex on the path from the root to the vertex $$$v$$$. Children of vertex $$$v$$$ are all nodes for which $$$v$$$ is the parent. A vertex is a leaf if it has no children.The rooted tree Serval owns has $$$n$$$ nodes, node $$$1$$$ is the root. Serval will write some numbers into all nodes of the tree. However, there are some restrictions. Each of the nodes except leaves has an operation $$$\max$$$ or $$$\min$$$ written in it, indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons, respectively. Assume that there are $$$k$$$ leaves in the tree. Serval wants to put integers $$$1, 2, \ldots, k$$$ to the $$$k$$$ leaves (each number should be used exactly once). He loves large numbers, so he wants to maximize the number in the root. As his best friend, can you help him?","import sys

n = int(input())
minmax = list(map(int, input().split()))
childs = [[] for i in range(n)]

for idx, father in enumerate(list(map(int,input().split()))):
    childs[father-1].append(idx+1)

stack = []
stack.append(0)

ans = [None for ele in range(n)]
vis = [False for ele in range(n)]

while len(stack):
    index = stack[-1]
    if not vis[index]:
        vis[index] = True
        if len(childs[index]) == 0:
            ans[index] = (0,1)
            stack.pop()
        else:
            for child in childs[index]:
                stack.append(child)
    else:
        stack.pop()
        res = [ans[child] for child in childs[index]]
        total = sum([ele[1] for ele in res])
        if minmax[index] == 1:
            ans[index] = min([ele[0] for ele in res]), total
        else:
            bigger_than = sum([ele[1] - ele[0] - 1 for ele in res])    
            ans[index] = total - bigger_than - 1, total

print(ans[0][1] - ans[0][0])","['dp', 'greedy', 'binary search', 'dfs and similar', 'trees']"
"Orac is studying number theory, and he is interested in the properties of divisors.For two positive integers $$$a$$$ and $$$b$$$, $$$a$$$ is a divisor of $$$b$$$ if and only if there exists an integer $$$c$$$, such that $$$a\cdot c=b$$$.For $$$n \ge 2$$$, we will denote as $$$f(n)$$$ the smallest positive divisor of $$$n$$$, except $$$1$$$.For example, $$$f(7)=7,f(10)=2,f(35)=5$$$.For the fixed integer $$$n$$$, Orac decided to add $$$f(n)$$$ to $$$n$$$. For example, if he had an integer $$$n=5$$$, the new value of $$$n$$$ will be equal to $$$10$$$. And if he had an integer $$$n=6$$$, $$$n$$$ will be changed to $$$8$$$.Orac loved it so much, so he decided to repeat this operation several times.Now, for two positive integers $$$n$$$ and $$$k$$$, Orac asked you to add $$$f(n)$$$ to $$$n$$$ exactly $$$k$$$ times (note that $$$n$$$ will change after each operation, so $$$f(n)$$$ may change too) and tell him the final value of $$$n$$$.For example, if Orac gives you $$$n=5$$$ and $$$k=2$$$, at first you should add $$$f(5)=5$$$ to $$$n=5$$$, so your new value of $$$n$$$ will be equal to $$$n=10$$$, after that, you should add $$$f(10)=2$$$ to $$$10$$$, so your new (and the final!) value of $$$n$$$ will be equal to $$$12$$$.Orac may ask you these queries many times.","def f(n):
	for i in range(3,n+1,2):
		if n%i == 0:
			return i
	return n


for t in range(int(input())):
	n, k = map(int, input().split())
	if n%2 == 0:
		n += 2*k
	else:
		n += f(n)
		n += 2*(k-1)
	print(n)",['math']
"One night, having had a hard day at work, Petya saw a nightmare. There was a binary search tree in the dream. But it was not the actual tree that scared Petya. The horrifying thing was that Petya couldn't search for elements in this tree. Petya tried many times to choose key and look for it in the tree, and each time he arrived at a wrong place. Petya has been racking his brains for long, choosing keys many times, but the result was no better. But the moment before Petya would start to despair, he had an epiphany: every time he was looking for keys, the tree didn't have the key, and occured exactly one mistake. ""That's not a problem!"", thought Petya. ""Why not count the expectation value of an element, which is found when I search for the key"". The moment he was about to do just that, however, Petya suddenly woke up.Thus, you are given a binary search tree, that is a tree containing some number written in the node. This number is called the node key. The number of children of every node of the tree is equal either to 0 or to 2. The nodes that have 0 children are called leaves and the nodes that have 2 children, are called inner. An inner node has the left child, that is the child whose key is less than the current node's key, and the right child, whose key is more than the current node's key. Also, a key of any node is strictly larger than all the keys of the left subtree of the node and strictly smaller than all the keys of the right subtree of the node.Also you are given a set of search keys, all of which are distinct and differ from the node keys contained in the tree. For each key from the set its search in the tree is realised. The search is arranged like this: initially we are located in the tree root, if the key of the current node is larger that our search key, then we move to the left child of the node, otherwise we go to the right child of the node and the process is repeated. As it is guaranteed that the search key is not contained in the tree, the search will always finish in some leaf. The key lying in the leaf is declared the search result.It is known for sure that during the search we make a mistake in comparing exactly once, that is we go the wrong way, but we won't make any mistakes later. All possible mistakes are equiprobable, that is we should consider all such searches where exactly one mistake occurs. Your task is to find the expectation (the average value) of the search result for every search key, considering that exactly one mistake occurs in the search. That is, for a set of paths containing exactly one mistake in the given key search, you should count the average value of keys containing in the leaves of those paths.","from bisect import bisect_left as bl
n = input()
n+=1
k = [0]*n
p = [0]*n
ma = [0]*n
mi = [0]*n
l = [0]*n
r = [0]*n
for i in xrange(1,n):
    pp,kk = map(int,raw_input().split())
    p[i] = pp
    ma[i] = mi[i] = k[i] = kk
kn = input()
for i in xrange(1,n):
    if p[i]<0: continue    
    if k[p[i]]<k[i]: r[p[i]]=i
    else: l[p[i]]=i
q = [i for i in xrange(1,n) if not l[i]]
v = [False]*n
for x in q: v[x] = True
for x in q:
    if p[x]<0: continue
    if v[p[x]]: continue
    if l[p[x]] and (not v[l[p[x]]] or not v[r[p[x]]]): continue
    v[p[x]] = True
    q.append(p[x])
for i in q:
    if not l[i]: continue
    ma[i]=ma[r[i]]
    mi[i]=mi[l[i]]
    #ma[p[i]]=max(ma[p[i]],ma[i])
    #mi[p[i]]=min(mi[p[i]],mi[i])
en = [0]*n
ex = [0.]*n
for i in reversed(q):
    if not l[i]: continue
    en[r[i]]=en[l[i]]=en[i]+1
    ex[l[i]]=ex[i]+mi[r[i]]
    ex[r[i]]=ex[i]+ma[l[i]]
k[0]=-1
kp = [(v,i) for i,v in enumerate(k)]
kp.sort()
kpv = [x for x,y in kp]
kpi = [y for x,y in kp]
for _ in xrange(kn):
    x = input()
    p = bl(kpv,x)-1
    e = kpi[p]
    if p<n-1:
        if not e or l[e]:
            e = kpi[p+1]
    if l[e]: raise NotImplemented
    print ""%.10f""%(1.*ex[e]/en[e])","['probabilities', 'sortings', 'binary search', 'dfs and similar', 'trees']"
"The Physical education teacher at SESC is a sort of mathematician too. His most favorite topic in mathematics is progressions. That is why the teacher wants the students lined up in non-decreasing height form an arithmetic progression.To achieve the goal, the gym teacher ordered a lot of magical buns from the dining room. The magic buns come in two types: when a student eats one magic bun of the first type, his height increases by one, when the student eats one magical bun of the second type, his height decreases by one. The physical education teacher, as expected, cares about the health of his students, so he does not want them to eat a lot of buns. More precisely, he wants the maximum number of buns eaten by some student to be minimum.Help the teacher, get the maximum number of buns that some pupils will have to eat to achieve the goal of the teacher. Also, get one of the possible ways for achieving the objective, namely, the height of the lowest student in the end and the step of the resulting progression.","q = 10001
n, a = int(input()), list(map(int, input().split()))
a.sort()
for i in range(40000 // (n - 1) + 1):
    b = [a[j] - j * i for j in range(n)]
    u, v = max(b), min(b)
    p = (u - v + 1) // 2
    if p < q: q, s, d = p, v + p, i
print(q)
print(s, d)","['implementation', 'brute force', 'math']"
"You are given a string $$$s$$$. Each character is either 0 or 1.You want all 1's in the string to form a contiguous subsegment. For example, if the string is 0, 1, 00111 or 01111100, then all 1's form a contiguous subsegment, and if the string is 0101, 100001 or 11111111111101, then this condition is not met.You may erase some (possibly none) 0's from the string. What is the minimum number of 0's that you have to erase?","for _ in range(int(input())):
    s = str(input())
    n = len(s)
    print(s.strip('0').count('0'))","['implementation', 'strings']"
"The Kingdom of Kremland is a tree (a connected undirected graph without cycles) consisting of $$$n$$$ vertices. Each vertex $$$i$$$ has its own value $$$a_i$$$. All vertices are connected in series by edges. Formally, for every $$$1 \leq i &lt; n$$$ there is an edge between the vertices of $$$i$$$ and $$$i+1$$$.Denote the function $$$f(l, r)$$$, which takes two integers $$$l$$$ and $$$r$$$ ($$$l \leq r$$$):    We leave in the tree only vertices whose values ​​range from $$$l$$$ to $$$r$$$.    The value of the function will be the number of connected components in the new graph. Your task is to calculate the following sum: $$$$$$\sum_{l=1}^{n} \sum_{r=l}^{n} f(l, r) $$$$$$","# 計算該點 左邊不包但包自己的區間數
n = int(input())
nums = list(map(int,input().split()))

# count the first one
ans = nums[0] * (n - nums[0] + 1)

for i in range(1,n):
    if nums[i] > nums[i-1]:
        ans += (nums[i] - nums[i-1]) * (n - nums[i] + 1)
    elif nums[i] < nums[i-1]:
        ans += (nums[i-1] - nums[i]) * nums[i]
print(ans)","['dp', 'combinatorics', 'data structures', 'math']"
"One day, ZS the Coder wrote down an array of integers a with elements a1,  a2,  ...,  an.A subarray of the array a is a sequence al,  al  +  1,  ...,  ar for some integers (l,  r) such that 1  ≤  l  ≤  r  ≤  n. ZS the Coder thinks that a subarray of a is beautiful if the bitwise xor of all the elements in the subarray is at least k.Help ZS the Coder find the number of beautiful subarrays of a!","import sys
range = xrange
input = raw_input

L = [-1, -1]
count = [0,0]
def check(i):
    if L[i] == -1:
        L[i] = len(L)
        L.append(-1)
        L.append(-1)
        count.append(0)
        count.append(0)

def add(x, i = 0, bits = 30):
    count[i] += 1
    for bit in reversed(range(bits)):
        check(i)
        i = L[i] ^ (x >> bit & 1)
        count[i] += 1

# count (y xor x) > k
def get_count(x, k, i = 0, bits = 30):
    ret = 0
    for bit in reversed(range(bits)):
        i = L[i] ^ (x >> bit & 1) ^ (k >> bit & 1)
        if i < 0:
            return ret
        if k >> bit & 1 == 0:
           ret += count[i ^ 1] 
    return ret

inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

n = inp[ii]; ii += 1
k = inp[ii] - 1; ii += 1

A = inp[ii:ii + n]; ii += n

xor = [0]
for a in A:
    xor.append(xor[-1] ^ a)
xor.sort()

ans = 0
for x in xor:
    add(x)
    ans += get_count(x, k)
print ans","['data structures', 'divide and conquer', 'trees', 'strings']"
"Alice became interested in periods of integer numbers. We say positive $$$X$$$ integer number is periodic with length $$$L$$$ if there exists positive integer number $$$P$$$ with $$$L$$$ digits such that $$$X$$$ can be written as $$$PPPP…P$$$. For example:$$$X = 123123123$$$ is periodic number with length $$$L = 3$$$ and $$$L = 9$$$$$$X = 42424242$$$ is periodic number with length $$$L = 2,L = 4$$$ and $$$L = 8$$$$$$X = 12345$$$ is periodic number with length $$$L = 5$$$For given positive period length $$$L$$$ and positive integer number $$$A$$$, Alice wants to find smallest integer number $$$X$$$ strictly greater than $$$A$$$ that is periodic with length L.","def revive(l):
    res = pow(10 , l-1)
    return str(res)



l = int(input())
s = input()
val = 0
if len(s) % l == 0:
    ans = s[:l]
    if ans*(len(s)//l) > s:
        print(ans*(len(s)//l))
        exit()
    elif ans == ""9""*l:
        ans = revive(l)
        val = l
    else:
        ans = str(int(ans) + 1)
else:
    ans = revive(l)
print(ans*((len(s) + l-1 + val)//l))","['implementation', 'strings']"
"Dreamoon has a string s and a pattern string p. He first removes exactly x characters from s obtaining string s' as a result. Then he calculates  that is defined as the maximal number of non-overlapping substrings equal to p that can be found in s'. He wants to make this number as big as possible.More formally, let's define  as maximum value of  over all s' that can be obtained by removing exactly x characters from s. Dreamoon wants to know  for all x from 0 to |s| where |s| denotes the length of string s.","s, p = input(), input()
n, m = len(s) + 1, len(p)
d = [[0] * n for t in range(n)]
for x in range(1, n):
    i, j = x, m
    while i and j:
        j -= s[i - 1] == p[j - 1]
        i -= 1
    if not j:
        for y in range(i + 1): d[x][y + x - i - m] = d[i][y] + 1
    for y in range(x): d[x][y] = max(d[x][y], d[x - 1][y])
print(*d[-1])","['dp', 'strings']"
"Student Vladislav came to his programming exam completely unprepared as usual. He got a question about some strange algorithm on a graph — something that will definitely never be useful in real life. He asked a girl sitting next to him to lend him some cheat papers for this questions and found there the following definition:The minimum spanning tree T of graph G is such a tree that it contains all the vertices of the original graph G, and the sum of the weights of its edges is the minimum possible among all such trees.Vladislav drew a graph with n vertices and m edges containing no loops and multiple edges. He found one of its minimum spanning trees and then wrote for each edge its weight and whether it is included in the found tree or not. Unfortunately, the piece of paper where the graph was painted is gone and the teacher is getting very angry and demands to see the original graph. Help Vladislav come up with a graph so that the information about the minimum spanning tree remains correct.","import sys
from operator import itemgetter

lines = sys.stdin.readlines()
n, m = map(int, lines[0].split(' '))

def build_edge(i, row):
	parts = row.split(' ')
	return (int(parts[0]), int(parts[1]), i)

def edge_key(a):
	return (a[0], -a[1])

edges = [build_edge(i, row) for i, row in enumerate(lines[1:])]
edges = sorted(edges, key=edge_key)
x, y = 1, 2
vertex = 1
color = [0 for x in range(n)]
color[0] = 1 # root of tree
ans = []
for weight, used, index in edges:
	 if used == 1:
	 	color[vertex] = 1
	 	ans.append((0, vertex, index))
	 	vertex += 1
	 else:
	 	if color[x] != 1 or color[y] != 1:
	 		print(-1)
	 		exit(0)
	 	ans.append((x,y,index))
	 	x += 1
	 	if x == y:
	 		x = 1
	 		y += 1
ans = sorted(ans, key=itemgetter(2))
for edge in ans:
	print(""%s %s"" % (edge[0]+1, edge[1]+1))",['graphs']
"During the ""Russian Code Cup"" programming competition, the testing system stores all sent solutions for each participant. We know that many participants use random numbers in their programs and are often sent several solutions with the same source code to check.Each participant is identified by some unique positive integer k, and each sent solution A is characterized by two numbers: x — the number of different solutions that are sent before the first solution identical to A, and k — the number of the participant, who is the author of the solution. Consequently, all identical solutions have the same x.It is known that the data in the testing system are stored in the chronological order, that is, if the testing system has a solution with number x (x &gt; 0) of the participant with number k, then the testing system has a solution with number x - 1 of the same participant stored somewhere before.During the competition the checking system crashed, but then the data of the submissions of all participants have been restored. Now the jury wants to verify that the recovered data is in chronological order. Help the jury to do so.","n=input()
v=[-1]*100100
for _ in range(n):
  a,b=map(int,raw_input().split())
  if v[b]<a-1:
    print 'NO'
    exit()
  v[b]=max(a,v[b])
print 'YES'",['implementation']
"Hyakugoku has just retired from being the resident deity of the South Black Snail Temple in order to pursue her dream of becoming a cartoonist. She spent six months in that temple just playing ""Cat's Cradle"" so now she wants to try a different game — ""Snakes and Ladders"". Unfortunately, she already killed all the snakes, so there are only ladders left now. The game is played on a $$$10 \times 10$$$ board as follows:  At the beginning of the game, the player is at the bottom left square.  The objective of the game is for the player to reach the Goal (the top left square) by following the path and climbing vertical ladders. Once the player reaches the Goal, the game ends.  The path is as follows: if a square is not the end of its row, it leads to the square next to it along the direction of its row; if a square is the end of its row, it leads to the square above it. The direction of a row is determined as follows: the direction of the bottom row is to the right; the direction of any other row is opposite the direction of the row below it. See Notes section for visualization of path.  During each turn, the player rolls a standard six-sided dice. Suppose that the number shown on the dice is $$$r$$$. If the Goal is less than $$$r$$$ squares away on the path, the player doesn't move (but the turn is performed). Otherwise, the player advances exactly $$$r$$$ squares along the path and then stops. If the player stops on a square with the bottom of a ladder, the player chooses whether or not to climb up that ladder. If she chooses not to climb, then she stays in that square for the beginning of the next turn.  Some squares have a ladder in them. Ladders are only placed vertically — each one leads to the same square of some of the upper rows. In order for the player to climb up a ladder, after rolling the dice, she must stop at the square containing the bottom of the ladder. After using the ladder, the player will end up in the square containing the top of the ladder. She cannot leave the ladder in the middle of climbing. And if the square containing the top of the ladder also contains the bottom of another ladder, she is not allowed to use that second ladder.  The numbers on the faces of the dice are 1, 2, 3, 4, 5, and 6, with each number having the same probability of being shown. Please note that:      it is possible for ladders to overlap, but the player cannot switch to the other ladder while in the middle of climbing the first one;     it is possible for ladders to go straight to the top row, but not any higher;     it is possible for two ladders to lead to the same tile;     it is possible for a ladder to lead to a tile that also has a ladder, but the player will not be able to use that second ladder if she uses the first one;     the player can only climb up ladders, not climb down. Hyakugoku wants to finish the game as soon as possible. Thus, on each turn she chooses whether to climb the ladder or not optimally. Help her to determine the minimum expected number of turns the game will take.","def pos(x, y):
    if y & 1:
        return y * w + w - 1 - x
    return y * w + x


CUBE = 6
h, w = 10, 10
n = h * w

grid = []
for y in range(h):
    line = list(map(int, input().split()))
    grid.append(line)
grid.reverse()
# print(*grid, sep='\n')

to = [0] * n
for y in range(h):
    for x in range(w):
        y1 = y + grid[y][x]
        if y1 != y:
#            print(f""({x}, {y}) --> ({x}, {y1})"", pos(x, y), pos(x, y1))
            to[pos(x, y)] = pos(x, y + grid[y][x])
# print(to)

exp = [0] * (n + CUBE)
for i in range(n - 2, -1, -1):
    exp[i] = 1
    for j in range(1, CUBE + 1):
        exp_to = exp[i + j] / CUBE
        if i + j < n and to[i + j]:
            exp_to = min(exp_to, exp[to[i + j]] / CUBE)
        exp[i] += exp_to
    if i + CUBE >= n:
        exp[i] = CUBE * exp[i] / (n - 1 - i)
# print(*[f""{x:.1f}"" for x in exp[:n]])
print(f""{exp[0]:.16f}"")","['dp', 'probabilities', 'shortest paths']"
"This is an interactive problem. Don't forget to flush output after printing queries using cout.flush() or fflush(stdout) in C++ or similar functions in other programming languages.There are $$$n$$$ gift boxes in a row, numbered from $$$1$$$ to $$$n$$$ from left to right. It's known that exactly $$$k$$$ of them contain valuable gifts — other boxes contain just lucky stones. All boxes look the same and differ only in weight. All boxes with stones have the same weight and are strictly heavier than boxes with valuable items. But valuable gifts may be different, so the boxes with valuable items may have different weights.You can ask no more than $$$50$$$ queries (printing an answer doesn't count). By each query you can compare total weights of two non-intersecting subsets of boxes $$$a_1, a_2, \dots, a_{k_a}$$$ and $$$b_1, b_2, \dots, b_{k_b}$$$. In return you'll get one of four results:  FIRST, if subset $$$a_1, a_2, \dots, a_{k_a}$$$ is strictly heavier;  SECOND, if subset $$$b_1, b_2, \dots, b_{k_b}$$$ is strictly heavier;  EQUAL, if subsets have equal total weights;  WASTED, if the query is incorrect or the limit of queries is exceeded. Using such queries (or, maybe, intuition) find the box with a valuable gift with the minimum index.","from random import randrange

def ask(a0,b0,L):
    print(""?"",L,L,flush=True)
    aa=[i for i in range(a0,a0+L)]
    print(*aa,flush=True)
    aa=[i for i in range(b0,b0+L)]
    print(*aa,flush=True)
    return input()

def main():
    for _ in range(int(input())):
        n,k=map(int,input().split())
        isfirst=False
        for _ in range(30):
            if ask(1,randrange(2,n+1),1)==""SECOND"":
                isfirst=True
        if isfirst:
            print(""! 1"",flush=True)
            continue

        ln=1
        while 1:
            ret=ask(1,1+ln,ln)
            if ret==""FIRST"":
                l,r=1+ln,1+ln*2
                break
            if ln*4>n:
                l,r=1+ln*2,n+1
                break
            ln*=2

        while l+1<r:
            m=(l+r)//2
            if ask(1,l,m-l)==""EQUAL"":l=m
            else:r=m

        print(""!"",l,flush=True)

main()","['binary search', 'probabilities', 'interactive']"
"An arithmetic progression is such a non-empty sequence of numbers where the difference between any two successive numbers is constant. This constant number is called common difference. For example, the sequence 3, 7, 11, 15 is an arithmetic progression. The definition implies that any sequences whose length equals 1 or 2 are arithmetic and all sequences whose length equals 0 are non-arithmetic.You are given a sequence of different integers a1, a2, ..., an. You should either split it into two arithmetic progressions or find out that the operation is impossible to perform. Splitting assigns each member of the given sequence to one of two progressions, but the relative order of numbers does not change. Splitting is an inverse operation to merging.","def sol(prog1, rest, nums):
  start = len(prog1) + len(rest)
  diff1 = prog1[1] - prog1[0]

  prog2 = []

  for x in xrange(start, len(nums)):
    val = nums[x]
    next1 = prog1[-1] + diff1
    if val == next1:
      prog1.append(val)
    else:
      rest.append(val)

  if len(rest) <= 2:
    return prog1, rest

  #print ""ASD"", prog1, rest
  prog1_set = set(prog1)

  diff2 = rest[1] - rest[0]
  prog2 = [rest[0], rest[1]]
  for x in xrange(2, len(rest)):
    next2 = prog2[-1] + diff2
    val = rest[x]

    #print next2, val
    while next2 != val:
      if next2 in prog1_set:
        prog1_set.remove(next2)
      else:
        return False
      prog2.append(next2)
      next2 = prog2[-1] + diff2

    prog2.append(val)

  prog1 = list(sorted(prog1_set))
  diff1 = abs(diff1)
  prog2 = list(sorted(prog2))
  diff2 = abs(diff2)

  for x in xrange(1, len(prog1)):
    if prog1[x] - prog1[x-1] != diff1:
      return False
  for x in xrange(1, len(prog2)):
    if prog2[x] - prog2[x-1] != diff2:
      return False

  return prog1, prog2

def d1(nums):
  if len(nums) == 2:
    return [nums[0]], [nums[1]]

  a, b, c = nums[0], nums[1], nums[2]
  # print a, b, c, nums[3:]
  # a, b
  res = sol([a, b], [], nums)
  if res != False:
    return res

  # a, c
  res = sol([a, c], [b], nums)
  if res != False:
    return res

  # b, c
  res = sol([b, c], [a], nums)
  if res != False:
    return res

  return False

def d(nums):
  res = d1(nums)

  if res is False:
    res = d1(list(reversed(nums)))

  if res is False:
    return ""No solution""

  if len(res[0]) == 0:
    res = [res[1][0]], res[1][1:]
  if len(res[1]) == 0:
    res = res[0][1:], [res[0][0]]

  if len(res[0]) >= 2:
    if nums.index(res[0][0]) > nums.index(res[0][1]):
      res = list(reversed(res[0])), res[1]
  if len(res[1]) >= 2:
    if nums.index(res[1][0]) > nums.index(res[1][1]):
      res = res[0], list(reversed(res[1]))

  return res

'''
vals = [4, 1, 2, 7, 3, 10]
answer = d(vals)
print vals
print answer
vals = [1, 2, 3, -2, -7]
answer = d(vals)
print vals
print answer
vals = [-10, -5, 0, 1, 2, 3, 4, 5, 6,]
answer = d(vals)
print vals
print answer
vals = [0, 3, 4, 5, 6, 12, 18]
answer = d(vals)
print vals
print answer
'''

unused = raw_input()
answer = d([int(x) for x in raw_input().split("" "")])

if type(answer) == str:
  print answer
else:
  print "" "".join(str(_) for _ in answer[0])
  print "" "".join(str(_) for _ in answer[1])","['constructive algorithms', 'greedy']"
"This is an interactive problem.To prevent the mischievous rabbits from freely roaming around the zoo, Zookeeper has set up a special lock for the rabbit enclosure. This lock is called the Rotary Laser Lock.  The lock consists of $$$n$$$ concentric rings numbered from $$$0$$$ to $$$n-1$$$. The innermost ring is ring $$$0$$$ and the outermost ring is ring $$$n-1$$$. All rings are split equally into $$$nm$$$ sections each. Each of those rings contains a single metal arc that covers exactly $$$m$$$ contiguous sections. At the center of the ring is a core and surrounding the entire lock are $$$nm$$$ receivers aligned to the $$$nm$$$ sections. The core has $$$nm$$$ lasers that shine outward from the center, one for each section. The lasers can be blocked by any of the arcs. A display on the outside of the lock shows how many lasers hit the outer receivers.   In the example above, there are $$$n=3$$$ rings, each covering $$$m=4$$$ sections. The arcs are colored in green (ring $$$0$$$), purple (ring $$$1$$$), and blue (ring $$$2$$$) while the lasers beams are shown in red. There are $$$nm=12$$$ sections and $$$3$$$ of the lasers are not blocked by any arc, thus the display will show $$$3$$$ in this case. Wabbit is trying to open the lock to free the rabbits, but the lock is completely opaque, and he cannot see where any of the arcs are. Given the relative positions of the arcs, Wabbit can open the lock on his own.  To be precise, Wabbit needs $$$n-1$$$ integers $$$p_1,p_2,\ldots,p_{n-1}$$$ satisfying $$$0 \leq p_i &lt; nm$$$ such that for each $$$i$$$ $$$(1 \leq i &lt; n)$$$, Wabbit can rotate ring $$$0$$$ clockwise exactly $$$p_i$$$ times such that the sections that ring $$$0$$$ covers perfectly aligns with the sections that ring $$$i$$$ covers. In the example above, the relative positions are $$$p_1 = 1$$$ and $$$p_2 = 7$$$. To operate the lock, he can pick any of the $$$n$$$ rings and rotate them by $$$1$$$ section either clockwise or anti-clockwise. You will see the number on the display after every rotation.Because his paws are small, Wabbit has asked you to help him to find the relative positions of the arcs after all of your rotations are completed. You may perform up to $$$15000$$$ rotations before Wabbit gets impatient.","import sys;Z=sys.stdin.readline
def P(d=1,x=0):
    print('?',x,2*d-1);sys.stdout.flush()
    return int(Z())
def poke(n):
    global K,S,C,L
    h=len(S);l=0;D=[0]*h
    while h-l>1:
        m=(l+h)//2;d=1-D[l]
        for i in range(m-l):
            v=P(d,S[l+i]);D[l+i]=d
        if v<P()+n:
            if d:l=m
            else:h=m
        else:
            if d:h=m
            else:l=m
        P(0)
    for i in range(len(S)):
        if D[i]:P(0,S[i])
    for i in range(M):v=P(0,S[l])
    K[S[l]]=C;L=C;S=S[:l]+S[l+1:]
    return v
N,M=map(int,Z().split())
if N==2:
    while P()>0:pass
    print('!',M);quit()
K=[-1]*N;S=[*range(1,N)]
pv=P();v=P();w=0
while 1-w or pv<=v:pv,v,w=v,P(),max(w,v>=pv)
pv,v=v,P(0)
good=[]
for i in S:
    pv,v=v,P(1,i)
    if v<pv:
        pv,v=v,P()
        if v>=pv:good.append(i);P(0,i);K[i]=0
        pv,v=v,P(0)
for i in good:S.remove(i)
L=C=0
for i in range(len(S)):
    n=0
    while (C-L)%(N*M)<M:
        pv,v,C=v,P(),C+1
        if pv==v:n=1;break
    else:
        pv=v
        while pv==v:pv,v,C=v,P(),C+1
    P(0);C-=1;v=poke(n)
print('!',' '.join(map(str,[(K[i]-C)%(M*N)for i in range(1,N)])))","['binary search', 'interactive']"
"An n × n square matrix is special, if:  it is binary, that is, each cell contains either a 0, or a 1;  the number of ones in each row and column equals 2. You are given n and the first m rows of the matrix. Print the number of special n × n matrices, such that the first m rows coincide with the given ones.As the required value can be rather large, print the remainder after dividing the value by the given number mod.","n,m,mod=map(int,raw_input().split())
col=[2]*n
for _ in range(m):
    s=raw_input()
    for i in range(n):
        if s[i]=='1':
            col[i]-=1
r2=r1=0
for i in col:
    if i==2:
        r2+=1
    elif i==1:
        r1+=1
dp=[[-1 for i in range(n+1)] for j in range(n+1)]
dp[r2][r1]=1
#f(i,j)=f(i+2,j-2)*(i+2)*(i+1)/2+f(i+1,j)*(i+1)*j+f(i,j+2)*(j+2)*(j+1)/2
def f(i,j):
    if dp[i][j]!=-1:
        return dp[i][j]
    ans=0
    if j>=2 and i+2<=n:
        ans+=f(i+2,j-2)*(i+2)*(i+1)/2
    if i+1<=n:
        ans+=f(i+1,j)*(i+1)*j
    if j+2<=n:
        ans+=f(i,j+2)*(j+2)*(j+1)/2
    ans%=mod
    dp[i][j]=ans
    return ans
print f(0,0)","['dp', 'combinatorics']"
"Recently Luba bought a very interesting book. She knows that it will take t seconds to read the book. Luba wants to finish reading as fast as she can.But she has some work to do in each of n next days. The number of seconds that Luba has to spend working during i-th day is ai. If some free time remains, she can spend it on reading.Help Luba to determine the minimum number of day when she finishes reading.It is guaranteed that the answer doesn't exceed n.Remember that there are 86400 seconds in a day.","n,t=map(int,input().split())
sec=list(map(int,input().split()))
c=1
for j in range(n):
    sec[j]=86400-sec[j]
    if(sec[j]>=t):print(c);break
    else:c+=1;t-=sec[j]",['implementation']
"Toad Zitz has an array of integers, each integer is between $$$0$$$ and $$$m-1$$$ inclusive. The integers are $$$a_1, a_2, \ldots, a_n$$$.In one operation Zitz can choose an integer $$$k$$$ and $$$k$$$ indices $$$i_1, i_2, \ldots, i_k$$$ such that $$$1 \leq i_1 &lt; i_2 &lt; \ldots &lt; i_k \leq n$$$. He should then change $$$a_{i_j}$$$ to $$$((a_{i_j}+1) \bmod m)$$$ for each chosen integer $$$i_j$$$. The integer $$$m$$$ is fixed for all operations and indices.Here $$$x \bmod y$$$ denotes the remainder of the division of $$$x$$$ by $$$y$$$.Zitz wants to make his array non-decreasing with the minimum number of such operations. Find this minimum number of operations.","n,m = [int(i) for i in input().split()]
array = [int(i) for i in input().split()]

# def bins(a, b):
#     if a == b:
#         return a
#     mid = (a+b)//2
#     if good(mid):
#         return bins(a, mid)
#     else:
#         return bins(mid+1, b)

# def good(k):
#     q = k - m
#     arr = array[:]
#     if arr[0] + q >= 0:
#         arr[0] = 0
#     for i in range(1, n):
#         d = arr[i-1] - arr[i]
#         if d > k:
#             return False
#         if d > 0 or d <= q:
#             arr[i] = arr[i-1]
        
#         # if arr[i] < arr[i-1]: #d>0
#         #     if arr[i-1] - arr[i] > k:#d>k
#         #         return False
#         #     else:
#         #         arr[i] = arr[i-1]
#         # else:#d<=0
#         #     if arr[i] + k - m >= arr[i-1]:#d <= k-m
#         #         arr[i] = arr[i-1]
#     return True



a=0
b=m-1
while a < b:
    mid = (a+b)//2
    ret = True
    q = mid - m
    #arr = array[:]
    last = array[0]
    if last + q >= 0:
        last = 0
    for i in range(1, n):
        d = last - array[i]
        if d > mid:
            ret = False
            break
        if d <= 0 and d > q:
            last = array[i]


    if ret:
        b = mid
    else:
        a = mid + 1

print(a)","['binary search', 'greedy']"
"After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can't use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant’s sentences, Yash determined a new cipher technique.For a given sentence, the cipher is processed as:   Convert all letters of the sentence to lowercase.  Reverse each of the words of the sentence individually.  Remove all the spaces in the sentence. For example, when this cipher is applied to the sentenceKira is childish and he hates losingthe resulting string isariksihsidlihcdnaehsetahgnisolNow Yash is given some ciphered string and a list of words. Help him to find out any original sentence composed using only words from the list. Note, that any of the given words could be used in the sentence multiple times.","#!/usr/bin/env python3

# http://codeforces.com/contest/633/problem/C

from collections import deque

# import sys
# sys.setrecursionlimit(10001)

n = int(input())
s = input()
m = int(input())
words = []
for i in range(0, m):
    words.append(input())

dict_words = {}
for word in words:
    dict_words[word.lower()[::-1]] = word

trie_words = {}
for word in dict_words.keys():
    d = trie_words
    for letter in word:
        d = d.setdefault(letter, {})
    d['word'] = word

def find_sentence(s):
    # stack = [0, '', dict_words, []] # position, used words so far, pos in trie we stopped on, children
    roots = deque() # position, used words so far, pos in trie we stopped on, children

    d = trie_words
    for i in range(0, len(s)):
        if not s[i] in d:
            break;
        d = d[s[i]]
        if 'word' in d:
            word = d['word']
            new_root = [i + 1, word, None]
            roots.append(new_root)
            if i + 1 == len(s):
                return new_root

    while len(roots) > 0:
        root = roots.popleft()
        d = trie_words

        for i in range(root[0], len(s)):
            if not s[i] in d:
                break;
            d = d[s[i]]
            if 'word' in d:
                word = d['word']
                new_root = [i + 1, word, root]
                roots.appendleft(new_root)
                if i + 1 == len(s):
                    return new_root

result = find_sentence(s)
words = []
while not result is None:
    word = result[1]
    words.append(dict_words[word])
    result = result[2]
print(' '.join(reversed(words)))","['dp', 'hashing', 'string suffix structures', 'implementation', 'sortings', 'data structures', 'strings']"
"A bracket sequence is a string containing only characters ""("" and "")"".A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example, bracket sequences ""()()"", ""(())"" are regular (the resulting expressions are: ""(1)+(1)"", ""((1+1)+1)""), and "")("" and ""("" are not.You are given $$$n$$$ bracket sequences $$$s_1, s_2, \dots , s_n$$$. Calculate the number of pairs $$$i, j \, (1 \le i, j \le n)$$$ such that the bracket sequence $$$s_i + s_j$$$ is a regular bracket sequence. Operation $$$+$$$ means concatenation i.e. ""()("" + "")()"" = ""()()()"".If $$$s_i + s_j$$$ and $$$s_j + s_i$$$ are regular bracket sequences and $$$i \ne j$$$, then both pairs $$$(i, j)$$$ and $$$(j, i)$$$ must be counted in the answer. Also, if $$$s_i + s_i$$$ is a regular bracket sequence, the pair $$$(i, i)$$$ must be counted in the answer.","import sys
import io

stream_enable = 0

inpstream = """"""
9
(()
((())
(
)
(()()(()())))
)
)(()(
)())(
)()(
""""""

if stream_enable:
    sys.stdin = io.StringIO(inpstream)
    input()

def inpmap():
    return list(map(int, input().split()))

n = int(input())
arr = []
for i in range(n):
    x = input()
    a = 0
    s = False
    for y in x:
        if y == '(':
            a += 1
        else:
            a -= 1
        if a < 0:
            s = True
    if s and a >= 0:
        continue
    a = 0
    s = False
    for y in x[::-1]:
        if y == '(':
            a += 1
        else:
            a -= 1
        if a > 0:
            s = True
    if s and a <= 0:
        continue
    arr.append(a)

    # arr.append(x.count('(') - x.count(')'))
s = 0
# print(arr)
# for x in set(arr):
st = set(arr)
for x in st:
    if x > 0:
        continue
    elif x == 0:
        s += arr.count(x) ** 2
    else:
        s += arr.count(x) * arr.count(-x)
print(s)",['implementation']
"We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer t Т-prime, if t has exactly three distinct positive divisors.You are given an array of n positive integers. For each of them determine whether it is Т-prime or not.","from math import sqrt
n = int(input())
s = [int(i) for i in input().split()]
d = [1]*1000002
e = set()
for i in range(2,1000002):
	if d[i]:
		e.add(i**2)
		for j in range(i**2,1000002,i):
			d[j]=0
for i in range(n):
	if s[i] in e:
		print(""YES"")
	else:
		print(""NO"")","['binary search', 'number theory', 'implementation', 'math']"
"A permutation p of size n is the sequence p1, p2, ..., pn, consisting of n distinct integers, each of them is from 1 to n (1 ≤ pi ≤ n).A lucky permutation is such permutation p, that any integer i (1 ≤ i ≤ n) meets this condition ppi = n - i + 1.You have integer n. Find some lucky permutation p of size n.","n = int(input())
p = [0] * n

if n == 1:
    print(1)
    exit()

for sh in range(n // 4):
    p[n - sh * 2 - 2] = n - sh * 2
    p[sh * 2] = n - 1 - sh * 2
    p[n - sh * 2 - 1] = 2 + sh * 2
    p[sh * 2 + 1] = 1 + sh * 2

if n % 4 == 1:
    p[n // 2] = n // 2 + 1

if n % 4 == 2:
    print(-1)
    exit()

if n % 4 == 3:
    print(-1)
    exit()

print("" "".join([str(i) for i in p]))","['constructive algorithms', 'implementation', 'greedy', 'math']"
"Vasya is a regular participant at programming contests and is already experienced in finding important sentences in long statements. Of course, numbers constraints are important — factorization of a number less than 1000000 is easier than of a number less than 1000000000. However, sometimes it's hard to understand the number at the first glance. Could it be shortened? For example, instead of 1000000 you could write $$$10^{6}$$$, instead of 1000000000  —$$$10^{9}$$$, instead of 1000000007 — $$$10^{9}+7$$$.Vasya decided that, to be concise, the notation should follow several rules:   the notation should only consist of numbers, operations of addition (""+""), multiplication (""*"") and exponentiation (""^""), in particular, the use of braces is forbidden;  the use of several exponentiation operations in a row is forbidden, for example, writing ""2^3^4"" is unacceptable;  the value of the resulting expression equals to the initial number;  the notation should consist of the minimal amount of symbols. Given $$$n$$$, find the equivalent concise notation for it.","import math
import itertools

pow10 = [1]
for i in range(10):
    pow10.append(pow10[-1] * 10)


def getlen(x):
    """"""length of the decimal representation of integer x""""""
    return int(math.log10(x)) + 1


class ShortestRepresentation:

    def __init__(self, n):
        self.n = n
        self._m = {}
        self._s = [set() for i in range(10)]

        self._generate_powers()
        self._generate_power_and_power(7)
        self._generate_simple_and_power(7)

    def _generate_powers(self):
        """"""add to the collection all expressions of the form a^b""""""
        range_x = itertools.takewhile(
            lambda x: x**2 <= self.n,
            itertools.count(2))
        for x in range_x:
            c = x**2
            p = 2
            while c <= self.n:
                self.update(c, '{}^{}'.format(x, p))
                c *= x
                p += 1

    def _generate_power_and_power(self, maxlen):
        """"""add to the collection all expressions of the form a^b*c^d""""""
        for i in range(1, maxlen + 1):
            range_j = itertools.takewhile(
                lambda j: i + j + 1 <= maxlen,
                itertools.count(i))
            for j in range_j:
                for x, y in itertools.product(self._s[i], self._s[j]):
                    x2 = self.get(x)
                    y2 = self.get(y)
                    self.update(x * y, '{}*{}'.format(x2, y2))

    def _generate_simple_and_power(self, maxlen):
        """"""add to the collection all expressions of the form a^b*c""""""
        for i in range(1, maxlen - 1):
            range_xy = itertools.product(
                range(1, pow10[maxlen - 1 - i]),
                self._s[i])
            for x, y in range_xy:
                y2 = self.get(y)
                self.update(x * y, '{}*{}'.format(x, y2))

    def update(self, x, s):
        """"""update with s x'th entry of the collection""""""
        if x > self.n:
            return

        ls = len(s)
        if ls >= getlen(x):  # length of s should be at least shorter
            return

        if x not in self._m:
            self._m[x] = s
            self._s[ls].add(x)
        else:
            lm = len(self._m[x])
            if ls < lm:
                self._s[lm].remove(x)
                self._m[x] = s
                self._s[ls].add(x)

    def get(self, x):
        """"""retrieve shortest valid representation of number x""""""
        return self._m[x] if x in self._m else str(x)


n = int(input())
if n < 10**10:
    sr = ShortestRepresentation(n)
    ans = sr.get(n)

    # check a*b and a+b
    range_i = itertools.takewhile(
        lambda i: i * 2 + 1 < len(ans),
        itertools.count())
    for i in range_i:
        range_x = itertools.chain(
            range(1, pow10[i] + 1),
            sr._s[i])
        for x in range_x:
            ans = min(
                ans, '{}+{}'.format(sr.get(x), sr.get(n - x)), key=len)
            if n % x > 0:
                continue
            ans = min(
                ans, '{}*{}'.format(sr.get(x), sr.get(n // x)), key=len)

    print(ans)
else:
    print('100^5')","['implementation', 'greedy', 'math', 'brute force']"
"Vanya has a table consisting of 100 rows, each row contains 100 cells. The rows are numbered by integers from 1 to 100 from bottom to top, the columns are numbered from 1 to 100 from left to right. In this table, Vanya chose n rectangles with sides that go along borders of squares (some rectangles probably occur multiple times). After that for each cell of the table he counted the number of rectangles it belongs to and wrote this number into it. Now he wants to find the sum of values in all cells of the table and as the table is too large, he asks you to help him find the result.","r=0
for i in range(int(input())):
    x1,y1,x2,y2 = list(map(int,input().split()))
    r = r + (x2-x1+1)*(y2-y1+1)
print(r)","['implementation', 'math']"
"Kuro is currently playing an educational game about numbers. The game focuses on the greatest common divisor (GCD), the XOR value, and the sum of two numbers. Kuro loves the game so much that he solves levels by levels day by day.Sadly, he's going on a vacation for a day, and he isn't able to continue his solving streak on his own. As Katie is a reliable person, Kuro kindly asked her to come to his house on this day to play the game for him.Initally, there is an empty array $$$a$$$. The game consists of $$$q$$$ tasks of two types. The first type asks Katie to add a number $$$u_i$$$ to $$$a$$$. The second type asks Katie to find a number $$$v$$$ existing in $$$a$$$ such that $$$k_i \mid GCD(x_i, v)$$$, $$$x_i + v \leq s_i$$$, and $$$x_i \oplus v$$$ is maximized, where $$$\oplus$$$ denotes the bitwise XOR operation, $$$GCD(c, d)$$$ denotes the greatest common divisor of integers $$$c$$$ and $$$d$$$, and $$$y \mid x$$$ means $$$x$$$ is divisible by $$$y$$$, or report -1 if no such numbers are found.Since you are a programmer, Katie needs you to automatically and accurately perform the tasks in the game to satisfy her dear friend Kuro. Let's help her!","import sys
range = xrange
input = raw_input

big = 10**5 + 1
M = 1
while M < big:
    M *= 2

mini = [0]
L = [0]
R = [0]

roots = [0]*big

def add(x, i):
    bits = []
    xx = x + M
    while xx != 1:
        bits.append(xx&1)
        xx >>= 1

    if not roots[i]:
        roots[i] = len(mini)
        mini.append(x)
        L.append(0)
        R.append(0)

    node = roots[i]
    mini[node] = min(mini[node], x)

    for b in reversed(bits):
        nesta = R if b else L
        if not nesta[node]:
            nesta[node] = len(mini)
            mini.append(x)
            L.append(0)
            R.append(0)
        node = nesta[node]
        mini[node] = min(mini[node], x)

found = [0]*big

divisors = [[] for _ in range(big)]
for i in range(1, big):
    ii = i
    while ii < big:
        divisors[ii].append(i)
        ii += i

inp = [int(x) for x in sys.stdin.read().split()]; ii = 0
out = []

q = inp[ii]; ii += 1
for _ in range(q):
    t = inp[ii]; ii += 1

    if t == 1:
        u = inp[ii]; ii += 1
        if not found[u]:
            found[u] = 1
            
            for d in divisors[u]:
                add(u, d)

    else:
        x = inp[ii]; ii += 1
        k = inp[ii]; ii += 1
        s = inp[ii]; ii += 1

        if x % k != 0:
            out.append(-1)
            continue
        s -= x

        node = roots[k]
        if not node or mini[node] > s:
            out.append(-1)
            continue
        
        xbits = []
        xx = x +  M
        while xx > 1:
            xbits.append(xx&1)
            xx >>= 1

        for bit in reversed(xbits):
            alt1,alt2 = (L[node],R[node]) if bit else (R[node],L[node])
            if alt1 and mini[alt1] <= s:
                node = alt1
            elif alt2 and mini[alt2] <= s:
                node = alt2
            else:
                break
        else:
            out.append(mini[node])
            continue
        out.append(-1)

print '\n'.join(str(x) for x in out)","['dp', 'greedy', 'number theory', 'bitmasks', 'math', 'trees', 'dsu', 'data structures', 'binary search', 'brute force', 'strings']"
"Petya has an array $$$a$$$ consisting of $$$n$$$ integers. He has learned partial sums recently, and now he can calculate the sum of elements on any segment of the array really fast. The segment is a non-empty sequence of elements standing one next to another in the array.Now he wonders what is the number of segments in his array with the sum less than $$$t$$$. Help Petya to calculate this number.More formally, you are required to calculate the number of pairs $$$l, r$$$ ($$$l \le r$$$) such that $$$a_l + a_{l+1} + \dots + a_{r-1} + a_r &lt; t$$$.","from bisect import bisect_left

sum = [0]*200005
srt = []
n,t = map(int,input().split())
a = list(map(int,input().split()))

tree = [0]*200005

def get(x):
    ans = 0
    while x:
        ans += tree[x]
        x -= x&-x
    return ans

def update(x):

    while x <= 200002:
        tree[x] += 1
        x += x&-x


for i in range(n):
    if i:
        sum[i] = sum[i-1] + a[i]
    else:
        sum[i] = a[i]
    srt.append(sum[i])

if 0 not in srt:
    srt.append(0)

srt.sort()

ans = 0
update(bisect_left(srt,0) + 1)




for i in range(n):
    l = min(len(srt)-1,bisect_left(srt,sum[i] - t))

    if srt[l] <= sum[i] - t:
        l = l+1

    cnt = get(l)
    ans += i + 1 - cnt


    update(bisect_left(srt,sum[i]) + 1)

print(ans)","['data structures', 'two pointers', 'divide and conquer']"
"As you know, Vova has recently become a new shaman in the city of Ultima Thule. So, he has received the shaman knowledge about the correct bracket sequences. The shamans of Ultima Thule have been using lots of different types of brackets since prehistoric times. A bracket type is a positive integer. The shamans define a correct bracket sequence as follows:  An empty sequence is a correct bracket sequence.  If {a1, a2, ..., al} and {b1, b2, ..., bk} are correct bracket sequences, then sequence {a1, a2, ..., al, b1, b2, ..., bk} (their concatenation) also is a correct bracket sequence.  If {a1, a2, ..., al} — is a correct bracket sequence, then sequence  also is a correct bracket sequence, where v (v &gt; 0) is an integer. For example, sequences {1, 1,  - 1, 2,  - 2,  - 1} and {3,  - 3} are correct bracket sequences, and {2,  - 3} is not.Moreover, after Vova became a shaman, he learned the most important correct bracket sequence {x1, x2, ..., xn}, consisting of n integers. As sequence x is the most important, Vova decided to encrypt it just in case.Encrypting consists of two sequences. The first sequence {p1, p2, ..., pn} contains types of brackets, that is, pi = |xi| (1 ≤ i ≤ n). The second sequence {q1, q2, ..., qt} contains t integers — some positions (possibly, not all of them), which had negative numbers in sequence {x1, x2, ..., xn}.Unfortunately, Vova forgot the main sequence. But he was lucky enough to keep the encryption: sequences {p1, p2, ..., pn} and {q1, q2, ..., qt}. Help Vova restore sequence x by the encryption. If there are multiple sequences that correspond to the encryption, restore any of them. If there are no such sequences, you should tell so.","from sys import stdin,stdout
def main():
    a = stdin.read().split()
    n = int(a[0]) + 1
    k = [True] * n
    st = []
    for i in xrange(n+1, n+1+int(a[n])):
        k[int(a[i])] = False
    ans = []
    sta = st.append
    stp = st.pop
    aa = ans.append
    for i in xrange(n-1, 0, -1):
        if k[i] and st and st[-1] == a[i]:
            stp()
            aa(a[i])
        else:
            sta(a[i])
            aa(""-"" + a[i])
    if st:
         print ""NO""
         return
    print ""YES""
    stdout.write(' '.join(reversed(ans)))
    print
main()","['implementation', 'greedy']"
"Peter wrote on the board a strictly increasing sequence of positive integers a1, a2, ..., an. Then Vasil replaced some digits in the numbers of this sequence by question marks. Thus, each question mark corresponds to exactly one lost digit.Restore the the original sequence knowing digits remaining on the board.","def solve(s, t, i, l):
    if i == l:
        return False
    if s[i] == ""?"":
        if solve(s, t, i + 1, l):
            s[i] = t[i]
            return True
        elif t[i] == ""9"":
            return False
        s[i] = nxt[t[i]]
        for j in range(i, l):
            if s[j] == ""?"":
                s[j] = ""0""
        return True
    elif s[i] > t[i]:
        for j in range(i, l):
            if s[j] == ""?"":
                s[j] = ""0""
        return True
    elif s[i] < t[i]:
        return False
    else:
        return solve(s, t, i + 1, l)


n = int(input())
a = [list(input()) for _ in range(n)]
p = [""0""]
nxt = {str(x): str(x + 1) for x in range(9)}

for i, ai in enumerate(a):
    if len(p) > len(ai):
        print(""NO"")
        break
    if len(p) < len(ai):
        if a[i][0] == ""?"":
            a[i][0] = ""1""
        for j in range(len(ai)):
            if a[i][j] == ""?"":
                a[i][j] = ""0""
    elif not solve(a[i], p, 0, len(ai)):
        print(""NO"")
        break
    p = a[i]
else:
    print(""YES"")
    print(""\n"".join("""".join(line) for line in a))","['binary search', 'implementation', 'greedy', 'brute force']"
"Alice is playing a game with her good friend, Marisa.There are $$$n$$$ boxes arranged in a line, numbered with integers from $$$1$$$ to $$$n$$$ from left to right. Marisa will hide a doll in one of the boxes. Then Alice will have $$$m$$$ chances to guess where the doll is. If Alice will correctly guess the number of box, where doll is now, she will win the game, otherwise, her friend will win the game.In order to win, Marisa will use some unfair tricks. After each time Alice guesses a box, she can move the doll to the neighboring box or just keep it at its place. Boxes $$$i$$$ and $$$i + 1$$$ are neighboring for all $$$1 \leq i \leq n - 1$$$. She can also use this trick once before the game starts.So, the game happens in this order: the game starts, Marisa makes the trick, Alice makes the first guess, Marisa makes the trick, Alice makes the second guess, Marisa makes the trick, $$$\ldots$$$, Alice makes $$$m$$$-th guess, Marisa makes the trick, the game ends.Alice has come up with a sequence $$$a_1, a_2, \ldots, a_m$$$. In the $$$i$$$-th guess, she will ask if the doll is in the box $$$a_i$$$. She wants to know the number of scenarios $$$(x, y)$$$ (for all $$$1 \leq x, y \leq n$$$), such that Marisa can win the game if she will put the doll at the $$$x$$$-th box at the beginning and at the end of the game, the doll will be at the $$$y$$$-th box. Help her and calculate this number.","import sys
input = sys.stdin.readline
 
n,m=map(int,input().split())
A=list(map(int,input().split()))
 
if n==1:
    print(0)
    sys.exit()
 
from collections import Counter
R=Counter()
L=Counter()
 
for i in range(n):
    R[i+1]=1
    L[i+1]=1
 
for i,a in enumerate(A):
    x=R[a-(i+1)]
    del R[a-(i+1)]
    R[a-(i+1)-1]+=x
 
    x=L[a+(i+1)]
    del L[a+(i+1)]
    L[a+(i+1)+1]+=x
 
#print(R,L)
 
 
ANS=0
for r in R:
    ANS+=R[r]*min(n,(r+m+1))
 
#print(ANS)
 
for l in L:
    ANS-=L[l]*(max(1,(l-(m+1)))-1)
 
print(ANS)","['dp', 'dsu', 'binary search', 'data structures']"
"A sportsman starts from point xstart = 0 and runs to point with coordinate xfinish = m (on a straight line). Also, the sportsman can jump — to jump, he should first take a run of length of not less than s meters (in this case for these s meters his path should have no obstacles), and after that he can jump over a length of not more than d meters. Running and jumping is permitted only in the direction from left to right. He can start andfinish a jump only at the points with integer coordinates in which there are no obstacles. To overcome some obstacle, it is necessary to land at a point which is strictly to the right of this obstacle.On the way of an athlete are n obstacles at coordinates x1, x2, ..., xn. He cannot go over the obstacles, he can only jump over them. Your task is to determine whether the athlete will be able to get to the finish point.","n,m,s,d=map(int,input().split())
x=sorted(map(int,input().split()))+[m+s+1]
cur=l=0
ans=[]
while l<m:
    r=min(x[cur]-1,m)
    ans+=['RUN '+str(r-l)]
    if r==m: break
    if r-l<s: ans=['IMPOSSIBLE']; break
    t=x[cur]+1
    while x[cur+1]-1-t<s: cur+=1; t=x[cur]+1
    if t-r>d: ans=['IMPOSSIBLE']; break
    ans+=['JUMP '+str(t-r)]
    l=t;cur+=1
print('\n'.join(ans))","['dp', '*special', 'greedy', 'data structures']"
"You are given an integer m.Let M = 2m - 1.You are also given a set of n integers denoted as the set T. The integers will be provided in base 2 as n binary strings of length m.A set of integers S is called ""good"" if the following hold.   If , then .  If , then     All elements of S are less than or equal to M. Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.Count the number of good sets S, modulo 109 + 7.","MOD = 10**9 + 7
m, N = map(int, input().split())

binom = [[1] + [0 for i in range(m)] for j in range(m + 1)]
for n in range(1, m + 1):
    for k in range(1, n + 1):
        binom[n][k] = (binom[n - 1][k] + binom[n - 1][k - 1]) % MOD

bell = [0 for n in range(m + 1)]
bell[0] = bell[1] = 1
for n in range(1, m):
    for k in range(n + 1):
        bell[n + 1] += bell[k] * binom[n][k]
        bell[n + 1] %= MOD
#print(bell)

bags = [0 for i in range(m)]
for it in range(N):
    for i, z in enumerate(input()):
        if z == '1':
            bags[i] |= (1 << it)
difs = set(bags)
sol = 1
for mask in difs:
    sol = sol * bell[bags.count(mask)] % MOD
print(sol)","['dp', 'combinatorics', 'bitmasks', 'math']"
"Pasha loves to send strictly positive integers to his friends. Pasha cares about security, therefore when he wants to send an integer $$$n$$$, he encrypts it in the following way: he picks three integers $$$a$$$, $$$b$$$ and $$$c$$$ such that $$$l \leq a,b,c \leq r$$$, and then he computes the encrypted value $$$m = n \cdot a + b - c$$$.Unfortunately, an adversary intercepted the values $$$l$$$, $$$r$$$ and $$$m$$$. Is it possible to recover the original values of $$$a$$$, $$$b$$$ and $$$c$$$ from this information? More formally, you are asked to find any values of $$$a$$$, $$$b$$$ and $$$c$$$ such that  $$$a$$$, $$$b$$$ and $$$c$$$ are integers,  $$$l \leq a, b, c \leq r$$$,  there exists a strictly positive integer $$$n$$$, such that $$$n \cdot a + b - c = m$$$.","# -*- coding: utf-8 -*-
""""""
Created on Tue Jul 21 01:33:02 2020

@author: Manan Tyagi
""""""
import math
t=int(input())
p=0
a=0
while t:
    t-=1
    l,r,m=map(int,input().split())
    mxd=r-l
    if m<l:
        pr=m-l
        c=r
        b=c+pr
        a=l
    elif m==l:
        a=l
        b=l
        c=l
        
        
        
    else:
        for i in range(r,l-1,-1):     #checking on every iteration
                                    
            n=math.floor(m/i)
            n1=math.ceil(m/i)
            f1=abs((n*i)-m)
            f2=abs((n1*i)-m)
            re=min(f1,f2)
            if re<=mxd:
                if re==f1:
                    p=n
                else:
                    p=n1
                a=i
                break
                
               
        
        #print(p)
        pr=m-(a*p)
        #print(pr)
        if pr>0:
            c=l
            b=c+pr
        else:
            c=r
            b=c+pr
            
        
    print(a,b,c)","['binary search', 'number theory', 'brute force', 'math']"
"Поликарп мечтает стать программистом и фанатеет от степеней двойки. Среди двух чисел ему больше нравится то, которое делится на большую степень числа 2. По заданной последовательности целых положительных чисел a1, a2, ..., an требуется найти r — максимальную степень числа 2, на которую делится хотя бы одно из чисел последовательности. Кроме того, требуется вывести количество чисел ai, которые делятся на r.","a = []
n = int(input())
a += (int(i) for i in input().split())
r, m = 1, 1
while m != 0:
    m2 = m
    m = 0
    for i in range(n):
        if a[i] % r == 0:
            m += 1
    if m != 0:
        r = r * 2
    else:
        break
print(r // 2, m2)",['constructive algorithms']
You are given a directed graph with $$$n$$$ vertices and $$$m$$$ directed edges without self-loops or multiple edges.Let's denote the $$$k$$$-coloring of a digraph as following: you color each edge in one of $$$k$$$ colors. The $$$k$$$-coloring is good if and only if there no cycle formed by edges of same color.Find a good $$$k$$$-coloring of given digraph with minimum possible $$$k$$$.,"from __future__ import division, print_function
import math
def main():
    from collections import defaultdict 
    from collections import deque
    class Graph(): 
        def __init__(self,vertices): 
            self.graph = defaultdict(list) 
            self.V = vertices 
      
        def addEdge(self,u,v): 
            self.graph[u].append(v) 
      
        def isCyclicUtil(self, v, visited, recStack): 
            visited[v] = True
            recStack[v] = True
            for neighbour in self.graph[v]: 
                if visited[neighbour] == False: 
                    if self.isCyclicUtil(neighbour, visited, recStack) == True: 
                        return True
                elif recStack[neighbour] == True: 
                    return True
            recStack[v] = False
            return False
        def isCyclic(self): 
            visited = [False] * self.V 
            recStack = [False] * self.V 
            for node in range(self.V): 
                if visited[node] == False: 
                    if self.isCyclicUtil(node,visited,recStack) == True: 
                        return True
            return False
        def neigh(self,u):
            return self.graph[u]
    
    n,m=map(int,input().split())
    g=Graph(n)
    pos={}
    for i in range(m):
        u,v=map(int,input().split())
        g.addEdge(u-1,v-1)
        pos[(u-1,v-1)]=i
    if g.isCyclic()==1:
        print(2)
        result=[0]*m
        for k in pos:
            if k[0]<k[1]:
                result[pos[k]]=1
            else :
                result[pos[k]]=2
        print("" "".join(str(x) for x in result))
    else :
        print(1)
        for i in range(m):
            print(1,end="" "")
                
 
######## Python 2 and 3 footer by Pajenegod and c1729
 
# Note because cf runs old PyPy3 version which doesn't have the sped up
# unicode strings, PyPy3 strings will many times be slower than pypy2.
# There is a way to get around this by using binary strings in PyPy3
# but its syntax is different which makes it kind of a mess to use.
 
# So on cf, use PyPy2 for best string performance.
 
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
 
import os, sys
from io import IOBase, BytesIO
 
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0
 
    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None
 
    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s
 
    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()
 
    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')
 
# Cout implemented in Python
import sys
class ostream:
    def __lshift__(self,a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
 
# Read all remaining integers in stdin, type is given by optional argument, this is fast
def readnumbers(zero = 0):
    conv = ord if py2 else lambda x:x
    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0' [0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-' [0]: sign = -1
            elif s[i] != b'\r' [0]:
                A.append(sign*numb)
                numb = zero; sign = 1
            i += 1
    except:pass
    if s and s[-1] >= b'0' [0]:
        A.append(sign*numb)
    return A
 
if __name__== ""__main__"":
  main()","['constructive algorithms', 'dfs and similar', 'graphs']"
"Dima is a good person. In fact, he's great. But all good things come to an end...Seryozha is going to kick Dima just few times.. For this reason he divides the room into unit squares. Now the room is a rectangle n × m consisting of unit squares.For the beginning, Seryozha put Dima in a center of some square. Then he started to kick Dima (it is known, that he kicks Dima at least once). Each time when Dima is kicked he flyes up and moves into one of four directions (up, left, right, down). On each move Dima passes k (k &gt; 1) unit of the length in the corresponding direction. Seryozha is really kind, so he kicks Dima in such way that Dima never meets the walls (in other words, Dima never leave the room's space). Seryozha is also dynamic character so Dima never flies above the same segment, connecting a pair of adjacent squares, twice.Seryozha kicks Dima for a long time, but Dima is not vindictive — Dima writes. Dima marked all squares in which he was staying or above which he was flying. Thanks to kicks, Dima does not remember the k value, so he asks you to find all possible values which matches to the Dima's records.","import sys
sys.setrecursionlimit(10**6)
def main():
    n, m = map(int, raw_input().split())
    a = [raw_input().split() for _ in xrange(n)]
    dd = [(1,0), (0,1)]
    od = 0
    D = [[[] for _ in xrange(m)] for _ in xrange(n)]
    done = [[False] * m for _ in xrange(n)]
    par = range(n * m)
    rank = [0] * (n * m)
    def find(x):
        if x == par[x]:
            return x
        else:
            par[x] = find(par[x])
            return par[x]
    def union(x, y):
        x, y = find(x), find(y)
        if x == y: return
        if rank[x] < rank[y]:
            par[y] = x
        else:
            par[x] = y
            if rank[x] == rank[y]:
                rank[x] += 1
    for i in xrange(n):
        for j in xrange(m):
            if a[i][j] == '0': continue
            deg = 0
            for d in dd:
                ni, nj = i + d[0], j + d[1]
                if 0 <= ni < n and 0 <= nj < m and a[ni][nj] == '1':
                    deg += 1
                    D[i][j].append(d)
                    union(i * m + j, ni * m + nj)
                ni, nj = i - d[0], j - d[1]
                if 0 <= ni < n and 0 <= nj < m and a[ni][nj] == '1':
                    deg += 1
            if deg % 2:
                od += 1 
    if od > 2:
        print -1
        return
    deg = 0
    S = set()
    for i in xrange(n):
        for j in xrange(m):
            if a[i][j] == '0': continue
            deg += 1
            S.add(find(i * m + j))
    if deg == 1 or len(S) != 1:
        print -1
        return
    def gcd(x, y):
        if y == 0:
            return x
        else:
            return gcd(y, x%y)
    p = 0
    for i in xrange(n):
        for j in xrange(m):
            if a[i][j] == '0' or done[i][j]: continue
            for d in D[i][j]:
                t = 1
                while 1:
                    ni, nj = i + t * d[0], j + t * d[1]
                    if 0 <= ni < n and 0 <= nj < m and a[ni][nj] == '1' and [d] == D[ni][nj]:
                        pass
                    else:
                        break
                    done[ni][nj] = 1
                    t += 1
                p = gcd(t, p)
    if p == 1:
        print -1
        return
    for i in xrange(2, p+1):
        if p % i == 0:
            print i,
main()","['dsu', 'implementation', 'brute force', 'graphs']"
"The Smart Beaver from ABBYY has once again surprised us! He has developed a new calculating device, which he called the ""Beaver's Calculator 1.0"". It is very peculiar and it is planned to be used in a variety of scientific problems.To test it, the Smart Beaver invited n scientists, numbered from 1 to n. The i-th scientist brought ki calculating problems for the device developed by the Smart Beaver from ABBYY. The problems of the i-th scientist are numbered from 1 to ki, and they must be calculated sequentially in the described order, since calculating each problem heavily depends on the results of calculating of the previous ones.Each problem of each of the n scientists is described by one integer ai, j, where i (1 ≤ i ≤ n) is the number of the scientist, j (1 ≤ j ≤ ki) is the number of the problem, and ai, j is the number of resource units the calculating device needs to solve this problem.The calculating device that is developed by the Smart Beaver is pretty unusual. It solves problems sequentially, one after another. After some problem is solved and before the next one is considered, the calculating device allocates or frees resources.The most expensive operation for the calculating device is freeing resources, which works much slower than allocating them. It is therefore desirable that each next problem for the calculating device requires no less resources than the previous one.You are given the information about the problems the scientists offered for the testing. You need to arrange these problems in such an order that the number of adjacent ""bad"" pairs of problems in this list is minimum possible. We will call two consecutive problems in this list a ""bad pair"" if the problem that is performed first requires more resources than the one that goes after it. Do not forget that the problems of the same scientist must be solved in a fixed order.","import sys

n = int(sys.stdin.readline())

k1, a11, x1, y1, m1 = map(int, sys.stdin.readline().split())
k2, a21, x2, y2, m2 = map(int, sys.stdin.readline().split())

# generate
a1vec = [0]*k1
a2vec = [0]*k2

a1vec[0] = a11
a2vec[0] = a21

for i in range(1, k1):
  a1vec[i] = (a1vec[i-1]*x1 + y1)%m1

for i in range(1, k2):
  a2vec[i] = (a2vec[i-1]*x2 + y2)%m2

i1 = 0
i2 = 0

last = -1

numBreaks = 0

resultStr = """"

while i1 < len(a1vec) and i2 < len(a2vec):
  # if both are valid, increment the least
  curr1 = a1vec[i1]
  curr2 = a2vec[i2]

  if curr1 >= last and curr2 >= last:
    if curr1 > curr2:
      last = curr2
      i2 += 1
      resultStr += (str(curr2) + "" 2\n"")
    else:
      last = curr1
      i1 += 1
      resultStr += (str(curr1) + "" 1\n"")
  elif curr1 >= last:
    last = curr1
    i1 += 1
    resultStr += (str(curr1) + "" 1\n"")
  elif curr2 >= last:
    last = curr2
    i2 += 1
    resultStr += (str(curr2) + "" 2\n"")  
  else:
    numBreaks += 1
    if curr1 > curr2:
      last = curr2
      i2 += 1
      resultStr += (str(curr2) + "" 2\n"")
    else:
      last = curr1
      i1 += 1
      resultStr += (str(curr1) + "" 1\n"")

# CONTINUE TO THE END IF ONE IS DONE
while i1 < len(a1vec):
  curr1 = a1vec[i1]
  i1 += 1
  resultStr += (str(curr1) + "" 1\n"")
  if curr1 < last:
    numBreaks +=1
  last = curr1

while i2 < len(a2vec):
  curr2 = a2vec[i2]
  i2 += 1
  resultStr += (str(curr2) + "" 2\n"")
  if curr2 < last:
    numBreaks +=1
  last = curr2
  
  

    
print(numBreaks)
print(resultStr)


# one of them may still have some left",['greedy']
"PolandBall has an undirected simple graph consisting of n vertices. Unfortunately, it has no edges. The graph is very sad because of that. PolandBall wanted to make it happier, adding some red edges. Then, he will add white edges in every remaining place. Therefore, the final graph will be a clique in two colors: white and red. Colorfulness of the graph is a value min(dr, dw), where dr is the diameter of the red subgraph and dw is the diameter of white subgraph. The diameter of a graph is a largest value d such that shortest path between some pair of vertices in it is equal to d. If the graph is not connected, we consider its diameter to be -1.PolandBall wants the final graph to be as neat as possible. He wants the final colorfulness to be equal to k. Can you help him and find any graph which satisfies PolandBall's requests?","n, k = map(int, input().split())

if n < 4:
    print(-1)
elif k == 1:
    print(-1)
elif k > 3:
    print(-1)
elif n == 4 and k == 2:
    print(-1)
elif k == 2:
    print(n - 1)
    for i in range(n - 1):
        print(i + 1, i + 2)
elif k == 3:
    print(n - 1)
    print(1, 2)
    print(2, 3)
    for i in range(4, n + 1):
        print(3, i)","['constructive algorithms', 'graphs', 'shortest paths']"
"Instructors of Some Informatics School make students go to bed.The house contains n rooms, in each room exactly b students were supposed to sleep. However, at the time of curfew it happened that many students are not located in their assigned rooms. The rooms are arranged in a row and numbered from 1 to n. Initially, in i-th room there are ai students. All students are currently somewhere in the house, therefore a1 + a2 + ... + an = nb. Also 2 instructors live in this house.The process of curfew enforcement is the following. One instructor starts near room 1 and moves toward room n, while the second instructor starts near room n and moves toward room 1. After processing current room, each instructor moves on to the next one. Both instructors enter rooms and move simultaneously, if n is odd, then only the first instructor processes the middle room. When all rooms are processed, the process ends.When an instructor processes a room, she counts the number of students in the room, then turns off the light, and locks the room. Also, if the number of students inside the processed room is not equal to b, the instructor writes down the number of this room into her notebook (and turns off the light, and locks the room). Instructors are in a hurry (to prepare the study plan for the next day), so they don't care about who is in the room, but only about the number of students.While instructors are inside the rooms, students can run between rooms that are not locked and not being processed. A student can run by at most d rooms, that is she can move to a room with number that differs my at most d. Also, after (or instead of) running each student can hide under a bed in a room she is in. In this case the instructor will not count her during the processing. In each room any number of students can hide simultaneously.Formally, here is what's happening:  A curfew is announced, at this point in room i there are ai students.  Each student can run to another room but not further than d rooms away from her initial room, or stay in place. After that each student can optionally hide under a bed.  Instructors enter room 1 and room n, they count students there and lock the room (after it no one can enter or leave this room).  Each student from rooms with numbers from 2 to n - 1 can run to another room but not further than d rooms away from her current room, or stay in place. Each student can optionally hide under a bed.  Instructors move from room 1 to room 2 and from room n to room n - 1.  This process continues until all rooms are processed. Let x1 denote the number of rooms in which the first instructor counted the number of non-hidden students different from b, and x2 be the same number for the second instructor. Students know that the principal will only listen to one complaint, therefore they want to minimize the maximum of numbers xi. Help them find this value if they use the optimal strategy.","read = lambda: map(int, input().split())
n, d, b = read()
d += 1
t, a = 0, [0] * (n + 1)
for i, x in enumerate(read()):
    t += x
    a[i + 1] = t
print(max(i - min(a[min(n, i * d)], (a[n] - a[max(0, n - i * d)])) // b for i in range(n + 3 >> 1)))","['binary search', 'sortings', 'greedy', 'brute force']"
"Celebrating the new year, many people post videos of falling dominoes; Here's a list of them: https://www.youtube.com/results?search_query=New+Years+Dominos User ainta, who lives in a 2D world, is going to post a video as well.There are n dominoes on a 2D Cartesian plane. i-th domino (1 ≤ i ≤ n) can be represented as a line segment which is parallel to the y-axis and whose length is li. The lower point of the domino is on the x-axis. Let's denote the x-coordinate of the i-th domino as pi. Dominoes are placed one after another, so p1 &lt; p2 &lt; ... &lt; pn - 1 &lt; pn holds.User ainta wants to take a video of falling dominoes. To make dominoes fall, he can push a single domino to the right. Then, the domino will fall down drawing a circle-shaped orbit until the line segment totally overlaps with the x-axis.   Also, if the s-th domino touches the t-th domino while falling down, the t-th domino will also fall down towards the right, following the same procedure above. Domino s touches domino t if and only if the segment representing s and t intersects.   See the picture above. If he pushes the leftmost domino to the right, it falls down, touching dominoes (A), (B) and (C). As a result, dominoes (A), (B), (C) will also fall towards the right. However, domino (D) won't be affected by pushing the leftmost domino, but eventually it will fall because it is touched by domino (C) for the first time.  The picture above is an example of falling dominoes. Each red circle denotes a touch of two dominoes.User ainta has q plans of posting the video. j-th of them starts with pushing the xj-th domino, and lasts until the yj-th domino falls. But sometimes, it could be impossible to achieve such plan, so he has to lengthen some dominoes. It costs one dollar to increase the length of a single domino by 1. User ainta wants to know, for each plan, the minimum cost needed to achieve it. Plans are processed independently, i. e. if domino's length is increased in some plan, it doesn't affect its length in other plans. Set of dominos that will fall except xj-th domino and yj-th domino doesn't matter, but the initial push should be on domino xj.","import sys
range = xrange
input = raw_input

class segtree:
    def __init__(s, data, f):
        s.n = len(data)
        s.m = 1
        s.f = f
        while s.m < s.n:
            s.m *= 2
        s.data = [0]*(2 * s.m)
        s.data[s.m: s.m + s.n] = data
        for i in reversed(range(1, s.m)):
            s.data[i] = f(s.data[2 * i], s.data[2 * i + 1])
    def set(s, i, x):
        i += s.m
        while i:
            s.data[i] = x
            x = s.f(x, s.data[i ^ 1])
            i >>= 1
    def query(s, l, r):
        l += s.m
        r += s.m
        x = s.data[l]
        while l<r:
            if l & 1:
                x = s.f(x, s.data[l])
                l += 1
            if r & 1:
                x = s.f(x, s.data[r - 1])
            l >>= 1
            r >>= 1
        return x

inp = [int(x) for x in sys.stdin.read().split()]
ii = 0

n = inp[ii]
ii += 1

L = inp[ii:ii + 2*n:2]
lens = inp[ii + 1:ii + 2*n:2]
ii += 2*n
R = [L[i] + lens[i] + 1 for i in range(n)]
Rseg = segtree(R, max)

DP = [0]*n
DPseg = segtree(DP, min)
for i in reversed(range(n - 1)):
    if R[i] <= L[i + 1]:
        DP[i] = L[i + 1] - R[i] + 1 + DP[i + 1]
    else:
        a = i + 1
        b = n - 1
        r = R[i]
        while a < b:
            c = a + b + 1 >> 1
            if L[c] < r:
                a = c
            else:
                b = c - 1
        DP[i] = DPseg.query(i + 1, a + 1)
        if a + 1 < n:
            DP[i] = min(DP[i], L[a + 1] - r + 1 + DP[a + 1])
    DPseg.set(i, DP[i])

q = inp[ii]
ii += 1

out = []
for _ in range(q):
    x = inp[ii] - 1
    ii += 1
    y = inp[ii]
    ii += 1

    cost = DP[x]
    r = Rseg.query(x,y)
        
    a = y - 1
    b = n - 1
    while a < b:
        c = a + b + 1 >> 1
        if L[c] < r:
            a = c
        else:
            b = c - 1
    cost -= DPseg.query(x, a + 1)
    out.append(cost)

print '\n'.join(str(x) for x in out)","['dp', 'dsu', 'data structures']"
"Kolya got an integer array $$$a_1, a_2, \dots, a_n$$$. The array can contain both positive and negative integers, but Kolya doesn't like $$$0$$$, so the array doesn't contain any zeros.Kolya doesn't like that the sum of some subsegments of his array can be $$$0$$$. The subsegment is some consecutive segment of elements of the array. You have to help Kolya and change his array in such a way that it doesn't contain any subsegments with the sum $$$0$$$. To reach this goal, you can insert any integers between any pair of adjacent elements of the array (integers can be really any: positive, negative, $$$0$$$, any by absolute value, even such a huge that they can't be represented in most standard programming languages).Your task is to find the minimum number of integers you have to insert into Kolya's array in such a way that the resulting array doesn't contain any subsegments with the sum $$$0$$$.","n = int(input())
a = list(map(int,input().split()))
p = {0: 1};c=0;result = 0
for i in range(n):
    c+=a[i]
    if c in p:

        result += 1

        p = {0 : 1}

        c = a[i]
    p[c] = 1


print(result)","['data structures', 'constructive algorithms', 'sortings', 'greedy']"
"Consider the function p(x), where x is an array of m integers, which returns an array y consisting of m + 1 integers such that yi is equal to the sum of first i elements of array x (0 ≤ i ≤ m).You have an infinite sequence of arrays A0, A1, A2..., where A0 is given in the input, and for each i ≥ 1 Ai = p(Ai - 1). Also you have a positive integer k. You have to find minimum possible i such that Ai contains a number which is larger or equal than k.","def p(arr):
	for i in range(1,len(arr)):
		arr[i]+=arr[i-1]
	return arr

def max_element(arr):
	x=0
	for i in arr:
		x=max(x,i)
	return x

def kek(a,b):
	if (a<=b):
		return 1
	else:
		return 0

[n,k]=[int(x) for x in input().split()]

def matmul(m1,m2):
	s=0     #сумма
	t=[]    #временная матрица
	m3=[] # конечная матрица
	if len(m2)!=len(m1[0]):
		print(""333"")       
	else:
		r1=len(m1) #количество строк в первой матрице
		c1=len(m1[0]) #Количество столбцов в 1   
		r2=c1           #и строк во 2ой матрице
		c2=len(m2[0])  # количество столбцов во 2ой матрице
		for z in range(0,r1):
			for j in range(0,c2):
				for i in range(0,c1):
					s=s+m1[z][i]*m2[i][j]
					s=min(s,k)
				t.append(s)
				s=0
			m3.append(t)
			t=[]           
	return m3	

def exp(m,p):
	if (p==1):
		return m
	if (p%2==0):
		w=exp(m,p//2)
		return matmul(w,w)
	else:
		return matmul(m,exp(m,p-1))



a=[int(x) for x in input().split()]
ind=0
while a[ind]==0:
	ind+=1
a=a[ind:]
n=len(a)
if (max_element(a)>=k):
	print(0)
else:
	a=[a]
	if (n>=10):
		res=0
		while(max_element(a[0])<k):
			res+=1
			a[0]=p(a[0])
		print(res)
	elif n==2:
		x1=a[0][0]
		x2=a[0][1]
		print((k-x2+x1-1)//x1)
	else:
		m=[]
		for i in range(n):
			m+=[[kek(i,j) for j in range(n)]]
		l=0;
		r=10**18
		while(l+1<r):
			mid=(l+r)//2;
			b=matmul(a,exp(m,mid))
			if max_element(b[0])<k:
				l=mid
			else:
				r=mid
		print(r)","['combinatorics', 'math', 'matrices', 'binary search', 'brute force']"
"There is a forest that we model as a plane and live $$$n$$$ rare animals. Animal number $$$i$$$ has its lair in the point $$$(x_{i}, y_{i})$$$. In order to protect them, a decision to build a nature reserve has been made.The reserve must have a form of a circle containing all lairs. There is also a straight river flowing through the forest. All animals drink from this river, therefore it must have at least one common point with the reserve. On the other hand, ships constantly sail along the river, so the reserve must not have more than one common point with the river.For convenience, scientists have made a transformation of coordinates so that the river is defined by $$$y = 0$$$. Check whether it is possible to build a reserve, and if possible, find the minimum possible radius of such a reserve.","l , r =-100000000, 1000000000
def check(mid):
    mx = 0
    for i in range(n):

        x,y = x1[i],y1[i]
        mx = max (mx ,(x1[i] - mid) ** 2 / (2 * y1[i]) + (y1[i] / 2))

    return mx



n = int(input())
count1 = 0
count2 = 0
x1 = []
y1 = []
for i in range(n):
    a,b = map(int,input().split())
    if b>=0:
        count1+=1
    else:
        count2+=1

    x1.append(a)
    y1.append(abs(b))

if count1 and count2:

    print(-1)
    exit()


for i in range(100):
    mid1 = l+(r-l)/3
    mid2 = r-(r-l)/3
    if check(mid1)>check(mid2):
        l = mid1
    else:
        r = mid2
    # print(l,r)
print(check(l))","['binary search', 'geometry', 'ternary search']"
"Despite his bad reputation, Captain Flint is a friendly person (at least, friendly to animals). Now Captain Flint is searching worthy sailors to join his new crew (solely for peaceful purposes). A sailor is considered as worthy if he can solve Flint's task.Recently, out of blue Captain Flint has been interested in math and even defined a new class of integers. Let's define a positive integer $$$x$$$ as nearly prime if it can be represented as $$$p \cdot q$$$, where $$$1 &lt; p &lt; q$$$ and $$$p$$$ and $$$q$$$ are prime numbers. For example, integers $$$6$$$ and $$$10$$$ are nearly primes (since $$$2 \cdot 3 = 6$$$ and $$$2 \cdot 5 = 10$$$), but integers $$$1$$$, $$$3$$$, $$$4$$$, $$$16$$$, $$$17$$$ or $$$44$$$ are not.Captain Flint guessed an integer $$$n$$$ and asked you: can you represent it as the sum of $$$4$$$ different positive integers where at least $$$3$$$ of them should be nearly prime.Uncle Bogdan easily solved the task and joined the crew. Can you do the same?","for _ in range(int(input())):

    n = int(input())
    if n <= 30:
        print('no')
    else:
        print('Yes')
        if n != 36 and n != 44 and n != 40:
            print(6, 10, 14, n-30)

        else:
            print(6, 10, 15, n-31)","['number theory', 'greedy', 'math', 'brute force']"
"Olya likes milk very much. She drinks k cartons of milk each day if she has at least k and drinks all of them if she doesn't. But there's an issue — expiration dates. Each carton has a date after which you can't drink it (you still can drink it exactly at the date written on the carton). Due to this, if Olya's fridge contains a carton past its expiry date, she throws it away.Olya hates throwing out cartons, so when she drinks a carton, she chooses the one which expires the fastest. It's easy to understand that this strategy minimizes the amount of cartons thrown out and lets her avoid it if it's even possible.    Milk. Best before: 20.02.2017. The main issue Olya has is the one of buying new cartons. Currently, there are n cartons of milk in Olya's fridge, for each one an expiration date is known (how soon does it expire, measured in days). In the shop that Olya visited there are m cartons, and the expiration date is known for each of those cartons as well.Find the maximum number of cartons Olya can buy so that she wouldn't have to throw away any cartons. Assume that Olya drank no cartons today.","import sys, collections

raw_input = sys.stdin.readline
n, m, k = map(int, raw_input().split())
current = map(int, raw_input().split())
store = map(int, raw_input().split())
milk = [0]*(10**7 + 1)
store_indexes = collections.defaultdict(list)
current.sort()
max_index = 10**7 + 1
valid = True
ans = []
count = 0

for i in xrange(m):
    store_indexes[store[i]].append(i+1)

store.sort()
for i in xrange(n-1, -1, -1):
    index = min(current[i], max_index)        
    while milk[index] >= k and index > -1:
        index -= 1

    if index == -1:
        valid = False
        break
    
    max_index = min(max_index, index)
    milk[index] += 1
    #print milk[:3]
    
if not valid:
    print -1
    raise SystemExit
else:
    min_index = 0
    for i in xrange(m):
        stop = store[i]
        index = min(stop, min_index)
        while milk[index] >= k and index <= stop:
            index += 1

        if index <= stop:
            milk[index] += 1
            count += 1
            ans.append(str(store_indexes[stop].pop()))

        min_index = max(min_index, index)
        #print milk[:3], count, stop

print count
print "" "".join(ans)","['greedy', 'two pointers', 'sortings', 'data structures', 'binary search']"
"Carl has $$$n$$$ coins of various colors, and he would like to sort them into piles. The coins are labeled $$$1,2,\ldots,n$$$, and each coin is exactly one of red, green, or blue. He would like to sort the coins into three different piles so one pile contains all red coins, one pile contains all green coins, and one pile contains all blue coins.Unfortunately, Carl is colorblind, so this task is impossible for him. Luckily, he has a friend who can take a pair of coins and tell Carl if they are the same color or not. Using his friend, Carl believes he can now sort the coins. The order of the piles doesn't matter, as long as all same colored coins are in the one pile, and no two different colored coins are in the same pile.His friend will answer questions about multiple pairs of coins in batches, and will answer about all of those pairs in parallel. Each coin should be in at most one pair in each batch. The same coin can appear in different batches.Carl can use only $$$7$$$ batches. Help him find the piles of coins after sorting.","t=int(input())
for _ in range(t):
    n=int(input())
    print(""Q"",n//2,"" "".join([str(i+1) for i in range(n//2*2)]))
    s1=input()
    print(""Q"",n-n//2-1,"" "".join([str(i+2) for i in range((n-n//2-1)*2)]))
    s2=input()
    con=[0]*(n-1)
    for i in range(n//2):
        con[2*i]=int(s1[i])
    for i in range(n-n//2-1):
        con[2*i+1]=int(s2[i])
    ints=[]
    start=1
    end=1
    for guy in con:
        if guy==0:
            ints.append((start,end))
            start,end=end+1,end+1
        else:
            end+=1
    ints.append((start,end))
    k=len(ints)
    things=[]
    for i in range(k-2):
        if i%4==0 or i%4==1:
            things.append(i)
            things.append(i+2)
    print(""Q"",len(things)//2,"" "".join([str(ints[guy][0]) for guy in things]))
    s1=input()
    others=[]
    for i in range(k-2):
        if i%4==2 or i%4==3:
            others.append(i)
            others.append(i+2)
    print(""Q"",len(others)//2,"" "".join([str(ints[guy][0]) for guy in others]))
    s2=input()
    skips=[0]*(k-2)
    for i in range(len(things)//2):
        skips[things[2*i]]=int(s1[i])
    for i in range(len(others)//2):
        skips[others[2*i]]=int(s2[i])
    cols=[0,1]
    for i in range(k-2):
        if skips[i]==1:
            cols.append(cols[-2])
        else:
            cols.append(2*(cols[-1]+cols[-2])%3)
    a=[]
    b=[]
    c=[]
    for i in range(k):
        if cols[i]==0:
            for guy in range(ints[i][0],ints[i][1]+1):
                a.append(guy)
        elif cols[i]==1:
            for guy in range(ints[i][0],ints[i][1]+1):
                b.append(guy)
        else:
            for guy in range(ints[i][0],ints[i][1]+1):
                c.append(guy)
    print(""A"",len(a),len(b),len(c))
    print(*a)
    print(*b)
    print(*c)",['interactive']
"The Old City is a rectangular city represented as an m × n grid of blocks. This city contains many buildings, straight two-way streets and junctions. Each junction and each building is exactly one block. All the streets have width of one block and are either vertical or horizontal. There is a junction on both sides of each street. We call two blocks adjacent if and only if they share a common side. No two blocks of different streets are adjacent and no two junctions are adjacent. There is an annual festival and as a part of it, The Old Peykan follows a special path in the city. This path starts from a block in a street, continues with many junctions and ends in a block of some street. For each street block, we know how much time it takes for the Old Peykan to go from this block to an adjacent block. Also the Old Peykan can go from each junction to its adjacent street blocks in one minute. Of course Old Peykan can't go to building blocks.We know the initial position of the Old Peykan and the sequence of junctions that it passes to reach its destination. After passing all the junctions and reaching the destination, it will stay there forever. Your task is to find out where will the Old Peykan be k minutes after it starts moving. Consider that The Old Peykan always follows the shortest path that passes through the given sequence of junctions and reaches the destination.Note that the Old Peykan may visit some blocks more than once.","#t = input()
t = 1
def xstep(p, q):
    if p<q:
        return p+1
    elif p>q:
        return p-1
    else:
        return p
def step(p, q):
    return (xstep(p[0], q[0]), xstep(p[1], q[1]))
for _ in range(t):
    n, m, k = tuple(int(x) for x in raw_input().split())
    tbl = [list(raw_input()) for i in range(n)]
    ind = {}
    for r in range(len(tbl)):
        for c in range(len(tbl[r])):
            if ord(tbl[r][c])>=ord('a') and ord(tbl[r][c])<=ord('z'):
                ind[tbl[r][c]]=(r,c)
                tbl[r][c]='1'
    l = {}
    for r in range(len(tbl)):
        for c in range(len(tbl[r])):
            if ord(tbl[r][c])>=ord('1') and ord(tbl[r][c])<=ord('9'):
                l[r, c] = int(tbl[r][c])
    inp = raw_input().split()
    path = []
    path.append((int(inp[0])-1, int(inp[1])-1))
    for c in inp[2]:
        path.append(ind[c])
    path.append((int(inp[3])-1, int(inp[4])-1))
    (x, y) = path[0]
    good = False
    for dest in path:
        while (x, y) != dest:
            if k>=l[x, y]:
                k-=l[x, y]
                (x, y) = step((x, y), dest)
            else:
                print x+1, y+1
                good = True
                break
        if good:
            break
    if not good:
        print path[-1][0]+1, path[-1][1]+1","['implementation', 'brute force']"
"Hamming distance between strings a and b of equal length (denoted by h(a, b)) is equal to the number of distinct integers i (1 ≤ i ≤ |a|), such that ai ≠ bi, where ai is the i-th symbol of string a, bi is the i-th symbol of string b. For example, the Hamming distance between strings ""aba"" and ""bba"" equals 1, they have different first symbols. For strings ""bbba"" and ""aaab"" the Hamming distance equals 4.John Doe had a paper on which four strings of equal length s1, s2, s3 and s4 were written. Each string si consisted only of lowercase letters ""a"" and ""b"". John found the Hamming distances between all pairs of strings he had. Then he lost the paper with the strings but he didn't lose the Hamming distances between all pairs.Help John restore the strings; find some four strings s'1, s'2, s'3, s'4 of equal length that consist only of lowercase letters ""a"" and ""b"", such that the pairwise Hamming distances between them are the same as between John's strings. More formally, set s'i must satisfy the condition . To make the strings easier to put down on a piece of paper, you should choose among all suitable sets of strings the one that has strings of minimum length.","def get_input():

    a, b, d = map(int, input().split())

    c, e = map(int, input().split())

    f = int(input())

    return [a, b, c, d, e, f]





def check_condition(a, b, c, d, e, f):

    condition1 = (a + b + c) % 2 == 0

    condition2 = (d + e + a) % 2 == 0

    condition3 = (e + f + c) % 2 == 0

    condition4 = (d + f + b) % 2 == 0

    condition = condition1 and condition2 and condition3 and condition4

    return condition





def find_t(a, b, c, d, e, f):

    t_min1 = round((d + f - a - c) / 2)

    t_min2 = round((e + f - a - b) / 2)

    t_min3 = round((d + e - b - c) / 2)

    t_min4 = 0

    t_min = max(t_min1, t_min2, t_min3, t_min4)

    t_max1 = round((d + e - a) / 2)

    t_max2 = round((e + f - c) / 2)

    t_max3 = round((d + f - b) / 2)

    t_max = min(t_max1, t_max2, t_max3)

    if t_min <= t_max:

        return t_min

    else:

        return -1





def find_all(a, b, c, d, e, f, t):

    x1 = round((a + c - d - f) / 2 + t)

    x2 = round((d + f - b) / 2 - t)

    y1 = round((a + b - e - f) / 2 + t)

    y2 = round((e + f - c) / 2 - t)

    z1 = round((b + c - d - e) / 2 + t)

    z2 = round((d + e - a) / 2 - t)

    return [x1, x2, y1, y2, z1, z2]





def generate_string(x1, x2, y1, y2, z1, z2, t):

    n = x1 + x2 + y1 + y2 + z1 + z2 + t

    s1 = ''.join(['a'] * n)

    s2 = ''.join(['a'] * (z1 + z2 + t)) + ''.join(['b'] * (x1 + x2 + y1 + y2))

    s3 = ''.join(['a'] * t) + ''.join(['b'] * (y1 + y2 + z1 + z2)) + ''.join(['a'] * (x1 + x2))

    s4 = ''.join(['b'] * (t + z2)) + ''.join(['a'] * (z1 + y2)) + ''.join(['b'] * (y1 + x2)) + ''.join(['a'] * x1)

    return [s1, s2, s3, s4]





def __main__():

    fail_output = ""-1""

    a, b, c, d, e, f = map(int, get_input())

    if not(check_condition(a, b, c, d, e, f)):

        print(fail_output)

        return False

    t = find_t(a, b, c, d, e, f)

    if t < 0:

        print(fail_output)

        return False

    x1, x2, y1, y2, z1, z2 = map(int, find_all(a, b, c, d, e, f, t))

    s1, s2, s3, s4 = map(str, generate_string(x1, x2, y1, y2, z1, z2, t))

    print(str(x1 + x2 + y1 + y2 + z1 + z2 + t) + '\n')

    print(s1 + '\n')

    print(s2 + '\n')

    print(s3 + '\n')

    print(s4 + '\n')





__main__()





# Made By Mostafa_Khaled","['constructive algorithms', 'greedy', 'math', 'matrices']"
"You have matrix a of size n × n. Let's number the rows of the matrix from 1 to n from top to bottom, let's number the columns from 1 to n from left to right. Let's use aij to represent the element on the intersection of the i-th row and the j-th column. Matrix a meets the following two conditions:   for any numbers i, j (1 ≤ i, j ≤ n) the following inequality holds: aij ≥ 0;  . Matrix b is strictly positive, if for any numbers i, j (1 ≤ i, j ≤ n) the inequality bij &gt; 0 holds. You task is to determine if there is such integer k ≥ 1, that matrix ak is strictly positive.","#!py2

def solve(N, A):
    graph = [set() for _ in xrange(N)]
    rgraph = [set() for _ in xrange(N)]
    
    for u, row in enumerate(A):
        for v, val in enumerate(row):
            if val:
                graph[u].add(v)
                rgraph[v].add(u)
    
    # Try to write row 0 in terms of row i
    stack, seen = [0], {0}
    while stack:
        node = stack.pop()
        for nei in graph[node]:
            if nei not in seen:
                seen.add(nei)
                stack.append(nei)
    if len(seen) != N:
        return False

    # Try to write row i in terms of row 0
    stack, seen = [0], {0}
    while stack:
        node = stack.pop()
        for nei in rgraph[node]:
            if nei not in seen:
                seen.add(nei)
                stack.append(nei)
    return len(seen) == N


N = int(raw_input())
A = [[+(x != '0') for x in raw_input().split()]
     for _ in xrange(N)]
print ""YES"" if solve(N, A) else ""NO""","['math', 'graphs']"
"The Bytelandian Institute for Biological Research (BIBR) is investigating the properties of two species of bacteria, named simply 0 and 1. Even under a microscope, bacteria of those two species are very difficult to distinguish. In fact, the only thing the scientists possess that is able to differentiate between them is a plant called Formurosa.If the scientists place a sample of colonies of bacteria on each on Formurosa's leaves, it will activate a complicated nutrition process. During that process color of Formurosa changes to reflect the result of a — possibly very complicated — logical formula on the species of bacteria, involving constants and the operators | (OR), &amp; (AND) and ^ (XOR). If it is 0, the plant will turn red, otherwise — it will turn blue.For example, if the nutrition process of Formurosa is described by the formula: (((?^?)|?)&amp;(1^?)); then Formurosa has four leaves (the ""?"" signs denote the leaves). If we place 0, 1, 0, 0 on the respective leaves, the result of the nutrition process will be (((0^1)|0)&amp;(1^0)) = 1, therefore the plant will turn blue.The scientists have n colonies of bacteria. They do not know their types; the only thing they know for sure is that not all colonies are of the same type. They want to attempt to determine the bacteria's species by repeated evaluations with Formurosa. During each evaluation they must place exactly one sample on every leaf of the plant. However, they may use multiple samples of one colony during a single evaluation; they can even cover the whole plant with bacteria from one colony!Is it possible for them to always determine the species of each colony, no matter what they are (assuming they are not all the same)?","n = int(raw_input())
f = raw_input()

ls = []
os = []

tmp = [[[0 for k in range(16)] for j in range(16)] for i in range(3)]

# 0
# 1
# a
# na
""""""
def maeshori():
    for i in range(3):
        for j in range(16):
            for k in range(16):
                tmp[i][j][k] = 0
    for j in range(16):
        for k in range(16):
            for i1,ii1 in [(p,2**p) for p in range(4)]:
                for i2,ii2 in [(p,2**p) for p in range(4)]:
                    if j&ii1==0 or k&ii2==0: continue
                    if i1<=1 and i2<=1: ans.add(i1&i2)
                        if tmp[0][j][k]&(2**(i1&i2))==0: tmp[0][j][k] += 2**(i1&i2)
                    elif (i1,i2) in [(0,2), (0,3), (2,0), (3,0), (2,3), (3,2)]:
                        if tmp[0][j][k]&1==0: tmp[0][j][k] += 1
                    elif (i1,i2) in [(1,2), (2,1), (2,2)]: ans.add(2)
                    elif (i1,i2) in [(1,3), (3,1), (3,3)]: ans.add(3)
""""""                    
""""""
    if o=='&':
    for i1 in u1:
    for i2 in u2:
    if i1<=1 and i2<=1: ans.add(i1&i2)
    elif (i1,i2) in [(0,2), (0,3), (2,0), (3,0), (2,3), (3,2)]: ans.add(0)
    elif (i1,i2) in [(1,2), (2,1), (2,2)]: ans.add(2)
    elif (i1,i2) in [(1,3), (3,1), (3,3)]: ans.add(3)
    if o=='|':
    for i1 in u1:
    for i2 in u2:
    if i1<=1 and i2<=1: ans.add(i1|i2)
    elif (i1,i2) in [(1,2), (1,3), (2,1), (3,1), (2,3), (3,2)]: ans.add(1)
    elif (i1,i2) in [(0,2), (2,0), (2,2)]: ans.add(2)
    elif (i1,i2) in [(0,3), (3,0), (3,3)]: ans.add(3)
    if o=='^':
    for i1 in u1:
    for i2 in u2:
    if i1<=1 and i2<=1: ans.add(i1^i2)
    elif (i1,i2) in [(2,2), (3,3)]: ans.add(0)
    elif (i1,i2) in [(2,3), (3,2)]: ans.add(1)
    elif (i1,i2) in [(0,2), (2,0), (1,3), (3,1)]: ans.add(2)
    elif (i1,i2) in [(0,3), (3,0), (1,2), (2,1)]: ans.add(3)
""""""

for ch in f:
    if ch==')':
        u1 = ls.pop()
        o = os.pop()
        u2 = ls.pop()
        ans = set([])
        if o=='&':
            for i1 in u1:
                for i2 in u2:
                    if (i1,i2) in ((0,0), (0,1), (1,0), (0,2), (2,0)): ans.add(0)
                    elif (i1,i2)==(1,1): ans.add(1)
                    elif (i1,i2) in ((1,2), (2,1)): ans.add(2)
                    elif (i1,i2)==(2,2): 
                        ans.add(0)
                        ans.add(2)
        elif o=='|':
#           print u1, u2, o
            for i1 in u1:
                for i2 in u2:
#                   print i1,i2
                    if (i1,i2)==(0,0): ans.add(0)
                    elif (i1,i2) in ((0,1), (1,0), (1,1), (1,2), (2,1)): ans.add(1)
                    elif (i1,i2) in ((0,2), (2,0)): ans.add(2)
                    elif (i1,i2)==(2,2):
                        ans.add(1)
                        ans.add(2)
        elif o=='^':
            for i1 in u1:
                for i2 in u2:
                    if (i1,i2) in ((0,0), (1,1)): ans.add(0)
                    elif (i1,i2) in ((0,1), (1,0)): ans.add(1)
                    elif (i1,i2)==(2,2):
                        ans.add(0)
                        ans.add(1)
                    elif (i1,i2) in [(0,2), (2,0), (1,2), (2,1)]:
                        ans.add(2)
        ls.append(ans)
#       print ls
    elif ch=='0': ls.append(set([0]))
    elif ch=='1': ls.append(set([1]))
    elif ch=='?': ls.append(set([2]))
    elif ch in ('&', '|', '^'): os.append(ch)

ans = ls.pop()
if (2 in ans): print 'YES'
else: print 'NO'","['dp', 'divide and conquer', 'expression parsing']"
"The government of Berland decided to improve network coverage in his country. Berland has a unique structure: the capital in the center and $$$n$$$ cities in a circle around the capital. The capital already has a good network coverage (so the government ignores it), but the $$$i$$$-th city contains $$$a_i$$$ households that require a connection.The government designed a plan to build $$$n$$$ network stations between all pairs of neighboring cities which will maintain connections only for these cities. In other words, the $$$i$$$-th network station will provide service only for the $$$i$$$-th and the $$$(i + 1)$$$-th city (the $$$n$$$-th station is connected to the $$$n$$$-th and the $$$1$$$-st city).All network stations have capacities: the $$$i$$$-th station can provide the connection to at most $$$b_i$$$ households.Now the government asks you to check can the designed stations meet the needs of all cities or not — that is, is it possible to assign each household a network station so that each network station $$$i$$$ provides the connection to at most $$$b_i$$$ households.","'''import sys
input = sys.stdin.readline
for _ in range(int(input())):
    n = int(input())
    a = [int(x) for x in input().split()]
    b = [int(x) for x in input().split()]
    ok = False
    w = 0
    for i in range(1, n * 2):
        w = max(0, w) + a[i % n] - b[(i - 1) % n]
        if w > b[i % n]:
            ok = True
            break
    ok |= sum(a) - sum(b) > 0
    print(['YES', 'NO'][ok])'''
from collections import defaultdict
import sys
input=sys.stdin.readline
def checker(a,b,pq):
    if pq>b[-1]:
        return(False)
    for i in range(n):
        if i==0:
            x=max(0,min(b[i-1]-pq,a[i]-pq))
            #print(x,pq)
            b[i-1]-=x
            a[i]-=x
            y=min(a[i],b[i])
            b[i]-=y
            a[i]-=y
        else:
            x=min(b[i-1],a[i])
            b[i-1]-=x
            a[i]-=x
            y=min(a[i],b[i])
            b[i]-=y
            a[i]-=y
        #print(copy1,copy2,pq)
    if set(copy1)=={0}:
        return(True)
    return(False)
    
t=int(input())
for ii in range(t):
        n=int(input())
        a=[int(i) for i in input().split() if i!='\n']
        b=[int(i) for i in input().split() if i!='\n']
        copy1=a[:]
        copy2=b[:]
        for i in range(n):
                x=min(b[i-1],a[i])
                b[i-1]-=x
                a[i]-=x
                y=min(a[i],b[i])
                b[i]-=y
                a[i]-=y
        #print(a,b)
        for i in range(len(a)):
                if a[i]>0:
                    if i==n-1:
                        #print(a[i])
                        if checker(copy1,copy2,a[-1]):
                            #print('1')
                            print('YES')
                            break
                        else:
                            print('NO')
                            break
                    else:
                        print(""NO"")
                        break
        else:
                print(""YES"")","['data structures', 'constructive algorithms', 'binary search', 'greedy']"
Petya and Vasya are inventing a new game that requires a rectangular board and one chess piece. At the beginning of the game the piece stands in the upper-left corner of the board. Two players move the piece in turns. Each turn the chess piece can be moved either one square to the right or one square down or jump k squares diagonally down and to the right. The player who can’t move the piece loses.   The guys haven’t yet thought what to call the game or the best size of the board for it. Your task is to write a program that can determine the outcome of the game depending on the board size.,"#!/usr/bin/python

c = ['-', '+']

infile = open(""input.txt"")
outfile = open(""output.txt"", 'w')

t, k = map(lambda x: int(x), infile.readline().split())
for i in range(t):
	n, m = map(lambda x: int(x)-1, infile.readline().split())
	if n > m:
		n, m = m, n
	if k >= 2:
		r = n % (2*k + 2)
		if r == k or r == 2*k+1:
			outfile.write('+\n')
		elif r <= k-1:
			outfile.write(c[(m+n)%2]+'\n')
		else:
			outfile.write(c[(m+n+1)%2]+'\n')
	else:
		if n % 2 == 1:
			outfile.write('+\n')
		else:
			outfile.write(c[(m+n)%2]+'\n')",['games']
"Xenia the horse breeder has n (n &gt; 1) horses that stand in a row. Each horse has its own unique number. Initially, the i-th left horse has number i. That is, the sequence of numbers of horses in a row looks as follows (from left to right): 1, 2, 3, ..., n.Xenia trains horses before the performance. During the practice sessions, she consistently gives them commands. Each command is a pair of numbers l, r (1 ≤ l &lt; r ≤ n). The command l, r means that the horses that are on the l-th, (l + 1)-th, (l + 2)-th, ..., r-th places from the left must be rearranged. The horses that initially stand on the l-th and r-th places will swap. The horses on the (l + 1)-th and (r - 1)-th places will swap. The horses on the (l + 2)-th and (r - 2)-th places will swap and so on. In other words, the horses that were on the segment [l, r] change their order to the reverse one.For example, if Xenia commanded l = 2, r = 5, and the sequence of numbers of horses before the command looked as (2, 1, 3, 4, 5, 6), then after the command the sequence will be (2, 5, 4, 3, 1, 6).We know that during the practice Xenia gave at most three commands of the described form. You have got the final sequence of numbers of horses by the end of the practice. Find what commands Xenia gave during the practice. Note that you do not need to minimize the number of commands in the solution, find any valid sequence of at most three commands.","n = input()
a = [0] + map(int, raw_input().split())
la, ra, m = [0]*3, [0]*3, 0

def left():
    for i in xrange(1, n+1):
        if a[i] != i:
            return i
    return 0

def right():
    for i in xrange(n, 0, -1):
        if a[i] != i:
            return i
    return 0

def find(x):
    for i in xrange(1, n+1):
        if a[i] == x:
            return i

def dfs(x):
    global a, la, ra, m
    l = left()
    if l == 0: return True
    if x == 3: return False 
    r = find(l)
    a[l:r+1] = a[r:l-1:-1]
    if dfs(x+1):
        la[m] = l
        ra[m] = r
        m += 1
        return True
    a[l:r+1] = a[r:l-1:-1]
    r = right()
    l = find(r)
    a[l:r+1] = a[r:l-1:-1]
    if dfs(x+1):
        la[m] = l
        ra[m] = r
        m += 1
        return True
    a[l:r+1] = a[r:l-1:-1]
    return False
    
dfs(0)

print m
for i in xrange(m):
    print la[i], ra[i]","['constructive algorithms', 'dfs and similar', 'greedy']"
"Janusz is a businessman. He owns a company ""Januszex"", which produces games for teenagers. Last hit of Januszex was a cool one-person game ""Make it one"". The player is given a sequence of $$$n$$$ integers $$$a_i$$$.It is allowed to select any subset of them, and the score is equal to the greatest common divisor of selected elements. The goal is to take as little elements as it is possible, getting the score $$$1$$$. Now Janusz wonders, for given sequence, how much elements should the player choose?","mod = int(1e9+7)
N = int(3e5+7)
fact = [0]*(N)
invfact = [0]*(N)
cnt = [0]*N
def ncr(n, r): 
    r = min(r, n-r)
    if n<r or r<0:
        return 0
    return ((fact[n] * invfact[r]) % mod * invfact[n-r]) % mod
fact[0] = 1
for i in range(1,N):
    fact[i] = (fact[i - 1] * i) % mod;
invfact[N-1] = pow(fact[N-1],mod-2,mod)
for i in range(N-1,0,-1):
    invfact[i-1] = (invfact[i]*i)%mod
n = int(raw_input(''))
a = map(int,raw_input().strip('\n').split(' '))
for i in a:
	cnt[i] += 1
for i in range(1,N):
	for j in range(i+i,N,i):
		cnt[i]+=cnt[j]
ans = -1
for i in range(1,10):
	dp = [0]*N
	for j in range(N-1,0,-1):
		dp[j]=ncr(cnt[j],i)
		for k in range(j+j,N,j):
			dp[j] = (dp[j]-dp[k])%mod
	if dp[1]>0:
		ans = i
		break
print ans","['dp', 'combinatorics', 'number theory', 'bitmasks', 'shortest paths', 'math']"
"Let $$$a$$$ and $$$b$$$ be two arrays of lengths $$$n$$$ and $$$m$$$, respectively, with no elements in common. We can define a new array $$$\mathrm{merge}(a,b)$$$ of length $$$n+m$$$ recursively as follows:  If one of the arrays is empty, the result is the other array. That is, $$$\mathrm{merge}(\emptyset,b)=b$$$ and $$$\mathrm{merge}(a,\emptyset)=a$$$. In particular, $$$\mathrm{merge}(\emptyset,\emptyset)=\emptyset$$$.  If both arrays are non-empty, and $$$a_1&lt;b_1$$$, then $$$\mathrm{merge}(a,b)=[a_1]+\mathrm{merge}([a_2,\ldots,a_n],b)$$$. That is, we delete the first element $$$a_1$$$ of $$$a$$$, merge the remaining arrays, then add $$$a_1$$$ to the beginning of the result.  If both arrays are non-empty, and $$$a_1&gt;b_1$$$, then $$$\mathrm{merge}(a,b)=[b_1]+\mathrm{merge}(a,[b_2,\ldots,b_m])$$$. That is, we delete the first element $$$b_1$$$ of $$$b$$$, merge the remaining arrays, then add $$$b_1$$$ to the beginning of the result. This algorithm has the nice property that if $$$a$$$ and $$$b$$$ are sorted, then $$$\mathrm{merge}(a,b)$$$ will also be sorted. For example, it is used as a subroutine in merge-sort. For this problem, however, we will consider the same procedure acting on non-sorted arrays as well. For example, if $$$a=[3,1]$$$ and $$$b=[2,4]$$$, then $$$\mathrm{merge}(a,b)=[2,3,1,4]$$$.A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).There is a permutation $$$p$$$ of length $$$2n$$$. Determine if there exist two arrays $$$a$$$ and $$$b$$$, each of length $$$n$$$ and with no elements in common, so that $$$p=\mathrm{merge}(a,b)$$$.","def main():
    n = int(input())
    p = [int(e) for e in input().split()]

    prev = 0
    items = [0]
    for i in range(1, 2 * n):
        if p[i] > p[prev]:
            items.append(i - prev)
            prev = i

    weights = {0}
    for item in items:
        new_weights = set(weight + item for weight in weights if weight + item <= n)
        weights = weights.union(new_weights)
        if n in weights:
            print(""YES"")
            return
    
    print(""NO"")


for _ in range(int(input())):
    main()",['dp']
"A Pythagorean triple is a triple of integer numbers $$$(a, b, c)$$$ such that it is possible to form a right triangle with the lengths of the first cathetus, the second cathetus and the hypotenuse equal to $$$a$$$, $$$b$$$ and $$$c$$$, respectively. An example of the Pythagorean triple is $$$(3, 4, 5)$$$.Vasya studies the properties of right triangles, and he uses a formula that determines if some triple of integers is Pythagorean. Unfortunately, he has forgotten the exact formula; he remembers only that the formula was some equation with squares. So, he came up with the following formula: $$$c = a^2 - b$$$.Obviously, this is not the right formula to check if a triple of numbers is Pythagorean. But, to Vasya's surprise, it actually worked on the triple $$$(3, 4, 5)$$$: $$$5 = 3^2 - 4$$$, so, according to Vasya's formula, it is a Pythagorean triple.When Vasya found the right formula (and understood that his formula is wrong), he wondered: how many are there triples of integers $$$(a, b, c)$$$ with $$$1 \le a \le b \le c \le n$$$ such that they are Pythagorean both according to his formula and the real definition? He asked you to count these triples.","from cmath import sqrt
from sys import stdin, stdout
import math

I = stdin.readline
O = stdout.write

# n = int(I())
# arr = list(map(int, I().split()))

def solve():
    n = int(I())
    
    maxi = int(math.sqrt(2*n - 1))
    ans = (maxi + 1) // 2
    ans -= 1

    print(ans)
    	

for tc in range(int(input())):
    solve()","['binary search', 'brute force', 'math', 'number theory']"
"When you play the game of thrones, you win, or you die. There is no middle ground.Cersei Lannister, A Game of Thrones by George R. R. MartinThere are $$$n$$$ nobles, numbered from $$$1$$$ to $$$n$$$. Noble $$$i$$$ has a power of $$$i$$$. There are also $$$m$$$ ""friendships"". A friendship between nobles $$$a$$$ and $$$b$$$ is always mutual.A noble is defined to be vulnerable if both of the following conditions are satisfied:   the noble has at least one friend, and  all of that noble's friends have a higher power. You will have to process the following three types of queries.   Add a friendship between nobles $$$u$$$ and $$$v$$$.  Remove a friendship between nobles $$$u$$$ and $$$v$$$.  Calculate the answer to the following process. The process: all vulnerable nobles are simultaneously killed, and all their friendships end. Then, it is possible that new nobles become vulnerable. The process repeats itself until no nobles are vulnerable. It can be proven that the process will end in finite time. After the process is complete, you need to calculate the number of remaining nobles.Note that the results of the process are not carried over between queries, that is, every process starts with all nobles being alive!","import sys
input = sys.stdin.readline
n,m = map(int,input().split())
arr = [-1]+[0]*n
ct = 0
for x in range(m):
    a,b = map(int,input().split())
    if a<b:
        c=a
    else:
        c=b
    arr[c]+=1
    if arr[c]==1:
        ct +=1

for y in range(int(input())):
    lst = list(map(int,input().split()))
    if lst[0]==3:
        print(n-ct)
        continue
    op,a,b = lst
    if a<b:
        c = a
    else:
        c = b

    if op==1:
        arr[c]+=1
        if arr[c]==1:
            ct+=1
    elif op==2:
        arr[c]-=1
        if arr[c]==0:
            ct-=1","['brute force', 'graphs', 'greedy']"
"A club plans to hold a party and will invite some of its $$$n$$$ members. The $$$n$$$ members are identified by the numbers $$$1, 2, \dots, n$$$. If member $$$i$$$ is not invited, the party will gain an unhappiness value of $$$a_i$$$.There are $$$m$$$ pairs of friends among the $$$n$$$ members. As per tradition, if both people from a friend pair are invited, they will share a cake at the party. The total number of cakes eaten will be equal to the number of pairs of friends such that both members have been invited.However, the club's oven can only cook two cakes at a time. So, the club demands that the total number of cakes eaten is an even number.What is the minimum possible total unhappiness value of the party, respecting the constraint that the total number of cakes eaten is even?","import sys
input = sys.stdin.readline
from collections import defaultdict as dd
t=int(input())
while(t):
    t-=1
    n,m=list(map(int,input().split()))
    l=list(map(int,input().split()))
    ct=[0]*(n+1)
    l1=[]
    for x in range(1,m+1):
        a,b=list(map(int,input().split()))
        l1.append([a,b])
        ct[a]+=1
        ct[b]+=1
    ans=1000000001
    if m%2==0:
        ans=0
    else:
        
        for x in range(1,n+1):
            if ct[x]%2==1:
                ans=min(ans,l[x-1])
    
        
        for x in range(1,m+1):
            if ct[l1[x-1][0]]%2==0 and ct[l1[x-1][1]]%2==0:
                ans=min(ans,l[l1[x-1][0]-1]+l[l1[x-1][1]-1])
                
    sys.stdout.write(str(ans)+""\n"")

        
#python=TLE","['brute force', 'graphs']"
"We will consider the numbers $$$a$$$ and $$$b$$$ as adjacent if they differ by exactly one, that is, $$$|a-b|=1$$$.We will consider cells of a square matrix $$$n \times n$$$ as adjacent if they have a common side, that is, for cell $$$(r, c)$$$ cells $$$(r, c-1)$$$, $$$(r, c+1)$$$, $$$(r-1, c)$$$ and $$$(r+1, c)$$$ are adjacent to it.For a given number $$$n$$$, construct a square matrix $$$n \times n$$$ such that:   Each integer from $$$1$$$ to $$$n^2$$$ occurs in this matrix exactly once;  If $$$(r_1, c_1)$$$ and $$$(r_2, c_2)$$$ are adjacent cells, then the numbers written in them must not be adjacent.","tests = int(input())
for i in range(tests):
    #another solution (the matrix doesnt have any adjacent elements)
    n = int(input())
    matrix = [[0 for c in range(n)] for c in range(n)]
    nums = n * n -1
    matrix[0][0] = 1
    matrix[n-1][n-1] = n ** 2
    for j in range(n):
        for k in range(n):
            if j == n-1 and k == n-1 or j == 0 and k == 0:
                continue
            if (j + k) % 2 == 0:
                matrix[j][k] = nums
                nums -= 1
    nums = 2
    for j in range(n-1,-1,-1):
        for k in range(n-1,-1,-1):
            if (j == n-1 and k == n-1) or (j == 0 and k == 0):
                continue
            if (j + k) % 2 == 1:
                matrix[j][k] = nums
                nums += 1

    if n == 2:
        print(-1)
    elif n == 1:
        print(1)
    else:
        for p in matrix:
            print(*p)

    # n = int(input())
    # if(n == 2):
    #     print(-1)
    #     continue
    # nums = 1
    # for j in range(n):
    #     for k in range(n):
    #         print(str(nums), end=' ')
    #         nums += 2
    #         if(nums > n*n):
    #             nums = 2
    #     print()",['constructive algorithms']
"You have $$$n$$$ rectangular wooden blocks, which are numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th block is $$$1$$$ unit high and $$$\lceil \frac{i}{2} \rceil$$$ units long.Here, $$$\lceil \frac{x}{2} \rceil$$$ denotes the result of division of $$$x$$$ by $$$2$$$, rounded up. For example, $$$\lceil \frac{4}{2} \rceil = 2$$$ and $$$\lceil \frac{5}{2} \rceil = \lceil 2.5 \rceil = 3$$$.For example, if $$$n=5$$$, then the blocks have the following sizes: $$$1 \times 1$$$, $$$1 \times 1$$$, $$$1 \times 2$$$, $$$1 \times 2$$$, $$$1 \times 3$$$.  The available blocks for $$$n=5$$$ Find the maximum possible side length of a square you can create using these blocks, without rotating any of them. Note that you don't have to use all of the blocks.  One of the ways to create $$$3 \times 3$$$ square using blocks $$$1$$$ through $$$5$$$","t = int(input())
for _ in range(t):
    n = int(input())
 
    #blocks = 0
    if n%2 == 0:
        print(n//2)
    else:
        print ((n//2) + 1)",['math']
"Let's call an array $$$a$$$ of $$$m$$$ integers $$$a_1, a_2, \ldots, a_m$$$ Decinc if $$$a$$$ can be made increasing by removing a decreasing subsequence (possibly empty) from it. For example, if $$$a = [3, 2, 4, 1, 5]$$$, we can remove the decreasing subsequence $$$[a_1, a_4]$$$ from $$$a$$$ and obtain $$$a = [2, 4, 5]$$$, which is increasing.You are given a permutation $$$p$$$ of numbers from $$$1$$$ to $$$n$$$. Find the number of pairs of integers $$$(l, r)$$$ with $$$1 \le l \le r \le n$$$ such that $$$p[l \ldots r]$$$ (the subarray of $$$p$$$ from $$$l$$$ to $$$r$$$) is a Decinc array.","input = __import__('sys').stdin.readline


n = int(input())
a = list(map(int, input().split())) + [n+1]

B = n+2
cache = {}
def check(i, u, d):
    keys = []
    j = i
    while j+1 <= n:
        key = (u * B + d) * B + j
        # key = (j, u, d)
        v = cache.get(key, -1)
        if v != -1:
            j = v
            break
        
        keys.append(key)
        # greedy
        if u < a[j] < d: # if can insert to both
            if a[j] < a[j+1]:
                u = max(u, a[j])
            elif a[j] > a[j+1]:
                d = min(d, a[j])
        elif u < a[j]: # if only can insert to increasing subsequence
            u = a[j]
        elif d > a[j]: # if only can insert to decreasing subsequence
            d = a[j]
        else:
            break

        j += 1
    
    for key in keys:
        cache[key] = j
    
    return j

ans = 0
for i in range(n):
    u = 0
    d = n+1
    j = check(i, u, d)
    ans += j - i
    # print(f'at {i} max {j} ans {ans}', u, d)

# print(f'count={len(cache)}')
print(ans)","['brute force', 'data structures', 'data structures', 'greedy']"
"This is an interactive problem. Remember to flush your output while communicating with the testing program. You may use fflush(stdout) in C++, system.out.flush() in Java, stdout.flush() in Python or flush(output) in Pascal to flush the output. If you use some other programming language, consult its documentation. You may also refer to the guide on interactive problems: https://codeforces.com/blog/entry/45307.The jury has chosen a string $$$s$$$ consisting of $$$n$$$ characters; each character of $$$s$$$ is a lowercase Latin letter. Your task is to guess this string; initially, you know only its length.You may ask queries of two types:  $$$1$$$ $$$i$$$ — the query of the first type, where $$$i$$$ is an integer from $$$1$$$ to $$$n$$$. In response to this query, the jury will tell you the character $$$s_i$$$;  $$$2$$$ $$$l$$$ $$$r$$$ — the query of the second type, where $$$l$$$ and $$$r$$$ are integers such that $$$1 \le l \le r \le n$$$. In response to this query, the jury will tell you the number of different characters among $$$s_l, s_{l+1}, \dots, s_r$$$. You are allowed to ask no more than $$$26$$$ queries of the first type, and no more than $$$6000$$$ queries of the second type. Your task is to restore the string $$$s$$$.For each test in this problem, the string $$$s$$$ is fixed beforehand, and will be the same for every submission.","from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def query1(i):

    print('?' , 1 , i , flush = True)
    return input().strip()

def query2(l , r):

    print('?' , 2 , l , r , flush = True)
    return int(input())


def answer():

    left , right = [] , []

    j = 0
    for i in range(n - 1):

        if(query2(i + 1 , i + 2) != 1):
            left.append(j)
            right.append(i)

            j = i + 1

    left.append(j)
    right.append(n - 1)

    ans = []
    ch = query1(1)
    for i in range(left[0] , right[0] + 1):
        ans.append(ch)

    pos = [[0 , ch]]
    for i in range(1 , len(left)):

        l , h = 0 , len(pos) - 1

        what = left[i]
        while(l <= h):

            mid = (l + h)//2

            if(query2(pos[mid][0] + 1 , right[i] + 1) != len(pos) - mid + 1):
                what = pos[mid][0]
                ch = pos[mid][1]
                l = mid + 1
            else:
                h = mid - 1

        if(what == left[i]):

            ch = query1(what + 1)
            pos.append([what , ch])
            for j in range(left[i] , right[i] + 1):
                ans.append(ch)

        else:

            pos.remove([what , ch])
            pos.append([left[i] , ch])

            for j in range(left[i] , right[i] + 1):
                ans.append(ch)

        pos.sort()

    return ''.join(ans)



for T in range(1):

    n = int(input())
    
    print('!' , answer() , flush = True)","['binary search', 'constructive algorithms', 'interactive']"
"You are given a sequence $$$A$$$, where its elements are either in the form + x or -, where $$$x$$$ is an integer.For such a sequence $$$S$$$ where its elements are either in the form + x or -, define $$$f(S)$$$ as follows:  iterate through $$$S$$$'s elements from the first one to the last one, and maintain a multiset $$$T$$$ as you iterate through it.  for each element, if it's in the form + x, add $$$x$$$ to $$$T$$$; otherwise, erase the smallest element from $$$T$$$ (if $$$T$$$ is empty, do nothing).  after iterating through all $$$S$$$'s elements, compute the sum of all elements in $$$T$$$. $$$f(S)$$$ is defined as the sum. The sequence $$$b$$$ is a subsequence of the sequence $$$a$$$ if $$$b$$$ can be derived from $$$a$$$ by removing zero or more elements without changing the order of the remaining elements. For all $$$A$$$'s subsequences $$$B$$$, compute the sum of $$$f(B)$$$, modulo $$$998\,244\,353$$$.","import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline


def main(t):

    M = 998244353
    n = int(input())
    op = []
    for _ in range(n):
        s = input().split()
        if s[0]==b'-':
            op.append(-1)
        elif s[0]==b'+':
            s = s[1]
            op.append(int(s))

    ans = 0

    for i in range(n):
        if op[i]<0:  continue
#        print(op[i]) 
        frontnum = [0]*(n+1)
        frontnum[0] = 1
        xi = 1

        for j in range(i):
            if op[j] > op[i]:
                xi *= 2
                xi %= M

            elif op[j]>0:
                for k in range(j+1,0,-1):
                    frontnum[k] += frontnum[k-1]
                    frontnum[k] %= M
            else:
                
                frontnum[0] = (frontnum[0]*2)%M
                for k in range(j):
                    frontnum[k] += frontnum[k+1]
                    frontnum[k] %= M


    #    print(""mid"",frontnum)

       
        for j in range(i+1,n):
            if op[j] >= op[i]:
                xi *= 2
                xi %= M
            elif op[j]>0:
                for k in range(j+1,0,-1):
                    frontnum[k] += frontnum[k-1] 
                    frontnum[k] %= M
            else:
                for k in range(j):
                    frontnum[k] += frontnum[k+1]
                    frontnum[k] %= M
        
 #       print(frontnum,xi)

        if op[i]>0:   
            ans += (  (sum(frontnum)*xi)%M * op[i] ) % M
            ans = ans % M








    print(ans)




















T = 1 #int(input())
t = 1
while t<=T:
    main(t)
    t += 1","['combinatorics', 'dp', 'implementation', 'math', 'ternary search']"
"This version of the problem differs from the next one only in the constraint on $$$n$$$.A tree is a connected undirected graph without cycles. A weighted tree has a weight assigned to each edge. The distance between two vertices is the minimum sum of weights on the path connecting them.You are given a weighted tree with $$$n$$$ vertices, each edge has a weight of $$$1$$$. Denote $$$d(v)$$$ as the distance between vertex $$$1$$$ and vertex $$$v$$$.Let $$$f(x)$$$ be the minimum possible value of $$$\max\limits_{1 \leq v \leq n} \ {d(v)}$$$ if you can temporarily add an edge with weight $$$x$$$ between any two vertices $$$a$$$ and $$$b$$$ $$$(1 \le a, b \le n)$$$. Note that after this operation, the graph is no longer a tree.For each integer $$$x$$$ from $$$1$$$ to $$$n$$$, find $$$f(x)$$$.","from sys import stdin
inp = stdin.readline

t = int(inp())

for _ in range(t):
    n = int(inp())
    tree = {i: [set(), 0, 0] for i in range(1, n+1)}

    for i in range(n-1):
        a, b = map(int, inp().split())
        tree[a][0].add(b)
        tree[b][0].add(a)

    layer = 0
    arr = [set(tree[1][0])]
    branch = [1]
    dist = 0
    dBranch = []

    while True:
        if not arr[layer]:
            if layer > dist:
                dBranch = branch[:]
                dist = layer

            for c in tree[branch[layer]][0]:
                if c != branch[layer-1] or layer == 0:
                    if tree[c][1] + 1 > tree[branch[layer]][1]:
                        tree[branch[layer]][2] = tree[branch[layer]][1]
                        tree[branch[layer]][1] = tree[c][1] + 1
                    elif tree[c][1] + 1 > tree[branch[layer]][2]:
                        tree[branch[layer]][2] = tree[c][1] + 1

            layer -= 1

            if layer == -1:
                break

            arr.pop()
            branch.pop()

        else:
            current = arr[layer].pop()
            arr.append(set(tree[current][0]))
            branch.append(current)
            arr[layer+1].discard(branch[layer])
            layer += 1

    longest = []
    for i in range(len(dBranch)):
        longest.append([i + (dist - tree[dBranch[i]][2] - i)//2, tree[dBranch[i]][2], i])

    longest.sort()

    ans = [0]*n
    x = 0
    last = 0

    for c in longest:
        while x+1 < 2*c[2] - c[0]:
            ans[x] = max(dist - c[0] + x + 1, last)
            x += 1
        last = max(c[1]+c[2], last)

    while x < n:
        ans[x] = dist
        x += 1

    print(*ans)","['binary search', 'data structures', 'dfs and similar', 'graphs', 'shortest paths', 'trees']"
"Recently, the students of School 179 have developed a unique algorithm, which takes in a binary string $$$s$$$ as input. However, they soon found out that if some substring $$$t$$$ of $$$s$$$ is a palindrome of length greater than 1, the algorithm will work incorrectly. Can the students somehow reorder the characters of $$$s$$$ so that the algorithm will work correctly on the string?A binary string is a string where each character is either 0 or 1.A string $$$a$$$ is a substring of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.A palindrome is a string that reads the same backwards as forwards.","for _ in range(int(input())):
    n=int(input())
    s=input()
    o=s.count('1')
    z=s.count('0')
    if o==1 and z==1 or z==1 and o==0 or z==0 and o==1:
        print(""YES"")
        continue
    else:
        print(""NO"")",['implementation']
"New Year is just around the corner, which means that in School 179, preparations for the concert are in full swing.There are $$$n$$$ classes in the school, numbered from $$$1$$$ to $$$n$$$, the $$$i$$$-th class has prepared a scene of length $$$a_i$$$ minutes.As the main one responsible for holding the concert, Idnar knows that if a concert has $$$k$$$ scenes of lengths $$$b_1$$$, $$$b_2$$$, $$$\ldots$$$, $$$b_k$$$ minutes, then the audience will get bored if there exist two integers $$$l$$$ and $$$r$$$ such that $$$1 \le l \le r \le k$$$ and $$$\gcd(b_l, b_{l + 1}, \ldots, b_{r - 1}, b_r) = r - l + 1$$$, where $$$\gcd(b_l, b_{l + 1}, \ldots, b_{r - 1}, b_r)$$$ is equal to the greatest common divisor (GCD) of the numbers $$$b_l$$$, $$$b_{l + 1}$$$, $$$\ldots$$$, $$$b_{r - 1}$$$, $$$b_r$$$.To avoid boring the audience, Idnar can ask any number of times (possibly zero) for the $$$t$$$-th class ($$$1 \le t \le k$$$) to make a new scene $$$d$$$ minutes in length, where $$$d$$$ can be any positive integer. Thus, after this operation, $$$b_t$$$ is equal to $$$d$$$. Note that $$$t$$$ and $$$d$$$ can be different for each operation.For a sequence of scene lengths $$$b_1$$$, $$$b_2$$$, $$$\ldots$$$, $$$b_{k}$$$, let $$$f(b)$$$ be the minimum number of classes Idnar has to ask to change their scene if he wants to avoid boring the audience.Idnar hasn't decided which scenes will be allowed for the concert, so he wants to know the value of $$$f$$$ for each non-empty prefix of $$$a$$$. In other words, Idnar wants to know the values of $$$f(a_1)$$$, $$$f(a_1$$$,$$$a_2)$$$, $$$\ldots$$$, $$$f(a_1$$$,$$$a_2$$$,$$$\ldots$$$,$$$a_n)$$$.","from math import gcd
import sys


class segmenttree:
    def __init__(self, n, default=0, func=lambda a, b: a + b):
        self.tree, self.n, self.func, self.default = [0] * (2 * n), n, func, default

    def fill(self, arr):
        self.tree[self.n:] = arr
        for i in range(self.n - 1, 0, -1):
            self.tree[i] = self.func(self.tree[i << 1], self.tree[(i << 1) + 1])

    # get interval[l,r)
    def query(self, l, r):
        res, l, r = self.default, l + self.n, r + self.n

        while l < r:
            if l & 1:
                res = self.func(res, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                res = self.func(res, self.tree[r])
            l, r = l >> 1, r >> 1

        return res

    def __setitem__(self, ix, val):
        ix += self.n
        self.tree[ix] = val

        while ix > 1:
            self.tree[ix >> 1] = self.func(self.tree[ix], self.tree[ix ^ 1])
            ix >>= 1

    def __getitem__(self, item):
        return self.tree[item + self.n]


input = lambda: sys.stdin.buffer.readline().decode().strip()
n, a = int(input()), [int(x) for x in input().split()]
tree, ans, lst = segmenttree(n, 0, lambda a, b: gcd(a, b)), 0, 0
tree.fill(a)

for i in range(n):
    be, en = lst, i
    while be <= en:
        md = (be + en) >> 1
        val = tree.query(md, i + 1)

        if val == i - md + 1:
            lst = i + 1
            ans += 1
            break
        elif val < i - md + 1:
            be = md + 1
        else:
            en = md - 1

    print(ans, end=' ')","['binary search', 'data structures', 'greedy', 'math', 'number theory', 'two pointers']"
"An array $$$b$$$ of length $$$k$$$ is called good if its arithmetic mean is equal to $$$1$$$. More formally, if $$$$$$\frac{b_1 + \cdots + b_k}{k}=1.$$$$$$Note that the value $$$\frac{b_1+\cdots+b_k}{k}$$$ is not rounded up or down. For example, the array $$$[1,1,1,2]$$$ has an arithmetic mean of $$$1.25$$$, which is not equal to $$$1$$$.You are given an integer array $$$a$$$ of length $$$n$$$. In an operation, you can append a non-negative integer to the end of the array. What's the minimum number of operations required to make the array good?We have a proof that it is always possible with finitely many operations.","from functools import reduce
import sys
from os import path
if(path.exists('input.txt')):
    sys.stdin = open(""input.txt"", 'r')
    sys.stdout = open(""output.txt"", 'w')


input = iter(sys.stdin.readlines())

n = int(next(input))

for _ in range(n):
    l = int(next(input))
    a = (int(i) for i in next(input).split())
    sum1 = sum(a)
    ar = sum1 / l

    if ar == 1:
        sys.stdout.write('0\n')
    elif ar < 1:
        sys.stdout.write('1\n')
    else:
        sys.stdout.write(str(sum1-l)+'\n')


sys.stdout.flush()","['greedy', 'math']"
"Riley is a very bad boy, but at the same time, he is a yo-yo master. So, he decided to use his yo-yo skills to annoy his friend Anton.Anton's room can be represented as a grid with $$$n$$$ rows and $$$m$$$ columns. Let $$$(i, j)$$$ denote the cell in row $$$i$$$ and column $$$j$$$. Anton is currently standing at position $$$(i, j)$$$ in his room. To annoy Anton, Riley decided to throw exactly two yo-yos in cells of the room (they can be in the same cell).Because Anton doesn't like yo-yos thrown on the floor, he has to pick up both of them and return back to the initial position. The distance travelled by Anton is the shortest path that goes through the positions of both yo-yos and returns back to $$$(i, j)$$$ by travelling only to adjacent by side cells. That is, if he is in cell $$$(x, y)$$$ then he can travel to the cells $$$(x + 1, y)$$$, $$$(x - 1, y)$$$, $$$(x, y + 1)$$$ and $$$(x, y - 1)$$$ in one step (if a cell with those coordinates exists).Riley is wondering where he should throw these two yo-yos so that the distance travelled by Anton is maximized. But because he is very busy, he asked you to tell him.","t = int(input())
for _ in range(t):
    n, m, y, x = map(int, input().split())
    if x <= round(m/2):
        print(n, m, 1, 1)
    else:
        print(n, 1, 1, m)","['constructive algorithms', 'greedy', 'math']"
"Let's call an array of $$$k$$$ integers $$$c_1, c_2, \ldots, c_k$$$ terrible, if the following condition holds:Let $$$AVG$$$ be the $$$\frac{c_1 + c_2 + \ldots + c_k}{k}$$$(the average of all the elements of the array, it doesn't have to be integer). Then the number of elements of the array which are bigger than $$$AVG$$$ should be strictly larger than the number of elements of the array which are smaller than $$$AVG$$$. Note that elements equal to $$$AVG$$$ don't count.For example $$$c = \{1, 4, 4, 5, 6\}$$$ is terrible because $$$AVG = 4.0$$$ and $$$5$$$-th and $$$4$$$-th elements are greater than $$$AVG$$$ and $$$1$$$-st element is smaller than $$$AVG$$$.Let's call an array of $$$m$$$ integers $$$b_1, b_2, \ldots, b_m$$$ bad, if at least one of its non-empty subsequences is terrible, and good otherwise.You are given an array of $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$. Find the minimum number of elements that you have to delete from it to obtain a good array.An array is a subsequence of another array if it can be obtained from it by deletion of several (possibly, zero or all) elements.","import sys
input = sys.stdin.buffer.readline 

def finder(A, x, l, r):
    if A[r] < x:
        return r+1
    if A[l] >= x:
        return l
    s = l 
    e = r
    #A[s] < x <= A[e]
    while s+1 < e:
        m = (s+e)//2
        if A[m] < x:
            s, e = m, e
        else:
            s, e = s, m
    return e
        
def process(A):
    n = len(A)
    if n <= 2 or A[-1]==A[0]:
        sys.stdout.write(f'0\n')
        return
    answer = n-2
    for s in range(n):
        if s==0 or A[s] > A[s-1]:
            entry = s
            if s >= answer:
                break
            s1 = s+1
            while s1+1 < n:
                x = 2*A[s1]-A[s]
                s2 = finder(A, x, s1+1, n-1)
                entry+=(s2-s1-1)
                if entry >= answer:
                    break
                s1 = s2
            answer = min(answer, entry)
    print(answer)
    return

t = int(input())
for i in range(t):
    n = int(input())
    A = [int(x) for x in input().split()]
    process(A)","['binary search', 'brute force', 'greedy', 'implementation', 'math']"
"Lee couldn't sleep lately, because he had nightmares. In one of his nightmares (which was about an unbalanced global round), he decided to fight back and propose a problem below (which you should solve) to balance the round, hopefully setting him free from the nightmares.A non-empty array $$$b_1, b_2, \ldots, b_m$$$ is called good, if there exist $$$m$$$ integer sequences which satisfy the following properties:  The $$$i$$$-th sequence consists of $$$b_i$$$ consecutive integers (for example if $$$b_i = 3$$$ then the $$$i$$$-th sequence can be $$$(-1, 0, 1)$$$ or $$$(-5, -4, -3)$$$ but not $$$(0, -1, 1)$$$ or $$$(1, 2, 3, 4)$$$).  Assuming the sum of integers in the $$$i$$$-th sequence is $$$sum_i$$$, we want $$$sum_1 + sum_2 + \ldots + sum_m$$$ to be equal to $$$0$$$. You are given an array $$$a_1, a_2, \ldots, a_n$$$. It has $$$2^n - 1$$$ nonempty subsequences. Find how many of them are good.As this number can be very large, output it modulo $$$10^9 + 7$$$.An array $$$c$$$ is a subsequence of an array $$$d$$$ if $$$c$$$ can be obtained from $$$d$$$ by deletion of several (possibly, zero or all) elements.","import sys
input = sys.stdin.readline
n = int(input().split('\n')[0])
a = [int(x) for x in input().split()]
 
o = [x for x in a if x%2 == 1]
e = [x for x in a if x%2 == 0]
 
ans = 0
ans += 2**(len(e))*(2**(len(o))-1)
 
while len(e)>=2:
    o = [x//2 for x in e if (x//2)%2==1]
    e = [x//2 for x in e if (x//2)%2==0]
    ans += 2**(len(e))*(2**max(0, len(o)-1)-1)
print(ans%(10**9+7))","['combinatorics', 'dp', 'math', 'number theory']"
"After many unsuccessful tries, Mashtali decided to copy modify an AtCoder problem. So here is his copied new problem:There is a tree with $$$n$$$ vertices and some non-empty set of the vertices are pinned to the ground.Two players play a game against each other on the tree. They alternately perform the following action:  Remove an edge from the tree, then remove every connected component that has no pinned vertex.The player who cannot move loses(every edge has been deleted already). You are given the tree, but not the set of the pinned vertices. Your task is to determine, for each $$$k$$$, the winner of the game, if only the vertices $$$1, 2, 3, \ldots, k$$$ are pinned and both players play optimally.","import sys
input = sys.stdin.buffer.readline

N = int(input())
T = [[] for i in range(N)]
for i in range(1, N):
	u, v = map(int, input().split())
	u -= 1
	v -= 1
	T[u].append(v)
	T[v].append(u)

stk = [(1, 0)]
par = [-1] * N
dp = [0] * N

while stk:
	t, u = stk.pop()
	if t == 1:
		stk.append((2, u))
		for v in T[u]:
			if v == par[u]:
				continue
			par[v] = u
			stk.append((1, v))
	else:
		for v in T[u]:
			if v == par[u]:
				continue
			dp[u] ^= dp[v] + 1

vis = [False] * N
vis[0] = True
ans = dp[0]
res = []

for i in range(N):
	u = i
	while not vis[u]:
		ans ^= (dp[u] + 1) ^ dp[u] ^ 1
		vis[u] = True
		u = par[u]
	res.append('2' if ans == 0 else '1')
print('%s' % """".join(res))","['games', 'trees']"
"You are given a rooted tree. Each vertex contains $$$a_i$$$ tons of gold, which costs $$$c_i$$$ per one ton. Initially, the tree consists only a root numbered $$$0$$$ with $$$a_0$$$ tons of gold and price $$$c_0$$$ per ton.There are $$$q$$$ queries. Each query has one of two types:   Add vertex $$$i$$$ (where $$$i$$$ is an index of query) as a son to some vertex $$$p_i$$$; vertex $$$i$$$ will have $$$a_i$$$ tons of gold with $$$c_i$$$ per ton. It's guaranteed that $$$c_i &gt; c_{p_i}$$$.  For a given vertex $$$v_i$$$ consider the simple path from $$$v_i$$$ to the root. We need to purchase $$$w_i$$$ tons of gold from vertices on this path, spending the minimum amount of money. If there isn't enough gold on the path, we buy all we can. If we buy $$$x$$$ tons of gold in some vertex $$$v$$$ the remaining amount of gold in it decreases by $$$x$$$ (of course, we can't buy more gold that vertex has at the moment). For each query of the second type, calculate the resulting amount of gold we bought and the amount of money we should spend.Note that you should solve the problem in online mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query, so don't forget to flush output after printing answers. You can use functions like fflush(stdout) in C++ and BufferedWriter.flush in Java or similar after each writing in your program. In standard (if you don't tweak I/O), endl flushes cout in C++ and System.out.println in Java (or println in Kotlin) makes automatic flush as well.","from array import array
import math
import os
import sys
input = sys.stdin.buffer.readline

q, a0, c0 = map(int, input().split())
mod = pow(10, 9) + 7
n = q + 5
pow2 = [1]
for _ in range(20):
    pow2.append(2 * pow2[-1])
cnt = [0] * n
cost = [0] * n
cnt[0], cost[0] = a0, c0
dp = array(""l"", [-1] * (20 * n))
dist = [-1] * n
dist[0] = 1
l0 = [-1] * n
for i in range(1, q + 1):
    t = list(map(int, input().split()))
    if t[0] == 1:
        p, a, c = t[1], t[2], t[3]
        cnt[i] = a
        cost[i] = c
        j = 0
        dp[20 * i] = p
        while dp[20 * dp[20 * i + j] + j] ^ -1:
            dp[20 * i + j + 1] = dp[20 * dp[20 * i + j] + j]
            j += 1
        dist[i] = dist[p] + 1
    else:
        v, w = t[1], t[2]
        if not v:
            u = 0
            x = min(w, cnt[u])
            cnt[u] -= x
            ans = [str(x), str(x * cost[0])]
            os.write(1, b""%d %d\n"" % (x, x * cost[0]))
            continue
        d, j, l = 0, v, int(math.log2(dist[v])) + 1
        for k in range(l - 1, -1, -1):
            m = dp[20 * j + k]
            if cnt[m]:
                d += pow2[k]
                j = m
        u0 = j
        ans0, ans1, ans2 = 0, 0, 0
        for j in range(d, -1, -1):
            if j ^ d:
                d0, u, k = j, v, 0
                while d0:
                    if d0 & pow2[k]:
                        d0 ^= pow2[k]
                        u = dp[20 * u + k]
                    k += 1
            else:
                u = u0
            x = min(w - ans0, cnt[u])
            cnt[u] -= x
            ans0 += x
            ans1 += x * cost[u] % mod
            ans2 += x * cost[u] // mod
            ans2 += ans1 // mod
            ans1 %= mod
            if not ans0 ^ w:
                break
        ans = [str(ans0), str(ans1 + ans2 * mod)]
        os.write(1, b""%d %d\n"" % (ans0, ans1 + ans2 * mod))","['binary search', 'data structures', 'dp', 'greedy', 'interactive', 'trees']"
"Bethany would like to tile her bathroom. The bathroom has width $$$w$$$ centimeters and length $$$l$$$ centimeters. If Bethany simply used the basic tiles of size $$$1 \times 1$$$ centimeters, she would use $$$w \cdot l$$$ of them. However, she has something different in mind.   On the interior of the floor she wants to use the $$$1 \times 1$$$ tiles. She needs exactly $$$(w-2) \cdot (l-2)$$$ of these.  On the floor boundary she wants to use tiles of size $$$1 \times a$$$ for some positive integer $$$a$$$. The tiles can also be rotated by $$$90$$$ degrees. For which values of $$$a$$$ can Bethany tile the bathroom floor as described? Note that $$$a$$$ can also be $$$1$$$.","import math

def div(x):
    ans=[]
    for i in range(1,math.floor(math.sqrt(x))+1):
        if x%i==0:
            ans.append(i)
            if x//i!=i:
                ans.append(x//i)
    
    return ans


            
t=int(input())
for _ in range(t):
    w,l=list(map(int,input().split()))
    res=[]
    
    # x=max(w-1,l-2,l)
    # res.append(math.gcd(w-1,l-2,l))
    
    # x=max(w,w-2,l-1)
    # res.append(math.gcd(w,w-2,l-1))
    
    #! Điều kiện này không cần vì chỉ có thể là a=2
    

    res.append(math.gcd(w,l-2))
    
    
    res.append(math.gcd(w-2,l))
            
    res.append(math.gcd(w-1,l-1))
    
    
    ans=[]
    for num in res:
        ans+=div(num)

    ans.append(2)
    ans=list(set(ans))
    ans.sort()
    print(len(ans),end="" "")
    print(*ans)","['brute force', 'math']"
"There are three sticks with integer lengths $$$l_1, l_2$$$ and $$$l_3$$$.You are asked to break exactly one of them into two pieces in such a way that:   both pieces have positive (strictly greater than $$$0$$$) integer length;  the total length of the pieces is equal to the original length of the stick;  it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle.Determine if it's possible to do that.","n=int(input())
for i in range(n):
    a, b, c=map(int, input().split())
    if a+b==c or a+c==b or b+c==a or a==b and c%2==0 or a==c and b%2==0 or b==c and a%2==0:
        print(""YES"")
    else:
        print(""NO"")
# Tue Jan 25 2022 07:44:44 GMT+0000 (Coordinated Universal Time)","['geometry', 'math']"
"Parsa has a humongous tree on $$$n$$$ vertices.On each vertex $$$v$$$ he has written two integers $$$l_v$$$ and $$$r_v$$$.To make Parsa's tree look even more majestic, Nima wants to assign a number $$$a_v$$$ ($$$l_v \le a_v \le r_v$$$) to each vertex $$$v$$$ such that the beauty of Parsa's tree is maximized.Nima's sense of the beauty is rather bizarre. He defines the beauty of the tree as the sum of $$$|a_u - a_v|$$$ over all edges $$$(u, v)$$$ of the tree.Since Parsa's tree is too large, Nima can't maximize its beauty on his own. Your task is to find the maximum possible beauty for Parsa's tree.","import sys
sys.setrecursionlimit(10 ** 5)
input = sys.stdin.buffer.readline
def dfs(par, x):
    for u in g[x]:
        if u == par:
            continue
        dfs(x, u)
    dp[par][0] += max(abs(a[par][0] - a[x][0]) + dp[x][0], abs(a[par][0] - a[x][1]) + dp[x][1])
    dp[par][1] += max(abs(a[par][1] - a[x][0]) + dp[x][0], abs(a[par][1] - a[x][1]) + dp[x][1])
for _ in range(int(input())):
    n = int(input())
    g = [[] for _ in range(n)]
    a = []
    for _ in range(n):
        a.append(list(map(int, input().split())))
    for _ in range(n - 1):
        u, v = map(int, input().split())
        g[u - 1].append(v - 1)
        g[v - 1].append(u - 1)
    dp = [[0.0, 0.0] for _ in range(n)]



    for p in g[0]:
        dfs(0, p)
    print(int(max(dp[0][0], dp[0][1])))","['dfs and similar', 'dp', 'graphs', 'greedy', 'trees']"
"Inflation has occurred in Berlandia, so the store needs to change the price of goods.The current price of good $$$n$$$ is given. It is allowed to increase the price of the good by $$$k$$$ times, with $$$1 \le k \le m$$$, k is an integer. Output the roundest possible new price of the good. That is, the one that has the maximum number of zeros at the end.For example, the number 481000 is more round than the number 1000010 (three zeros at the end of 481000 and only one at the end of 1000010).If there are several possible variants, output the one in which the new price is maximal.If it is impossible to get a rounder price, output $$$n \cdot m$$$ (that is, the maximum possible price).","#I = lambda: [int(i) for i in input().split()]
#import io, os, sys
#input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
 
 
from collections import Counter,defaultdict,deque
#from heapq import heappush,heappop,heapify
import sys
import math
import bisect
def lcm(a,b):
    return ((a*b)//math.gcd(a,b))


def all_factors(n):
    """"""returns a sorted list of all distinct factors of n""""""
    small, large = [], []
    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
        if not n % i:
            small.append(i)
            large.append(n // i)
    if small[-1] == large[-1]:
        large.pop()
    large.reverse()
    small.extend(large)
    return small
 
# n = int(input())
# l1 = list(map(int,input().split()))
# n,x = map(int,input().split())
# s = input()
mod = 1000000007
# print(""Case #""+str(_+1)+"":"",)
def f(x):
    l = [x,0,0]
    while(x%2==0 or x%5==0):
        if x%2==0:
            l[1]+=1
            x = x//2
        if x%5==0:
            l[2]+=1
            x = x//5
    l[0] = x
    return l
def count(x):
    c = 0
    x = str(x)
    for i in range(len(x)-1,-1,-1):
        if x[i] != '0':
            break
        c+=1
    return c
for _ in range(int(input())):
    n,m = map(int,input().split())
    a = f(n)
    x = 1
    px = -1
    t1 = a[1]
    t2 = a[2]
    a[1] -= min(t1,t2)
    a[2] -= min(t1,t2)
    while(x < m and (a[1] or a[2])):
        if x==px:
            break
        px = x
        if a[1] and x*5<=m:
            x*=5
            a[1]-=1
        if a[2] and x*2<=m:
            x*=2
            a[2]-=1
        
    while(x*10 < m):
        x*=10
    x = x*(m//x)
    ans = n*x
    print(ans)
    '''if count(ans)-count(n) > count(m):
        print(ans)
    else:
        while(x < m):
            x = x+(pow(10,len(str(m))-1))
            t = n*x
            if count(t)>=count(ans):
                ans =  max(ans,t)
        print(ans)'''","['brute force', 'number theory']"
"You are given $$$n$$$ strings $$$s_1, s_2, \dots, s_n$$$ of length at most $$$\mathbf{8}$$$. For each string $$$s_i$$$, determine if there exist two strings $$$s_j$$$ and $$$s_k$$$ such that $$$s_i = s_j + s_k$$$. That is, $$$s_i$$$ is the concatenation of $$$s_j$$$ and $$$s_k$$$. Note that $$$j$$$ can be equal to $$$k$$$.Recall that the concatenation of strings $$$s$$$ and $$$t$$$ is $$$s + t = s_1 s_2 \dots s_p t_1 t_2 \dots t_q$$$, where $$$p$$$ and $$$q$$$ are the lengths of strings $$$s$$$ and $$$t$$$ respectively. For example, concatenation of ""code"" and ""forces"" is ""codeforces"".","#import io, os
#input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

t=int(input())
for _ in range(t):
  n=int(input())
  words=[]
  prefs={}
  suffs={}
  for i in range(n):
    word=input()
    words.append(word)
    if not word in prefs:
      prefs.update({word:1})
    else:
      prefs.update({word:prefs[word]+1})
    if not word in suffs:     
      suffs.update({word:1})
    else:
      suffs.update({word:suffs[word]+1})
  bina=""""
  for i in words:#
    flag=False
    for j in range(len(i)-1):
      a=i[:(j+1)]
      b=i[j+1:]
      if a in prefs and b in suffs:
        flag=True
    if flag:
      bina+=""1""
    else:
      bina+=""0""
  print(bina)","['brute force', 'data structures', 'strings']"
"You have a permutation: an array $$$a = [a_1, a_2, \ldots, a_n]$$$ of distinct integers from $$$1$$$ to $$$n$$$. The length of the permutation $$$n$$$ is odd.You need to sort the permutation in increasing order.In one step, you can choose any prefix of the permutation with an odd length and reverse it. Formally, if $$$a = [a_1, a_2, \ldots, a_n]$$$, you can choose any odd integer $$$p$$$ between $$$1$$$ and $$$n$$$, inclusive, and set $$$a$$$ to $$$[a_p, a_{p-1}, \ldots, a_1, a_{p+1}, a_{p+2}, \ldots, a_n]$$$.Find a way to sort $$$a$$$ using no more than $$$\frac{5n}{2}$$$ reversals of the above kind, or determine that such a way doesn't exist. The number of reversals doesn't have to be minimized.","''' C. Bottom-Tier Reversals
https://codeforces.com/contest/1558/problem/C
'''

import io, os, sys
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline  # decode().strip() if str
output = sys.stdout.write

def debug(*args):   
    if os.environ.get('debug') in [None, '0']: return
    from inspect import currentframe, getframeinfo
    from re import search
    frame = currentframe().f_back
    s = getframeinfo(frame).code_context[0]
    r = search(r""\((.*)\)"", s).group(1)
    vnames = r.split(', ')
    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]
    prefix = f'{currentframe().f_back.f_lineno:02d}: '
    print(f'{prefix}{"", "".join(var_and_vals)}')

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack: return f(*args, **kwargs)
        to = f(*args, **kwargs)
        while True:
            if type(to) is GeneratorType:
                stack.append(to)
                to = next(to)
            else:
                stack.pop()
                if not stack: break
                to = stack[-1].send(to)
        return to
    return wrappedfunc

class IntKeyDict(dict):
    from random import randrange
    rand = randrange(1 << 62)
    def __setitem__(self, k, v): super().__setitem__(k^self.rand, v)
    def __getitem__(self, k): return super().__getitem__(k^self.rand)
    def __contains__(self, k): return super().__contains__(k^self.rand)
    def __repr__(self): return str({k: v for k, v in self.items()})
    def get(self, k, default=None): return super().get(k^self.rand, default)
    def keys(self): return [k^self.rand for k in super().keys()]
    def items(self): return [(k^self.rand, v) for k, v in super().items()]

INF = float('inf')

# -----------------------------------------

# reversal preserves parity of position
# put pair of (n, n-1), (n-2, n-3), ... in order
#    7 a b 6 c d e
#    b a 7 6 c d e
#    e d c 6 7 a b
#    7 6 c d e a b
#    b a e d c 6 7

def solve(N, A):
    res = []
    for a1 in range(N, 1, -2):
        # put a1 at 0
        for i, a in enumerate(A):
            if a == a1:
                if i & 1: return -1, []
                res.append(i + 1)
                A[:i+1] = A[:i+1][::-1]
                break 

        i0 = -1
        for i, a in enumerate(A):
            if a == a1 - 1: 
                if i & 1 == 0: return -1, []
                i0 = i
                break

        # 7 a b 6 c d e -> b a 7 6 c d e
        res.append(i0)
        A[:i0] = A[:i0][::-1]
        i1 = i0 - 1

        # b a 7 6 c d e -> e d c 6 7 a b
        res.append(a1)
        A[:a1] = A[:a1][::-1]
        i1 = a1 - 1 - i1

        # e d c 6 7 a b -> 7 6 c d e a b
        res.append(i1 + 1)
        A[:i1+1] = A[:i1+1][::-1]

        # 7 6 c d e a b -> b a e d c 6 7
        res.append(a1)
        A[:a1] = A[:a1][::-1]
        
    assert A == list(range(1, N + 1))
    assert all(a & 1 for a in res)
    assert len(res) <= 5 * N // 2
    return len(res), res



def main():
    T = int(input())
    for _ in range(T):
        N = int(input())
        A = list(map(int, input().split()))
        r1, r2 = solve(N, A)
        print(r1)
        if r2: print(*r2)


if __name__ == '__main__':
    main()","['constructive algorithms', 'greedy']"
"A bitstring is a string that contains only the characters 0 and 1.Koyomi Kanou is working hard towards her dream of becoming a writer. To practice, she decided to participate in the Binary Novel Writing Contest. The writing prompt for the contest consists of three bitstrings of length $$$2n$$$. A valid novel for the contest is a bitstring of length at most $$$3n$$$ that contains at least two of the three given strings as subsequences.Koyomi has just received the three prompt strings from the contest organizers. Help her write a valid novel for the contest.A string $$$a$$$ is a subsequence of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero) characters.","import sys
input = lambda : sys.stdin.readline().rstrip()

write = lambda x: sys.stdout.write(x+""\n""); writef = lambda x: print(""{:.12f}"".format(x))
debug = lambda x: sys.stderr.write(x+""\n"")
YES=""Yes""; NO=""No""; pans = lambda v: print(YES if v else NO)
LI = lambda : list(map(int, input().split()))
# sys.setrecursionlimit(3*10**5+10)

t = int(input())
for _ in range(t):
    n = int(input())
    s = [list(map(int, input())) for _ in range(3)]
    index = [0,0,0]
    l = []
    for i in range(3*n):
        if max(index)==2*n:
            inds = list(range(3))
            inds.sort(key=lambda i: index[i])
            j = inds[1]
            for k in range(index[j], 2*n):
                l.append(s[j][k])
            break
        if s[0][index[0]] + s[1][index[1]] + s[2][index[2]] >= 2:
            v = 1
        else:
            v = 0
        l.append(v)
        for j in range(3):
            if s[j][index[j]]==v:
                index[j] += 1
    assert len(l)<=3*n
    write("""".join(map(str, l)))
#     break","['constructive algorithms', 'greedy', 'implementation', 'strings', 'two pointers']"
"You found a map of a weirdly shaped labyrinth. The map is a grid, consisting of $$$n$$$ rows and $$$n$$$ columns. The rows of the grid are numbered from $$$1$$$ to $$$n$$$ from bottom to top. The columns of the grid are numbered from $$$1$$$ to $$$n$$$ from left to right.The labyrinth has $$$n$$$ layers. The first layer is the bottom left corner (cell $$$(1, 1)$$$). The second layer consists of all cells that are in the grid and adjacent to the first layer by a side or a corner. The third layer consists of all cells that are in the grid and adjacent to the second layer by a side or a corner. And so on. The labyrinth with $$$5$$$ layers, for example, is shaped as follows:   The layers are separated from one another with walls. However, there are doors in these walls.Each layer (except for layer $$$n$$$) has exactly two doors to the next layer. One door is placed on the top wall of the layer and another door is placed on the right wall of the layer. For each layer from $$$1$$$ to $$$n-1$$$ you are given positions of these two doors. The doors can be passed in both directions: either from layer $$$i$$$ to layer $$$i+1$$$ or from layer $$$i+1$$$ to layer $$$i$$$.If you are standing in some cell, you can move to an adjacent by a side cell if a wall doesn't block your move (e.g. you can't move to a cell in another layer if there is no door between the cells).Now you have $$$m$$$ queries of sort: what's the minimum number of moves one has to make to go from cell $$$(x_1, y_1)$$$ to cell $$$(x_2, y_2)$$$.","#!/usr/bin/env PyPy3

from collections import Counter, defaultdict, deque
import itertools
import re
import math
from functools import reduce
import operator
import bisect
from heapq import *
import functools
mod=998244353

import sys
import os
from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


import typing
class SegTree:
    def __init__(self,
                 op: typing.Callable[[typing.Any, typing.Any], typing.Any],
                 e: typing.Any,
                 v: typing.Union[int, typing.List[typing.Any]]) -> None:
        self._op = op
        self._e = e

        if isinstance(v, int):
            v = [e] * v

        self._n = len(v)
        self._log = self._n.bit_length()
        self._size = 1 << self._log
        self._d = [e] * (2 * self._size)

        for i in range(self._n):
            self._d[self._size + i] = v[i]
        for i in range(self._size - 1, 0, -1):
            self._update(i)

    def set(self, p: int, x: typing.Any) -> None:
        assert 0 <= p < self._n

        p += self._size
        self._d[p] = x
        for i in range(1, self._log + 1):
            self._update(p >> i)

    def get(self, p: int) -> typing.Any:
        assert 0 <= p < self._n

        return self._d[p + self._size]

    def prod(self, left: int, right: int) -> typing.Any:
        assert 0 <= left <= right <= self._n
        sml = self._e
        smr = self._e
        left += self._size
        right += self._size

        while left < right:
            if left & 1:
                sml = self._op(sml, self._d[left])
                left += 1
            if right & 1:
                right -= 1
                smr = self._op(self._d[right], smr)
            left >>= 1
            right >>= 1

        return self._op(sml, smr)

    def all_prod(self) -> typing.Any:
        return self._d[1]

    def max_right(self, left: int,
                  f: typing.Callable[[typing.Any], bool]) -> int:
        assert 0 <= left <= self._n
        assert f(self._e)

        if left == self._n:
            return self._n

        left += self._size
        sm = self._e

        first = True
        while first or (left & -left) != left:
            first = False
            while left % 2 == 0:
                left >>= 1
            if not f(self._op(sm, self._d[left])):
                while left < self._size:
                    left *= 2
                    if f(self._op(sm, self._d[left])):
                        sm = self._op(sm, self._d[left])
                        left += 1
                return left - self._size
            sm = self._op(sm, self._d[left])
            left += 1

        return self._n

    def min_left(self, right: int,
                 f: typing.Callable[[typing.Any], bool]) -> int:
        assert 0 <= right <= self._n
        assert f(self._e)

        if right == 0:
            return 0

        right += self._size
        sm = self._e

        first = True
        while first or (right & -right) != right:
            first = False
            right -= 1
            while right > 1 and right % 2:
                right >>= 1
            if not f(self._op(self._d[right], sm)):
                while right < self._size:
                    right = 2 * right + 1
                    if f(self._op(self._d[right], sm)):
                        sm = self._op(self._d[right], sm)
                        right -= 1
                return right + 1 - self._size
            sm = self._op(self._d[right], sm)

        return 0

    def _update(self, k: int) -> None:
        self._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])
def op(x,y):
    return [min(x[0] + y[0],x[1] + y[2]),min(x[0] + y[1],x[1] + y[3]),min(x[2] + y[0],x[3] + y[2]),min(x[2] + y[1],x[3] + y[3])]
INF = 1 << 60
e = [0,INF,INF,0]

n = int(input())
door = []
for _ in range(n-1):
    d1x,d1y,d2x,d2y = map(int,input().split())
    d1x -= 1
    d1y -= 1
    d2x -= 1
    d2y -= 1
    door.append([d1x,d1y,d2x,d2y])
a = [[0] * 4 for _ in range(n-2)]
for i in range(n-2):
    a[i][0] = abs(door[i][0] + 1 - door[i+1][0]) + abs(door[i][1] - door[i+1][1]) + 1
    a[i][1] = abs(door[i][0] + 1 - door[i+1][2]) + abs(door[i][1] - door[i+1][3]) + 1
    a[i][2] = abs(door[i][2] - door[i+1][0]) + abs(door[i][3] - door[i+1][1] + 1) + 1
    a[i][3] = abs(door[i][2] - door[i+1][2]) + abs(door[i][3] - door[i+1][3] + 1) + 1
seg = SegTree(op,e,a)

m = int(input())
for i in range(m):
    sx,sy,gx,gy=map(int,input().split())
    sx -= 1
    sy -= 1
    gx -= 1
    gy -= 1
    p1 = max(sx,sy)
    p2 = max(gx,gy)
    if p1 == p2:
        print(abs(sx - gx) + abs(sy - gy))
    else:
        if p1 > p2:
            sx,gx=gx,sx
            sy,gy=gy,sy
            p1,p2=p2,p1
        '''
        if p2 == p1 + 1:
            ans = INF
            ans = min(ans, abs(sx - door[p1][0]) + abs(sy - door[p1][1]) + 1 + abs(door[p1][0] + 1 - gx) + abs(door[p1][1] - gy))
            ans = min(ans, abs(sx - door[p1][2]) + abs(sy - door[p1][3]) + 1 + abs(door[p1][2] - gx) + abs(door[p1][3] + 1 - gy))
            print(ans)
        '''
        R = seg.prod(p1,p2 - 1)
        ans = INF
        ans = min(ans,abs(sx - door[p1][0]) + abs(sy - door[p1][1]) + R[0] + 1 + abs(gx - door[p2 - 1][0] - 1) + abs(gy - door[p2 - 1][1]))
        ans = min(ans,abs(sx - door[p1][0]) + abs(sy - door[p1][1]) + R[1] + 1 + abs(gx - door[p2 - 1][2]) + abs(gy - door[p2 - 1][3] - 1))
        ans = min(ans,abs(sx - door[p1][2]) + abs(sy - door[p1][3]) + R[2] + 1 + abs(gx - door[p2 - 1][0] - 1) + abs(gy - door[p2 - 1][1]))
        ans = min(ans,abs(sx - door[p1][2]) + abs(sy - door[p1][3]) + R[3] + 1 + abs(gx - door[p2 - 1][2]) + abs(gy - door[p2 - 1][3] - 1))
        print(ans)","['data structures', 'dp', 'matrices', 'shortest paths']"
"Lord Omkar would like to have a tree with $$$n$$$ nodes ($$$3 \le n \le 10^5$$$) and has asked his disciples to construct the tree. However, Lord Omkar has created $$$m$$$ ($$$\mathbf{1 \le m &lt; n}$$$) restrictions to ensure that the tree will be as heavenly as possible. A tree with $$$n$$$ nodes is an connected undirected graph with $$$n$$$ nodes and $$$n-1$$$ edges. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.Here is an example of a tree:   A restriction consists of $$$3$$$ pairwise distinct integers, $$$a$$$, $$$b$$$, and $$$c$$$ ($$$1 \le a,b,c \le n$$$). It signifies that node $$$b$$$ cannot lie on the simple path between node $$$a$$$ and node $$$c$$$. Can you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.","import os
import sys
import math
from io import BytesIO, IOBase
from collections import deque,defaultdict,OrderedDict,Counter
from heapq import heappush,heappop,heapify
from bisect import bisect_right,insort,bisect_left
from functools import lru_cache
from itertools import permutations

sys.setrecursionlimit(10**6)

def STRIN():return input()
def INTIN():return int(input())
def LINT():return list(map(int,input().split()))
def LSTR():return list(map(str,input().split()))
def MINT():return map(int,input().split())
def MSTR():return map(str,input().split())

def divisors(n) :
     
    c=0
    i=1
    while i <= int(math.sqrt(n)):
         
        if (n % i == 0) :
            if (n // i == i):
                c+=1
            else :
                c+=2
                 
        i = i + 1

    return c 

def isValid(x,y,n,m,graph,vis):
    if x<0 or x>=n or y<0 or y>=m or graph[x][y]=='#' or vis[x][y]:

        return False

    return True


def dfs(u,graph,vis,parent,p,vertex):
    
    vis[u]=1
   
    parent[u]=p
    for v in graph[u]:
       
        if vis[v]:
            if p!=v:
                vertex[0]=v 
                vertex[1]=u
                return True
 
        if not vis[v]:
            
            if dfs(v,graph,vis,parent,u,vertex):                               
                return True
    
    return False
 

def bfs(u,graph,vis,teams):
    pass

    
def palin(s):
    s=str(s)

    i=0
    j=len(s)-1

    while i<=j:
        if s[i]!=s[j]:
            return False

        i+=1
        j-=1


    return True




def solve():

    n,m=MINT()
    ans=[]
    st=set()
    nodes=[]

    for i in range(m):
        a,b,c=MINT()
        nodes.append((a,b,c))
        st.add(b)
           
            
    for i in range(1,n+1):
        if i not in st:
            node=i  


            break

            
           
    for i in range(1,n+1):
        if i!=node:
            ans.append([node,i])
    

    for i in range(len(ans)):
        print(*ans[i],end=""\n"")



       


def main():
    for _ in range(INTIN()):
        solve()
    
    
        





# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()","['constructive algorithms', 'trees']"
"Nastya owns too many arrays now, so she wants to delete the least important of them. However, she discovered that this array is magic! Nastya now knows that the array has the following properties:  In one second we can add an arbitrary (possibly negative) integer to all elements of the array that are not equal to zero.  When all elements of the array become equal to zero, the array explodes. Nastya is always busy, so she wants to explode the array as fast as possible. Compute the minimum time in which the array can be exploded.","n = int(input())
arr = list(map(int,input().split(' ')))


c = 0
arr = sorted(arr);
for i in range(0,n):
    if arr[i]==0:
        continue
    if i!=0 and arr[i]==arr[i-1]:
        continue
    c = c+1
    
print(c)","['implementation', 'sortings']"
"You are given a permutation $$$a_1,a_2,\ldots,a_n$$$ of integers from $$$0$$$ to $$$n - 1$$$. Your task is to find how many permutations $$$b_1,b_2,\ldots,b_n$$$ are similar to permutation $$$a$$$. Two permutations $$$a$$$ and $$$b$$$ of size $$$n$$$ are considered similar if for all intervals $$$[l,r]$$$ ($$$1 \le l \le r \le n$$$), the following condition is satisfied: $$$$$$\operatorname{MEX}([a_l,a_{l+1},\ldots,a_r])=\operatorname{MEX}([b_l,b_{l+1},\ldots,b_r]),$$$$$$ where the $$$\operatorname{MEX}$$$ of a collection of integers $$$c_1,c_2,\ldots,c_k$$$ is defined as the smallest non-negative integer $$$x$$$ which does not occur in collection $$$c$$$. For example, $$$\operatorname{MEX}([1,2,3,4,5])=0$$$, and $$$\operatorname{MEX}([0,1,2,4,5])=3$$$.Since the total number of such permutations can be very large, you will have to print its remainder modulo $$$10^9+7$$$.In this problem, a permutation of size $$$n$$$ is an array consisting of $$$n$$$ distinct integers from $$$0$$$ to $$$n-1$$$ in arbitrary order. For example, $$$[1,0,2,4,3]$$$ is a permutation, while $$$[0,1,1]$$$ is not, since $$$1$$$ appears twice in the array. $$$[0,1,3]$$$ is also not a permutation, since $$$n=3$$$ and there is a $$$3$$$ in the array.","import sys
input = sys.stdin.readline
t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split(' ')))
    mod = 10 ** 9 + 7
    if n <= 3:
        print(1)
        continue
    indices = [0] * n
    for i in range(n):
        indices[a[i]] = i
    res, l, r = 1, min(indices[0], indices[1]), max(indices[0], indices[1])
    for i in range(2, n):
        if l < indices[i] < r:
            res *= r - l + 1 - i
            res %= mod
        else:
            l = min(l, indices[i])
            r = max(r, indices[i])
    print(res)","['combinatorics', 'constructive algorithms', 'math']"
"Let's call a list of positive integers $$$a_0, a_1, ..., a_{n-1}$$$ a power sequence if there is a positive integer $$$c$$$, so that for every $$$0 \le i \le n-1$$$ then $$$a_i = c^i$$$.Given a list of $$$n$$$ positive integers $$$a_0, a_1, ..., a_{n-1}$$$, you are allowed to:  Reorder the list (i.e. pick a permutation $$$p$$$ of $$$\{0,1,...,n - 1\}$$$ and change $$$a_i$$$ to $$$a_{p_i}$$$), then  Do the following operation any number of times: pick an index $$$i$$$ and change $$$a_i$$$ to $$$a_i - 1$$$ or $$$a_i + 1$$$ (i.e. increment or decrement $$$a_i$$$ by $$$1$$$) with a cost of $$$1$$$. Find the minimum cost to transform $$$a_0, a_1, ..., a_{n-1}$$$ into a power sequence.","import copy
import math
 
n = int(input())
nums = list(map(int,input().split()))

 
nums.sort()
f_1 = 0 
for i in range(n):
    f_1 += math.fabs(1 - nums[i])

term = f_1 + nums[-1]
max_c = math.floor(math.pow(term,1/(n-1)))
cost2 = float('inf')
prev_cost = 0
for c in range(1,max_c+1):
    cost = 0
    for i in range(n):
        cost += math.fabs((c**i - nums[i]))
    cost2 = min(cost,cost2)
    
print(int(cost2))","['number theory', 'sortings', 'brute force', 'math']"
"Let's define the cost of a string $$$s$$$ as the number of index pairs $$$i$$$ and $$$j$$$ ($$$1 \le i &lt; j &lt; |s|$$$) such that $$$s_i = s_j$$$ and $$$s_{i+1} = s_{j+1}$$$.You are given two positive integers $$$n$$$ and $$$k$$$. Among all strings with length $$$n$$$ that contain only the first $$$k$$$ characters of the Latin alphabet, find a string with minimum possible cost. If there are multiple such strings with minimum cost — find any of them.","import bisect
import collections
import heapq
import io
import math
import os
import sys

LO = 'abcdefghijklmnopqrstuvwxyz'
Mod = 1000000007

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

# _input = lambda: io.BytesIO(os.read(0, os.fstat(0).st_size)).readline().decode()
_input = lambda: sys.stdin.buffer.readline().strip().decode()

n, m = map(int, _input().split())
if m > 1:
    s = ['a', 'a']
    for i in range(1, m):
        x = LO[i]
        for j in range(i):
            y = LO[j]
            u = s.index(y)
            s[u: u + 1] = [y, x, y]
        u = s.index(x)
        s.insert(u, x)
        if len(s) >= n:
            break
    s = ''.join(s)
    if n > len(s):
        k = (n - len(s) + m * m - 1) // (m * m)
        s += s[1:] * k
    print(s[:n])
else:
    print('a' * n)","['brute force', 'constructive algorithms', 'graphs', 'greedy', 'strings']"
"You have a card deck of $$$n$$$ cards, numbered from top to bottom, i. e. the top card has index $$$1$$$ and bottom card — index $$$n$$$. Each card has its color: the $$$i$$$-th card has color $$$a_i$$$.You should process $$$q$$$ queries. The $$$j$$$-th query is described by integer $$$t_j$$$. For each query you should:   find the highest card in the deck with color $$$t_j$$$, i. e. the card with minimum index;  print the position of the card you found;  take the card and place it on top of the deck.","import sys
n,q=map(int,sys.stdin.readline().split())
a=[int(i) for i in sys.stdin.readline().split()]
t=[int(i) for i in sys.stdin.readline().split()]

# print(a.index(t[0]))
for i in range(0,len(t)):
    x=a.index(t[i])
    print(x+1,end="" "")
    a[:x+1]=[a[x]]+a[:x]
    # print(a)","['brute force', 'data structures', 'implementation', 'trees']"
"Along the railroad there are stations indexed from $$$1$$$ to $$$10^9$$$. An express train always travels along a route consisting of $$$n$$$ stations with indices $$$u_1, u_2, \dots, u_n$$$, where ($$$1 \le u_i \le 10^9$$$). The train travels along the route from left to right. It starts at station $$$u_1$$$, then stops at station $$$u_2$$$, then at $$$u_3$$$, and so on. Station $$$u_n$$$ — the terminus.It is possible that the train will visit the same station more than once. That is, there may be duplicates among the values $$$u_1, u_2, \dots, u_n$$$.You are given $$$k$$$ queries, each containing two different integers $$$a_j$$$ and $$$b_j$$$ ($$$1 \le a_j, b_j \le 10^9$$$). For each query, determine whether it is possible to travel by train from the station with index $$$a_j$$$ to the station with index $$$b_j$$$.For example, let the train route consist of $$$6$$$ of stations with indices [$$$3, 7, 1, 5, 1, 4$$$] and give $$$3$$$ of the following queries:   $$$a_1 = 3$$$, $$$b_1 = 5$$$It is possible to travel from station $$$3$$$ to station $$$5$$$ by taking a section of the route consisting of stations [$$$3, 7, 1, 5$$$]. Answer: YES.  $$$a_2 = 1$$$, $$$b_2 = 7$$$You cannot travel from station $$$1$$$ to station $$$7$$$ because the train cannot travel in the opposite direction. Answer: NO.  $$$a_3 = 3$$$, $$$b_3 = 10$$$It is not possible to travel from station $$$3$$$ to station $$$10$$$ because station $$$10$$$ is not part of the train's route. Answer: NO.","def main():
    t = int(input())
    ans = []
    for _ in range(t):
        input()
        n,k=map(int, input().split())
        nums = list(input().split())
        d = {}
        for i in range(n):
            x = nums[i]
            if x in d.keys():
                d[x] = (d[x][0], i)
            else:
                d[x] = (i, i)
        for _ in range(k):
            a,b=input().split()
            if a in d.keys() and b in d.keys():
                if d[a][0] < d[b][1]:
                    print(""YES"")
                else:
                    print(""NO"")
            else:
                print(""NO"")    
main()","['data structures', 'greedy']"
"This is a hard version of the problem. The only difference between an easy and a hard version is in the number of queries.Polycarp grew a tree from $$$n$$$ vertices. We remind you that a tree of $$$n$$$ vertices is an undirected connected graph of $$$n$$$ vertices and $$$n-1$$$ edges that does not contain cycles.He calls a set of vertices passable if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice. The path can visit other vertices (not from this set).In other words, a set of vertices is called passable if there is a simple path that passes through all the vertices of this set (and possibly some other).For example, for a tree below sets $$$\{3, 2, 5\}$$$, $$$\{1, 5, 4\}$$$, $$$\{1, 4\}$$$ are passable, and $$$\{1, 3, 5\}$$$, $$$\{1, 2, 3, 4, 5\}$$$ are not.  Polycarp asks you to answer $$$q$$$ queries. Each query is a set of vertices. For each query, you need to determine whether the corresponding set of vertices is passable.","def dfs(root):
    dis=[0]*n
    parent_list = [-1] * n
    stops_left=[len(tree[node])-1 for node in range(n)]
    stops_left[root]=-1 # you always have to stop when you reach the root
    eular_path=[]
    stack=[root]
    node_mapping=[-1]*n
    count=0
    while stack:
        node=stack.pop()
        node_mapping[node]=count
        count+=1
        eular_path.append(node_mapping[node])
        for child in tree[node]:
            if child != parent_list[node]:
                stack.append(child)
                parent_list[child] = node
                dis[child]=dis[node]+1

        if stops_left[node]==0: # it have only one edge
            node=parent_list[node]
            while True:
                stops_left[node]-=1
                eular_path.append(node_mapping[node])
                if stops_left[node]!=0:
                    break
                node=parent_list[node]
    node_return=[-1]*n
    for i in range(n):
        node_return[node_mapping[i]]=i
    return eular_path,node_mapping,node_return,dis

def pre_compute_min(x):
    n=len(x)
    powers_of_two_min = [[float(""-INF"")] * n for _ in range(int(math.log(n, 2)) + 1)]
    powers_of_two_min[0] = x
    for i in range(1, len(powers_of_two_min)):
        for j in range(n- (1 << (i-1))):
            powers_of_two_min[i][j] = min(powers_of_two_min[i - 1][j], powers_of_two_min[i - 1][j + (1 << (i-1))])
    return powers_of_two_min

def get_range_min(a,b):
    #both a and b are inculded
    length=b-a+1
    nearest_power_of_two=int(math.log(length,2))
    return min(powers_of_two_min[nearest_power_of_two][a],powers_of_two_min[nearest_power_of_two][b-(1<<nearest_power_of_two)+1])

def LCA(a,b):
    node_a=node_mapping[a]
    node_b=node_mapping[b]
    if first[node_a]>first[node_b]:
        node_a,node_b=node_b,node_a
    return node_return[get_range_min(first[node_a],first[node_b])]

import math
input = __import__('sys').stdin.readline
mapnode = lambda x: int(x)-1
n=int(input())
tree=[[] for _ in range(n)]
for _ in range(n-1):
    a,b=map(mapnode,input().split())
    tree[a].append(b)
    tree[b].append(a)
eular_path,node_mapping,node_return,dis=dfs(0)
powers_of_two_min=pre_compute_min(eular_path)
first=[-1]*n
for i in range(len(eular_path)):
    temp=eular_path[i]
    first[temp]=i if first[temp]==-1 else first[temp]
q=int(input())
for __ in range(q):
    k=int(input())
    x=sorted(map(mapnode,input().split()),key=lambda a:-dis[a])
    deepest1=x[0]
    deepest2 = deepest1
    for node in x:
        if LCA(node,deepest1)==node or LCA(node,deepest2)==node:
            k-=1
        else:
            if deepest2==deepest1:
                deepest2=node
                k-=1
    print(""YES"" if k==0 and (deepest1==deepest2 or dis[LCA(deepest1,deepest2)]<=dis[x[-1]]) else ""NO"")","['data structures', 'dfs and similar', 'trees']"
"You are given an array $$$a$$$ of $$$n$$$ integers. You are asked to find out if the inequality $$$$$$\max(a_i, a_{i + 1}, \ldots, a_{j - 1}, a_{j}) \geq a_i + a_{i + 1} + \dots + a_{j - 1} + a_{j}$$$$$$ holds for all pairs of indices $$$(i, j)$$$, where $$$1 \leq i \leq j \leq n$$$.","import sys
from array import array


class segmenttree:
    def __init__(self, n, default=0, func=lambda a, b: a + b):
        self.tree, self.n, self.func, self.default = [default] * (2 * n), n, func, default

    def fill(self, arr):
        self.tree[self.n:] = arr
        for i in range(self.n - 1, 0, -1):
            self.tree[i] = self.func(self.tree[i << 1], self.tree[(i << 1) + 1])

    # get interval[l,r)
    def query(self, l, r):
        res = self.default
        l += self.n
        r += self.n
        while l < r:
            if l & 1:
                res = self.func(res, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                res = self.func(res, self.tree[r])
            l >>= 1
            r >>= 1
        return res


input = lambda: sys.stdin.buffer.readline().decode().strip()
for _ in range(int(input())):
    n = int(input())
    a = array('i', [int(x) for x in input().split()])
    max_, ix, inc = array('q', a[:]), n - 1, -1

    for _ in range(2):
        pre = array('q', [0] * n)
        stk, pre[0] = [], a[0]

        for i in range(1, n):
            pre[i] = pre[i - 1] + a[i]

        tree = segmenttree(n, -10**15, lambda a, b: max(a, b))
        tree.fill(pre)

        for i in range(n - 1, -1, -1):
            if a[i] > 0:
                while stk and a[i] >= a[stk[-1]]:
                    stk.pop()

                l = n
                if stk and a[stk[-1]] > a[i]:
                    l = stk[-1]
                stk.append(i)
                max_[ix] += max(tree.query(i , l) - pre[i], 0)

            ix += inc

        a.reverse()
        ix, inc = 0, 1

    print(['yes', 'no'][any([max_[i] > a[i] for i in range(n)])])","['binary search', 'constructive algorithms', 'data structures', 'divide and conquer', 'implementation', 'two pointers']"
"Eric has an array $$$b$$$ of length $$$m$$$, then he generates $$$n$$$ additional arrays $$$c_1, c_2, \dots, c_n$$$, each of length $$$m$$$, from the array $$$b$$$, by the following way:Initially, $$$c_i = b$$$ for every $$$1 \le i \le n$$$. Eric secretly chooses an integer $$$k$$$ $$$(1 \le k \le n)$$$ and chooses $$$c_k$$$ to be the special array.There are two operations that Eric can perform on an array $$$c_t$$$: Operation 1: Choose two integers $$$i$$$ and $$$j$$$ ($$$2 \leq i &lt; j \leq m-1$$$), subtract $$$1$$$ from both $$$c_t[i]$$$ and $$$c_t[j]$$$, and add $$$1$$$ to both $$$c_t[i-1]$$$ and $$$c_t[j+1]$$$. That operation can only be used on a non-special array, that is when $$$t \neq k$$$.; Operation 2: Choose two integers $$$i$$$ and $$$j$$$ ($$$2 \leq i &lt; j \leq m-2$$$), subtract $$$1$$$ from both $$$c_t[i]$$$ and $$$c_t[j]$$$, and add $$$1$$$ to both $$$c_t[i-1]$$$ and $$$c_t[j+2]$$$. That operation can only be used on a special array, that is when $$$t = k$$$.Note that Eric can't perform an operation if any element of the array will become less than $$$0$$$ after that operation.Now, Eric does the following:  For every non-special array $$$c_i$$$ ($$$i \neq k$$$), Eric uses only operation 1 on it at least once. For the special array $$$c_k$$$, Eric uses only operation 2 on it at least once.Lastly, Eric discards the array $$$b$$$.For given arrays $$$c_1, c_2, \dots, c_n$$$, your task is to find out the special array, i.e. the value $$$k$$$. Also, you need to find the number of times of operation $$$2$$$ was used on it.","from collections import Counter, deque, defaultdict
import math
from itertools import permutations, accumulate
from sys import *
from heapq import *
from bisect import bisect_left, bisect_right
from functools import cmp_to_key
from random import randint
xor = randint(10 ** 7, 10**8)
# https://docs.python.org/3/library/bisect.html
on = lambda mask, pos: (mask & (1 << pos)) > 0
lcm = lambda x, y: (x * y) // math.gcd(x,y)
rotate = lambda seq, k: seq[k:] + seq[:k]
input = stdin.readline
'''
Check for typos before submit, Check if u can get hacked with Dict (use xor)
Observations/Notes: 

O(n)
'''
for _ in range(int(input())):
    n, m = map(int, input().split())
    arrs = [list(map(int, input().split())) for i in range(n)]
    ans = [sum(v * (i + 1) for i, v in enumerate(arrs[i])) for i in range(n)]
    print(ans.index(max(ans)) + 1, max(ans) - min(ans))","['constructive algorithms', 'hashing', 'implementation', 'math']"
"During their New Year holidays, Alice and Bob play the following game using an array $$$a$$$ of $$$n$$$ integers:   Players take turns, Alice moves first.  Each turn a player chooses any element and removes it from the array.  If Alice chooses even value, then she adds it to her score. If the chosen value is odd, Alice's score does not change.  Similarly, if Bob chooses odd value, then he adds it to his score. If the chosen value is even, then Bob's score does not change. If there are no numbers left in the array, then the game ends. The player with the highest score wins. If the scores of the players are equal, then a draw is declared.For example, if $$$n = 4$$$ and $$$a = [5, 2, 7, 3]$$$, then the game could go as follows (there are other options):   On the first move, Alice chooses $$$2$$$ and get two points. Her score is now $$$2$$$. The array $$$a$$$ is now $$$[5, 7, 3]$$$.  On the second move, Bob chooses $$$5$$$ and get five points. His score is now $$$5$$$. The array $$$a$$$ is now $$$[7, 3]$$$.  On the third move, Alice chooses $$$7$$$ and get no points. Her score is now $$$2$$$. The array $$$a$$$ is now $$$[3]$$$.  On the last move, Bob chooses $$$3$$$ and get three points. His score is now $$$8$$$. The array $$$a$$$ is empty now.  Since Bob has more points at the end of the game, he is the winner. You want to find out who will win if both players play optimally. Note that there may be duplicate numbers in the array.","def solve(arr):
    alice = []
    bob = []
    for i in arr:
        if i % 2 == 0:
            alice.append(i)
        else:
            bob.append(i)

    alice.sort(reverse=True)
    bob.sort(reverse=True)

    aliceTmp = []
    bobTmp = []

    indexAlice = 0
    indexBOB = 0

    while indexAlice < len(alice) or indexBOB < len(bob) :
        maxAlice=0
        if indexAlice < len(alice):
            maxAlice = alice[indexAlice]

        maxBob = 0
        if indexBOB < len(bob):
            maxBob = bob[indexBOB]

        if maxAlice <= maxBob:
            indexBOB += 1
        else:
            if maxAlice != 0:
                aliceTmp.append(alice[indexAlice])
            indexAlice +=1

        maxAlice=0
        if indexAlice < len(alice):
            maxAlice = alice[indexAlice]

        maxBob = 0
        if indexBOB < len(bob):
            maxBob = bob[indexBOB]

        if maxBob <= maxAlice:
            indexAlice +=1
        else:
            if maxBob != 0:
                bobTmp.append(bob[indexBOB])
            indexBOB += 1

    sumAlice = sum(aliceTmp)
    sumBob = sum(bobTmp)

    if sumAlice > sumBob:
        print(""Alice"")
    else:
        if sumAlice < sumBob:
            print(""Bob"")
        else:
            print(""Tie"")



count = int(input())

for i in range(count):
    n = input()

    arr = map(int, input().split())

    solve(list(arr))","['dp', 'games', 'greedy', 'sortings']"
"You are playing a computer game. To pass the current level, you have to kill a big horde of monsters. In this horde, there are $$$n$$$ monsters standing in the row, numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th monster has $$$a_i$$$ health and a special ""Death's Blessing"" spell of strength $$$b_i$$$ attached to it.You are going to kill all of them one by one. It takes exactly $$$h$$$ seconds to kill a monster with health $$$h$$$.When the $$$i$$$-th monster dies, it casts its spell that increases the health of its neighbors by $$$b_i$$$ (the neighbors of the $$$j$$$-th monster in the row are the monsters on places $$$j - 1$$$ and $$$j + 1$$$. The first and the last monsters have only one neighbor each).After each monster is killed, the row shrinks, so its former neighbors become adjacent to each other (so if one of them dies, the other one is affected by its spell). For example, imagine a situation with $$$4$$$ monsters with health $$$a = [2, 6, 7, 3]$$$ and spells $$$b = [3, 6, 0, 5]$$$. One of the ways to get rid of the monsters is shown below:  $$$2$$$$$$6$$$$$$7$$$$$$3$$$$$$\xrightarrow{6\ s}$$$$$$8$$$$$$13$$$$$$3$$$$$$\xrightarrow{13\ s}$$$$$$8$$$$$$3$$$$$$\xrightarrow{8\ s}$$$$$$6$$$$$$\xrightarrow{6\ s}$$$$$$\{\}$$$$$$3$$$$$$6$$$$$$0$$$$$$5$$$$$$3$$$$$$0$$$$$$5$$$$$$3$$$$$$5$$$$$$5$$$ The first row represents the health of each monster, the second one — the power of the spells. As a result, we can kill all monsters in $$$6 + 13 + 8 + 6$$$ $$$=$$$ $$$33$$$ seconds. Note that it's only an example and may not be the fastest way to get rid of the monsters.What is the minimum time required to kill all monsters in the row?","def solve0(health , power):
    maxPower = max(power)
    return sum(health) + sum(power)  - maxPower


def solve1(aList, bList):
    result = sum(aList)
    while bList:
        minElement = min(bList)
        minPos = bList.index(minElement)
        if minPos != 0 and minPos != len(bList):
            result += minElement
        bList.pop(minPos)
        result += minElement
    return result
 
 
if __name__ == ""__main__"":    
    t = int(input())
    for _ in range(t):
        n = int(input())
        health = [int(x) for x in input().split()]
        power = [int(x) for x in input().split()]
        # print(n, health, power)
        print(solve0(health, power))
        # print(solve1(health, power))",['greedy']
"Burenka is about to watch the most interesting sporting event of the year — a fighting tournament organized by her friend Tonya.$$$n$$$ athletes participate in the tournament, numbered from $$$1$$$ to $$$n$$$. Burenka determined the strength of the $$$i$$$-th athlete as an integer $$$a_i$$$, where $$$1 \leq a_i \leq n$$$. All the strength values are different, that is, the array $$$a$$$ is a permutation of length $$$n$$$. We know that in a fight, if $$$a_i &gt; a_j$$$, then the $$$i$$$-th participant always wins the $$$j$$$-th.The tournament goes like this: initially, all $$$n$$$ athletes line up in ascending order of their ids, and then there are infinitely many fighting rounds. In each round there is exactly one fight: the first two people in line come out and fight. The winner goes back to the front of the line, and the loser goes to the back.Burenka decided to ask Tonya $$$q$$$ questions. In each question, Burenka asks how many victories the $$$i$$$-th participant gets in the first $$$k$$$ rounds of the competition for some given numbers $$$i$$$ and $$$k$$$. Tonya is not very good at analytics, so he asks you to help him answer all the questions.","import sys, threading
import math
from os import path
from collections import defaultdict, Counter, deque
from bisect import *
from string import ascii_lowercase
from functools import cmp_to_key
import heapq
 
 
def readInts():
    x = list(map(int, (sys.stdin.readline().rstrip().split())))
    return x[0] if len(x) == 1 else x
 
 
def readList(type=int):
    x = sys.stdin.readline()
    x = list(map(type, x.rstrip('\n\r').split()))
    return x
 
 
def readStr():
    x = sys.stdin.readline().rstrip('\r\n')
    return x
 
 
write = sys.stdout.write
read = sys.stdin.readline
 
 
MAXN = 1123456


class mydict:
    def __init__(self, func):
        self.random = randint(0, 1 << 32)
        self.default = func
        self.dict = {}
 
    def __getitem__(self, key):
        mykey = self.random ^ key
        if mykey not in self.dict:
            self.dict[mykey] = self.default()
        return self.dict[mykey]
 
    def get(self, key, default):
        mykey = self.random ^ key
        if mykey not in self.dict:
            return default
        return self.dict[mykey]
 
    def __setitem__(self, key, item):
        mykey = self.random ^ key
        self.dict[mykey] = item
 
    def getkeys(self):
        return [self.random ^ i for i in self.dict]
 
    def __str__(self):
        return f'{[(self.random ^ i, self.dict[i]) for i in self.dict]}'

 
def lcm(a, b):
    return (a*b)//(math.gcd(a,b))
 
 
def mod(n):
    return n%(998244353) 


def upper_bound(a, num):
    l = 0
    r = len(a)-1
    ans = -1
    while l <= r:
        mid = (l+r)//2
        if a[mid] >= num:
            ans = mid
            r = mid-1
        else:
            l = mid+1

    return ans


def solve(t):
    # print(f'Case #{t}: ', end = '')
    n, q = readInts()
    ar = readList()
    mr = []
    m = ar[0]
    mp = {}
    for i in range(n):
        m = max(ar[i], m)
        mp[m] = i
        mr.append(m)

    # print(mp)

    for _ in range(q):
        ind, r = readInts()
        ind -= 1
        if r < ind:
            print(0)
            continue
        
        if ar[ind] == n:
            print(max(0, r-max(0, (ind-1))))
            continue
        

        ans = 0
        r -= max(0, ind-1)
        if ind > 0 and mr[ind-1] > ar[ind]:
                print(0)
                continue

        if ind > 0 and r > 0:
            ans = 1
            r -= 1


        if r > 0:
            if ar[ind] in mp:
                # print(mp[ar[ind]])
                tmp = mp[ar[ind]] - ind
                if r >= tmp:
                    ans += tmp
                else:
                    ans += r
        
        print(ans) 



def main():
    t = 1
    if path.exists(""F:/Comp Programming/input.txt""):
        sys.stdin = open(""F:/Comp Programming/input.txt"", 'r')
        sys.stdout = open(""F:/Comp Programming/output1.txt"", 'w')
    # sys.setrecursionlimit(10**6) 
    t = readInts()
    for i in range(t):
        solve(i+1)
 
 
if __name__ == '__main__':
    main()","['binary search', 'data structures', 'implementation', 'two pointers']"
"$$$n$$$ students attended the first meeting of the Berland SU programming course ($$$n$$$ is even). All students will be divided into two groups. Each group will be attending exactly one lesson each week during one of the five working days (Monday, Tuesday, Wednesday, Thursday and Friday), and the days chosen for the groups must be different. Furthermore, both groups should contain the same number of students.Each student has filled a survey in which they told which days of the week are convenient for them to attend a lesson, and which are not. Your task is to determine if it is possible to choose two different week days to schedule the lessons for the group (the first group will attend the lesson on the first chosen day, the second group will attend the lesson on the second chosen day), and divide the students into two groups, so the groups have equal sizes, and for each student, the chosen lesson day for their group is convenient.","t = int(input())
for i in range(t):
    n = int(input())
    a = [[] for i in range(n)]
    for j in range(n):
        a[j] = list(map(int, input().split()))
    ans = False
    for j in range(5):
        for k in range(5):
            if k != j:
                this_website_is_garbage = 0
                kill_yourselves_idiots = 0
                cntno = 0
                for z in range(n):
                    if a[z][j] == 1:
                        this_website_is_garbage += 1
                    if a[z][k] == 1:
                        kill_yourselves_idiots += 1
                    if a[z][j] == 0 and a[z][k] == 0:
                        cntno += 1
                if this_website_is_garbage >= n // 2 and kill_yourselves_idiots >= n // 2 and cntno == 0:
                    ans = True
    if ans:
        print('YES')
    else:
        print('NO')","['brute force', 'implementation']"
"Let's call a positive integer good if there is no digit 0 in its decimal representation.For an array of a good numbers $$$a$$$, one found out that the sum of some two neighboring elements is equal to $$$x$$$ (i.e. $$$x = a_i + a_{i + 1}$$$ for some $$$i$$$). $$$x$$$ had turned out to be a good number as well.Then the elements of the array $$$a$$$ were written out one after another without separators into one string $$$s$$$. For example, if $$$a = [12, 5, 6, 133]$$$, then $$$s = 1256133$$$.You are given a string $$$s$$$ and a number $$$x$$$. Your task is to determine the positions in the string that correspond to the adjacent elements of the array that have sum $$$x$$$. If there are several possible answers, you can print any of them.","import sys
s = sys.stdin.readline().strip()
x = sys.stdin.readline().strip()
ls, lx = len(s), len(x)
MOD = 2**31-1 
h = [0] * (ls+1)
p = [1] * (ls+1)
def gh(start, end):
    return (h[end+1] - h[start] * p[end-start+1]) % MOD

def gen_z(s, zx = None, x=None):
    z = [0]*len(s)
    l, r, start = 0, -1, 0
    if not zx: zx = z; x =s; z[0] = len(s); start = 1
    for i in range(start, len(s)):
        if i <= r: z[i] = min(zx[i - l], r - i + 1);
        while i + z[i] < len(s) and z[i] < len(x) and s[i + z[i]] == x[z[i]]: z[i]+=1;
        if i + z[i] - 1 > r:
            l = i;
            r = i + z[i] - 1;
    return z

zx = gen_z(x)
zs = gen_z(s, zx, x)

for idx, i in enumerate(s):
    h[idx+1] = (h[idx] * 10 + ord(i) - 48) % MOD
    p[idx+1] = p[idx]*10 % MOD
target = 0
for i in x: target = (target * 10 + ord(i) - 48) % MOD

def printresult(a, b, c):
    sys.stdout.write(""%d %d\n%d %d\n"" % (a+1, b, b+1, c+1))
    sys.exit()

if lx > 1:
    for i in range(ls - lx - lx + 3):
        if (gh(i, i+lx-2) + gh(i+lx-1, i+lx+lx-3)) % MOD == target: printresult(i, i+lx-1, i+lx+lx-3)

for i in range(ls - lx + 1):
    j = lx - zs[i]
    if j > 0:
        if i+lx+j <= ls and (gh(i, i+lx-1) + gh(i+lx, i+lx+j-1)) % MOD == target: printresult(i, i+lx, i+lx+j-1)
        if i-j >= 0 and (gh(i-j, i-1) + gh(i, i+lx-1)) % MOD == target: printresult(i-j, i, i+lx-1)
    if j > 1:
        if i+lx+j-1 <= ls and (gh(i, i+lx-1) + gh(i+lx, i+lx+j-2)) % MOD == target: printresult(i, i+lx, i+lx+j-2)
        if i-j+1 >= 0 and (gh(i-j+1, i-1) + gh(i, i+lx-1)) % MOD == target: printresult(i-j+1, i, i+lx-1)","['hashing', 'math', 'string suffix structures', 'strings']"
"She is skilled in all kinds of magics, and is keen on inventing new one.—Perfect Memento in Strict SensePatchouli is making a magical talisman. She initially has $$$n$$$ magical tokens. Their magical power can be represented with positive integers $$$a_1, a_2, \ldots, a_n$$$. Patchouli may perform the following two operations on the tokens.  Fusion: Patchouli chooses two tokens, removes them, and creates a new token with magical power equal to the sum of the two chosen tokens.  Reduction: Patchouli chooses a token with an even value of magical power $$$x$$$, removes it and creates a new token with magical power equal to $$$\frac{x}{2}$$$. Tokens are more effective when their magical powers are odd values. Please help Patchouli to find the minimum number of operations she needs to make magical powers of all tokens odd values.","for s in[*open(0)][2::2]:b=min(a:=[x&-x for x in
map(int,s.split())]);print(len(a)+min(k:=bin(b)[::-1].find('1')-1,k*a.count(b)))","['bitmasks', 'constructive algorithms', 'greedy', 'sortings']"
"As for the technology in the outside world, it is really too advanced for Gensokyo to even look up to.—Yasaka Kanako, Symposium of Post-mysticismThis is an interactive problem.Under the direct supervision of Kanako and the Moriya Shrine, the railway system of Gensokyo is finally finished. GSKR (Gensokyo Railways) consists of $$$n$$$ stations with $$$m$$$ bidirectional tracks connecting them. The $$$i$$$-th track has length $$$l_i$$$ ($$$1\le l_i\le 10^6$$$). Due to budget limits, the railway system may not be connected, though there may be more than one track between two stations.The value of a railway system is defined as the total length of its all tracks. The maximum (or minimum) capacity of a railway system is defined as the maximum (or minimum) value among all of the currently functional system's full spanning forest.In brief, full spanning forest of a graph is a spanning forest with the same connectivity as the given graph.Kanako has a simulator only able to process no more than $$$2m$$$ queries. The input of the simulator is a string $$$s$$$ of length $$$m$$$, consisting of characters 0 and/or 1. The simulator will assume the $$$i$$$-th track functional if $$$s_i=$$$ 1. The device will then tell Kanako the maximum capacity of the system in the simulated state.Kanako wants to know the the minimum capacity of the system with all tracks functional with the help of the simulator.The structure of the railway system is fixed in advance. In other words, the interactor is not adaptive.","def ask(ii):
    aa = [0]*m
    for i in ii: aa[i] = 1
    print(""? "", *aa, sep="""", flush=True)
    return int(input())

n, m = map(int, input().split())
ll = []
for i in range(m):
    ll.append(ask([i]))

il = sorted(enumerate(ll), key=lambda x: x[1])
ans = il[0][1]
ii = [il[0][0]]
for i, l in il[1:]:
    ii.append(i)
    r = ask(ii)
    if l == r-ans:
        ans = r
    else:
        ii.pop()

print(""!"", ans, flush=True)","['brute force', 'constructive algorithms', 'dsu', 'graphs', 'greedy', 'interactive', 'sortings']"
"A revolution has recently happened in Segmentland. The new government is committed to equality, and they hired you to help with land redistribution in the country.Segmentland is a segment of length $$$l$$$ kilometers, with the capital in one of its ends. There are $$$n$$$ citizens in Segmentland, the home of $$$i$$$-th citizen is located at the point $$$a_i$$$ kilometers from the capital. No two homes are located at the same point. Each citizen should receive a segment of positive length with ends at integer distances from the capital that contains her home. The union of these segments should be the whole of Segmentland, and they should not have common points besides their ends. To ensure equality, the difference between the lengths of the longest and the shortest segments should be as small as possible.","import io
import os
import heapq
from collections import deque, Counter
 
 
FILE_INPUT_MODE = 0  # 0 for BytesIO, 1 for input.txt, -1 for stdin, input()
if FILE_INPUT_MODE >= 0:
 
    if FILE_INPUT_MODE == 1:
        CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
        FD = os.open(f""{CURRENT_DIR}\input.txt"", os.O_RDONLY)
    elif FILE_INPUT_MODE == 0:
        FD = 0
    DATA = io.BytesIO(os.read(FD, os.fstat(FD).st_size))
    if FD != 0:
        os.close(FD)
 
    def input():
        return DATA.readline().decode().rstrip('\r\n')
 
 
def solve():
    def check_max(x):
        nonlocal n, a, l
        cur = a[1]
        for i in range(1, n):
            if cur > x:
                return False
            cur = max(a[i + 1] - a[i] + cur - x, 0)
        return cur + l - a[n] <= x
 
    def check_min(x):
        nonlocal n, a, l
        cur = a[1]
        for i in range(1, n):
            if cur + a[i + 1] - a[i] < x:
                return False
            cur = min(cur + a[i + 1] - a[i] - x, a[i + 1] - a[i])
        return True
    l, n = [int(word) for word in input().split()]
    a = [int(word) for word in input().split()]
    a = [0] + a + [l]
    left = 0
    right = l
    while left + 1 < right:
        mid = (left + right) // 2
        if check_max(mid):
            right = mid
        else:
            left = mid
    hi = right
    left = 0
    right = l + 1
    while left + 1 < right:
        mid = (left + right) // 2
        if check_min(mid):
            left = mid
        else:
            right = mid
    lo = left
 
    graph = [[] for i in range(n + 1)]
    d = [float('inf') for i in range(n + 1)]
    for i in range(0, n):
        graph[i].append((i + 1, hi))
        graph[i + 1].append((i, -lo))
    for i in range(1, n):
        graph[0].append((i, a[i + 1]))
        graph[i].append((n, l - a[i]))
    graph[0].append((n, l))
    d[0] = 0
    q = deque([0])
    # vis = {0}
    while len(q) != 0:
        u = q.popleft()
        # vis.remove(u)
        for v, cost in graph[u]:
            if d[u] + cost < d[v]:
                d[v] = d[u] + cost
                # if v not in vis:
                #     vis.add(v)
                q.append(v)
 
    ans = []
    for i in range(1, len(d)):
        ans.append(f""{d[i - 1]} {d[i]}"")
    return ""\n"".join(ans)
 
 
def main():
    print(solve())
 
 
if __name__ == ""__main__"":
    main()","['binary search', 'constructive algorithms', 'greedy', 'math']"
"Julia's $$$n$$$ friends want to organize a startup in a new country they moved to. They assigned each other numbers from 1 to $$$n$$$ according to the jobs they have, from the most front-end tasks to the most back-end ones. They also estimated a matrix $$$c$$$, where $$$c_{ij} = c_{ji}$$$ is the average number of messages per month between people doing jobs $$$i$$$ and $$$j$$$.Now they want to make a hierarchy tree. It will be a binary tree with each node containing one member of the team. Some member will be selected as a leader of the team and will be contained in the root node. In order for the leader to be able to easily reach any subordinate, for each node $$$v$$$ of the tree, the following should apply: all members in its left subtree must have smaller numbers than $$$v$$$, and all members in its right subtree must have larger numbers than $$$v$$$.After the hierarchy tree is settled, people doing jobs $$$i$$$ and $$$j$$$ will be communicating via the shortest path in the tree between their nodes. Let's denote the length of this path as $$$d_{ij}$$$. Thus, the cost of their communication is $$$c_{ij} \cdot d_{ij}$$$.Your task is to find a hierarchy tree that minimizes the total cost of communication over all pairs: $$$\sum_{1 \le i &lt; j \le n} c_{ij} \cdot d_{ij}$$$.","n=int(input())
c=[]
for _ in range(n):
    c.append(tuple(map(int,input().split())))
prefix_sum=[[0]*(n+1) for _ in range(n+1)]
for i in range(1,n+1):
    temp=0
    for j in range(1,n+1):
        temp+=c[i-1][j-1]
        prefix_sum[i][j]+=prefix_sum[i-1][j]+temp
def get_rectangel_sum(x1,y1,x2,y2):
    return prefix_sum[x2+1][y2+1]-prefix_sum[x1][y2+1]-prefix_sum[x2+1][y1]+prefix_sum[x1][y1]
def cost(x,y):
    if x>y:
        return 0
    a=get_rectangel_sum(x,0,y,x-1) if x!=0 else 0
    b=get_rectangel_sum(x,y+1,y,n-1) if y!=n-1 else 0
    return a+b
dp=[[float(""INF"")]*n for _ in range(n)]
best_root_for_range=[[-1]*n for _ in range(n)]
for i in range(n):
    dp[i][i]=0
    best_root_for_range[i][i]=i
def get_dp_cost(x,y):
    return dp[x][y] if x<=y else 0
for length in range(1,n):
    # actual length is length+1
    for i in range(n-length):
        j=i+length
        for root in range(i,j+1):
            temp=cost(i,root-1)+cost(root+1,j)+get_dp_cost(i,root-1)+get_dp_cost(root+1,j)
            if temp<dp[i][j]:
                dp[i][j]=temp
                best_root_for_range[i][j]=root
ans=[-1]*n
def assign_ans(ansecstor,x,y):
    if x>y:
        return
    root=best_root_for_range[x][y]
    ans[root]=ansecstor
    assign_ans(root,x,root-1)
    assign_ans(root,root+1,y)
assign_ans(-1,0,n-1)
print(*[i+1 for i in ans])

# 3
# 0 1 2
# 1 0 3
# 2 3 0

# 4
# 0 1 2 3
# 1 0 5 7
# 2 5 0 4
# 3 7 4 0

# 6
# 0 100 20 37 14 73
# 100 0 17 13 20 2
# 20 17 0 1093 900 1
# 37 13 1093 0 2 4
# 14 20 900 2 0 1
# 73 2 1 4 1 0","['constructive algorithms', 'dp', 'shortest paths', 'trees']"
"Finally, you have defeated Razor and now, you are the Most Wanted street racer. Sergeant Cross has sent the full police force after you in a deadly pursuit. Fortunately, you have found a hiding spot but you fear that Cross and his force will eventually find you. To increase your chances of survival, you want to tune and repaint your BMW M3 GTR.The car can be imagined as a permuted $$$n$$$-dimensional hypercube. A simple $$$n$$$-dimensional hypercube is an undirected unweighted graph built recursively as follows:   Take two simple $$$(n-1)$$$-dimensional hypercubes one having vertices numbered from $$$0$$$ to $$$2^{n-1}-1$$$ and the other having vertices numbered from $$$2^{n-1}$$$ to $$$2^{n}-1$$$. A simple $$$0$$$-dimensional Hypercube is just a single vertex.  Add an edge between the vertices $$$i$$$ and $$$i+2^{n-1}$$$ for each $$$0\leq i &lt; 2^{n-1}$$$. A permuted $$$n$$$-dimensional hypercube is formed by permuting the vertex numbers of a simple $$$n$$$-dimensional hypercube in any arbitrary manner.Examples of a simple and permuted $$$3$$$-dimensional hypercubes are given below:  Note that a permuted $$$n$$$-dimensional hypercube has the following properties:   There are exactly $$$2^n$$$ vertices.  There are exactly $$$n\cdot 2^{n-1}$$$ edges.  Each vertex is connected to exactly $$$n$$$ other vertices.  There are no self-loops or duplicate edges. Let's denote the permutation used to generate the permuted $$$n$$$-dimensional hypercube, representing your car, from a simple $$$n$$$-dimensional hypercube by $$$P$$$. Before messing up the functionalities of the car, you want to find this permutation so that you can restore the car if anything goes wrong. But the job isn't done yet.You have $$$n$$$ different colours numbered from $$$0$$$ to $$$n-1$$$. You want to colour the vertices of this permuted $$$n$$$-dimensional hypercube in such a way that for each and every vertex $$$u$$$ satisfying $$$0\leq u &lt; 2^n$$$ and for each and every colour $$$c$$$ satisfying $$$0\leq c &lt; n$$$, there is at least one vertex $$$v$$$ adjacent to $$$u$$$ having a colour $$$c$$$. In other words, from each and every vertex, it must be possible to reach a vertex of any colour by just moving to an adjacent vertex. Given the permuted $$$n$$$-dimensional hypercube, find any valid permutation $$$P$$$ and colouring.","from collections import deque
from sys import stdin
import sys
 
tt = int(stdin.readline())
 
for loop in range(tt):
 
    n = int(stdin.readline())
 
    lis = [ [] for i in range(2**n)]
 
    for i in range(n*(2**(n-1))):
 
        u,v = map(int,stdin.readline().split())
        lis[u].append(v)
        lis[v].append(u)
 
    rp = [0] * (2**n)
    d = [float(""inf"")] * (2**n)
 
    d[0] = 0
 
    q = deque()
    for i in range(n):
        nexv = lis[0][i]
        rp[nexv] = 2**i
        d[nexv] = 1
        q.append(nexv)
 
    while q:
        v = q.popleft()
        for nexv in lis[v]:
 
            if d[nexv] == float(""inf""):
                d[nexv] = d[v] + 1
                q.append(nexv)
 
            if d[nexv] > d[v]:
                rp[nexv] |= rp[v]
 
    p = [None] * (2**n)
    for i in range(2**n):
        p[rp[i]] = i
 
    print (*p)
 
    if (2**n) % n == 0:
 
        c = [None] * (2**n)
        
        for i in range(2**n):
 
            now = 0
            for j in range(n):
                if 2**j & i > 0:
                    now ^= j
            c[p[i]] = now
 
        print (*c)
 
    else:
        print (-1)","['bitmasks', 'constructive algorithms', 'divide and conquer', 'graphs', 'greedy', 'math']"
"You are given two positive integers $$$n$$$ and $$$s$$$. Find the maximum possible median of an array of $$$n$$$ non-negative integers (not necessarily distinct), such that the sum of its elements is equal to $$$s$$$.A median of an array of integers of length $$$m$$$ is the number standing on the $$$\lceil {\frac{m}{2}} \rceil$$$-th (rounding up) position in the non-decreasing ordering of its elements. Positions are numbered starting from $$$1$$$. For example, a median of the array $$$[20,40,20,50,50,30]$$$ is the $$$\lceil \frac{m}{2} \rceil$$$-th element of $$$[20,20,30,40,50,50]$$$, so it is $$$30$$$. There exist other definitions of the median, but in this problem we use the described definition.","t = int(input())
for _ in range(t):
    n,s = map(int,input().split())
    if n%2 != 0:
        res = s//(n-(n//2))
    else:
        res = s//(n//2+1)
        
    print(res)","['binary search', 'greedy', 'math']"
"This is the hard version of the problem. The difference between the versions is the constraints on $$$a_i$$$. You can make hacks only if all versions of the problem are solved.Little Dormi has recently received a puzzle from his friend and needs your help to solve it. The puzzle consists of an upright board with $$$n$$$ rows and $$$m$$$ columns of cells, some empty and some filled with blocks of sand, and $$$m$$$ non-negative integers $$$a_1,a_2,\ldots,a_m$$$ ($$$0 \leq a_i \leq n$$$). In this version of the problem, $$$a_i$$$ will always be not greater than the number of blocks of sand in column $$$i$$$.When a cell filled with a block of sand is disturbed, the block of sand will fall from its cell to the sand counter at the bottom of the column (each column has a sand counter). While a block of sand is falling, other blocks of sand that are adjacent at any point to the falling block of sand will also be disturbed and start to fall. Specifically, a block of sand disturbed at a cell $$$(i,j)$$$ will pass through all cells below and including the cell $$$(i,j)$$$ within the column, disturbing all adjacent cells along the way. Here, the cells adjacent to a cell $$$(i,j)$$$ are defined as $$$(i-1,j)$$$, $$$(i,j-1)$$$, $$$(i+1,j)$$$, and $$$(i,j+1)$$$ (if they are within the grid). Note that the newly falling blocks can disturb other blocks.In one operation you are able to disturb any piece of sand. The puzzle is solved when there are at least $$$a_i$$$ blocks of sand counted in the $$$i$$$-th sand counter for each column from $$$1$$$ to $$$m$$$.You are now tasked with finding the minimum amount of operations in order to solve the puzzle. Note that Little Dormi will never give you a puzzle that is impossible to solve.","import itertools
import math
from math import inf


def readline():
    return map(int, input().split())


def blocks(bits):
    start = None
    for (i, bit) in enumerate(itertools.chain(bits, [False])):
        if bit and start is None:
            start = i
        if not bit and start is not None:
            yield (start, i)
            start = None


def test_blocks():
    assert list(blocks([0, 0, 0])) == []
    assert list(blocks([0, 1, 1])) == [(1, 3)]
    assert list(blocks([1, 1])) == [(0, 2)]
    assert list(blocks([0, 1, 1, 0, 0, 1, 1, 0])) == [(1, 3), (5, 7)]



def cut(iterable):
    for (a, b, __) in iterable:
        yield (a, b)


def magic_blocks(blocks, prev_blocks, annotate_w=False):
    if annotate_w:
        blocks = ((a, b, b-a) for (a, b) in blocks)
    glue = itertools.chain(prev_blocks, [(inf, inf)])
    gb, ge = -inf, -inf
    ma, mb, weight = None, None, 0
    for (a, b, w) in itertools.chain(blocks, [(inf, inf, inf)]):
        if ma is None:
            ma, mb, weight = a, b, w
            continue
        while ge <= a and ge < inf:
            gb, ge = next(glue)
        if gb < mb:
            mb = b
            weight += w
        else:
            # assert math.isfinite(weight)
            yield ma, mb, weight
            ma, mb, weight = a, b, w


def test_magic_blocks():
    blocks = ((0, 2), (4, 7), (10, 15))
    def tcut(mb):
        return tuple(cut(mb))
    assert tcut(magic_blocks(blocks, [])) == blocks
    assert tcut(magic_blocks(blocks, [(2, 4)])) == blocks
    assert tcut(magic_blocks(blocks, [(1, 4)])) == blocks
    assert tcut(magic_blocks(blocks, [(1, 5)])) == ((0, 7), (10, 15))
    assert tcut(magic_blocks(blocks, [(1, 10)])) == ((0, 7), (10, 15))
    assert tcut(magic_blocks(blocks, [(1, 11)])) == ((0, 15),)
    assert tcut(magic_blocks(blocks, [(1, 2), (3, 4), (7, 10)])) == blocks
    assert tcut(magic_blocks(blocks, [(1, 2), (3, 4), (6, 100)])) == ((0, 2), (4, 15))
    assert tcut(magic_blocks(blocks, [(7, 100), (101, 104)])) == blocks
    assert tcut(magic_blocks((), [(7, 100), (101, 104)])) == ()


unset = object()


def debug(*args):
    import sys
    print(*args, file=sys.stderr)


def solve_1(seq, a):
    ans = 0
    t = False
    for (is_sand, ai) in zip(seq, a):
        if not is_sand:
            t = False
        if ai:
            assert is_sand
            if not t:
                ans += 1
                t = True
    print(ans)


def main():
    n, m = readline()
    s = [
        [ch == '#' for ch in input()]
        for __ in range(n)
    ]
    # assert all(len(row) == m for row in s)
    a = list(readline())
    ans = 0

    if n == 1:
        solve_1(s[0], a)
        return

    m_blocks = [()]
    for i in range(m):
        sb = (blocks(row[i] for row in reversed(s)))
        m_blocks.append(tuple(magic_blocks(sb, cut(m_blocks[-1]), annotate_w=True)))
    m_blocks.pop(0)
    m_blocks.append(())
    for i in range(m, 0, -1):
        m_blocks[i-1] = tuple(magic_blocks(m_blocks[i-1], cut(m_blocks[i])))

    c = None
    f = -1
    for i in range(m):
        sand = a[i]
        next_c = unset
        next_f = -1
        top = -1
        for (from_, to, weight) in m_blocks[i]:
            top = to - 1
            if from_ <= f:
                next_f = top
            sand -= weight
            if sand > 0:
                continue
            if c is not None and c > top:
                continue
            if next_c is unset:
                next_c = from_
        assert sand <= 0

        if next_c is not unset and (c is not None or a[i] and next_c > f):
            if c is None:
                ans += 1
            c = next_c
            f = top
        else:
            c = None
            f = next_f
        # debug('cf', c, f)

    print(ans)


if __name__ == '__main__':
    main()","['dfs and similar', 'dp', 'graphs', 'greedy']"
"You have two strings $$$s_1$$$ and $$$s_2$$$ of length $$$n$$$, consisting of lowercase English letters. You can perform the following operation any (possibly zero) number of times:   Choose a positive integer $$$1 \leq k \leq n$$$.  Swap the prefix of the string $$$s_1$$$ and the suffix of the string $$$s_2$$$ of length $$$k$$$. Is it possible to make these two strings equal by doing described operations?","for _ in range(int(input())):
    n = int(input())
    w1 = input()
    w2 = input()[::-1]
    pairs = {}
    odd = 0
    for x in range(n):
        tmp_l = sorted([w1[x], w2[x]])
        tmp = f'{tmp_l[0]}{tmp_l[1]}'
        if tmp not in pairs:
            pairs[tmp] = 1
        else:
            pairs[tmp] += 1
    for k, v in pairs.items():
        if v % 2 == 1:
            if k[0] == k[1]:
                odd += 1
            else:
                odd += 2
                break
    if odd <= 1:
        print('YES')
    else:
        print('NO')","['constructive algorithms', 'strings', 'two pointers']"
"For the first place at the competition, Alex won many arrays of integers and was assured that these arrays are very expensive. After the award ceremony Alex decided to sell them. There is a rule in arrays pawnshop: you can sell array only if it can be compressed to a generator.This generator takes four non-negative numbers $$$n$$$, $$$m$$$, $$$c$$$, $$$s$$$. $$$n$$$ and $$$m$$$ must be positive, $$$s$$$ non-negative and for $$$c$$$ it must be true that $$$0 \leq c &lt; m$$$. The array $$$a$$$ of length $$$n$$$ is created according to the following rules:   $$$a_1 = s \bmod m$$$, here $$$x \bmod y$$$ denotes remainder of the division of $$$x$$$ by $$$y$$$;  $$$a_i = (a_{i-1} + c) \bmod m$$$ for all $$$i$$$ such that $$$1 &lt; i \le n$$$. For example, if $$$n = 5$$$, $$$m = 7$$$, $$$c = 4$$$, and $$$s = 10$$$, then $$$a = [3, 0, 4, 1, 5]$$$.Price of such an array is the value of $$$m$$$ in this generator.Alex has a question: how much money he can get for each of the arrays. Please, help him to understand for every array whether there exist four numbers $$$n$$$, $$$m$$$, $$$c$$$, $$$s$$$ that generate this array. If yes, then maximize $$$m$$$.","def fun(a,n):
    if n == 1 or n == 2:
        return 0
 
    p = set()
    for i in range(1,n):
        p.add(a[i]-a[i-1])
 
    p = list(p)
    p.sort()
 
    if len(p) > 2:
        return -1
    elif len(p) == 2:
        m = p[1]+(abs(p[0]) if p[0]<0 else -p[0])
        c = p[1]
        if m <= max(a):
            return -1
        
        for i in range(1,n):
            if a[i] != (a[i-1]+c)%m:
                return -1        
        return m, c
 
    elif len(p) == 1:
        return 0    
        
        
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    
    try:
        print(*fun(a, n))
    except:
        print(fun(a,n))","['implementation', 'math']"
"Aleksey has $$$n$$$ friends. He is also on a vacation right now, so he has $$$m$$$ days to play this new viral cooperative game! But since it's cooperative, Aleksey will need one teammate in each of these $$$m$$$ days.On each of these days some friends will be available for playing, and all others will not. On each day Aleksey must choose one of his available friends to offer him playing the game (and they, of course, always agree). However, if any of them happens to be chosen strictly more than $$$\left\lceil\dfrac{m}{2}\right\rceil$$$ times, then all other friends are offended. Of course, Aleksey doesn't want to offend anyone.Help him to choose teammates so that nobody is chosen strictly more than $$$\left\lceil\dfrac{m}{2}\right\rceil$$$ times.","import sys
input = sys.stdin.readline

tests = int(input())

for tt in range(tests):
    n, m = list(map(int, input().split()))

    cnt = [0] * (n+1)
    ans = [0] * (m)

    friend = [[] for i in range(m)]

    for i in range(m):
        friend[i] = list(map(int, input().split()))

    for i in range(m):
        if len(friend[i]) == 2:
            take = friend[i][1]
            cnt[take] += 1
            ans[i] = take

    for i in range(m):
        if ans[i] == 0:
            dmin, take = 200003, -1

            for j in friend[i][1::]:
                if cnt[j] < dmin:
                    dmin, take = cnt[j], j

            cnt[take] += 1
            ans[i] = take

    good = True
    for x in ans:
        if cnt[x] > (m+1)//2:
            good = False
            break

    if good:
        print(""YES"")
        print("" "".join(map(str, ans)))
    else:
        print(""NO"")","['combinatorics', 'flows', 'greedy', 'implementation']"
"Black is gifted with a Divine array $$$a$$$ consisting of $$$n$$$ ($$$1 \le n \le 2000$$$) integers. Each position in $$$a$$$ has an initial value. After shouting a curse over the array, it becomes angry and starts an unstoppable transformation.The transformation consists of infinite steps. Array $$$a$$$ changes at the $$$i$$$-th step in the following way: for every position $$$j$$$, $$$a_j$$$ becomes equal to the number of occurrences of $$$a_j$$$ in $$$a$$$ before starting this step.Here is an example to help you understand the process better:  Initial array:$$$2$$$ $$$1$$$ $$$1$$$ $$$4$$$ $$$3$$$ $$$1$$$ $$$2$$$After the $$$1$$$-st step:$$$2$$$ $$$3$$$ $$$3$$$ $$$1$$$ $$$1$$$ $$$3$$$ $$$2$$$After the $$$2$$$-nd step:$$$2$$$ $$$3$$$ $$$3$$$ $$$2$$$ $$$2$$$ $$$3$$$ $$$2$$$After the $$$3$$$-rd step:$$$4$$$ $$$3$$$ $$$3$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$4$$$...... In the initial array, we had two $$$2$$$-s, three $$$1$$$-s, only one $$$4$$$ and only one $$$3$$$, so after the first step, each element became equal to the number of its occurrences in the initial array: all twos changed to $$$2$$$, all ones changed to $$$3$$$, four changed to $$$1$$$ and three changed to $$$1$$$.The transformation steps continue forever.You have to process $$$q$$$ queries: in each query, Black is curious to know the value of $$$a_x$$$ after the $$$k$$$-th step of transformation.","for _ in range(int(input())):
   n = int(input())
   lst = list(map(int,input().split()))
   og,last = [0]*(n+1),0
   og[0] = lst
   for i in range(1,n+1):
      time = [og[i-1].count(j) for j in og[i-1]]
      if og[i-1] == time :
         og[i] = time
         last = i
         break
      else:
         og[i] = time
         last = i
   q = int(input())
   for k in range(q):
      a,k = map(int,input().split())
      if k < last:
         print(og[k][a-1])
      else:
         print(og[last][a-1])","['constructive algorithms', 'implementation']"
"Circular land is an $$$2n \times 2n$$$ grid. Rows of this grid are numbered by integers from $$$1$$$ to $$$2n$$$ from top to bottom and columns of this grid are numbered by integers from $$$1$$$ to $$$2n$$$ from left to right. The cell $$$(x, y)$$$ is the cell on the intersection of row $$$x$$$ and column $$$y$$$ for $$$1 \leq x \leq 2n$$$ and $$$1 \leq y \leq 2n$$$.There are $$$n^2$$$ of your friends in the top left corner of the grid. That is, in each cell $$$(x, y)$$$ with $$$1 \leq x, y \leq n$$$ there is exactly one friend. Some of the other cells are covered with snow.Your friends want to get to the bottom right corner of the grid. For this in each cell $$$(x, y)$$$ with $$$n+1 \leq x, y \leq 2n$$$ there should be exactly one friend. It doesn't matter in what cell each of friends will be.You have decided to help your friends to get to the bottom right corner of the grid.For this, you can give instructions of the following types:   You select a row $$$x$$$. All friends in this row should move to the next cell in this row. That is, friend from the cell $$$(x, y)$$$ with $$$1 \leq y &lt; 2n$$$ will move to the cell $$$(x, y + 1)$$$ and friend from the cell $$$(x, 2n)$$$ will move to the cell $$$(x, 1)$$$.  You select a row $$$x$$$. All friends in this row should move to the previous cell in this row. That is, friend from the cell $$$(x, y)$$$ with $$$1 &lt; y \leq 2n$$$ will move to the cell $$$(x, y - 1)$$$ and friend from the cell $$$(x, 1)$$$ will move to the cell $$$(x, 2n)$$$.  You select a column $$$y$$$. All friends in this column should move to the next cell in this column. That is, friend from the cell $$$(x, y)$$$ with $$$1 \leq x &lt; 2n$$$ will move to the cell $$$(x + 1, y)$$$ and friend from the cell $$$(2n, y)$$$ will move to the cell $$$(1, y)$$$.  You select a column $$$y$$$. All friends in this column should move to the previous cell in this column. That is, friend from the cell $$$(x, y)$$$ with $$$1 &lt; x \leq 2n$$$ will move to the cell $$$(x - 1, y)$$$ and friend from the cell $$$(1, y)$$$ will move to the cell $$$(2n, y)$$$. Note how friends on the grid border behave in these instructions.  Example of applying the third operation to the second column. Here, colorful circles denote your friends and blue cells are covered with snow. You can give such instructions any number of times. You can give instructions of different types. If after any instruction one of your friends is in the cell covered with snow he becomes ill.In order to save your friends you can remove snow from some cells before giving the first instruction:   You can select the cell $$$(x, y)$$$ that is covered with snow now and remove snow from this cell for $$$c_{x, y}$$$ coins. You can do this operation any number of times.You want to spend the minimal number of coins and give some instructions to your friends. After this, all your friends should be in the bottom right corner of the grid and none of them should be ill.Please, find how many coins you will spend.","from sys import stdin, gettrace

if gettrace():
    def inputi():
        return input()
else:
    def input():
        return next(stdin)[:-1]


    def inputi():
        return stdin.buffer.readline()


def solve():
    n = int(input())
    cc = [[int(c) for c in input().split()] for _ in range(2*n)]
    res = sum(sum(cc[i][n:]) for i in range(n, 2*n)) + min(cc[0][n],
                                                           cc[0][2*n - 1],
                                                           cc[n-1][n],
                                                           cc[n-1][2*n -1],
                                                           cc[n][0],
                                                           cc[2*n-1][0],
                                                           cc[n][n-1],
                                                           cc[2*n-1][n-1])
    print(res)

def main():
    t = int(input())
    for _ in range(t):
        solve()


if __name__ == ""__main__"":
    main()","['constructive algorithms', 'greedy', 'math']"
"This is the easy version of the problem. The difference between the versions is the constraint on $$$n$$$ and the required number of operations. You can make hacks only if all versions of the problem are solved.There are two binary strings $$$a$$$ and $$$b$$$ of length $$$n$$$ (a binary string is a string consisting of symbols $$$0$$$ and $$$1$$$). In an operation, you select a prefix of $$$a$$$, and simultaneously invert the bits in the prefix ($$$0$$$ changes to $$$1$$$ and $$$1$$$ changes to $$$0$$$) and reverse the order of the bits in the prefix.For example, if $$$a=001011$$$ and you select the prefix of length $$$3$$$, it becomes $$$011011$$$. Then if you select the entire string, it becomes $$$001001$$$.Your task is to transform the string $$$a$$$ into $$$b$$$ in at most $$$3n$$$ operations. It can be proved that it is always possible.","for _ in range(int(input())):
    n=int(input())
    s=input()
    s1=input()
    s=list(str(x) for x in s)
    s1=list(str(x) for x in s1)
    c=[]
    for i in range(n-1,-1,-1):
        if s[len(s)-1]==s1[i]:
            s=s[:len(s)-1]
            ##print(s,i)
            continue
        if int(s1[i])+int(s[0])==1:

            c.append(i+1)
            s=s[:i+1]
            for i in range(len(s)):
                if s[i]=='0':
                    s[i]='1'
                else:
                    s[i]='0'
            s=s[::-1]
            s=s[:len(s)-1]
            continue
        if s1[i]==s[0]:
            if s1[i]=='1':
                s[0]='0'
                c.append(1)
            else:
                c.append(1)
                s[0]='1'
            c.append(i + 1)
            s = s[:i + 1]
            ##print(s)
            for i in range(len(s)):
                if s[i] == '0':
                    s[i] = '1'
                else:
                    s[i] = '0'

            s = s[::-1]
            s=s[:len(s)-1]
            ##print(s)
            continue
    if len(c)==0:
        print(0)
        continue
    print(len(c),*c)","['data structures', 'constructive algorithms', 'strings']"
"Nastya baked $$$m$$$ pancakes and spread them on $$$n$$$ dishes. The dishes are in a row and numbered from left to right. She put $$$a_i$$$ pancakes on the dish with the index $$$i$$$.Seeing the dishes, Vlad decided to bring order to the stacks and move some pancakes. In one move, he can shift one pancake from any dish to the closest one, that is, select the dish $$$i$$$ ($$$a_i &gt; 0$$$) and do one of the following: if $$$i &gt; 1$$$, put the pancake on a dish with the previous index, after this move $$$a_i = a_i - 1$$$ and $$$a_{i - 1} = a_{i - 1} + 1$$$; if $$$i &lt; n$$$, put the pancake on a dish with the following index, after this move $$$a_i = a_i - 1$$$ and $$$a_{i + 1} = a_{i + 1} + 1$$$.Vlad wants to make the array $$$a$$$non-increasing, after moving as few pancakes as possible. Help him find the minimum number of moves needed for this.The array $$$a=[a_1, a_2,\dots,a_n]$$$ is called non-increasing if $$$a_i \ge a_{i+1}$$$ for all $$$i$$$ from $$$1$$$ to $$$n-1$$$.","import sys
from functools import cache
from itertools import accumulate
from math import inf

input = sys.stdin.readline

N, S = map(int, input().split())

A = list(map(int, input().split()))[::-1]
P = list(accumulate(A, initial=0))

dp = [[[inf] * (S + 1) for _ in range(S + 1)] for _ in range(N + 1)]
for val in range(S + 1):
    dp[N][val][S] = 0

for i in range(N - 1, -1, -1):
    for val in range(S, -1, -1):
        for total in range(S + 1):
            skip = dp[i][val + 1][total] if val + 1 <= S else inf
            new_total = total + val
            take = (abs(P[i + 1] - new_total) + dp[i + 1][val][new_total]) if new_total <= S else inf
            dp[i][val][total] = min(skip, take)

print(dp[0][0][0])",['dp']
"You are given a matrix $$$a$$$ consisting of positive integers. It has $$$n$$$ rows and $$$m$$$ columns.Construct a matrix $$$b$$$ consisting of positive integers. It should have the same size as $$$a$$$, and the following conditions should be met:   $$$1 \le b_{i,j} \le 10^6$$$;  $$$b_{i,j}$$$ is a multiple of $$$a_{i,j}$$$;  the absolute value of the difference between numbers in any adjacent pair of cells (two cells that share the same side) in $$$b$$$ is equal to $$$k^4$$$ for some integer $$$k \ge 1$$$ ($$$k$$$ is not necessarily the same for all pairs, it is own for each pair). We can show that the answer always exists.","a = []
n, m = map(int, input().split())
t = 720720
for _ in range(n):
    a.append([])
    for j in map(int, input().split()):
        a[-1].append(j)
for i in range(n):
    for j in range(m):
        if ((i + 1) + (j + 1)) % 2 == 1:
            a[i][j] = t
        else:
            a[i][j] **= 4
            a[i][j] += t
for i in range(n):
    print(*a[i])","['constructive algorithms', 'graphs', 'math', 'number theory']"
"Given a positive integer $$$k$$$, two arrays are called $$$k$$$-similar if:  they are strictly increasing;  they have the same length;  all their elements are positive integers between $$$1$$$ and $$$k$$$ (inclusive);  they differ in exactly one position. You are given an integer $$$k$$$, a strictly increasing array $$$a$$$ and $$$q$$$ queries. For each query, you are given two integers $$$l_i \leq r_i$$$. Your task is to find how many arrays $$$b$$$ exist, such that $$$b$$$ is $$$k$$$-similar to array $$$[a_{l_i},a_{l_i+1}\ldots,a_{r_i}]$$$.","import sys
import math


def prime_generator(nr_elemente_prime):
 
 #print(""pornire"")
 vector_prime=[-1]*nr_elemente_prime
 vector_rasp=[0]*nr_elemente_prime
 
 vector_prime[1]=1
 
 vector_rasp[1]=1
#primes sieve 
 contor=2
 
 for i in range(2,nr_elemente_prime):
  if vector_prime[i]==-1:
   vector_prime[i]=1
   vector_rasp[contor]=i
   contor=contor+1
  for j in range(i+i,nr_elemente_prime,i):
    if vector_prime[j]==-1:
     vector_prime[j]=i
   #print(i,j) 
 
 my_set=set(vector_rasp)
 my_set.remove(0)
 my_set.remove(1)
 
 lista_prime=list(my_set)
 lista_prime.sort()
 return lista_prime
 
 
vector_prime= prime_generator(1000000)
#print(vector_prime) 

set_prime=set(vector_prime)


def functie_divizori(numar):
 radical=int(numar**(1/2))
 set_divizori=set()
 if numar==1:
  set_divizori.add(1)
 elif numar in set_prime:
  set_divizori.add(numar)
 else: 
  for x in vector_prime:
   if x>radical:
    break
   else: 
    if numar%x==0:
     set_divizori.add(x)
     set_divizori.add(numar//x)
    
  set_divizori.add(numar)
 return set_divizori
 
#print(functie_divizori(6)) 
 
def printare_matrice(mat):
 for i in mat:
  for j in i:
   print(j,end=' ')
  print() 
 
 
def transformare_baza(numar,baza):
 
 transformare=""""
 while numar>=baza:
  rest=numar%baza
  numar=numar//baza
  transformare+=str(rest)
 
 transformare+=str(numar)
 noua_baza=transformare[::-1]
 return noua_baza
 
def cautare_binara(pozitie,vector):
 
  #print(""aici"")
  pornire=0
  oprire=pozitie-1
  noua_pozitie=(pornire+oprire)//2
  
  diferenta=vector[pozitie][0]-vector[pozitie][1]
  #print(""dif="",diferenta)
  #print(pozitie,pornire,oprire,noua_pozitie)
  
  while pornire+1<oprire:
   
  # print(noua_pozitie,vector[noua_pozitie][0])
   while  pornire+1<oprire and diferenta<=vector[noua_pozitie][0]:
   # print(""aici?"",noua_pozitie,vector[noua_pozitie][0])
    oprire=noua_pozitie
    noua_pozitie=(pornire+oprire)//2
    
    
   while  pornire+1<oprire and diferenta>vector[noua_pozitie][0]: 
    #print(noua_pozitie,vector[noua_pozitie][0])
    pornire=noua_pozitie
    noua_pozitie=(pornire+oprire)//2
  
  
 # print(""p="",pornire,""d="",diferenta) 
  while vector[pornire][0]<diferenta:
   pornire+=1
  while pornire-1>=0 and vector[pornire-1][0]>=diferenta:
    pornire-=1
    
   
  
  

  return (pozitie-pornire)
 
#vector = sorted(vector, key=lambda x: x[0])
 
 #lista=list(map(int,input().split()))
#alfabet = {'a': 1, 'b': 2,'c': 3,'d': 4,'e': 5,'f': 6,'g': 7,'h': 8,'i': 9,'j': 10,'k': 11,'l': 12,'m': 13,'n': 14,'o': 15,'p': 16,'q': 17,'r': 18,'s': 19,'t': 20,'u': 21,'v': 22,'w': 23,'x': 24,'y': 25,'z': 26}
#alfabet_2={'1':""a"", '2':""b"", '3':""c"", '4':""d"", '5':""e"", '6':""f"", '7':""g"", '8':""h"", '9':""i"", '10':""j"", '11':""k"", '12':""l"", '13':""m"", '14':""n"", '15':""o"", '16':""p"", '17':""q"", '18':""r"", '19':""s"", '20':""t"", '21':""u"", '22':""v"", '23':""w"", '24':""x"", '25':""y"", '26':""z""}
 
 
#print(vector[0:10])
#print(lista[0:10])
 
#z=int(input())
for contorr in range(1):
 
 n,q,k= list(map(int, sys.stdin.readline().split()))
 vector=list(map(int, sys.stdin.readline().split()))
# val=list(map(int, sys.stdin.readline().split()))
# blocari.append(n) 
 
 if n==1:
  for jj in range(q):
   print(k-1)
 else: 
  
  left=[]
  
  left.append(vector[1]-2)
 # left=[0]*n
 # left[0]=vector[1]-2
 
 
  right=[]
  right.append(k-1)
  
 
  #print(right[n-1])
 
 
  intre=[]
  intre.append(0)
  startare=[]
  startare.append(0)
  
  for i in range(1,n-1):
 
   left.append(vector[i+1]-2)
   right.append(k-vector[i-1]-1)
   intre.append(vector[i+1]-vector[i-1]-2)
  
   startare.append(startare[i-1]+intre[i])
   
  intre.append(0)
  left.append(k-vector[n-1])
  right.append(k-vector[n-2]-1)

  startare.append(0)
 # print(intre,left,right,startare) 
  
  
  #print(intre,left,right) 

  for x in range(q):
   l,r= map(int, sys.stdin.readline().split())
   l-=1
   r-=1
   
   #print(x)
   if l==r:
    print(k-1)
   else: 
    print(int(left[l]+right[r]+startare[r-1]-startare[l]))","['dp', 'implementation', 'math']"
"This is the easy version of the problem. The only difference is that in this version $$$q = 1$$$. You can make hacks only if both versions of the problem are solved.There is a process that takes place on arrays $$$a$$$ and $$$b$$$ of length $$$n$$$ and length $$$n-1$$$ respectively. The process is an infinite sequence of operations. Each operation is as follows:   First, choose a random integer $$$i$$$ ($$$1 \le i \le n-1$$$).  Then, simultaneously set $$$a_i = \min\left(a_i, \frac{a_i+a_{i+1}-b_i}{2}\right)$$$ and $$$a_{i+1} = \max\left(a_{i+1}, \frac{a_i+a_{i+1}+b_i}{2}\right)$$$ without any rounding (so values may become non-integer).  See notes for an example of an operation.It can be proven that array $$$a$$$ converges, i. e. for each $$$i$$$ there exists a limit $$$a_i$$$ converges to. Let function $$$F(a, b)$$$ return the value $$$a_1$$$ converges to after a process on $$$a$$$ and $$$b$$$.You are given array $$$b$$$, but not array $$$a$$$. However, you are given a third array $$$c$$$. Array $$$a$$$ is good if it contains only integers and satisfies $$$0 \leq a_i \leq c_i$$$ for $$$1 \leq i \leq n$$$.Your task is to count the number of good arrays $$$a$$$ where $$$F(a, b) \geq x$$$ for $$$q$$$ values of $$$x$$$. Since the number of arrays can be very large, print it modulo $$$10^9+7$$$.","def putin():
    return map(int, input().split())


def sol():
    n = int(input())
    C = list(putin())
    B = list(putin())
    q = int(input())
    x = int(input())
    min_arr = [x]
    min_part_sums = [x]
    part_sums = [C[0]]
    for i in range(1, n):
        part_sums.append(part_sums[-1] + C[i])
    for elem in B:
        min_arr.append(min_arr[-1] + elem)
        min_part_sums.append(min_arr[-1] + min_part_sums[-1])
    for i in range(n):
        if min_part_sums[i] > part_sums[i]:
            return 0
    if min_part_sums[0] > C[0]:
        return 0
    answer = [1] * (part_sums[0] - max(0, min_part_sums[0]) + 1)
    for k in range(1, n):
        new_answer = [0] * (part_sums[k] - max(0, min_part_sums[k]) + 1)
        cnt = 1
        window = answer[-1]
        new_answer[-1] = window
        while cnt <= len(new_answer) - 1:
            cnt += 1
            if cnt <= len(answer):
                window += answer[-cnt]
            if C[k] + 1 < cnt:
                window -= answer[C[k] + 1 - cnt]
            new_answer[-cnt] = window
        answer = new_answer.copy()
    m = 10 ** 9 + 7
    return sum(answer) % m


print(sol())","['dp', 'math']"
"Farmer John has a farm that consists of $$$n$$$ pastures connected by one-directional roads. Each road has a weight, representing the time it takes to go from the start to the end of the road. The roads could have negative weight, where the cows go so fast that they go back in time! However, Farmer John guarantees that it is impossible for the cows to get stuck in a time loop, where they can infinitely go back in time by traveling across a sequence of roads. Also, each pair of pastures is connected by at most one road in each direction.Unfortunately, Farmer John lost the map of the farm. All he remembers is an array $$$d$$$, where $$$d_i$$$ is the smallest amount of time it took the cows to reach the $$$i$$$-th pasture from pasture $$$1$$$ using a sequence of roads. The cost of his farm is the sum of the weights of each of the roads, and Farmer John needs to know the minimal cost of a farm that is consistent with his memory.","t = int(input())

def solve(n, a):
    a = sorted(a)
    s, uk = 0, 0
    for i in range(1, n):
        uk = uk+(s-a[i]*i)
        s = s+a[i]
        
    uk=uk+a[-1]
    return uk

for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    print(solve(n, a))","['constructive algorithms', 'graphs', 'greedy', 'shortest paths', 'sortings']"
"Sam is a kindergartener, and there are $$$n$$$ children in his group. He decided to create a team with some of his children to play ""brawl:go 2"".Sam has $$$n$$$ power-ups, the $$$i$$$-th has type $$$a_i$$$. A child's strength is equal to the number of different types among power-ups he has.For a team of size $$$k$$$, Sam will distribute all $$$n$$$ power-ups to $$$k$$$ children in such a way that each of the $$$k$$$ children receives at least one power-up, and each power-up is given to someone.For each integer $$$k$$$ from $$$1$$$ to $$$n$$$, find the minimum sum of strengths of a team of $$$k$$$ children Sam can get.","for i in range(int(input())):
		n= int(input())
		a=list(map(int,input().split()))
		x=len(set(a))
		z="" "".join(str(max(j,x)) for j in range(1,n+1) )
		print(z)",['greedy']
"You have a sequence $$$a_1, a_2, \ldots, a_n$$$ of length $$$n$$$, consisting of integers between $$$1$$$ and $$$m$$$. You also have a string $$$s$$$, consisting of $$$m$$$ characters B.You are going to perform the following $$$n$$$ operations.   At the $$$i$$$-th ($$$1 \le i \le n$$$) operation, you replace either the $$$a_i$$$-th or the $$$(m + 1 - a_i)$$$-th character of $$$s$$$ with A. You can replace the character at any position multiple times through the operations. Find the lexicographically smallest string you can get after these operations.A string $$$x$$$ is lexicographically smaller than a string $$$y$$$ of the same length if and only if in the first position where $$$x$$$ and $$$y$$$ differ, the string $$$x$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$y$$$.","def convertToList(str1):
    list1=[]
    list1[:]=str1
    return list1
    
def convertToString(list1):
    str1 =""""
    return str1.join(list1)
    
n =int(input())
for i in range(n):
    t,m=map(int,input().split())
    x=list(map(int,input().split()))
    num2 =0
    num3=0
    str1 =""B""*m
    list1 = convertToList(str1)
    for j in range(t):
        num = (m+1)-x[j]-1
        num1 =x[j]-1
        num2= min(num1,num)
        if(list1[num2] != ""A""):
            list1[num2] = ""A""
        else:
            num3= max(num1,num)
            list1[num3] = ""A""
    str1 = convertToString(list1)
    print(str1)","['2-sat', 'constructive algorithms', 'greedy', 'string suffix structures', 'strings']"
"You are given a connected undirected graph with $$$n$$$ vertices and $$$m$$$ edges. Vertices of the graph are numbered by integers from $$$1$$$ to $$$n$$$ and edges of the graph are numbered by integers from $$$1$$$ to $$$m$$$.Your task is to answer $$$q$$$ queries, each consisting of two integers $$$l$$$ and $$$r$$$. The answer to each query is the smallest non-negative integer $$$k$$$ such that the following condition holds:   For all pairs of integers $$$(a, b)$$$ such that $$$l\le a\le b\le r$$$, vertices $$$a$$$ and $$$b$$$ are reachable from one another using only the first $$$k$$$ edges (that is, edges $$$1, 2, \ldots, k$$$).","import os
import sys
from io import BytesIO, IOBase

import sys
import threading

threading.stack_size(250 * 1024 * 1024)
sys.setrecursionlimit(5000)


BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


class DisjointSetWithWeights:
    def __init__(self, size):
        self.U = [[i, 1] for i in range(size)]
        self.W = [10**9 for i in range(size)]
        
    def root(self, e):
        u = self.U[e]

        if u[0] != e:
#            r = self.U[e] = self.root(u[0])
            return self.root(u[0])

        return u

    def union(self, first, second, weight):
        uFirst, uSecond = self.root(first), self.root(second)

        if uFirst == uSecond:
            return False

        if uFirst[1] < uSecond[1]:
            uFirst, uSecond = uSecond, uFirst
            first, second = second, first

        if uSecond[0] != uFirst[0]:
            self.W[uSecond[0]] = weight
            uSecond[0] = uFirst[0]
            uFirst[1] += uSecond[1]
            
        return True

    def maxWeight(self, s, e):
        w = 0

        while s != e:
            if self.W[s] < self.W[e]:
                s, w = self.U[s][0], self.W[s]
            else:
                e, w = self.U[e][0], self.W[e]

        return w
                

class SparseTable:
    def __init__(self, A, F):
        self.A = A
        self.F = F

        self.buildLG()
        self.buildST()

    def buildLG(self):
        self.LG = []
        lg, V = 0, 1
        for e in range(len(self.A) + 1):
            if V * 2 <= e:
                V *= 2
                lg += 1
            self.LG.append(lg)

    def buildST(self):
        n = len(self.A)
        self.ST = []
        length = 1
        while length <= n:
            if length == 1:
                self.ST.append(self.A)
            else:
                self.ST.append([self.F(self.ST[-1][s], self.ST[-1][s + length//2]) for s in range(n - length + 1)])

            length <<= 1

    def query(self, l, r):
        if l == r:
            return self.ST[0][l]

        if l > r:
            l, r = r, l
        
        e = self.LG[r - l + 1]
        return self.F(self.ST[e][l], self.ST[e][r - 2**e + 1])


T = int(input())
for _ in range(T):
    n, m, q = map(int, input().split())

    dsu = DisjointSetWithWeights(n + 1)

    for i in range(m):
        s, e = map(int, input().split())
        dsu.union(s, e, i)

    W = [dsu.maxWeight(i, i + 1) for i in range(1, n)]

    ST = SparseTable(W, max)

    R = []
    for i in range(q):
        a, b = map(int, input().split())
        if a == b:
            R.append(0)
        else:
            R.append(ST.query(a - 1, b - 2) + 1)


    print("" "".join(str(r) for r in R))","['binary search', 'data structures', 'dfs and similar', 'divide and conquer', 'dsu', 'greedy', 'trees']"
"This is the hard version of the problem. The only difference between the versions is the constraints on $$$n$$$, $$$k$$$, $$$a_i$$$, and the sum of $$$n$$$ over all test cases. You can make hacks only if both versions of the problem are solved.Note the unusual memory limit.You are given an array of integers $$$a_1, a_2, \ldots, a_n$$$ of length $$$n$$$, and an integer $$$k$$$.The cost of an array of integers $$$p_1, p_2, \ldots, p_n$$$ of length $$$n$$$ is $$$$$$\max\limits_{1 \le i \le n}\left(\left \lfloor \frac{a_i}{p_i} \right \rfloor \right) - \min\limits_{1 \le i \le n}\left(\left \lfloor \frac{a_i}{p_i} \right \rfloor \right).$$$$$$Here, $$$\lfloor \frac{x}{y} \rfloor$$$ denotes the integer part of the division of $$$x$$$ by $$$y$$$. Find the minimum cost of an array $$$p$$$ such that $$$1 \le p_i \le k$$$ for all $$$1 \le i \le n$$$.","#!/usr/bin/env python3
import sys
import heapq
input = sys.stdin.readline  # to read input quickly
 
def ceiling_division(numer, denom):
    return -((-numer)//denom)
 
mask = 2**18 - 1
m0 = mask
m1 = mask << 18
m2 = mask << 36
 
 
def ungroup(x):
    return (x&m2) >> 36, (x&m1) >> 18, (x&m0) 
 
def group(a,b,c):
    val = (a << 36) ^ (b << 18) ^ c
    return val
 
for case_num in range(int(input())):
    n,k = list(map(int,input().split()))
 
    n_cooldown = 18*n
    cnt = n_cooldown
 
    arr = [group((x//k),k,x) for x in map(int,input().split())]
 
    minn = ungroup(arr[0])[0]
    maxx = ungroup(arr[-1])[0]
    minres = maxx - minn
 
    if minres == 0:
        print(0)
        continue
 
    maxx = max(1, maxx)
 
    while ungroup(arr[0])[1] > 1 and cnt > 0:
        nx,i,x = ungroup(heapq.heappop(arr))
 
        i = max(1, min(ceiling_division(x, maxx), x // (nx+1)))
        nx = (x//i)
        heapq.heappush(arr, group(nx,i,x))
 
        maxx = max(maxx, nx)
        minn = ungroup(arr[0])[0]
        cnt -= 1
        if maxx - minn < minres:
            minres = maxx - minn
            cnt = n_cooldown
        if minres == 0:
            break
 
    print(minres)","['brute force', 'constructive algorithms', 'data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']"
"Polycarp started working at a bank. He was assigned to monitor the ATM. The ATM initially contains $$$s$$$ rubles.A queue of $$$n$$$ students lined up to him. Each student wants to either withdraw a certain amount of money or deposit it into an account. If $$$a_i$$$ is positive, then the student credits that amount of money via ATM. Otherwise, the student withdraws $$$|a_i|$$$ rubles.In the beginning, the ATM is turned off and an arbitrary number of students are not served. At some point, Polycarp turns on the ATM, which has an initial amount of $$$s$$$ rubles. Then, the remaining students start queueing at the ATM. If at some point in time there is less money in the ATM than the student wants to withdraw, then the student is not served and Polycarp turns off the ATM and does not turn it on anymore.More formally, the students that are served are forming a contiguous subsequence.Polycarp wants the ATM to serve the maximum number of students. Help him in this matter. Print the numbers of the first and last student, or determine that he will not be able to serve anyone.In other words, find such a longest continuous segment of students that, starting with the sum of $$$s$$$ at the ATM, all these students will be served. ATM serves students consistently (i.e. one after another in the order of the queue).","from itertools import accumulate
from math import log
import sys
input = sys.stdin.buffer.readline

def parent(i):
	return i//2

def left_c(i):
	return i*2

def right_c(i):
	return i*2+1

def fill_tree(i, fro, to):
	if fro == to:
		tr[i] = pf[fro]
		d[fro] = i
		di[i] = fro
	else:
		tr[i] = min(fill_tree(left_c(i), fro, (fro+to)//2), fill_tree(right_c(i),(fro+to)//2 + 1,to))
	return tr[i]

def f(i):
	def ascend(i):
		if i == 1:
			return 1
		par = parent(i)
		cand = right_c(par)
		if tr[cand] < val:
			return cand
		return ascend(par)

	def descend(i):
		lc, rc = left_c(i), right_c(i)
		# if sum([tr[rc] is None, tr[lc] is None]) == 1:
		# 	assert False
		if rc <= max_i and tr[rc] is not None and tr[lc] is not None:
			# har två barn
			if tr[lc] < val:
				return descend(lc)
			else:
				return descend(rc)
		else:
			# har inga barn
			if tr[i] < val:
				return di[i]-1
			else:
				return di[i]





	ind = d[i]
	sta_pf = pf[i]
	val = sta_pf-s
	sto = descend(ascend(ind))
	# print(""ggg"", i, sto)
	return sto - i


for _ in range(int(input())):
	n, s = map(int, input().split())
	a = map(int, input().split())
	pf = [0]+list(accumulate(a))
	tr = [None] * (4 * n)
	d = {}
	di = {}
	fill_tree(1, 0, n)
	ans = 0
	sta = -1
	max_i = -1
	# print(""pf"",pf)
	for i in range(len(tr)):
		if tr[i] is not None:
			max_i = i
	# print(""max_i"",max_i)
	# for i in range(max_i):
	# 	if tr[i] is None:
	# 		print(tr[i],i)
	for i in range(n):
		ans1 = f(i)
		if ans1 > ans:
			ans = ans1
			sta = i
	if ans == 0:
		print(-1)
	else:
		print(sta+1, sta+ans)","['binary search', 'data structures', 'two pointers']"
"Vlad has $$$n$$$ friends, for each of whom he wants to buy one gift for the New Year.There are $$$m$$$ shops in the city, in each of which he can buy a gift for any of his friends. If the $$$j$$$-th friend ($$$1 \le j \le n$$$) receives a gift bought in the shop with the number $$$i$$$ ($$$1 \le i \le m$$$), then the friend receives $$$p_{ij}$$$ units of joy. The rectangular table $$$p_{ij}$$$ is given in the input.Vlad has time to visit at most $$$n-1$$$ shops (where $$$n$$$ is the number of friends). He chooses which shops he will visit and for which friends he will buy gifts in each of them.Let the $$$j$$$-th friend receive $$$a_j$$$ units of joy from Vlad's gift. Let's find the value $$$\alpha=\min\{a_1, a_2, \dots, a_n\}$$$. Vlad's goal is to buy gifts so that the value of $$$\alpha$$$ is as large as possible. In other words, Vlad wants to maximize the minimum of the joys of his friends.For example, let $$$m = 2$$$, $$$n = 2$$$. Let the joy from the gifts that we can buy in the first shop: $$$p_{11} = 1$$$, $$$p_{12}=2$$$, in the second shop: $$$p_{21} = 3$$$, $$$p_{22}=4$$$.Then it is enough for Vlad to go only to the second shop and buy a gift for the first friend, bringing joy $$$3$$$, and for the second — bringing joy $$$4$$$. In this case, the value $$$\alpha$$$ will be equal to $$$\min\{3, 4\} = 3$$$Help Vlad choose gifts for his friends so that the value of $$$\alpha$$$ is as high as possible. Please note that each friend must receive one gift. Vlad can visit at most $$$n-1$$$ shops (where $$$n$$$ is the number of friends). In the shop, he can buy any number of gifts.","import sys, os

#
# Benchmarking weird pypy3
inp = [int(x) for x in os.read(0, 10**7).split()]; ii = 0
 
out = []
 
t = inp[ii]; ii += 1
for _ in range(t):
    n = inp[ii]; ii += 1
    m = inp[ii]; ii += 1
    A = inp[ii: ii + n * m]; ii += n * m
 
    def solve(bound):
        B = [+(a >= bound) for a in A]
        
        for j in range(m):
            Bcol = [B[ind] for ind in range(j,n*m,m)]
        
            if not any(Bcol):
                return False
 
        for i in range(n):
            Brow = [B[ind] for ind in range(i * m, i * m + m)]
 
            if sum(Brow) >= 2:
                return True
        return False
 
    l = 1
    r = 10**9
    while l < r:
        mid = l + r + 1 >> 1
        if not solve(mid):
            r = mid - 1
        else:
            l = mid
    
    print(l)","['binary search', 'greedy', 'sortings']"
"Consider the array $$$a$$$ composed of all the integers in the range $$$[l, r]$$$. For example, if $$$l = 3$$$ and $$$r = 7$$$, then $$$a = [3, 4, 5, 6, 7]$$$.Given $$$l$$$, $$$r$$$, and $$$k$$$, is it possible for $$$\gcd(a)$$$ to be greater than $$$1$$$ after doing the following operation at most $$$k$$$ times?   Choose $$$2$$$ numbers from $$$a$$$.  Permanently remove one occurrence of each of them from the array.  Insert their product back into $$$a$$$. $$$\gcd(b)$$$ denotes the greatest common divisor (GCD) of the integers in $$$b$$$.","for i in range(int(input())):
    a=list(map(int,input().split(' ')))
    if a[0]==a[1]:
        if a[0]!=1:
            print('YES')
        else:
            print('NO')
    else:
        k=a[2]
        if a[0]%2!=0:
            d=1+(a[1]-a[0])//2
        else:
            d=(a[1]-a[0]+1)//2
        if k>=d:
            print('YES')
        else:
            print('NO')","['greedy', 'math', 'number theory']"
"Some time ago Homer lived in a beautiful city. There were $$$n$$$ blocks numbered from $$$1$$$ to $$$n$$$ and $$$m$$$ directed roads between them. Each road had a positive length, and each road went from the block with the smaller index to the block with the larger index. For every two (different) blocks, there was at most one road between them. Homer discovered that for some two numbers $$$L$$$ and $$$R$$$ the city was $$$(L, R)$$$-continuous. The city is said to be $$$(L, R)$$$-continuous, if   all paths from block $$$1$$$ to block $$$n$$$ are of length between $$$L$$$ and $$$R$$$ (inclusive); and  for every $$$L \leq d \leq R$$$, there is exactly one path from block $$$1$$$ to block $$$n$$$ whose length is $$$d$$$. A path from block $$$u$$$ to block $$$v$$$ is a sequence $$$u = x_0 \to x_1 \to x_2 \to \dots \to x_k = v$$$, where there is a road from block $$$x_{i-1}$$$ to block $$$x_{i}$$$ for every $$$1 \leq i \leq k$$$. The length of a path is the sum of lengths over all roads in the path. Two paths $$$x_0 \to x_1 \to \dots \to x_k$$$ and $$$y_0 \to y_1 \to \dots \to y_l$$$ are different, if $$$k \neq l$$$ or $$$x_i \neq y_i$$$ for some $$$0 \leq i \leq \min\{k, l\}$$$. After moving to another city, Homer only remembers the two special numbers $$$L$$$ and $$$R$$$ but forgets the numbers $$$n$$$ and $$$m$$$ of blocks and roads, respectively, and how blocks are connected by roads. However, he believes the number of blocks should be no larger than $$$32$$$ (because the city was small).As the best friend of Homer, please tell him whether it is possible to find a $$$(L, R)$$$-continuous city or not.","import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16
md = 10**9+7
# md = 998244353

L, R = MI()
if L==R:
    print(""YES"")
    print(2,1)
    print(1,2,L)
    exit()

# [L,R] to [0,R-L]+L
r = R-L
n = r.bit_length()+1
# print(n)
ans = []
for i in range(2, n+1):
    c = 1 << i-2
    ans.append((1, i, 1))
    for j in range(i+1, n+1):
        ans.append((i, j, c))
# print(ans)

c = 1 << n-2
n += 1
update=False
for i in range(n-4, -1, -1):
    if r >> i & 1:
        ans.append((i+2, n, c))
        c += 1 << i
        update=True

n += 1
if update:ans.append((n-1, n, L))
ans.append((n-2, n, L))
ans.append((1, n, L))

print(""YES"")
print(n, len(ans))
for i, j, c in ans: print(i, j, c)","['bitmasks', 'constructive algorithms']"
"A basketball competition is held where the number of players in a team does not have a maximum or minimum limit (not necessarily $$$5$$$ players in one team for each match). There are $$$N$$$ candidate players in the competition that will be trained by Pak Chanek, the best basketball coach on earth. The $$$i$$$-th candidate player has a power of $$$P_i$$$.Pak Chanek will form zero or more teams from the $$$N$$$ candidate players on the condition that each candidate player may only join in at most one team. Each of Pak Chanek's teams will be sent to compete once with an enemy team that has a power of $$$D$$$. In each match, the team sent is said to defeat the enemy team if the sum of powers from the formed players is strictly greater than $$$D$$$.One of Pak Chanek's skills is that when a team that has been formed plays in a match, he can change the power of each player in the team to be equal to the biggest player power from the team.Determine the maximum number of wins that can be achieved by Pak Chanek.","import math
nd = input().split()
n = int(nd[0])
d = int(nd[1])
 
pstr = input().split()
p = []
for i in pstr:
    p.append(int(i))
p = sorted(p, reverse = True)
 

remplayers = n
teamcount = 0

for i in p:
    reqplayers = math.ceil((d+1)/i)
    remplayers -= reqplayers
    if remplayers >= 0:
        teamcount += 1

print(teamcount)","['binary search', 'greedy', 'sortings']"
"I, Fischl, Prinzessin der Verurteilung, descend upon this land by the call of fate an — Oh, you are also a traveler from another world? Very well, I grant you permission to travel with me.It is no surprise Fischl speaks with a strange choice of words. However, this time, not even Oz, her raven friend, can interpret her expressions! Maybe you can help us understand what this young princess is saying?You are given a string of $$$n$$$ lowercase Latin letters, the word that Fischl just spoke. You think that the MEX of this string may help you find the meaning behind this message. The MEX of the string is defined as the shortest string that doesn't appear as a contiguous substring in the input. If multiple strings exist, the lexicographically smallest one is considered the MEX. Note that the empty substring does NOT count as a valid MEX.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds:   $$$a$$$ is a prefix of $$$b$$$, but $$$a \ne b$$$;  in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$. A string $$$a$$$ is a substring of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.Find out what the MEX of the string is!","t=int(input())
for  p in range(t):
    n=int(input())
    a=input()
    o=0
    l=1
    if len(set(a))==26:
        o=1
    for i in 'abcdefghijklmnopqrstuvwxyz':
        if i not in a:
            print(i)
            break
        elif o==1:
            for j in 'abcdefghijklmnopqrstuvwxyz':
                if i+j not in a and n<676:
                    print(i+j)
                    l=0
                    break
                if n>676:
                    for x in 'abcdefghijklmnopqrstuvwxyz':
                        if i+j+x not in a:
                            print(i+j+x)
                            l=0
                            break
                if l==0:
                    break
        if l==0:
            break","['brute force', 'constructive algorithms', 'strings']"
"You have a stripe of checkered paper of length $$$n$$$. Each cell is either white or black.What is the minimum number of cells that must be recolored from white to black in order to have a segment of $$$k$$$ consecutive black cells on the stripe?If the input data is such that a segment of $$$k$$$ consecutive black cells already exists, then print 0.","t = int(input())
while t:
    n, m = map(int, input(). split())
    s = input()
    mn = 2 * (10 ** 5)
    W = 0
    B = 0
    for i in range(n):
        if s[i] == 'W':
            W += 1
        if s[i] == 'B':
            B += 1
        if (i + 1) >= m:
            mn = min(mn, W)
            if s[(i + 1) - m] == 'W':
                W -= 1
            else:
                B -= 1
    print(mn)
    t -= 1","['implementation', 'two pointers']"
"Polycarp found the string $$$s$$$ and the permutation $$$p$$$. Their lengths turned out to be the same and equal to $$$n$$$.A permutation of $$$n$$$ elements — is an array of length $$$n$$$, in which every integer from $$$1$$$ to $$$n$$$ occurs exactly once. For example, $$$[1, 2, 3]$$$ and $$$[4, 3, 5, 1, 2]$$$ are permutations, but $$$[1, 2, 4]$$$, $$$[4, 3, 2, 1, 2]$$$ and $$$[0, 1, 2]$$$ are not.In one operation he can multiply $$$s$$$ by $$$p$$$, so he replaces $$$s$$$ with string $$$new$$$, in which for any $$$i$$$ from $$$1$$$ to $$$n$$$ it is true that $$$new_i = s_{p_i}$$$. For example, with $$$s=wmbe$$$ and $$$p = [3, 1, 4, 2]$$$, after operation the string will turn to $$$s=s_3 s_1 s_4 s_2=bwem$$$.Polycarp wondered after how many operations the string would become equal to its initial value for the first time. Since it may take too long, he asks for your help in this matter.It can be proved that the required number of operations always exists. It can be very large, so use a 64-bit integer type.","from collections import *
from heapq import *
from bisect import *
from itertools import *
from string import *
from math import *
 
 
def solve():
    n = int(input())
    s = input()
    P = list(map(int, input().split()))
    P = [x - 1 for x in P]

    seen = set()
    components = []

    def dfs(u, component):
        if u not in seen:
            seen.add(u)
            component.append(u)
            dfs(P[u], component)

    for i in range(n):
        if i not in seen:
            component = []
            dfs(i, component)
            components.append(component)

    def find_cycle_length(vals):
        a = ''.join(s[i] for i in vals)
        m = len(a)
        for k in range(1,m+1):
            if m % k != 0: continue
            if all(a[j] == a[j-k] for j in range(k,m)):
                return k
        assert False

 
    ans = [find_cycle_length(comp) for comp in components]
    return lcm(*ans)
 
 
def main():
    T = int(input())
    for _ in range(T):
        print(solve())
 
 
if __name__ == ""__main__"":
    main()","['graphs', 'math', 'number theory', 'strings']"
"Given the integer $$$n$$$ — the number of available blocks. You must use all blocks to build a pedestal. The pedestal consists of $$$3$$$ platforms for $$$2$$$-nd, $$$1$$$-st and $$$3$$$-rd places respectively. The platform for the $$$1$$$-st place must be strictly higher than for the $$$2$$$-nd place, and the platform for the $$$2$$$-nd place must be strictly higher than for the $$$3$$$-rd place. Also, the height of each platform must be greater than zero (that is, each platform must contain at least one block).    Example pedestal of $$$n=11$$$ blocks: second place height equals $$$4$$$ blocks, first place height equals $$$5$$$ blocks, third place height equals $$$2$$$ blocks.Among all possible pedestals of $$$n$$$ blocks, deduce one such that the platform height for the $$$1$$$-st place minimum as possible. If there are several of them, output any of them.","# -*- coding: utf-8 -*-
""""""
Created on Sat Jun 11 14:58:24 2022

@author: Ajay Varma
""""""

# 5 9 3
# aaacc
# bbdddeeee

# aaabbcc

for i in range(int(input())):
    n = int(input())
    if n==7:
        print(2 ,4, 1)
        continue
    if n%3:
        a = (n//3)+1
        b = (n//3)+2
        c = (n//3)- (2 if n%3==1 else 1)
    else:
        a = (n//3)
        b = (n//3)+1
        c=  (n//3)-1
    print(a,b,c)","['constructive algorithms', 'greedy']"
"You are given a permutation $$$p$$$ consisting of $$$n$$$ integers $$$1, 2, \dots, n$$$ (a permutation is an array where each element from $$$1$$$ to $$$n$$$ occurs exactly once).Let's call an array $$$a$$$ bipartite if the following undirected graph is bipartite:  the graph consists of $$$n$$$ vertices;  two vertices $$$i$$$ and $$$j$$$ are connected by an edge if $$$i &lt; j$$$ and $$$a_i &gt; a_j$$$. Your task is to find a bipartite array of integers $$$a$$$ of size $$$n$$$, such that $$$a_i = p_i$$$ or $$$a_i = -p_i$$$, or report that no such array exists. If there are multiple answers, print any of them.","from math import inf
import sys

input = sys.stdin.readline
inf = 1 << 20

def sol(numbers):
    n, elems = numbers

    # dp[i, sign]
    # i: posición del elemento i-ésimo del array elems que se está analizando
    # sign: signo que se le puso al elemento (i-1)-ésimo de elems   
    dp = [[inf, inf] for _ in range(n)]
    dp[0][0] = dp[0][1] = -inf

    # cad
    cad = [[0, 0] for _ in range(n)]

    for i in range(n - 1):
        for s in range(2):
            if dp[i][s] != inf:
                x = -1 * elems[i] if s else elems[i]
                y = dp[i][s]
                if x < y:
                    x, y = y, x
                for sp in range(2):
                    z = -1 * elems[i + 1] if sp else elems[i + 1]
                    if z > x and dp[i + 1][sp] > y:
                        dp[i + 1][sp] = y
                        cad[i + 1][sp] = s
                    elif z > y and dp[i + 1][sp] > x:
                        dp[i + 1][sp] = x
                        cad[i + 1][sp] = s

    sg = -1
    for s in range(2):
        if dp[n - 1][s] != inf:
            sg = s

    if sg == -1:
        print(""NO"")
        return

    res = [0] * n
    for i in range(n - 1, -1, -1):
        res[i] = -1 * elems[i] if sg else elems[i]
        sg = cad[i][sg]

    print(""YES"")
    print(*res)

def main():
    # t: number of test cases
    t = int(input())

    # test cases
    for _ in range(t):
        n = int(input())
        numbers = (n, list(map(int, input().split("" ""))))
        sol(numbers)
    



main()","['dp', 'greedy']"
"The cuteness of a binary string is the number of $$$\texttt{1}$$$s divided by the length of the string. For example, the cuteness of $$$\texttt{01101}$$$ is $$$\frac{3}{5}$$$.Juju has a binary string $$$s$$$ of length $$$n$$$. She wants to choose some non-intersecting subsegments of $$$s$$$ such that their concatenation has length $$$m$$$ and it has the same cuteness as the string $$$s$$$. More specifically, she wants to find two arrays $$$l$$$ and $$$r$$$ of equal length $$$k$$$ such that $$$1 \leq l_1 \leq r_1 &lt; l_2 \leq r_2 &lt; \ldots &lt; l_k \leq r_k \leq n$$$, and also:  $$$\sum\limits_{i=1}^k (r_i - l_i + 1) = m$$$;  The cuteness of $$$s[l_1,r_1]+s[l_2,r_2]+\ldots+s[l_k,r_k]$$$ is equal to the cuteness of $$$s$$$, where $$$s[x, y]$$$ denotes the subsegment $$$s_x s_{x+1} \ldots s_y$$$, and $$$+$$$ denotes string concatenation. Juju does not like splitting the string into many parts, so she also wants to minimize the value of $$$k$$$. Find the minimum value of $$$k$$$ such that there exist $$$l$$$ and $$$r$$$ that satisfy the constraints above or determine that it is impossible to find such $$$l$$$ and $$$r$$$ for any $$$k$$$.","import sys
from calendar import c
import math

t = int(input())

for _ in range(0, t):
    n,m = [int(i) for i in input().split()]
    s = input()
    p = [0 for i in range(n+1)]
    for i in range(0, n):
        p[i + 1] = p[i] + (s[i] == '1')
    k = p[n]
    c = k * m
    if c % n != 0:
        print(""-1"")
        continue
    c /= n
    sol =- 1
    for i in range(0, n-m+1):
        if p[i + m] - p[i] == c:
            sol = i
            break
    if sol != -1:
        print(1)
        print('{} {}'.format(sol + 1,sol + m))
        continue
    
    for i in range(0, m+1):
        if p[i + (n-m)] - p[i] == k-c:
            sol = i
    
    if sol != -1:
        print(2)
        print('{} {}'.format(1,sol))
        print('{} {}'.format(sol+1+n-m,n))","['brute force', 'constructive algorithms', 'greedy', 'math']"
"Ezzat has an array of $$$n$$$ integers (maybe negative). He wants to split it into two non-empty subsequences $$$a$$$ and $$$b$$$, such that every element from the array belongs to exactly one subsequence, and the value of $$$f(a) + f(b)$$$ is the maximum possible value, where $$$f(x)$$$ is the average of the subsequence $$$x$$$. A sequence $$$x$$$ is a subsequence of a sequence $$$y$$$ if $$$x$$$ can be obtained from $$$y$$$ by deletion of several (possibly, zero or all) elements.The average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence.For example, the average of $$$[1,5,6]$$$ is $$$(1+5+6)/3 = 12/3 = 4$$$, so $$$f([1,5,6]) = 4$$$.","#!/usr/bin/env python3
import io
import os
import sys

input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

def printd(*args, **kwargs):
    #print(*args, **kwargs, file=sys.stderr)
    print(*args, **kwargs)
    pass

def get_str():
    return input().decode().strip()

def rint():
    return map(int, input().split())

def oint():
    return int(input())

def solve_(iter, cnt):
    if cnt == 0:
        return
    iter()
    solve(iter, cnt - 1)

def solve(iter, cnt):
    for _ in range(cnt):
        iter()

def solve_iter():
    n = oint()
    a = sorted(rint())
    print(a[n-1] + sum(a[:n-1])/(n-1))

solve(solve_iter, oint())","['brute force', 'math', 'sortings']"
"Madoka as a child was an extremely capricious girl, and one of her favorite pranks was drawing on her wall. According to Madoka's memories, the wall was a table of $$$n$$$ rows and $$$m$$$ columns, consisting only of zeroes and ones. The coordinate of the cell in the $$$i$$$-th row and the $$$j$$$-th column ($$$1 \le i \le n$$$, $$$1 \le j \le m$$$) is $$$(i, j)$$$.One day she saw a picture ""Mahou Shoujo Madoka Magica"" and decided to draw it on her wall. Initially, the Madoka's table is a table of size $$$n \times m$$$ filled with zeroes. Then she applies the following operation any number of times:Madoka selects any rectangular subtable of the table and paints it in a chess coloring (the upper left corner of the subtable always has the color $$$0$$$). Note that some cells may be colored several times. In this case, the final color of the cell is equal to the color obtained during the last repainting.  White color means $$$0$$$, black means $$$1$$$. So, for example, the table in the first picture is painted in a chess coloring, and the others are not. For better understanding of the statement, we recommend you to read the explanation of the first test.Help Madoka and find some sequence of no more than $$$n \cdot m$$$ operations that allows you to obtain the picture she wants, or determine that this is impossible.","import sys
import math
from collections import defaultdict, Counter, deque
from bisect import *
from string import ascii_lowercase
from heapq import *


def readInts():
    x = list(map(int, (sys.stdin.readline().rstrip().split())))
    return x[0] if len(x) == 1 else x


def readList(type=int):
    x = sys.stdin.readline()
    x = list(map(type, x.rstrip('\n\r').split()))
    return x


def readStr():
    x = sys.stdin.readline().rstrip('\r\n')
    return x


write = sys.stdout.write
read = sys.stdin.readline


def dist(x1, x2, y1, y2):
    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)


def mergeSort(arr, check = lambda a, b: a < b, reverse = False):
    if len(arr) > 1:
  
        # Finding the mid of the array
        mid = len(arr)//2
  
        # Dividing the array elements
        L = arr[:mid]
  
        # into 2 halves
        R = arr[mid:]
  
        # Sorting the first half
        mergeSort(L, check, reverse)
  
        # Sorting the second half
        mergeSort(R, check, reverse)
  
        i = j = k = 0
  
        # Copy data to temp arrays L[] and R[]
        while i < len(L) and j < len(R):
            if check(L[i], R[j]):
                if not reverse:
                    arr[k] = L[i]
                    i += 1
                else:
                    arr[k] = R[j]
                    j += 1
            else:
                if not reverse:
                    arr[k] = R[j]
                    j += 1
                else:
                    arr[k] = L[i]
                    i += 1 
            k += 1
  
        # Checking if any element was left
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
      
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1


def maxSum(arr):
    
    max_sum = float('-inf')   
    max_cur = 0 
    for num in ar:
        max_cur = max(max_cur + num, num)
        if max_cur > max_sum:
            max_sum = max_cur
    return max_sum


def hcf(a, b):
    if b == 0:
        return a
    else:
        return hcf(b, b%a)


def get_power(n, m):
    i = 1
    p = -1
    while i <= n:
        i = i*m
        p += 1
    return p


def fact(n):
    f = 1
    for i in range(2, n+1):
        f *= i
    return f


def find_closest(num, ar):
    min_d = float('inf')
    for num2 in ar:
        d = abs(num2-num)
        if d < min_d:
            min_d = d
    return min_d 


def check_pal(n):
    s = str(n)
    j = len(s)-1
    i = 0
    while j > i:
        if s[i] != s[j]:
            return False
        i += 1
        j -= 1

    return True


def solve(t):
    n, m = readInts()
    ar = []
    
    for _ in range(n):
        ar.append(list(readStr()))

    prev = False
    res = []

    if ar[0][0] == '1':
        print(-1)
        return

    for i in range(n-1, -1, -1):
        for j in range(m-1, -1, -1):
            if ar[i][j] == '1':
                if i == 0:
                    res.append([i+1, j, i+1, j+1])
                else:
                    res.append([i, j+1, i+1, j+1])


    print(len(res))
    for op in res:
        print(*op)


def main():
    t = 1
    #f = open('F:/ts2_input.txt', 'r')
    #sys.stdin = f
    sys.setrecursionlimit(10000)
    t = readInts()
    for i in range(t):
        solve(i+1)
    #f.close()


if __name__ == '__main__':
    main()","['constructive algorithms', 'greedy']"
"A binary string is a string consisting only of the characters 0 and 1. You are given a binary string $$$s_1 s_2 \ldots s_n$$$. It is necessary to make this string non-decreasing in the least number of operations. In other words, each character should be not less than the previous. In one operation, you can do the following: Select an arbitrary index $$$1 \leq i \leq n$$$ in the string; For all $$$j \geq i$$$, change the value in the $$$j$$$-th position to the opposite, that is, if $$$s_j = 1$$$, then make $$$s_j = 0$$$, and vice versa.What is the minimum number of operations needed to make the string non-decreasing?","from sys import stdin, stdout
 
t = int(stdin.readline())
 
for p in range(t):
    n = int(stdin.readline())
    listA = [int(x) for x in str(stdin.readline().strip())]
    
    count = 0
    i = 0
    while i < n-1:
        #print(i, count)
        if listA[i] == 1 and listA[i+1] == 0:
            if i+2 < n:
                for j in range(i+2,n):
                    if listA[j] == 1:
                        i = j
                        count += 2
                        break
                    if j == n-1:
                        i = j +1
                        count += 1
            else:
                i = i+2
                count += 1
        else:
            i += 1
    print(count)","['brute force', 'dp', 'greedy', 'implementation']"
"Ashish has a string $$$s$$$ of length $$$n$$$ containing only characters 'a', 'b' and 'c'.He wants to find the length of the smallest substring, which satisfies the following conditions:   Length of the substring is at least $$$2$$$  'a' occurs strictly more times in this substring than 'b'  'a' occurs strictly more times in this substring than 'c'  Ashish is busy planning his next Codeforces round. Help him solve the problem.A string $$$a$$$ is a substring of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.","t = int(input())
for case in range(t):
    n = int(input())
    s = input()
    ans = -1
    tests = ['aa', 'aba', 'aca', 'abca', 'acba', 'abbacca', 'accabba']
    for i in tests:
        if i in s:
            ans = len(i)
            break
    print(ans)","['brute force', 'greedy', 'implementation', 'strings']"
"Tokitsukaze has a permutation $$$p$$$ of length $$$n$$$. Recall that a permutation $$$p$$$ of length $$$n$$$ is a sequence $$$p_1, p_2, \ldots, p_n$$$ consisting of $$$n$$$ distinct integers, each of which from $$$1$$$ to $$$n$$$ ($$$1 \leq p_i \leq n$$$).She wants to know how many different indices tuples $$$[a,b,c,d]$$$ ($$$1 \leq a &lt; b &lt; c &lt; d \leq n$$$) in this permutation satisfy the following two inequalities:  $$$p_a &lt; p_c$$$ and $$$p_b &gt; p_d$$$. Note that two tuples $$$[a_1,b_1,c_1,d_1]$$$ and $$$[a_2,b_2,c_2,d_2]$$$ are considered to be different if $$$a_1 \ne a_2$$$ or $$$b_1 \ne b_2$$$ or $$$c_1 \ne c_2$$$ or $$$d_1 \ne d_2$$$.","import sys
input = sys.stdin.readline
t = int(input())
for _ in range(t):
    f = [0] * 5001
    bitf = [0] * 5001
    count = 0
    length = int(input())
    lst = tuple(map(int, input().split()))
    for j in range(length):
        for l in range(j+1, length):
            if lst[j]>lst[l]: f[j]+=1
    for k in range(length):
        for j in range(k):
            if lst[j]>lst[k]: f[j]-= 1
        bitf[0] = 0;
        for i in range(k): bitf[i]=bitf[i-1]+f[i]
        for i in range(k-1): 
            if lst[i]<lst[k]: count += bitf[k-1]-bitf[i]
    print(count)","['brute force', 'data structures', 'dp']"
"Tokitsukaze is arranging a meeting. There are $$$n$$$ rows and $$$m$$$ columns of seats in the meeting hall.There are exactly $$$n \cdot m$$$ students attending the meeting, including several naughty students and several serious students. The students are numerated from $$$1$$$ to $$$n\cdot m$$$. The students will enter the meeting hall in order. When the $$$i$$$-th student enters the meeting hall, he will sit in the $$$1$$$-st column of the $$$1$$$-st row, and the students who are already seated will move back one seat. Specifically, the student sitting in the $$$j$$$-th ($$$1\leq j \leq m-1$$$) column of the $$$i$$$-th row will move to the $$$(j+1)$$$-th column of the $$$i$$$-th row, and the student sitting in $$$m$$$-th column of the $$$i$$$-th row will move to the $$$1$$$-st column of the $$$(i+1)$$$-th row.For example, there is a meeting hall with $$$2$$$ rows and $$$2$$$ columns of seats shown as below:  There will be $$$4$$$ students entering the meeting hall in order, represented as a binary string ""1100"", of which '0' represents naughty students and '1' represents serious students. The changes of seats in the meeting hall are as follows:  Denote a row or a column good if and only if there is at least one serious student in this row or column. Please predict the number of good rows and columns just after the $$$i$$$-th student enters the meeting hall, for all $$$i$$$.","t = int(input())
for _ in range(t):
    n, m = list(map(int, input().split()))
    s = list(input())
    if s[0] == '1':
        rw = [1]
        cn = [True]
        cnt = 1
        ans = [2]
    else:
        rw = [0]
        cn = [False]
        cnt = 0
        ans = [0]
    k = 0
    for i in range(1, m):
        if s[i] == '1':
            cnt += 1
            cn += [True]
            rw += [1]
            k = m
        else:
            cn += [False]
            rw += [rw[-1]]
        k -= 1
        ans += [cnt + rw[-1]]
    for i in range(m, m * n):
        if s[i] == '1':
            if not cn[i % m]:
                cnt += 1
                cn[i % m] = True
            k = m
            rw[i % m] += 1
        elif k > 0:
            rw[i % m] += 1
        k -= 1
        ans += [cnt + rw[i % m]]
    print(' '.join(map(str, ans)))","['data structures', 'implementation', 'math']"
"Monocarp had a permutation $$$a$$$ of $$$n$$$ integers $$$1$$$, $$$2$$$, ..., $$$n$$$ (a permutation is an array where each element from $$$1$$$ to $$$n$$$ occurs exactly once).Then Monocarp calculated an array of integers $$$b$$$ of size $$$n$$$, where $$$b_i = \left\lfloor \frac{i}{a_i} \right\rfloor$$$. For example, if the permutation $$$a$$$ is $$$[2, 1, 4, 3]$$$, then the array $$$b$$$ is equal to $$$\left[ \left\lfloor \frac{1}{2} \right\rfloor, \left\lfloor \frac{2}{1} \right\rfloor, \left\lfloor \frac{3}{4} \right\rfloor, \left\lfloor \frac{4}{3} \right\rfloor \right] = [0, 2, 0, 1]$$$.Unfortunately, the Monocarp has lost his permutation, so he wants to restore it. Your task is to find a permutation $$$a$$$ that corresponds to the given array $$$b$$$. If there are multiple possible permutations, then print any of them. The tests are constructed in such a way that least one suitable permutation exists.","import heapq

import sys
input = sys.stdin.readline
rounds=int(input())
for ii in range(rounds):
  out=0
  length=int(input())
  arr=list(map(int,input().split()))
  small=[]
  for l in range(length):
    if arr[l]==0:
      small.append([l+2,length,l])
    else:
      little=(l+1)//(arr[l]+1)+1
      big=(l+1)//arr[l]
      small.append([little,big,l])
  
  small.sort()
  used=set()
  out=[0]*length
  p=1
  hold=[]
  heapq.heapify(hold)
  ind=0
  while p<length+1:
    for j in range(ind,length):
      if p>=small[j][0] and small[j][2] not in used:
        heapq.heappush(hold,(small[j][1],small[j][2]))
        used.add(small[j][2])
      else:
        ind=j
        break
    cur=heapq.heappop(hold)
    out[cur[1]]=p
    p+=1

  for o in out:
    print(o,end=' ')
  print('')","['binary search', 'data structures', 'greedy', 'math', 'sortings', 'two pointers']"
"Burenka came to kindergarden. This kindergarten is quite strange, so each kid there receives two fractions ($$$\frac{a}{b}$$$ and $$$\frac{c}{d}$$$) with integer numerators and denominators. Then children are commanded to play with their fractions.Burenka is a clever kid, so she noticed that when she claps once, she can multiply numerator or denominator of one of her two fractions by any integer of her choice (but she can't multiply denominators by $$$0$$$). Now she wants know the minimal number of claps to make her fractions equal (by value). Please help her and find the required number of claps!","#comment

n = int(input())



def do(a, b, c, d):
    if a==0 and c!=0:
        return 1
    if c==0 and a!=0:
        return 1
    fst, snd = a * d, b * c
    if fst == snd:
        return 0
    if fst % snd == 0 or snd % fst == 0:
        return 1
    else:
        return 2


for i in range(n):
    a, b, c, d = map(int, input().split())
    claps = 0
    print(do(a, b, c, d))","['math', 'number theory']"
"An ant moves on the real line with constant speed of $$$1$$$ unit per second. It starts at $$$0$$$ and always moves to the right (so its position increases by $$$1$$$ each second).There are $$$n$$$ portals, the $$$i$$$-th of which is located at position $$$x_i$$$ and teleports to position $$$y_i &lt; x_i$$$. Each portal can be either active or inactive. The initial state of the $$$i$$$-th portal is determined by $$$s_i$$$: if $$$s_i=0$$$ then the $$$i$$$-th portal is initially inactive, if $$$s_i=1$$$ then the $$$i$$$-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal):   if the portal is inactive, it becomes active (in this case the path of the ant is not affected);  if the portal is active, it becomes inactive and the ant is instantly teleported to the position $$$y_i$$$, where it keeps on moving as normal. How long (from the instant it starts moving) does it take for the ant to reach the position $$$x_n + 1$$$? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo $$$998\,244\,353$$$.","from bisect import *
from array import *

MODULO=998244353
N = int(input())
X=[]

ans=0
ps=[0]*(N+1)
for i in range(N):
  x,y,s=map(int,input().split())
  X.append(x)
  dist= x - y
  j = bisect(X,y)
  cost=ps[i]-ps[j]
  dp_i=cost+dist
  ps[i+1]=(dp_i+ps[i])%MODULO
  ans+=(s*dp_i)%MODULO
ans+=X[-1]+1%MODULO
print(ans%MODULO)
exit(0)","['binary search', 'data structures', 'dp', 'sortings']"
"You are given two integers $$$a$$$ and $$$m$$$. Calculate the number of integers $$$x$$$ such that $$$0 \le x &lt; m$$$ and $$$\gcd(a, m) = \gcd(a + x, m)$$$.Note: $$$\gcd(a, b)$$$ is the greatest common divisor of $$$a$$$ and $$$b$$$.","import math
 
def cal(x, y, z):
    return z // x - y // x
 
T = int(input())
 
while T:
    T -= 1
    a, m = map(int, input().split())
    k = math.gcd(a, m)
    
    x = (m - 1) // k
    n = m // k
    i = 2
    p = []
    while i * i <= m // k:
        if n % i == 0:
            while n % i == 0:
                n //= i
            p.append(i)
        i += 1
    if n > 1:
        p.append(n)
        
    res = 0
    for mask in range(1, 1<<len(p)):
        tmp = 1
        cnt = 0
        for i in range(len(p)):
            if mask & (1<<i):
                tmp *= p[i]
                cnt += 1
        if cnt % 2 == 1:
            res += cal(tmp, a//k, a//k + x)
        else:
            res -= cal(tmp, a//k, a//k + x)
    print(x + 1 - res)
#Участник 165 место, s34vv1nd","['number theory', 'math']"
"A permutation of length $$$n$$$ is an array $$$p=[p_1,p_2,\dots, p_n]$$$ which contains every integer from $$$1$$$ to $$$n$$$ (inclusive) exactly once. For example, $$$p=[4, 2, 6, 5, 3, 1]$$$ is a permutation of length $$$6$$$.You are given three integers $$$n$$$, $$$a$$$ and $$$b$$$, where $$$n$$$ is an even number. Print any permutation of length $$$n$$$ that the minimum among all its elements of the left half equals $$$a$$$ and the maximum among all its elements of the right half equals $$$b$$$. Print -1 if no such permutation exists.","tst = int(input())
 
for i in range(tst):
    n,a,b = map(int,input().split())
    c = [a]
    for i in range(n, 0, -1):
        if i != a and i != b:
            c.append(i)
    c.append(b)
    if(len(c) == n and min(c[0:n//2]) == a and max(c[n//2:n]) == b):
        print(*c)
    else:
        print(-1)","['constructive algorithms', 'greedy']"
"Let's define $$$f(x)$$$ for a positive integer $$$x$$$ as the length of the base-10 representation of $$$x$$$ without leading zeros. I like to call it a digital logarithm. Similar to a digital root, if you are familiar with that.You are given two arrays $$$a$$$ and $$$b$$$, each containing $$$n$$$ positive integers. In one operation, you do the following:   pick some integer $$$i$$$ from $$$1$$$ to $$$n$$$;  assign either $$$f(a_i)$$$ to $$$a_i$$$ or $$$f(b_i)$$$ to $$$b_i$$$. Two arrays are considered similar to each other if you can rearrange the elements in both of them, so that they are equal (e. g. $$$a_i = b_i$$$ for all $$$i$$$ from $$$1$$$ to $$$n$$$).What's the smallest number of operations required to make $$$a$$$ and $$$b$$$ similar to each other?","import sys
from collections import defaultdict, deque
input = lambda : sys.stdin.readline().strip()
md = int(1e9+7)

from heapq import heappush, heappop, heapify
for t in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c,d = [],[]
    for i in range(n):
        heappush(c, -a[i])
        heappush(d, -b[i])
    ans = 0
    while c:
        e1 = -heappop(c)
        e2 = -heappop(d)
        if e1 == e2:
            continue
        else:
            if e1 > e2:
                heappush(c, -len(str(e1)))
                heappush(d, -e2)
            else:
                heappush(c, -e1)
                heappush(d, -len(str(e2)))
            ans += 1
    print(ans)","['data structures', 'greedy', 'sortings']"
"This is the hard version of the problem. The only difference is maximum value of $$$a_i$$$.Once in Kostomuksha Divan found an array $$$a$$$ consisting of positive integers. Now he wants to reorder the elements of $$$a$$$ to maximize the value of the following function: $$$$$$\sum_{i=1}^n \operatorname{gcd}(a_1, \, a_2, \, \dots, \, a_i),$$$$$$ where $$$\operatorname{gcd}(x_1, x_2, \ldots, x_k)$$$ denotes the greatest common divisor of integers $$$x_1, x_2, \ldots, x_k$$$, and $$$\operatorname{gcd}(x) = x$$$ for any integer $$$x$$$.Reordering elements of an array means changing the order of elements in the array arbitrary, or leaving the initial order.Of course, Divan can solve this problem. However, he found it interesting, so he decided to share it with you.","''' D2. Divan and Kostomuksha (hard version)
https://codeforces.com/contest/1614/problem/D2
'''
 
import io, os, sys
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str
output = sys.stdout.write
 
INF = float('inf')
 
def sieve(N):
    '''return all primes in [2..N] in O(N)'''
    primes = []
    mpf = [0]*(N+1)  # min prime factor
    for i in range(2, N+1):
        if mpf[i] == 0:
            primes.append(i)
            mpf[i] = i
        for p in primes:
            if p*i > N or p > mpf[i]: break  # mpf[p*i] <= mpf[i] < p
            mpf[p*i] = p                     # once per composite number
    return primes, mpf
 
 
# https://codeforces.com/contest/1614/submission/137008425
 
def solve(N, A):
	MAX = max(A)
	primes, mpf = sieve(MAX + 1)
 
	# F[a] = all unique prime factors of a
	F = {}
	def get_factors(a):
		if a in F: return F[a]
		facs = []
		while a > 1:
			facs.append(mpf[a])
			while facs[-1] == mpf[a]: a //= mpf[a] 
		return facs

	# C[f] = num elements in A divisible by f
	# think of primes as axes and numbers as points with coordinates = powers of primes
	# for each possible factor f, want to calc how many points a in A have all coordinates >= f
	C = [0]*(MAX+1)
	for a in A: C[a] += 1
 
	# i.e. for each point a, want to increment count for each b inside the cube 0..a
	# to ensure a increments each b once and only once, there has to be a unique counting path from a to b
	# the below procedure traverses each axis one by one, hence ensures unique paths
	# note that the order of primes/axes are therefore not important
	# it's easiest to visualize a 2D lattice (2 primes)
	for p in primes:
		for a in range(MAX//p, 0, -1):
			C[a] += C[a*p]
 
	# let g[i]=gcd(a[1]..a[i]) for i=1..N
	# then g[1], g[2]...., g[N] is non-increasing, g[i] % g[i+1] == 0
	# want to max SUM_i g[i]
 
	# dp(g, p) = max gcd sum from this point onward where
	# * g is the next gcd
	# * p numbers already placed
	# * memo[g] = dp(f, C[g]) over all factors f of g
	#   --> max gcd sum onwards after choosing g as first gcd
	def dp(g, p=0, memo={}):
		if g == 1: return N-p
		if g not in memo:
			facs = get_factors(g)
			memo[g] = max(dp(g//f, C[g], memo) for f in facs)
		
		# note previous p numbers are all multiples of g
		# so there are C[g]-p multiples of g left to place
		return memo[g] + g*(C[g]-p)
 
	# try each possible g[1]
	res = max(dp(a) for a in A)

 
	return res
 
 
def main():
	N = int(input())
	A = list(map(int, input().split()))
	out = solve(N, A)
	output(f'{out}\n')
 
 
if __name__ == '__main__':
	main()","['dp', 'number theory']"
"A chess tournament will be held soon, where $$$n$$$ chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.Each of the players has their own expectations about the tournament, they can be one of two types:  a player wants not to lose any game (i. e. finish the tournament with zero losses);  a player wants to win at least one game. You have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.","#lista=list(map(int,input().split()))
#x=lista[0]
#n=lista[0]
import math
#import sys
#from collections import deque
#from sys import stdin, stdout
from decimal import *
 
#lista=list(map(int,input().split()))
#x=lista[0]
#n=lista[0]
 
rasp_final=""""
#my_set=set()
#for x in range(1, 100000):
 #my_set.add(2*x*x)
 #my_set.add(4*x*x)
 
#vector_prime=[-1]*21000
#vector_rasp=[0]*21000
 
#vector_prime[1]=1
 
#vector_rasp[1]=1
 
#contor=2
#primes sieve
#for i in range(2,21000):
 #if vector_prime[i]==-1:
  #vector_prime[i]=1
  #vector_rasp[contor]=i
  #contor=contor+1
  #for j in range(i+i,21000,i):
  # vector_prime[j]=0
   #print(i,j)
 
 
  
#suma=0
#vector=list(map(int,input().split()))
#for i in vector:
 #suma=suma+i
#luni = {'January':1, 'February':2, 'March':3, 'April':4, 'May':5, 'June':6, 'July':7, 'August':8, 'September':9, 'October':10, 'November':11, 'December':0}
#luni_reverse = {1:'January', 2:'February', 3:'March', 4:'April', 5:'May', 6:'June', 7:'July', 8:'August', 9:'September', 10:'October', 11:'November', 0:'December'} 
#alfabet = {'a': 1, 'b': 2,'c': 3,'d': 4,'e': 5,'f': 6,'g': 7,'h': 8,'i': 9,'j': 10,'k': 11,'l': 12,'m': 13,'n': 14,'o': 15,'p': 16,'q': 17,'r': 18,'s': 19,'t': 20,'u': 21,'v': 22,'w': 23,'x': 24,'y': 25,'z': 26}
#alfabet_2={'1':""a"", '2':""b"", '3':""c"", '4':""d"", '5':""e"", '6':""f"", '7':""g"", '8':""h"", '9':""i"", '10':""j"", '11':""k"", '12':""l"", '13':""m"", '14':""n"", '15':""o"", '16':""p"", '17':""q"", '18':""r"", '19':""s"", '20':""t"", '21':""u"", '22':""v"", '23':""w"", '24':""x"", '25':""y"", '26':""z""}

k=int(input()) 
#k=1
 
#contor=0 
while k>0:
 
 
 #contor+=1
 
# waiting=deque()
 
 
 #lista=list(map(int,input().split()))
 
 sss=""""
 n=int(input())
 #lista=list(map(int,input().split()))
 lista=input()
 victorii=[0]*n
 
 
 matrix=[]
 adev=1
 cate_doi=len(lista)-len(lista.replace(""2"",""""))
 if cate_doi>0 and cate_doi<3:
  adev=0
  
 else:
  for i in range(0,n):
   a=[]
   for j in range(0,n):
   
    if i==j:
     a.append(""X"")
    elif j<i:
     if matrix[j][i]==""+"":
      a.append('-')
     elif matrix[j][i]==""-"":
      a.append('+')
     else:
      a.append('=')
    
    elif j>i:
    
     if lista[i]==""1"" or lista[j]==""1"":
    
      a.append(""="")
     elif lista[i]==""2"" and victorii[i]==0:
      victorii[i]=1
      a.append(""+"")
     else:
      a.append(""-"")
  
   bbb=''.join(a) 
 
   sss=sss + bbb+ ""\n""
  
    
   matrix.append(a)
 
 
 if adev==0:
  print(""NO"")
 else: 
  print(""YES"")
  print(sss)
   

 
 k=k-1

#print(rasp_final)",['constructive algorithms']
"Alperen has two strings, $$$s$$$ and $$$t$$$ which are both initially equal to ""a"". He will perform $$$q$$$ operations of two types on the given strings:  $$$1 \;\; k \;\; x$$$ — Append the string $$$x$$$ exactly $$$k$$$ times at the end of string $$$s$$$. In other words, $$$s := s + \underbrace{x + \dots + x}_{k \text{ times}}$$$.  $$$2 \;\; k \;\; x$$$ — Append the string $$$x$$$ exactly $$$k$$$ times at the end of string $$$t$$$. In other words, $$$t := t + \underbrace{x + \dots + x}_{k \text{ times}}$$$. After each operation, determine if it is possible to rearrange the characters of $$$s$$$ and $$$t$$$ such that $$$s$$$ is lexicographically smaller$$$^{\dagger}$$$ than $$$t$$$.Note that the strings change after performing each operation and don't go back to their initial states.$$$^{\dagger}$$$ Simply speaking, the lexicographical order is the order in which words are listed in a dictionary. A formal definition is as follows: string $$$p$$$ is lexicographically smaller than string $$$q$$$ if there exists a position $$$i$$$ such that $$$p_i &lt; q_i$$$, and for all $$$j &lt; i$$$, $$$p_j = q_j$$$. If no such $$$i$$$ exists, then $$$p$$$ is lexicographically smaller than $$$q$$$ if the length of $$$p$$$ is less than the length of $$$q$$$. For example, $$$\texttt{abdc} &lt; \texttt{abe}$$$ and $$$\texttt{abc} &lt; \texttt{abcd}$$$, where we write $$$p &lt; q$$$ if $$$p$$$ is lexicographically smaller than $$$q$$$.","t = int(input())
for _ in range(t):
    q = int(input())

    s_a_count = 1
    t_a_count = 1

    other_than_a_t = False
    other_than_a_s = False

    for _ in range(q):
        line = list(map(str, input().rstrip().split()))

        if line[0] == '2':
            for char in line[2]:
                if char != 'a':
                    other_than_a_t = True
                    break
                else:
                    t_a_count += int(line[1])
        else:
            for char in line[2]:
                if char != 'a':
                    other_than_a_s = True
                else:
                    s_a_count += int(line[1])

        print('YES' if other_than_a_t or (not other_than_a_s and s_a_count < t_a_count) else 'NO')","['constructive algorithms', 'greedy', 'strings']"
"There are $$$n$$$ candles on a Hanukkah menorah, and some of its candles are initially lit. We can describe which candles are lit with a binary string $$$s$$$, where the $$$i$$$-th candle is lit if and only if $$$s_i=1$$$.  Initially, the candle lights are described by a string $$$a$$$. In an operation, you select a candle that is currently lit. By doing so, the candle you selected will remain lit, and every other candle will change (if it was lit, it will become unlit and if it was unlit, it will become lit).You would like to make the candles look the same as string $$$b$$$. Your task is to determine if it is possible, and if it is, find the minimum number of operations required.","import decimal
import heapq
import math
import os
import sys
from collections import Counter, deque
from io import BytesIO, IOBase
import bisect
from types import GeneratorType

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')


def isPrime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i = i + 6
    return True


def lcm(a, b): return (a * b) // math.gcd(a, b)


def ints_get(): return map(int, input().strip().split())


def list_get(): return list(map(int, sys.stdin.readline().strip().split()))


def chars_get(): return list(map(str, sys.stdin.readline().strip().split()))


def ipn(): return int(input())


def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc


# ******************************************************#
# **************** code starts here ********************#
# ******************************************************#

def main():
    for _ in range(ipn()):
        n = ipn()
        a = [int(x) for x in input()]
        b = [int(x) for x in input()]
        p = a.count(1)
        q = b.count(1)
        w, e, f = 0, 0, 0
        for i in range(n):
            if a[i] != b[i]:
                e += 1
            elif a[i] == b[i] == 1:
                w += 1
            if a[i] == b[i]:
                f += 1
        o = 10**7
        if p == q:
            o = min(o, e)
        if q == n - p + 1:
            if w > 0 and f % 2 != 0:
                o = min(o, f)

        if o < 10**7:
            print(o)
        else:
            print(-1)
    return


if __name__ == ""__main__"":
    main()","['brute force', 'graphs', 'greedy', 'math']"
"Two players, Red and Blue, are at it again, and this time they're playing with crayons! The mischievous duo is now vandalizing a rooted tree, by coloring the nodes while playing their favorite game.The game works as follows: there is a tree of size $$$n$$$, rooted at node $$$1$$$, where each node is initially white. Red and Blue get one turn each. Red goes first. In Red's turn, he can do the following operation any number of times:   Pick any subtree of the rooted tree, and color every node in the subtree red.  However, to make the game fair, Red is only allowed to color $$$k$$$ nodes of the tree. In other words, after Red's turn, at most $$$k$$$ of the nodes can be colored red.Then, it's Blue's turn. Blue can do the following operation any number of times:   Pick any subtree of the rooted tree, and color every node in the subtree blue. However, he's not allowed to choose a subtree that contains a node already colored red, as that would make the node purple and no one likes purple crayon.  Note: there's no restriction on the number of nodes Blue can color, as long as he doesn't color a node that Red has already colored.After the two turns, the score of the game is determined as follows: let $$$w$$$ be the number of white nodes, $$$r$$$ be the number of red nodes, and $$$b$$$ be the number of blue nodes. The score of the game is $$$w \cdot (r - b)$$$.Red wants to maximize this score, and Blue wants to minimize it. If both players play optimally, what will the final score of the game be?","import sys
input = sys.stdin.buffer.readline
n, k = [*map(int, input().split())]
d = [[] for i in range(n)]
p, h, l, v = [0]*n, [-1]*n, [0]*n, [0]*n
for _ in range(n-1):
    a, b = [int(i)-1 for i in input().split()]
    d[a].append(b)
    d[b].append(a)
q, p[0] = [0], -1
leaves = []
while q:
    q1 = []
    for i in q:
        for j in d[i]:
            if j != p[i]:
                q1.append(j)
                p[j] = i
                if len(d[j]) == 1: leaves.append(j)
    q = q1
for i in leaves[::-1]:
    c, x = 0, i
    while x != -1 and h[x] < c: h[x] = c; c+=1; l[x]=i; x=p[x];
t = sorted(list(range(n)), key=lambda x: h[x], reverse=True)
r = nb = 0
for i in t:
    if not v[i]:
        r += 1
        nb += h[i]+1
        v[i] = 1
        x = l[i]
        while not v[x]: v[x] = 1; x = p[x]
    if r == k: break
rr = max((nb-i)*(i+nb-n) for i in range(r, k+1))
rl = min((nb-k+i)*(k+nb-n+i) for i in range(max(n-nb-k+1,1)))
print(rr if n-nb < k else rl)","['data structures', 'dfs and similar', 'games', 'graphs', 'greedy', 'math', 'sortings', 'trees']"
"An accordion is a string (yes, in the real world accordions are musical instruments, but let's forget about it for a while) which can be represented as a concatenation of: an opening bracket (ASCII code $$$091$$$), a colon (ASCII code $$$058$$$), some (possibly zero) vertical line characters (ASCII code $$$124$$$), another colon, and a closing bracket (ASCII code $$$093$$$). The length of the accordion is the number of characters in it.For example, [::], [:||:] and [:|||:] are accordions having length $$$4$$$, $$$6$$$ and $$$7$$$. (:|:), {:||:}, [:], ]:||:[ are not accordions. You are given a string $$$s$$$. You want to transform it into an accordion by removing some (possibly zero) characters from it. Note that you may not insert new characters or reorder existing ones. Is it possible to obtain an accordion by removing characters from $$$s$$$, and if so, what is the maximum possible length of the result?","from __future__ import division, print_function
 
import os,sys
from io import BytesIO, IOBase
 
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
 
 
def ii():  return int(input())
def si():  return input()
def mi():  return map(int,input().split("" ""))
def msi(): return map(str,input().split("" ""))
def li():  return list(mi())
 
def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
    
#from math import *

 
def gcd(x, y):
    while y:
        x, y = y, x % y
    return x
    
def checkPrime(n) : # Check Prime Number or not 
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) : 
        if (n % i == 0 or n % (i + 2) == 0) : 
            return False
        i = i + 6
    return True
 
def read():
    sys.stdin = open('input.txt', 'r')  
    sys.stdout = open('output.txt', 'w') 
def accordian(s):
    idx1=s.find(""["")
    if idx1==-1:
        return(""-1"")
    s=s[idx1+1:]
    
    idx2=s.find("":"")
    if idx2==-1:
        return(""-1"")
    s=s[idx2+1:]
    
    s=s[::-1]
    
    idx3=s.find(""]"")
    if idx3==-1:
        return(""-1"")
    s=s[idx3+1:]
   
    idx4=s.find("":"")
    if idx4==-1:
        return(""-1"")
    s=s[idx4+1:]
    
    count=s.count(""|"")
    count+=4
    return count
def main():
    s=si()
    res=accordian(s)
    print(res)
# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()
 
 
if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
 
if __name__ == ""__main__"":
    #read()
    main()
    #dmain()
 
# Comment Read()","['implementation', 'greedy']"
"Sehr Sus is an infinite hexagonal grid as pictured below, controlled by MennaFadali, ZerooCool and Hosssam.They love equilateral triangles and want to create $$$n$$$ equilateral triangles on the grid by adding some straight lines. The triangles must all be empty from the inside (in other words, no straight line or hexagon edge should pass through any of the triangles).You are allowed to add straight lines parallel to the edges of the hexagons. Given $$$n$$$, what is the minimum number of lines you need to add to create at least $$$n$$$ equilateral triangles as described?  Adding two red lines results in two new yellow equilateral triangles.",print(*[1+int((int(input())*1.5)**0.5-9e-9)for _ in range(int(input()))]),"['binary search', 'brute force', 'geometry', 'greedy', 'implementation', 'math']"
"While searching for the pizza, baby Hosssam came across two permutations $$$a$$$ and $$$b$$$ of length $$$n$$$.Recall that a permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).Baby Hosssam forgot about the pizza and started playing around with the two permutations. While he was playing with them, some elements of the first permutation got mixed up with some elements of the second permutation, and to his surprise those elements also formed a permutation of size $$$n$$$.Specifically, he mixed up the permutations to form a new array $$$c$$$ in the following way.  For each $$$i$$$ ($$$1\le i\le n$$$), he either made $$$c_i=a_i$$$ or $$$c_i=b_i$$$.  The array $$$c$$$ is a permutation. You know permutations $$$a$$$, $$$b$$$, and values at some positions in $$$c$$$. Please count the number different permutations $$$c$$$ that are consistent with the described process and the given values. Since the answer can be large, print it modulo $$$10^9+7$$$.It is guaranteed that there exists at least one permutation $$$c$$$ that satisfies all the requirements.","import sys
input = sys.stdin.readline
def pow(x, a, mod):
    if a == 0:
        return 1
    if a == 1:
        return x % mod
    if a % 2:
        return (x * pow(x * x, a // 2, mod)) % mod
    else:
        return (pow(x * x, a // 2, mod)) % mod

def sol(n, a, b, d):
    vis = [False] * n
    
    aind = [0] * n
    for i in range(n):
        aind[a[i]] = i
    res = 0
    for i in range(n):
        if vis[a[i]]: continue
        if a[i] == b[i]: continue
        
        count = 0
        vis[a[i]] = True
        curr = i
        count += d[curr]
        while not vis[b[curr]]:
            vis[b[curr]] = True
            curr = aind[b[curr]]
            count += d[curr]
        if not count:
            res += 1

    return pow(2, res, (10 ** 9 +7))

    
t = int(input())
for case in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))
    d = list(map(int,input().split()))
    a = [i-1 for i in a]
    b = [i-1 for i in b]
    print(sol(n, a, b, d))","['data structures', 'dfs and similar', 'dsu', 'graphs', 'implementation', 'math']"
"The last contest held on Johnny's favorite competitive programming platform has been received rather positively. However, Johnny's rating has dropped again! He thinks that the presented tasks are lovely, but don't show the truth about competitors' skills.The boy is now looking at the ratings of consecutive participants written in a binary system. He thinks that the more such ratings differ, the more unfair is that such people are next to each other. He defines the difference between two numbers as the number of bit positions, where one number has zero, and another has one (we suppose that numbers are padded with leading zeros to the same length). For example, the difference of $$$5 = 101_2$$$ and $$$14 = 1110_2$$$ equals to $$$3$$$, since $$$0101$$$ and $$$1110$$$ differ in $$$3$$$ positions. Johnny defines the unfairness of the contest as the sum of such differences counted for neighboring participants.Johnny has just sent you the rating sequence and wants you to find the unfairness of the competition. You have noticed that you've got a sequence of consecutive integers from $$$0$$$ to $$$n$$$. That's strange, but the boy stubbornly says that everything is right. So help him and find the desired unfairness for received numbers.","t = int(input())
for iteration in range(0, t):
	n = int(input())
	res = 0
	for _pow in range(0, 65):
		if (n + 1) % (1 << _pow) == 0:
			res += (n + 1) // (1 << _pow) - 1
		else:
			res += (n + 1) // (1 << _pow)
	print(res)","['bitmasks', 'greedy', 'math']"
"In order to write a string, Atilla needs to first learn all letters that are contained in the string.Atilla needs to write a message which can be represented as a string $$$s$$$. He asks you what is the minimum alphabet size required so that one can write this message.The alphabet of size $$$x$$$ ($$$1 \leq x \leq 26$$$) contains only the first $$$x$$$ Latin letters. For example an alphabet of size $$$4$$$ contains only the characters $$$\texttt{a}$$$, $$$\texttt{b}$$$, $$$\texttt{c}$$$ and $$$\texttt{d}$$$.","import sys
raw_input = iter(sys.stdin.read().splitlines()).next

def solution():
    n = int(raw_input())
    s = raw_input()
    return ord(max(s))-ord('a')+1

for case in xrange(int(raw_input())):
    print '%s' % solution()","['greedy', 'implementation', 'strings']"
"There are $$$n$$$ quests. If you complete the $$$i$$$-th quest, you will gain $$$a_i$$$ coins. You can only complete at most one quest per day. However, once you complete a quest, you cannot do the same quest again for $$$k$$$ days. (For example, if $$$k=2$$$ and you do quest $$$1$$$ on day $$$1$$$, then you cannot do it on day $$$2$$$ or $$$3$$$, but you can do it again on day $$$4$$$.)You are given two integers $$$c$$$ and $$$d$$$. Find the maximum value of $$$k$$$ such that you can gain at least $$$c$$$ coins over $$$d$$$ days. If no such $$$k$$$ exists, output Impossible. If $$$k$$$ can be arbitrarily large, output Infinity.","t = int(input())
 
def possible(k, n, c, d, nums):
    ssum = 0
    for i in range(d):
        try:
            a = nums[i%(k+1)]
        except:
            a = 0
        ssum += a
    return ssum >= c
 
 
def solve():
    n, c, d = [int(x) for x in input().split()]
    nums = [int(x) for x in input().split()]
    nums.sort(reverse=True)
    
    l = 0
    r = d-1
    
    
    if sum(nums[:min(d,n, len(nums) )]) >= c:
        print(""Infinity"")
        return
    
    #print(sum(nums[:min(d,n, len(nums) )]))
    #print(nums)
    #print(n, c, d)
    #print(possible(1, n, c, d, nums))
    #quit()
 
    while True:
        if r - l <= 3:
            for k in range(r, l-1, -1):
                if possible(k, n, c, d, nums):
                    print(k)
                    return
            print(""Impossible"")
            return
        
        k = (l + r) // 2
        pos = possible(k, n, c, d, nums)
        if pos:
            l = k
        else:
            r = k-1
        
 
    
for _ in range(t):
    solve()","['binary search', 'greedy', 'sortings']"
"This is the easy version of this problem. The only difference is the constraint on $$$k$$$ — the number of gifts in the offer. In this version: $$$k=2$$$.Vasya came to the store to buy goods for his friends for the New Year. It turned out that he was very lucky — today the offer ""$$$k$$$ of goods for the price of one"" is held in store. Remember, that in this problem $$$k=2$$$.Using this offer, Vasya can buy exactly $$$k$$$ of any goods, paying only for the most expensive of them. Vasya decided to take this opportunity and buy as many goods as possible for his friends with the money he has.More formally, for each good, its price is determined by $$$a_i$$$ — the number of coins it costs. Initially, Vasya has $$$p$$$ coins. He wants to buy the maximum number of goods. Vasya can perform one of the following operations as many times as necessary:  Vasya can buy one good with the index $$$i$$$ if he currently has enough coins (i.e $$$p \ge a_i$$$). After buying this good, the number of Vasya's coins will decrease by $$$a_i$$$, (i.e it becomes $$$p := p - a_i$$$).  Vasya can buy a good with the index $$$i$$$, and also choose exactly $$$k-1$$$ goods, the price of which does not exceed $$$a_i$$$, if he currently has enough coins (i.e $$$p \ge a_i$$$). Thus, he buys all these $$$k$$$ goods, and his number of coins decreases by $$$a_i$$$ (i.e it becomes $$$p := p - a_i$$$). Please note that each good can be bought no more than once.For example, if the store now has $$$n=5$$$ goods worth $$$a_1=2, a_2=4, a_3=3, a_4=5, a_5=7$$$, respectively, $$$k=2$$$, and Vasya has $$$6$$$ coins, then he can buy $$$3$$$ goods. A good with the index $$$1$$$ will be bought by Vasya without using the offer and he will pay $$$2$$$ coins. Goods with the indices $$$2$$$ and $$$3$$$ Vasya will buy using the offer and he will pay $$$4$$$ coins. It can be proved that Vasya can not buy more goods with six coins.Help Vasya to find out the maximum number of goods he can buy.","t = int(input())
answer = []

for i in range(t):
    n, p, k = [int(j) for j in input().split()]
    a = [int(j) for j in input().split()]

    a.sort()
    j = 2
    if p - a[0] < 0:
        v = 0
    else:
        v = 1
        p -= a[0]
    while v and j < n and p - a[j] >= 0:
        p -= a[j]
        v += 2
        j += 2
    if j - 1 < n and v != 0:
        for k in range(j):
            if k % 2 == 0:
                p += a[k]
            else:
                p -= a[k]
        if p >= 0:
            v += 1
    answer.append(v)
for i in answer:
    print(i)","['dp', 'sortings', 'greedy']"
"You have two binary strings $$$a$$$ and $$$b$$$ of length $$$n$$$. You would like to make all the elements of both strings equal to $$$0$$$. Unfortunately, you can modify the contents of these strings using only the following operation:  You choose two indices $$$l$$$ and $$$r$$$ ($$$1 \le l \le r \le n$$$);  For every $$$i$$$ that respects $$$l \le i \le r$$$, change $$$a_i$$$ to the opposite. That is, $$$a_i := 1 - a_i$$$;  For every $$$i$$$ that respects either $$$1 \le i &lt; l$$$ or $$$r &lt; i \le n$$$, change $$$b_i$$$ to the opposite. That is, $$$b_i := 1 - b_i$$$. Your task is to determine if this is possible, and if it is, to find such an appropriate chain of operations. The number of operations should not exceed $$$n + 5$$$. It can be proven that if such chain of operations exists, one exists with at most $$$n + 5$$$ operations.","f=open(0)
I=lambda:next(f,'0 ')[:-1]
I()
while n:=int(I()):i=int(a:=I(),2)^int(I(),2);c=[f'{i} {i}'for i,x in
enumerate(a,1)if'0'<x];c+=(len(c)+i)%2*['1 1',f'1 {n}',f'2 {n}'];print(*(['YES',len(c)]+c,['NO'])[1<i+1<1<<n])","['constructive algorithms', 'implementation']"
"A sequence $$$a = [a_1, a_2, \ldots, a_l]$$$ of length $$$l$$$ has an ascent if there exists a pair of indices $$$(i, j)$$$ such that $$$1 \le i &lt; j \le l$$$ and $$$a_i &lt; a_j$$$. For example, the sequence $$$[0, 2, 0, 2, 0]$$$ has an ascent because of the pair $$$(1, 4)$$$, but the sequence $$$[4, 3, 3, 3, 1]$$$ doesn't have an ascent.Let's call a concatenation of sequences $$$p$$$ and $$$q$$$ the sequence that is obtained by writing down sequences $$$p$$$ and $$$q$$$ one right after another without changing the order. For example, the concatenation of the $$$[0, 2, 0, 2, 0]$$$ and $$$[4, 3, 3, 3, 1]$$$ is the sequence $$$[0, 2, 0, 2, 0, 4, 3, 3, 3, 1]$$$. The concatenation of sequences $$$p$$$ and $$$q$$$ is denoted as $$$p+q$$$.Gyeonggeun thinks that sequences with ascents bring luck. Therefore, he wants to make many such sequences for the new year. Gyeonggeun has $$$n$$$ sequences $$$s_1, s_2, \ldots, s_n$$$ which may have different lengths. Gyeonggeun will consider all $$$n^2$$$ pairs of sequences $$$s_x$$$ and $$$s_y$$$ ($$$1 \le x, y \le n$$$), and will check if its concatenation $$$s_x + s_y$$$ has an ascent. Note that he may select the same sequence twice, and the order of selection matters.Please count the number of pairs ($$$x, y$$$) of sequences $$$s_1, s_2, \ldots, s_n$$$ whose concatenation $$$s_x + s_y$$$ contains an ascent.","from sys import stdin
input=stdin.readline
n=int(input());s=cnt=0;v,p=[],[]
for _ in range(n):
	a=list(map(int,input().split()))
	l=a[0]
	del a[0]
	mx=mn=a[0];f=1
	for i in range(1,l):
		if a[i]>mn:f=0;break
		else:mn=a[i]
	if f:
		v+=mn,
		p+=mx,
	else:
		s+=1
cnt=s*n+(n-s)*s
m=n-s
p=sorted(p,reverse=True)
for i in range(m):
	l=0
	r=m-1
	ans=-1
	while l<=r:
		md=(l+r)//2
		if p[md]<=v[i]:r=md-1
		else:ans=md;l=md+1
	cnt+=(ans+1)
print(cnt)","['dp', 'combinatorics', 'implementation', 'sortings', 'data structures', 'binary search']"
"There is an array $$$a$$$ with $$$n-1$$$ integers. Let $$$x$$$ be the bitwise XOR of all elements of the array. The number $$$x$$$ is added to the end of the array $$$a$$$ (now it has length $$$n$$$), and then the elements are shuffled.You are given the newly formed array $$$a$$$. What is $$$x$$$? If there are multiple possible values of $$$x$$$, you can output any of them.",print(*[_.split()[0]+'\n' for _ in [*open(0)][2::2]]),"['bitmasks', 'brute force']"
"You are given a permutation $$$a$$$ of length $$$n$$$. Recall that permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order.You have a strength of $$$s$$$ and perform $$$n$$$ moves on the permutation $$$a$$$. The $$$i$$$-th move consists of the following:   Pick two integers $$$x$$$ and $$$y$$$ such that $$$i \leq x \leq y \leq \min(i+s,n)$$$, and swap the positions of the integers $$$x$$$ and $$$y$$$ in the permutation $$$a$$$. Note that you can select $$$x=y$$$ in the operation, in which case no swap will occur. You want to turn $$$a$$$ into another permutation $$$b$$$ after $$$n$$$ moves. However, some elements of $$$b$$$ are missing and are replaced with $$$-1$$$ instead. Count the number of ways to replace each $$$-1$$$ in $$$b$$$ with some integer from $$$1$$$ to $$$n$$$ so that $$$b$$$ is a permutation and it is possible to turn $$$a$$$ into $$$b$$$ with a strength of $$$s$$$. Since the answer can be large, output it modulo $$$998\,244\,353$$$.","from functools import reduce
from sys import stdin, stdout


def read(): return stdin.readline().strip()
def write(x): stdout.write(str(x) + '\n')


def get_index(a):
    a_index = [-1] * len(a)
    for i in range(len(a)):
        if a[i] != -1:
            a_index[a[i]] = i
    return a_index


def solve():
    n, s = map(int, read().split())

    a_ = list(map(int, read().split()))
    b_ = list(map(int, read().split()))

    a = [i - 1 for i in a_]
    b = [i - 1 if i != -1 else -1 for i in b_]

    a_index = get_index(a)
    b_index = get_index(b)

    a = [a_index[i] for i in range(n)]
    b = [b_index[i] if b_index[i] != -1 else -1 for i in range(n)]

    a_index = get_index(a)
    b_index = get_index(b)

    # p = [a[i] for i in range(s)]
    # p_in_b = [a[i] for i in range(s) if a[i] in b]
    p_in_b = [a[i] for i in range(s) if b_index[a[i]] != -1]
    # p_not_in_b = [a[i] for i in range(s) if a[i] not in b]
    p_not_in_b = [a[i] for i in range(s) if b_index[a[i]] == -1]

    p_in_b_index = [-1] * n
    for i in range(len(p_in_b)):
        p_in_b_index[p_in_b[i]] = i

    c = [0] * n
    for i in range(n):
        j = i + s
        if j < n:
            # p.append(a[j])
            # if a[j] in b:
            if b_index[a[j]] != -1:
                p_in_b.append(a[j])
                p_in_b_index[a[j]] = len(p_in_b) - 1
            else:
                p_not_in_b.append(a[j])

        if b[i] == -1:
            # c[i] = len([i for i in p if i not in b])
            c[i] = len(p_not_in_b)
            # for i in p:
            #     if i not in b:
            #         p.remove(i)
            #         break
            # p_not_in_b.remove(p_not_in_b[0])
            if p_not_in_b:
                p_not_in_b.pop()
        else:
            # if b[i] in p_in_b:
            if p_in_b_index[b[i]] != -1:
                # if p_in_b_index[b[i]] != -1:
                c[i] = 1
                # p_in_b.remove(b[i])
                p_in_b_index[b[i]] = -1
            else:
                c[i] = 0
                break

    # print(c)
    write(reduce(lambda x, y: x * y % 998244353, c))


T = 1
T = int(read())
for _ in range(T):
    solve()","['brute force', 'combinatorics', 'greedy', 'sortings', 'trees', 'two pointers']"
"Every December, VK traditionally holds an event for its employees named ""Secret Santa"". Here's how it happens.$$$n$$$ employees numbered from $$$1$$$ to $$$n$$$ take part in the event. Each employee $$$i$$$ is assigned a different employee $$$b_i$$$, to which employee $$$i$$$ has to make a new year gift. Each employee is assigned to exactly one other employee, and nobody is assigned to themselves (but two employees may be assigned to each other). Formally, all $$$b_i$$$ must be distinct integers between $$$1$$$ and $$$n$$$, and for any $$$i$$$, $$$b_i \ne i$$$ must hold.The assignment is usually generated randomly. This year, as an experiment, all event participants have been asked who they wish to make a gift to. Each employee $$$i$$$ has said that they wish to make a gift to employee $$$a_i$$$.Find a valid assignment $$$b$$$ that maximizes the number of fulfilled wishes of the employees.","from collections import defaultdict

def first(U):
    if len(U) == 0:
        return None

    it = iter(U)
    return next(it)

def solve(A):
    N = len(A)

    for i in range(N):
        A[i] -= 1

    r = 0
    B = [None] * N
    U = {}
    empty = []
    for i in range(N):
        if A[i] not in U:
            B[i] = A[i]
            U[A[i]] = i
            r += 1
        else:
            empty.append(i)

    if len(empty) == 1:
        e = empty[0]
        if e not in U:
            B[e] = A[e]
            B[U[A[e]]] = e
        else:
            for z in range(N):
                if z not in U:
                    B[e] = z
                    break
    elif len(empty) > 1:
        src = empty
        src.sort(lambda x: 0 if x not in U else 1)

        dst = []
        G = {i for i in range(N) if i not in U}
        for s in src:
            if s not in U:
                dst.append(s)
                G.discard(s)
        dst.extend(G)

        size = len(src)
        for i in range(size):
            B[src[i]] = dst[(i + 1) % size]
                        

    print(r)
    print("" "".join(str(e + 1) for e in B))

T = int(input())
for _ in range(T):
    n = int(input())
    A = [int(e) for e in input().split(' ')]

    solve(A)","['graphs', 'greedy', 'math']"
"There are $$$n$$$ lanterns in a row. The lantern $$$i$$$ is placed in position $$$i$$$ and has power equal to $$$p_i$$$.Each lantern can be directed to illuminate either some lanterns to the left or some lanterns to the right. If the $$$i$$$-th lantern is turned to the left, it illuminates all such lanterns $$$j$$$ that $$$j \in [i - p_i, i - 1]$$$. Similarly, if it is turned to the right, it illuminates all such lanterns $$$j$$$ that $$$j \in [i + 1, i + p_i]$$$.Your goal is to choose a direction for each lantern so each lantern is illuminated by at least one other lantern, or report that it is impossible.","from bisect import bisect_left;from math import inf
class ST:
    def __init__(self,arr):
        n=len(arr);mx=n.bit_length();self.st=[[0]*mx for i in range(n)]
        for i in range(n):self.st[i][0]=arr[i]
        for j in range(1,mx):
            for i in range(n-(1<<j)+1):self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])
    def query(self,l,r):
        if l>r:return -inf
        s=(r+1-l).bit_length()-1;return max(self.st[l][s],self.st[r-(1<<s)+1][s])
for i in range(int(input())):
    n=int(input());p=[0]+list(map(int,input().split()));a=[i+p[i] for i in range(n+1)];st=ST(a);dp=[0]*(n+1);last=[0]*(n+1)
    for i in range(2,n+1):
        if not p[i]:dp[i]=dp[i-1];last[i]=i;continue
        j=bisect_left(dp,i-p[i]-1,0,i);last[i]=j
        if j==i:dp[i]=dp[i-1]
        else:
            dp[i]=max(dp[j],st.query(j+1,i-1),i-1)
            if dp[i-1]>=i:
                if dp[i]<max(dp[i-1],i+p[i]):dp[i]=max(dp[i-1],i+p[i]);last[i]=i              
    if dp[-1]<n:print(""NO"")
    else:
        print(""YES"");cur=n;ans=[""R""]*n
        while cur:
            if last[cur]!=cur:ans[cur-1]=""L"";cur=last[cur]
            else:cur-=1
        print(''.join(ans))","['binary search', 'data structures', 'dp']"
"Polycarp has $$$3$$$ positive integers $$$a$$$, $$$b$$$ and $$$c$$$. He can perform the following operation exactly once.  Choose a positive integer $$$m$$$ and multiply exactly one of the integers $$$a$$$, $$$b$$$ or $$$c$$$ by $$$m$$$. Can Polycarp make it so that after performing the operation, the sequence of three numbers $$$a$$$, $$$b$$$, $$$c$$$ (in this order) forms an arithmetic progression? Note that you cannot change the order of $$$a$$$, $$$b$$$ and $$$c$$$.Formally, a sequence $$$x_1, x_2, \dots, x_n$$$ is called an arithmetic progression (AP) if there exists a number $$$d$$$ (called ""common difference"") such that $$$x_{i+1}=x_i+d$$$ for all $$$i$$$ from $$$1$$$ to $$$n-1$$$. In this problem, $$$n=3$$$.For example, the following sequences are AP: $$$[5, 10, 15]$$$, $$$[3, 2, 1]$$$, $$$[1, 1, 1]$$$, and $$$[13, 10, 7]$$$. The following sequences are not AP: $$$[1, 2, 4]$$$, $$$[0, 1, 0]$$$ and $$$[1, 3, 2]$$$.You need to answer $$$t$$$ independent test cases.","for j in[0]*int(input()):
    i=input().split()
    a=int(i[0])
    b=int(i[1])
    c=int(i[2])
    if ((a+c)%(2*b)==0) or (((2*b-c)%a ==0) and ((2*b-c)>0)) or (((2*b-a)%c ==0) and ((2*b-a)>0)): print(""YES"")
    else :print(""NO"")","['implementation', 'math']"
"You are given a connected undirected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. The weight of the $$$i$$$-th edge is $$$i$$$.Here is a wrong algorithm of finding a minimum spanning tree (MST) of a graph:vis := an array of length ns := a set of edgesfunction dfs(u):    vis[u] := true    iterate through each edge (u, v) in the order from smallest to largest edge weight        if vis[v] = false            add edge (u, v) into the set (s)            dfs(v)function findMST(u):    reset all elements of (vis) to false    reset the edge set (s) to empty    dfs(u)    return the edge set (s)Each of the calls findMST(1), findMST(2), ..., findMST(n) gives you a spanning tree of the graph. Determine which of these trees are minimum spanning trees.","import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline


n,m=map(int,input().split())
EDGE=[tuple(map(int,input().split())) for i in range(m)]

# UnionFind

Group = [i for i in range(n+1)] # グループ分け
Nodes = [1]*(n+1) # 各グループのノードの数

def find(x):
    while Group[x] != x:
        x=Group[x]
    return x

def Union(x,y):
    if find(x) != find(y):
        if Nodes[find(x)] < Nodes[find(y)]:
            
            Nodes[find(y)] += Nodes[find(x)]
            Nodes[find(x)] = 0
            Group[find(x)] = find(y)
            
        else:
            Nodes[find(x)] += Nodes[find(y)]
            Nodes[find(y)] = 0
            Group[find(y)] = find(x)

USE=[0]*m

for i in range(m):
    x,y=EDGE[i]

    if find(x)==find(y):
        USE[i]=0
    else:
        USE[i]=1
        Union(x,y)

E=[[] for i in range(n+1)]

OK=[0]*(n+1)

for i in range(m):
    if USE[i]==1:
        x,y = EDGE[i]
        E[x].append(y)
        E[y].append(x)

        OK[x]=1
        OK[y]=1

# 木のHL分解+LCA

N=n+1
ROOT=1

QUE=[ROOT] 
Parent=[-1]*(N+1)
Height=[-1]*(N+1)
Parent[ROOT]=N # ROOTの親を定めておく.
Height[ROOT]=0
Child=[[] for i in range(N+1)]
TOP_SORT=[] # トポロジカルソート

while QUE: # トポロジカルソートと同時に親を見つける
    x=QUE.pop()
    TOP_SORT.append(x)
    for to in E[x]:
        if Parent[to]==-1:
            Parent[to]=x
            Height[to]=Height[x]+1
            Child[x].append(to)
            QUE.append(to)

Children=[1]*(N+1)

for x in TOP_SORT[::-1]: #（自分を含む）子ノードの数を調べる
    Children[Parent[x]]+=Children[x]

USE=[0]*N
Group=[i for i in range(N)]

for x in TOP_SORT: # HL分解によるグループ分け
    USE[x]=1
    MAX_children=0
    select_node=0

    for to in E[x]:
        if USE[to]==0 and Children[to]>MAX_children:
            select_node=to
            MAX_children=Children[to]

    for to in E[x]:
        if USE[to]==0 and to==select_node:
            Group[to]=Group[x]

def LCA(a,b): # HL分解を利用してLCAを求める
    while Group[a]!=Group[b]:
        if Children[Parent[Group[a]]]<Children[Parent[Group[b]]]:
            a=Parent[Group[a]]
        else:
            b=Parent[Group[b]]

    if Children[a]>Children[b]:
        return a
    else:
        return b

Parents=[Parent]

for i in range(30):
    X=[-1]*(N+1)

    for i in range(N+1):
        X[i]=Parents[-1][Parents[-1][i]]

    Parents.append(X)

def LCA_mae(x,y):
    while Height[x]>Height[y]+1:
        for i in range(30):
            k=Parents[i][x]

            if k==-1 or k>=n or Height[k]<=Height[y]:
                x=Parents[i-1][x]
                break
    return x

DOWN=[0]*(N+1)

score=0

for x,y in EDGE:
    if OK[x]==1 and OK[y]==1:
        if Parent[x]==y or Parent[y]==x:
            continue

        k=LCA(x,y)

        if k==x:
            DOWN[y]+=1
            k=LCA_mae(y,x)
            DOWN[k]-=1
            
        elif k==y:
            DOWN[x]+=1
            k=LCA_mae(x,y)
            DOWN[k]-=1

        else:
            score+=1
            DOWN[x]+=1
            DOWN[y]+=1

for x in TOP_SORT[1:]:
    DOWN[x]+=DOWN[Parent[x]]

ANS=[0]*N

for i in range(N):
    if OK[i]==1 and DOWN[i]==score:
        ANS[i]=1

print("""".join(map(str,ANS[1:N])))","['dfs and similar', 'dsu', 'graphs', 'greedy', 'sortings', 'trees']"
"You are given an array $$$a$$$ of $$$n$$$ non-negative integers. In one operation you can change any number in the array to any other non-negative integer.Let's define the cost of the array as $$$\operatorname{DIFF}(a) - \operatorname{MEX}(a)$$$, where $$$\operatorname{MEX}$$$ of a set of non-negative integers is the smallest non-negative integer not present in the set, and $$$\operatorname{DIFF}$$$ is the number of different numbers in the array.For example, $$$\operatorname{MEX}(\{1, 2, 3\}) = 0$$$, $$$\operatorname{MEX}(\{0, 1, 2, 4, 5\}) = 3$$$.You should find the minimal cost of the array $$$a$$$ if you are allowed to make at most $$$k$$$ operations.","import os, sys
from io import BytesIO, IOBase
from array import array


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class segmenttree:
    def __init__(self, n, default=0, func=lambda a, b: a + b):
        self.tree, self.n, self.func, self.default = [default] * (2 * n), n, func, default

    def fill(self, arr):
        self.tree[self.n:] = arr
        for i in range(self.n - 1, 0, -1):
            self.tree[i] = self.func(self.tree[i << 1], self.tree[(i << 1) + 1])

    # get interval[l,r)
    def query(self, l, r):
        res = self.default
        l += self.n
        r += self.n
        while l < r:
            if l & 1:
                res = self.func(res, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                res = self.func(res, self.tree[r])
            l >>= 1
            r >>= 1

        return res

    def __setitem__(self, ix, val):
        ix += self.n
        self.tree[ix] = val

        while ix > 1:
            self.tree[ix >> 1] = self.func(self.tree[ix], self.tree[ix ^ 1])
            ix >>= 1

    def __getitem__(self, item):
        return self.tree[item + self.n]


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
ceil1, out = lambda a, b: (a + b - 1) // b, []

for _ in range(int(input())):
    n, k = inp(int)
    a = array('i', sorted(inp(int)))
    coun = segmenttree(n + 2)
    coun2 = segmenttree(n + 2)
    ix, ans = n - 1, n
    cum = array('i', [0] * (n + 3))

    for i in range(n):
        if a[i] <= n:
            cum[a[i]] = 1

    for i in range(1, n + 1):
        cum[i] += cum[i - 1]

    for mex in range(n, -1, -1):
        mmex = 0

        while ix > -1 and a[ix] >= mex:
            mmex += 1
            if ix == 0 or a[ix] != a[ix - 1]:
                coun[mmex] += mmex
                coun2[mmex] += 1
                mmex = 0

            ix -= 1

        if ix < n - 1 and a[ix + 1] != mex:
            mmex = 0

        k_ = k - mmex
        rem = max(mex - cum[mex - 1] - mmex, 0)

        if rem > k_:
            continue

        coun2[mmex] -= 1
        coun[mmex] -= mmex
        if coun.query(1, n + 1) <= rem:
            ans = 0
        else:
            be, en = 0, n
            while be < en:
                md = (be + en + 1) >> 1
                if coun.query(0, md + 1) <= k_:
                    be = md
                else:
                    en = md - 1

            k_ -= coun.query(1, be + 1)
            ans = min(ans, coun2.query(1, n + 1) - (coun2.query(1, be + 1) + k_ // (be + 1)))

        coun2[mmex] += 1
        coun[mmex] += mmex
    out.append(f'{ans}')
print('\n'.join(out))","['binary search', 'brute force', 'constructive algorithms', 'data structures', 'greedy', 'two pointers']"
"This is an interactive problem.Given a simple undirected graph with $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$, your task is to color all the vertices such that for every color $$$c$$$, the following conditions hold:   The set of vertices with color $$$c$$$ is connected;  $$$s_c \leq n_c^2$$$, where $$$n_c$$$ is the number of vertices with color $$$c$$$, and $$$s_c$$$ is the sum of degrees of vertices with color $$$c$$$.  It can be shown that there always exists a way to color all the vertices such that the above conditions hold. Initially, you are only given the number $$$n$$$ of vertices and the degree of each vertex. In each query, you can choose a vertex $$$u$$$. As a response, you will be given the $$$k$$$-th edge incident to $$$u$$$, if this is the $$$k$$$-th query on vertex $$$u$$$. You are allowed to make at most $$$n$$$ queries.An undirected graph is simple if it does not contain multiple edges or self-loops.The degree of a vertex is the number of edges incident to it. A set $$$S$$$ of vertices is connected if for every two different vertices $$$u, v \in S$$$, there is a path, which only passes through vertices in $$$S$$$, that connects $$$u$$$ and $$$v$$$. That is, there is a sequence of edges $$$(u_1, v_1), (u_2, v_2), \dots, (u_k, v_k)$$$ with $$$k \geq 1$$$ such that   $$$u_1 = u$$$, $$$v_k = v$$$, and $$$v_i = u_{i+1}$$$ for every $$$1 \leq i &lt; k$$$; and  $$$u_k \in S$$$ and $$$v_k \in S$$$ for every $$$1 \leq i \leq k$$$.  Especially, a set containing only one vertex is connected.","#!/usr/bin/env python3
import sys, getpass
import math, random
import functools, itertools, collections, heapq, bisect
from collections import Counter, defaultdict, deque
input = sys.stdin.readline  # to read input quickly

# available on Google, AtCoder Python3, not available on Codeforces
# import numpy as np
# import scipy

m9 = 10**9 + 7  # 998244353
# d4 = [(1,0),(0,1),(-1,0),(0,-1)]
# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]
# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout
MAXINT = sys.maxsize
e18 = 10**18 + 10

# if testing locally, print to terminal with a different color
OFFLINE_TEST = getpass.getuser() == ""htong""
# OFFLINE_TEST = False  # codechef does not allow getpass
def log(*args):
    if OFFLINE_TEST:
        print('\033[36m', *args, '\033[0m', file=sys.stderr)

# ---------------------------- template ends here ----------------------------

def query(pos):
    print(""? {}"".format(pos+1), flush=True)
    response = int(input()) - 1
    assert response >= 0
    return response

def alert(arr):
    print(""! {}"".format("" "".join(str(x) for x in arr)), flush=True)

# -----------------------------------------------------------------------------

class DisjointSet:
    # github.com/not522/ac-library-python/blob/master/atcoder/dsu.py

    def __init__(self, n: int = 0) -> None:
        if n > 0:  # constant size DSU
            self.parent_or_size = [-1]*n
        else:
            self.parent_or_size = defaultdict(lambda: -1)

    def union(self, a: int, b: int) -> int:
        x = self.find(a)
        y = self.find(b)

        if x == y:
            return x

        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x

        self.parent_or_size[x] += self.parent_or_size[y]
        self.parent_or_size[y] = x

        return x

    def find(self, a: int) -> int:
        parent = self.parent_or_size[a]
        while parent >= 0:
            if self.parent_or_size[parent] < 0:
                return parent
            self.parent_or_size[a], a, parent = (
                self.parent_or_size[parent],
                self.parent_or_size[parent],
                self.parent_or_size[self.parent_or_size[parent]]
            )
        return a

    def size(self, a: int) -> int:
        return -self.parent_or_size[self.find(a)]

import random
# get highest degree
# get adjacent nodes
# if nodes is in previous group, join

for case_num in range(int(input())):

    # read line as an integer
    n = int(input())

    # read line as a string
    # srr = input().strip()

    # read one line and parse each word as a string
    # lst = input().split()

    ds = DisjointSet(n)
    for i in range(n):
        ds.find(i)
    # read one line and parse each word as an integer
    # a,b,c = list(map(int,input().split()))
    degrees = list(map(int,input().split()))

    taken = set()
    arr = [(x,i) for i,x in enumerate(degrees)]
    # random.shuffle(arr)
    arr.sort()
    # arr.reverse()

    # log(arr)
    query_cnt = 0

    while arr:
        x,cur = arr.pop()
        if cur in taken:
            continue
        taken.add(cur)
        for _ in range(x):
            nex = query(cur)
            query_cnt += 1
            ds.union(cur, nex)
            if nex in taken:
                break
            taken.add(nex)

    assert query_cnt <= n

    for i in range(n):
        ldr = ds.find(i)

    cntr = 1
    val_to_cntr = {}
    for i in range(n):
        ldr = ds.find(i)
        if ldr not in val_to_cntr:
            val_to_cntr[ldr] = cntr
            cntr += 1

    res = [-1 for _ in range(n)]
    for i in range(n):
        res[i] = val_to_cntr[ds.find(i)]

    assert max(res) <= n
    assert min(res) >= 1

    cnt_nodes = defaultdict(int)
    cnt_edges = defaultdict(int)
    for i,x in enumerate(res):
        cnt_nodes[x] += 1
        cnt_edges[x] += degrees[i]
    
    for i in cnt_nodes.keys():
        assert cnt_edges[i] <= cnt_nodes[i]**2

    alert(res)

    # -----------------------------------------------------------------------------

    # your code here
sys.exit()","['constructive algorithms', 'dsu', 'graphs', 'greedy', 'interactive', 'shortest paths', 'trees']"
"This is the hard version of this problem. In this version, we have queries. Note that we do not have multiple test cases in this version. You can make hacks only if both versions of the problem are solved.An array $$$b$$$ of length $$$m$$$ is good if for all $$$i$$$ the $$$i$$$-th element is greater than or equal to $$$i$$$. In other words, $$$b$$$ is good if and only if $$$b_i \geq i$$$ for all $$$i$$$ ($$$1 \leq i \leq m$$$).You are given an array $$$a$$$ consisting of $$$n$$$ positive integers, and you are asked $$$q$$$ queries. In each query, you are given two integers $$$p$$$ and $$$x$$$ ($$$1 \leq p,x \leq n$$$). You have to do $$$a_p := x$$$ (assign $$$x$$$ to $$$a_p$$$). In the updated array, find the number of pairs of indices $$$(l, r)$$$, where $$$1 \le l \le r \le n$$$, such that the array $$$[a_l, a_{l+1}, \ldots, a_r]$$$ is good.Note that all queries are independent, which means after each query, the initial array $$$a$$$ is restored.","import random
import sys
import os
import math
from collections import Counter, defaultdict, deque
from functools import lru_cache, reduce
from itertools import accumulate, combinations, permutations
from heapq import nsmallest, nlargest, heapify, heappop, heappush
from io import BytesIO, IOBase
from copy import deepcopy
import threading
import bisect
BUFSIZE = 4096


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def I():
    return input()

def II():
    return int(input())

def MI():
    return map(int, input().split())

def LI():
    return list(input().split())

def LII():
    return list(map(int, input().split()))

def GMI():
    return map(lambda x: int(x) - 1, input().split())

def LGMI():
    return list(map(lambda x: int(x) - 1, input().split()))

n = II()
nums = [0] + LII()
nums = [idx - val for idx, val in enumerate(nums)]
prefix_maximum = list(accumulate(nums, max))
prefix_maximum_presum = list(accumulate(prefix_maximum))
q = II()
queries = []
for idx in range(q): queries.append((idx, LII()))
tot = n * (n + 1) // 2
queries.sort(key=lambda x: x[1][0])
ans = [0] * q

stack_nums = []
acc_sum = [0]
acc_count = [0]
queries_pt = q-1
for i in range(n, 0, -1):
    while queries_pt >= 0 and queries[queries_pt][1][0] == i:
        val = max(prefix_maximum[i-1], queries[queries_pt][1][0] - queries[queries_pt][1][1])
        l, r = 0, len(stack_nums) - 1
        while l <= r:
            m = (l + r) // 2
            if stack_nums[m][0] < val: r = m - 1
            else: l = m + 1
        ans[queries[queries_pt][0]] = n * (n + 1) // 2 - (prefix_maximum_presum[queries[queries_pt][1][0] - 1] + acc_sum[l] + (acc_count[-1] - acc_count[l] + 1) * val)
        queries_pt -= 1
    if queries_pt < 0: break
    v, cnt = nums[i], 1
    while len(stack_nums) and stack_nums[-1][0] <= v:
        _, new_cnt = stack_nums.pop()
        acc_sum.pop()
        acc_count.pop()
        cnt += new_cnt
    stack_nums.append((v, cnt))
    acc_sum.append(acc_sum[-1] + v * cnt)
    acc_count.append(acc_count[-1] + cnt)
print(*ans)","['binary search', 'data structures', 'dp', 'two pointers']"
"Let's denote the size of the maximum matching in a graph $$$G$$$ as $$$\mathit{MM}(G)$$$.You are given a bipartite graph. The vertices of the first part are numbered from $$$1$$$ to $$$n$$$, the vertices of the second part are numbered from $$$n+1$$$ to $$$2n$$$. Each vertex's degree is $$$2$$$.For a tuple of four integers $$$(l, r, L, R)$$$, where $$$1 \le l \le r \le n$$$ and $$$n+1 \le L \le R \le 2n$$$, let's define $$$G'(l, r, L, R)$$$ as the graph which consists of all vertices of the given graph that are included in the segment $$$[l, r]$$$ or in the segment $$$[L, R]$$$, and all edges of the given graph such that each of their endpoints belongs to one of these segments. In other words, to obtain $$$G'(l, r, L, R)$$$ from the original graph, you have to remove all vertices $$$i$$$ such that $$$i \notin [l, r]$$$ and $$$i \notin [L, R]$$$, and all edges incident to these vertices.Calculate the sum of $$$\mathit{MM}(G(l, r, L, R))$$$ over all tuples of integers $$$(l, r, L, R)$$$ having $$$1 \le l \le r \le n$$$ and $$$n+1 \le L \le R \le 2n$$$.","class unionfind:
    def __init__(self,uni_num):
        self.uni_num=uni_num
        self.union_root = [-1 for i in range(self.uni_num + 1)]
        self.union_depth = [0] * (self.uni_num + 1)
        self.e_num=[0]*(self.uni_num+1)

    def find(self,x):  # 親は誰？
        if self.union_root[x] < 0:
            return x
        else:
            self.union_root[x] = self.find(self.union_root[x])
            return self.union_root[x]

    def unite(self,x, y):
        x = self.find(x)
        y = self.find(y)
        if x == y:
            self.e_num[x]+=1
            return
        if self.union_depth[x] < self.union_depth[y]:
            x, y = y, x
        if self.union_depth[x] == self.union_depth[y]:
            self.union_depth[x] += 1
        self.union_root[x] += self.union_root[y]
        self.union_root[y] = x
        self.e_num[x]+=self.e_num[y]+1


    def size(self,x):
        return -self.union_root[self.find(x)]

    def same(self,x,y):
        return self.find(x)==self.find(y)
    def edge(self,x):
        return self.e_num[self.find(x)]


n=int(input())
root=[[] for i in range(2*n+3)]
uf=unionfind(2*n+10)
for i in range(2*n):
    u,v=map(int,input().split())
    root[u].append(v)
    root[v].append(u)
    uf.unite(u,v)
seen=[0]*(2*n+4)
def cnt(mal,mir,maL,miR,ng1,ng2):
    if mal>mir or maL>miR:return 0

    res1=mal*(n+1-mir)
    if 1<=ng1<=n:
        a,b=min(mal,ng1),max(mir,ng1)
        res1-=a*(n+1-b)
    if 1<=ng2<=n:
        a, b = min(mal, ng2), max(mir, ng2)
        res1 -= a * (n + 1 - b)
    if (1<=ng1<=n and 1<=ng2<=n):
        a,b=min(mal,ng1,ng2),max(mir,ng1,ng2)
        res1+=a*(n+1-b)

    maL-=n
    miR-=n
    ng1-=n
    ng2-=n
    res2=maL*(n+1-miR)
    if 1<=ng1<=n:
        a,b=min(maL,ng1),max(miR,ng1)
        res2-=a*(n+1-b)
    if 1<=ng2<=n:
        a, b = min(maL, ng2), max(miR, ng2)
        res2 -= a * (n + 1 - b)
    if (1<=ng1<=n and 1<=ng2<=n):
        a,b=min(maL,ng1,ng2),max(miR,ng1,ng2)
        res2+=a*(n+1-b)
    return res1*res2






ans=0
for x in range(1,2*n+1):
    if x!=uf.find(x):continue
    path=[x]
    now=x
    while 1:
        seen[now]=1
        flag=0
        for y in root[now]:
            if seen[y]:continue
            now=y
            path.append(y)
            flag=1
            break
        if not flag:break
    m=len(path)

    for indl in range(m):
        maxl = 10 ** 10
        minr = -10 ** 10
        maxL = 10 ** 10
        minR = -10 ** 10
        indr=(indl+1)%m
        num=0
        while 1:
            if indr==indl:break
            ans+=(num//2)*cnt(maxl,minr,maxL,minR,path[indl],path[indr])
            nod=path[indr]
            if nod<=n:
                maxl=min(maxl,nod)
                minr=max(minr,nod)
            else:
                maxL=min(maxL,nod)
                minR=max(minR,nod)
            num+=1
            indr+=1
            indr%=m
    for ind in range(m):
        maxl = 10 ** 10
        minr = -10 ** 10
        maxL = 10 ** 10
        minR = -10 ** 10
        i=(ind+1)%m
        while 1:
            if i==ind:break
            nod = path[i]
            if nod <= n:
                maxl = min(maxl, nod)
                minr = max(minr, nod)
            else:
                maxL = min(maxL, nod)
                minR = max(minR, nod)
            i=(i+1)%m
        num=m-1
        ans+=(num//2)*cnt(maxl,minr,maxL,minR,path[ind],path[ind])

    maxl = 10 ** 10
    minr = -10 ** 10
    maxL = 10 ** 10
    minR = -10 ** 10
    for i in range(m):
        nod = path[i]
        if nod <= n:
            maxl = min(maxl, nod)
            minr = max(minr, nod)
        else:
            maxL = min(maxL, nod)
            minR = max(minR, nod)
    num=m
    ans += (num // 2) * cnt(maxl, minr, maxL, minR,10**9,10**9)


print(ans)","['brute force', 'combinatorics', 'constructive algorithms', 'dfs and similar', 'graph matchings', 'greedy', 'math']"
"Madoka is a very strange girl, and therefore she suddenly wondered how many pairs of integers $$$(a, b)$$$ exist, where $$$1 \leq a, b \leq n$$$, for which $$$\frac{\operatorname{lcm}(a, b)}{\operatorname{gcd}(a, b)} \leq 3$$$.In this problem, $$$\operatorname{gcd}(a, b)$$$ denotes the greatest common divisor of the numbers $$$a$$$ and $$$b$$$, and $$$\operatorname{lcm}(a, b)$$$ denotes the smallest common multiple of the numbers $$$a$$$ and $$$b$$$.","import math
t = int(input())
for _ in range(t):
    n = int(input())
    c = 0
    c = n + 2*(n//2) + 2*(n//3)
    print(c)","['math', 'number theory']"
"Oh no, on the first exam Madoka got this hard problem:Given integer $$$n$$$ and $$$m$$$ pairs of integers ($$$v_i, u_i$$$). Also there is an array $$$b_1, b_2, \ldots, b_n$$$, initially filled with zeros.Then for each index $$$i$$$, where $$$1 \leq i \leq m$$$, perform either $$$b_{v_i} := b_{v_i} - 1$$$ and $$$b_{u_i} := b_{u_i} + 1$$$, or $$$b_{v_i} := b_{v_i} + 1$$$ and $$$b_{u_i} := b_{u_i} - 1$$$. Note that exactly one of these operations should be performed for every $$$i$$$.Also there is an array $$$s$$$ of length $$$n$$$ consisting of $$$0$$$ and $$$1$$$. And there is an array $$$a_1, a_2, \ldots, a_n$$$, where it is guaranteed, that if $$$s_i = 0$$$ holds, then $$$a_i = 0$$$.Help Madoka and determine whenever it is possible to perform operations in such way that for every $$$i$$$, where $$$s_i = 1$$$ it holds that $$$a_i = b_i$$$. If it possible you should also provide Madoka with a way to perform operations.","from collections import deque

import sys
sys.setrecursionlimit(10**4+10)
class mf_graph:
    n=1
    g=[[] for i in range(1)]
    pos=[]
    def __init__(self,N):
        self.n=N
        self.g=[[] for i in range(N)]
        self.pos=[]
    def add_edge(self,From,To,cap):
        assert 0<=From and From<self.n
        assert 0<=To and To<self.n
        assert 0<=cap
        m=len(self.pos)
        self.pos.append((From,len(self.g[From])))
        self.g[From].append({""to"":To,""rev"":len(self.g[To]),""cap"":cap})
        self.g[To].append({""to"":From,""rev"":len(self.g[From])-1,""cap"":0})
        return m
    def get_edge(self,i):
        m=len(self.pos)
        assert 0<=i and i<m
        _e=self.g[self.pos[i][0]][self.pos[i][1]]
        _re=self.g[_e[""to""]][_e[""rev""]]
        return {""from"":self.pos[i][0],
                ""to"":_e[""to""],
                ""cap"":_e[""cap""]+_re[""cap""],
                ""flow"":_re[""cap""]}
    def edges(self):
        m=len(self.pos)
        result=[]
        for i in range(m):
            result.append(self.get_edge(i))
        return result
    def change_edge(self,i,new_cap,new_flow):
        m=len(self.pos)
        assert 0<=i and i<m
        assert 0<=new_flow and new_flow<=new_cap
        _e=self.g[self.pos[i][0]][self.pos[i][1]]
        _re=self.g[_e[""to""]][_e[""rev""]]
        _e[""cap""]=new_cap-new_flow
        _re[""cap""]=new_flow
    def flow(self,s,t,flow_limit=(1<<63)-1):
        assert 0<=s and s<self.n
        assert 0<=t and t<self.n
        level=[0 for i in range(self.n)]
        Iter=[0 for i in range(self.n)]
        que=deque([])
        def bfs():
            for i in range(self.n):level[i]=-1
            level[s]=0
            que=deque([])
            que.append(s)
            while(len(que)>0):
                v=que.popleft()
                for e in self.g[v]:
                    if e[""cap""]==0 or level[e[""to""]]>=0:continue
                    level[e[""to""]]=level[v]+1
                    if e[""to""]==t:return
                    que.append(e[""to""])
        def dfs(func,v,up):
            if (v==s):return up
            res=0
            level_v=level[v]
            for i in range(Iter[v],len(self.g[v])):
                e=self.g[v][i]
                if (level_v<=level[e[""to""]] or self.g[e[""to""]][e[""rev""]][""cap""]==0):continue
                d=func(func,e[""to""],min(up-res,self.g[e[""to""]][e[""rev""]][""cap""]))
                if d<=0:continue
                self.g[v][i][""cap""]+=d
                self.g[e[""to""]][e[""rev""]][""cap""]-=d
                res+=d
                if res==up:return res
            level[v]=self.n
            return res
        flow=0
        while(flow<flow_limit):
            bfs()
            if level[t]==-1:break
            for i in range(self.n):Iter[i]=0
            while(flow<flow_limit):
                f=dfs(dfs,t,flow_limit-flow)
                if not(f):break
                flow+=f
        return flow
    def min_cut(self,s):
        visited=[False for i in range(self.n)]
        que=deque([])
        que.append(s)
        while(len(que)>0):
            p=que.popleft()
            visited[p]=True
            for e in self.g[p]:
                if e[""cap""] and not(visited[e[""to""]]):
                    visited[e[""to""]]=True
                    que.append(e[""to""])
        return

from sys import stdin
input=lambda :stdin.readline()[:-1]


n,m=map(int,input().split())
s=list(map(int,input().split()))
a=list(map(int,input().split()))
g=mf_graph(n+m+2)
S=n+m
T=S+1
tmp=[0]*n
edges=[]
edge1=[]
edge2=[]
for i in range(m):
  x,y=map(lambda x:int(x)-1,input().split())
  tmp[x]+=1
  tmp[y]+=1
  if s[x]==1 and s[y]==1:
    edge1.append((x,y,i))
  elif s[x]==1 or s[y]==1:
    edge2.append((x,y,i))
  edges.append((x,y))
  
cnt=0
for i in range(n):
  if s[i]==1:
    if a[i]>tmp[i] or (tmp[i]-a[i])%2==1:
      print('NO')
      exit()
    t=(tmp[i]-a[i])//2
    if t!=0:
      g.add_edge(i,T,t)
      cnt+=t

for x,y,i in edge1:
  g.add_edge(S,n+i,1)
  g.add_edge(n+i,x,1)
  g.add_edge(n+i,y,1)

ans_flow=g.flow(S,T)
for x,y,i in edge2:
  g.add_edge(S,n+i,1)
  g.add_edge(n+i,x,1)
  g.add_edge(n+i,y,1)
ans_flow+=g.flow(S,T)
if ans_flow!=cnt:
  print('NO')
  exit()

ans=[-1]*m
for e in g.edges():
  frm=e['from']-n
  if 0<=frm<m:
    to=e['to']
    if e['flow']!=0:
      ans[frm]=to

ANS=[]
for i in range(m):
  x,y=edges[i]
  if ans[i]!=-1:
    if ans[i]==x:
      ANS.append((x,y))
    else:
      ANS.append((y,x))
  else:
    if s[x]==0:
      ANS.append((x,y))
    elif s[y]==0:
      ANS.append((y,x))
    else:
      print('NO')
      exit()

print('YES')
for x,y in ANS:
  print(x+1,y+1)","['constructive algorithms', 'flows', 'graph matchings', 'graphs', 'implementation']"
"Petya got an array $$$a$$$ of numbers from $$$1$$$ to $$$n$$$, where $$$a[i]=i$$$.He performed $$$n$$$ operations sequentially. In the end, he received a new state of the $$$a$$$ array.At the $$$i$$$-th operation, Petya chose the first $$$i$$$ elements of the array and cyclically shifted them to the right an arbitrary number of times (elements with indexes $$$i+1$$$ and more remain in their places). One cyclic shift to the right is such a transformation that the array $$$a=[a_1, a_2, \dots, a_n]$$$ becomes equal to the array $$$a = [a_i, a_1, a_2, \dots, a_{i-2}, a_{i-1}, a_{i+1}, a_{i+2}, \dots, a_n]$$$.For example, if $$$a = [5,4,2,1,3]$$$ and $$$i=3$$$ (that is, this is the third operation), then as a result of this operation, he could get any of these three arrays:  $$$a = [5,4,2,1,3]$$$ (makes $$$0$$$ cyclic shifts, or any number that is divisible by $$$3$$$);  $$$a = [2,5,4,1,3]$$$ (makes $$$1$$$ cyclic shift, or any number that has a remainder of $$$1$$$ when divided by $$$3$$$);  $$$a = [4,2,5,1,3]$$$ (makes $$$2$$$ cyclic shifts, or any number that has a remainder of $$$2$$$ when divided by $$$3$$$). Let's look at an example. Let $$$n=6$$$, i.e. initially $$$a=[1,2,3,4,5,6]$$$. A possible scenario is described below.  $$$i=1$$$: no matter how many cyclic shifts Petya makes, the array $$$a$$$ does not change.  $$$i=2$$$: let's say Petya decided to make a $$$1$$$ cyclic shift, then the array will look like $$$a = [\textbf{2}, \textbf{1}, 3, 4, 5, 6]$$$.  $$$i=3$$$: let's say Petya decided to make $$$1$$$ cyclic shift, then the array will look like $$$a = [\textbf{3}, \textbf{2}, \textbf{1}, 4, 5, 6]$$$.  $$$i=4$$$: let's say Petya decided to make $$$2$$$ cyclic shifts, the original array will look like $$$a = [\textbf{1}, \textbf{4}, \textbf{3}, \textbf{2}, 5, 6]$$$.  $$$i=5$$$: let's say Petya decided to make $$$0$$$ cyclic shifts, then the array won't change.  $$$i=6$$$: let's say Petya decided to make $$$4$$$ cyclic shifts, the array will look like $$$a = [\textbf{3}, \textbf{2}, \textbf{5}, \textbf{6}, \textbf{1}, \textbf{4}]$$$. You are given a final array state $$$a$$$ after all $$$n$$$ operations. Determine if there is a way to perform the operation that produces this result. In this case, if an answer exists, print the numbers of cyclical shifts that occurred during each of the $$$n$$$ operations.","#!/usr/bin/env pypy3

import io, os, sys
from sys import stdin, stdout

# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
def input(): return stdin.readline().strip()
def read_int_list(): return list(map(int, input().split()))
def read_int_tuple(): return tuple(map(int, input().split()))
def read_int(): return int(input())

from itertools import permutations, chain, combinations, product
from math import factorial, gcd
from collections import Counter, defaultdict, deque
from heapq import heappush, heappop, heapify
from bisect import bisect_left
from functools import lru_cache

### CODE HERE

class FenwickTree:
    def __init__(self, x):
        """"""transform list into BIT""""""
        self.bit = x
        for i in range(len(x)):
            j = i | (i + 1)
            if j < len(x):
                x[j] += x[i]

    def update(self, idx, x):
        """"""updates bit[idx] += x""""""
        while idx < len(self.bit):
            self.bit[idx] += x
            idx |= idx + 1

    def query(self, end):
        """"""calc sum(bit[:end])""""""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x

    def findkth(self, k):
        """"""Find largest idx such that sum(bit[:idx]) <= k""""""
        idx = -1
        for d in reversed(range(len(self.bit).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(self.bit) and k >= self.bit[right_idx]:
                idx = right_idx
                k -= self.bit[idx]
        return idx + 1

class IndexingDelList:
    """"""
    A list with fast index and del operations
    Note: del is with indexes of the original
    However, get/set are not supported
    """"""
    from collections import defaultdict
    def __init__(self, A):
        self.ones = FenwickTree([1]*len(A))
        self.A = list(A)
        self.index_of = dict()
        for i, a in enumerate(A):
            self.index_of[a] = i
        self.total_len = len(A)

    def index(self, n):
        return self.ones.query(self.index_of[n])


    def __getitem__(self, k):
        # not implemented, could do some binary search
        assert(False)
    def __setitem__(self, k, v):
        assert(False)
    def __len__(self):
        return self.total_len

    def remove(self, a):
        self.total_len -= 1
        idx = self.index_of[a]
        self.ones.update(idx, -1)

def ans(A):
    N = len(A)
    A = IndexingDelList([a-1 for a in A])
    last = N
    ret = []
    for n in range(N-1, -1, -1):
        r = A.index(n)
        gap = (r + len(A) - last + 1) % len(A)
        ret += [gap]
        last = r
        A.remove(n)
    print(*ret[::-1])

for _ in range(read_int()):
    input()
    ans(read_int_list())","['brute force', 'constructive algorithms', 'implementation', 'math']"
"Let's say you are standing on the $$$XY$$$-plane at point $$$(0, 0)$$$ and you want to reach point $$$(n, n)$$$.You can move only in two directions:   to the right, i. e. horizontally and in the direction that increase your $$$x$$$ coordinate,  or up, i. e. vertically and in the direction that increase your $$$y$$$ coordinate. In other words, your path will have the following structure:   initially, you choose to go to the right or up;  then you go some positive integer distance in the chosen direction (distances can be chosen independently);  after that you change your direction (from right to up, or from up to right) and repeat the process. You don't like to change your direction too much, so you will make no more than $$$n - 1$$$ direction changes.As a result, your path will be a polygonal chain from $$$(0, 0)$$$ to $$$(n, n)$$$, consisting of at most $$$n$$$ line segments where each segment has positive integer length and vertical and horizontal segments alternate.Not all paths are equal. You have $$$n$$$ integers $$$c_1, c_2, \dots, c_n$$$ where $$$c_i$$$ is the cost of the $$$i$$$-th segment.Using these costs we can define the cost of the path as the sum of lengths of the segments of this path multiplied by their cost, i. e. if the path consists of $$$k$$$ segments ($$$k \le n$$$), then the cost of the path is equal to $$$\sum\limits_{i=1}^{k}{c_i \cdot length_i}$$$ (segments are numbered from $$$1$$$ to $$$k$$$ in the order they are in the path).Find the path of the minimum cost and print its cost.","import random
from datetime import datetime
import math

now = datetime.now() 
 
cazuri=int(input())
for tt in range(cazuri):
 #n,c=map(int,input().split())
 n=int(input())
 
 #stringul=input()
 
 bloc=list(map(int,input().split()))
 

  
  
 pare=[]
 impare=[]
 
 suma_pare=0
 suma_impare=0
 cate_pare=1
 cate_impare=1
 
 
 suma_totala=0
 
 suma_pare=bloc[0]
 suma_impare=bloc[1]
 
 min_pare=bloc[0]
 min_impare=bloc[1]
 
 val_pare=bloc[0]*n
 val_impare=bloc[1]*n
 
 val_total=val_pare+val_impare
 
# print(""val total="",val_total)
 
 if n==2:
  print(val_total)
 else:
  
  for i in range(2,n):
   if i%2==0:
    cate_pare+=1
    suma_pare+=bloc[i]
    if bloc[i]<min_pare:
     min_pare=bloc[i]
     
    val_pare=min_pare*(n+1-cate_pare)+suma_pare-min_pare
    val_total=min(val_total,val_pare+val_impare)
    
   
   else:
    cate_impare+=1
    suma_impare+=bloc[i]
    if bloc[i]<min_impare:
     min_impare=bloc[i]
     
    val_impare=min_impare*(n+1-cate_impare)+suma_impare-min_impare
    
   # print(""val impare="",val_impare,val_pare)
    val_total=min(val_total,val_impare+val_pare)
    
 
  print(val_total)","['brute force', 'data structures', 'greedy', 'math']"
"This time around, Baby Ehab will play with permutations. He has $$$n$$$ cubes arranged in a row, with numbers from $$$1$$$ to $$$n$$$ written on them. He'll make exactly $$$j$$$ operations. In each operation, he'll pick up $$$2$$$ cubes and switch their positions.He's wondering: how many different sequences of cubes can I have at the end? Since Baby Ehab is a turbulent person, he doesn't know how many operations he'll make, so he wants the answer for every possible $$$j$$$ between $$$1$$$ and $$$k$$$.","import os,sys
from random import randint
from io import BytesIO, IOBase

from collections import defaultdict,deque,Counter
from bisect import bisect_left,bisect_right
from heapq import heappush,heappop
from functools import lru_cache
from itertools import accumulate
import math

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))

# for _ in range(int(input())):
#     n, k = list(map(int, input().split()))
#     a = list(map(int, input().split()))
#     i = 0
#     while i < n - 1 and k > 0:
#         if a[i] > 0:
#             a[i] -= 1
#             a[-1] += 1
#             k -= 1
#         else:
#             i += 1
#     print(*a)

# for _ in range(int(input())):
#     def solve():
#         n = int(input())
#         a = list(map(int, input().split()))
#         tot = 0
#         for i in range(n):
#             tot ^= a[i]
#         if tot == 0:
#             print('YES')
#             return
#         res = 0
#         for i in range(n):
#             res ^= a[i]
#             if res == tot:
#                 l = i
#                 break
#         res = 0
#         for i in range(n)[::-1]:
#             res ^= a[i]
#             if res == tot:
#                 r = i
#                 break
#         if l < r:
#             print('YES')
#         else:
#             print('NO')
#     solve()

# def solve():
#     n = int(input())
#     a = list(map(int, input().split()))
#     if sum(a) % 2:
#         print(0)
#         return
#     b = sorted(a)
#     s = set([0])
#     for i in range(n):
#         news = set()
#         for j in s:
#             news.add(j)
#             news.add(j + a[i])
#         s = news
#     if sum(a) // 2 not in s:
#         print(0)
#         return
#     for _ in range(40):
#         for i in range(n):
#             if a[i] % 2 == 1:
#                 print(1)
#                 print(i + 1)
#                 return
#             a[i] //= 2
# solve()

mod = 10 ** 9 + 7
N = 410
c = [[0] * N for _ in range(N)]
for i in range(N):
    c[i][0] = c[i][i] = 1
for i in range(1, N):
    for j in range(1, i):
        c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod

n, k = list(map(int, input().split()))
f = [[0] * (k + 1) for _ in range(2 * k + 1)]
for i in range(1, 2 * k + 1):
    f[i][0] = 1
    for j in range(1, k + 1):
        f[i][j] = (f[i - 1][j] + (i - 1) * f[i - 1][j - 1]) % mod

g = [[0] * (k + 1) for _ in range(2 * k + 1)]
for j in range(k + 1):
    for i in range(min(n, 2 * j) + 1):
        for l in range(i + 1):
            if l % 2 == 0:
                g[i][j] += c[i][l] * f[i - l][j]
            else:
                g[i][j] -= c[i][l] * f[i - l][j]
            g[i][j] %= mod

ans = [0] * (k + 1)
ans[0] = 1
for i in range(1, k + 1):
    w = 1
    for j in range(min(n, 2 * i) + 1):
        ans[i] += w * g[j][i] % mod
        ans[i] %= mod
        w *= (n - j) * pow(j + 1, mod - 2, mod) % mod
        w %= mod
for i in range(2, k + 1):
    ans[i] = (ans[i] + ans[i - 2]) % mod
print(*ans[1:])","['combinatorics', 'dp', 'math']"
"On a number axis directed from the left rightwards, n marbles with coordinates x1, x2, ..., xn are situated. Let's assume that the sizes of the marbles are infinitely small, that is in this task each of them is assumed to be a material point. You can stick pins in some of them and the cost of sticking in the marble number i is equal to ci, number ci may be negative. After you choose and stick the pins you need, the marbles will start to roll left according to the rule: if a marble has a pin stuck in it, then the marble doesn't move, otherwise the marble rolls all the way up to the next marble which has a pin stuck in it and stops moving there. If there is no pinned marble on the left to the given unpinned one, it is concluded that the marble rolls to the left to infinity and you will pay an infinitely large fine for it. If no marble rolled infinitely to the left, then the fine will consist of two summands:   the sum of the costs of stuck pins;  the sum of the lengths of the paths of each of the marbles, that is the sum of absolute values of differences between their initial and final positions. Your task is to choose and pin some marbles in the way that will make the fine for you to pay as little as possible.","#import time

#st = time.time()
n = int(raw_input())
s = []
q = []
i = n
while i > 0:
	i -= 1
	p = raw_input().split()
	x = int(p[0])
	y = int(p[1])
	s.append((x, y))
	q.append(10**10)
s.sort()
p = []
for i in range(n):
	p.append(s[i][1])
	s[i] = s[i][0]
#print time.time()-st

i = 0
q[0] = p[0]
for x in s[1:]:
	i += 1
	q[i] = min(q[:i]) + p[i]
	j = 0
	z = s[i]
	for y in s[:i]:
		q[j] +=	z-y
		j += 1

print min(q)
#print time.time()-st","['dp', 'sortings']"
"The statement of this problem shares a lot with problem A. The differences are that in this problem, the probability is introduced, and the constraint is different.A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of $$$n$$$ rows and $$$m$$$ columns. The rows of the floor are numbered from $$$1$$$ to $$$n$$$ from top to bottom, and columns of the floor are numbered from $$$1$$$ to $$$m$$$ from left to right. The cell on the intersection of the $$$r$$$-th row and the $$$c$$$-th column is denoted as $$$(r,c)$$$. The initial position of the robot is $$$(r_b, c_b)$$$.In one second, the robot moves by $$$dr$$$ rows and $$$dc$$$ columns, that is, after one second, the robot moves from the cell $$$(r, c)$$$ to $$$(r + dr, c + dc)$$$. Initially $$$dr = 1$$$, $$$dc = 1$$$. If there is a vertical wall (the left or the right walls) in the movement direction, $$$dc$$$ is reflected before the movement, so the new value of $$$dc$$$ is $$$-dc$$$. And if there is a horizontal wall (the upper or lower walls), $$$dr$$$ is reflected before the movement, so the new value of $$$dr$$$ is $$$-dr$$$.Each second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at $$$(r_d, c_d)$$$. The job of the robot is to clean that dirty cell. After a lot of testings in problem A, the robot is now broken. It cleans the floor as described above, but at each second the cleaning operation is performed with probability $$$\frac p {100}$$$ only, and not performed with probability $$$1 - \frac p {100}$$$. The cleaning or not cleaning outcomes are independent each second.Given the floor size $$$n$$$ and $$$m$$$, the robot's initial position $$$(r_b, c_b)$$$ and the dirty cell's position $$$(r_d, c_d)$$$, find the expected time for the robot to do its job.It can be shown that the answer can be expressed as an irreducible fraction $$$\frac x y$$$, where $$$x$$$ and $$$y$$$ are integers and $$$y \not \equiv 0 \pmod{10^9 + 7} $$$. Output the integer equal to $$$x \cdot y^{-1} \bmod (10^9 + 7)$$$. In other words, output such an integer $$$a$$$ that $$$0 \le a &lt; 10^9 + 7$$$ and $$$a \cdot y \equiv x \pmod {10^9 + 7}$$$.","import os,sys
from io import BytesIO, IOBase

from collections import defaultdict,deque,Counter
from bisect import bisect_left,bisect_right
from heapq import heappush,heappop
from functools import lru_cache
from itertools import accumulate
import math

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split(' ')))

# for _ in range(int(input())):
#     def solve():
#         n, m, rb, cb, rd, cd = list(map(int, input().split(' ')))
#         dr = dc = 1
#         ans = 0
#         if rb == rd or cb == cd:
#             print(0)
#             return
#         while rb != rd and cb != cd:
#             if dr == dc == 1:
#                 while rb != rd and cb != cd and 1 <= rb < n and 1 <= cb < m:
#                     rb += 1
#                     cb += 1
#                     ans += 1
#                 if rb == rd or cb == cd:
#                     print(ans)
#                     return
#                 if rb == n:
#                     dr = -1
#                 if cb == m:
#                     dc = -1
#             elif dr == 1 and dc == -1:
#                 while rb != rd and cb != cd and 1 <= rb < n and 1 < cb <= m:
#                     rb += 1
#                     cb -= 1
#                     ans += 1
#                 if rb == rd or cb == cd:
#                     print(ans)
#                     return
#                 if rb == n:
#                     dr = -1
#                 if cb == 1:
#                     dc = 1
#             elif dr == -1 and dc == 1:
#                 while rb != rd and cb != cd and 1 < rb <= n and 1 <= cb < m:
#                     rb -= 1
#                     cb += 1
#                     ans += 1
#                 if rb == rd or cb == cd:
#                     print(ans)
#                     return
#                 if rb == 1:
#                     dr = 1
#                 if cb == m:
#                     dc = -1
#             else:
#                 while rb != rd and cb != cd and 1 < rb <= n and 1 < cb <= m:
#                     rb -= 1
#                     cb -= 1
#                     ans += 1
#                 if rb == rd or cb == cd:
#                     print(ans)
#                     return
#                 if rb == 1:
#                     dr = 1
#                 if cb == 1:
#                     dc = 1
#     solve()

# for _ in range(int(input())):
#     n = int(input())
#     a = [list(map(int, input().split(' '))) for _ in range(n)]
#     a.sort(key = lambda x : x[1] - x[0])
#     vis = set()
#     for i in range(n):
#         l, r = a[i]
#         for i in range(l, r + 1):
#             if i not in vis:
#                 print(l, r, i)
#                 vis.add(i)
#     print()

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split(' ')))
#     def check(mid):
#         b = a[:]
#         for i in range(n - 1, 1, -1):
#             if b[i] < mid:
#                 return False
#             r = min(a[i], b[i] - mid)
#             r //= 3
#             b[i] -= 3 * r
#             b[i - 1] += r
#             b[i - 2] += 2 * r
#         return min(b) >= mid

#     l, r = 1, 10 ** 9
#     while l <= r:
#         mid = (l + r) // 2
#         if check(mid):
#             l = mid + 1
#         else:
#             r = mid - 1
#     print(r)

mod = 10 ** 9 + 7
for _ in range(int(input())):
    def solve():
        n, m, rb, cb, rd, cd, p = list(map(int, input().split(' ')))
        dr = dc = 1
        ans = 0
        tmp = []
        vis = set()
        if rb == n:
            dr = -1
        if cb == m:
            dc = -1
        if rb == rd or cb == cd:
            tmp.append(0)
            vis.add((rb, cb, dr, dc))
        ok = True
        while ok: 
            if dr == dc == 1:
                while 1 <= rb < n and 1 <= cb < m:
                    rb += 1
                    cb += 1
                    ans += 1
                    if rb == n:
                        dr = -1
                    if cb == m:
                        dc = -1
                    if rb == rd or cb == cd:
                        if (rb, cb, dr, dc) in vis:
                            T = ans - tmp[0]
                            ok = False
                            break
                        tmp.append(ans)
                        vis.add((rb, cb, dr, dc))
                
            elif dr == 1 and dc == -1:
                while 1 <= rb < n and 1 < cb <= m:
                    rb += 1
                    cb -= 1
                    ans += 1
                    if rb == n:
                        dr = -1
                    if cb == 1:
                        dc = 1
                    if rb == rd or cb == cd:
                        if (rb, cb, dr, dc) in vis:
                            T = ans - tmp[0]
                            ok = False
                            break
                        tmp.append(ans)
                        vis.add((rb, cb, dr, dc))
                
            elif dr == -1 and dc == 1:
                while 1 < rb <= n and 1 <= cb < m:
                    rb -= 1
                    cb += 1
                    ans += 1
                    if rb == 1:
                        dr = 1
                    if cb == m:
                        dc = -1
                    if rb == rd or cb == cd:
                        if (rb, cb, dr, dc) in vis:
                            T = ans - tmp[0]
                            ok = False
                            break
                        tmp.append(ans)
                        vis.add((rb, cb, dr, dc))
                
            else:
                while 1 < rb <= n and 1 < cb <= m:
                    rb -= 1
                    cb -= 1
                    ans += 1
                    if rb == 1:
                        dr = 1
                    if cb == 1:
                        dc = 1
                    if rb == rd or cb == cd:
                        if (rb, cb, dr, dc) in vis:
                            T = ans - tmp[0]
                            ok = False
                            break
                        tmp.append(ans)
                        vis.add((rb, cb, dr, dc))
                

        l = len(tmp)
        res = 0
        p = p * pow(100, mod - 2, mod) % mod
        q = (1 - p) % mod
        power = [1] * 100005
        for i in range(1, 100005):
             power[i] = power[i - 1] * q % mod
        for i in range(l):
            res += tmp[i] * p * power[i] * pow(1 - power[l], mod - 2, mod) + T * p * power[i + l] * pow((1 - power[l]) * (1 - power[l]) % mod, mod - 2, mod)
            res %= mod
        # print(tmp,T)
        # print(l, T)
        # print(tmp[-100:])
        print(res % mod)
    solve()","['implementation', 'math', 'probabilities']"
"Note that the memory limit is unusual.You are given an integer $$$n$$$ and two sequences $$$a_1, a_2, \dots, a_n$$$ and $$$b_1, b_2, \dots, b_n$$$.Let's call a set of integers $$$S$$$ such that $$$S \subseteq \{1, 2, 3, \dots, n\}$$$ strange, if, for every element $$$i$$$ of $$$S$$$, the following condition is met: for every $$$j \in [1, i - 1]$$$, if $$$a_j$$$ divides $$$a_i$$$, then $$$j$$$ is also included in $$$S$$$. An empty set is always strange.The cost of the set $$$S$$$ is $$$\sum\limits_{i \in S} b_i$$$. You have to calculate the maximum possible cost of a strange set.","from collections import deque
class Dinic:
    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    # 1方向
    def add_edge(self, fr, to, cap):
        forward = [to, cap, None]
        forward[2] = backward = [fr, 0, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    # 両方向
    def add_multi_edge(self, v1, v2, cap1, cap2):
        edge1 = [v2, cap1, None]
        edge1[2] = edge2 = [v1, cap2, edge1]
        self.G[v1].append(edge1)
        self.G[v2].append(edge2)

    def bfs(self, s, t):
        self.level = level = [None]*self.N
        deq = deque([s])
        level[s] = 0
        G = self.G
        while deq:
            v = deq.popleft()
            lv = level[v] + 1
            for w, cap, _ in G[v]:
                if cap and level[w] is None:
                    level[w] = lv
                    deq.append(w)
        return level[t] is not None

    def dfs(self, v, t, f):
        if v == t:
            return f
        level = self.level
        for e in self.it[v]:
            w, cap, rev = e
            if cap and level[v] < level[w]:
                d = self.dfs(w, t, min(f, cap))
                if d:
                    e[1] -= d
                    rev[1] += d
                    return d
        return 0

    def flow(self, s, t):
        flow = 0
        INF = 10**9 + 7
        G = self.G
        while self.bfs(s, t):
            *self.it, = map(iter, self.G)
            f = INF
            while f:
                f = self.dfs(s, t, INF)
                flow += f
        return flow

import sys
input = sys.stdin.readline

n = int(input())
a = list(map(int,input().split()))
b = list(map(int,input().split()))

# s:n+1,g:0
f = Dinic(n+2)
INF = 10**15

for i in range(n):
    if b[i] > 0:
        f.add_edge(n+1,i+1,b[i])
    elif b[i] < 0:
        f.add_edge(i+1,0,-b[i])

for i in range(n):
    used = [False]*101
    for j in reversed(range(i)):
        if a[i] % a[j] == 0 and not used[a[j]]:
            f.add_edge(i+1,j+1,INF)
            used[a[j]] = True

ans = sum(b[i]*(b[i] > 0) for i in range(n)) - f.flow(n+1,0)
print(ans)","['flows', 'math']"
"Timur has $$$n$$$ candies. The $$$i$$$-th candy has a quantity of sugar equal to $$$a_i$$$. So, by eating the $$$i$$$-th candy, Timur consumes a quantity of sugar equal to $$$a_i$$$.Timur will ask you $$$q$$$ queries regarding his candies. For the $$$j$$$-th query you have to answer what is the minimum number of candies he needs to eat in order to reach a quantity of sugar greater than or equal to $$$x_j$$$ or print -1 if it's not possible to obtain such a quantity. In other words, you should print the minimum possible $$$k$$$ such that after eating $$$k$$$ candies, Timur consumes a quantity of sugar of at least $$$x_j$$$ or say that no possible $$$k$$$ exists.Note that he can't eat the same candy twice and queries are independent of each other (Timur can use the same candy in different queries).","for o in range(int(input())):
  
    n,q=map(int,input().split())
    cand=list(map(int,input().split()))
    
    a=[]
    for i in range(q):
        t=int(input())
        a.append(t)
    cand.sort(reverse=True)
    
    b=[]
    su=0
    for j in range(n):
        su+=cand[j]
        b.append(su)
    
    for i in range(q):
        if a[i]>b[-1]:
            print(-1)
        elif a[i]==b[-1]:
            print(n)
        else:
            w=0
            if len(b)==1:
                print(1)
                w=1
            
            else:
                low=0
                high=n-1
                mid=0
                while (low+1!=high):
                    mid=(low+high)//2
                    if b[mid]>a[i]:
                        high=mid
                    elif b[mid]<a[i]:
                        low=mid
                    else:
                        print(mid+1)
                        w=1
                        break
                
                if w==0:        
                    if a[i]<=b[low]:
                        print(high)
                    else:
                        print(high+1)","['binary search', 'greedy', 'sortings']"
"Bakry got bored of solving problems related to xor, so he asked you to solve this problem for him.You are given an array $$$a$$$ of $$$n$$$ integers $$$[a_1, a_2, \ldots, a_n]$$$.Let's call a subarray $$$a_{l}, a_{l+1}, a_{l+2}, \ldots, a_r$$$ good if $$$a_l \, \&amp; \, a_{l+1} \, \&amp; \, a_{l+2} \, \ldots \, \&amp; \, a_r &gt; a_l \oplus a_{l+1} \oplus a_{l+2} \ldots \oplus a_r$$$, where $$$\oplus$$$ denotes the bitwise XOR operation and $$$\&amp;$$$ denotes the bitwise AND operation.Find the length of the longest good subarray of $$$a$$$, or determine that no such subarray exists.","from __future__ import division, print_function

import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip

from bisect import bisect_left as lower_bound, bisect_right as upper_bound 
def so():  return int(input())
def st():  return input()
def mj():  return map(int,input().strip().split("" ""))
def msj(): return list(map(str,input().strip().split("" "")))
def le():  return list(map(int,input().split()))
def rc():  return map(float,input().split())
def lebe():return list(map(int, input()))

def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
def joro(L):
    return(''.join(map(str, L)))
def joron(L):
    return('\n'.join(map(str, L)))

def decimalToBinary(n): return bin(n).replace(""0b"","""")


def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True
def npr(n, r):
    return factorial(n) // factorial(n - r) if n >= r else 0
 
 
def ncr(n, r):
    return factorial(n) // (factorial(r) * factorial(n - r)) if n >= r else 0
 
 
def lower_bound(li, num):
    answer = -1
    start = 0
    end = len(li) - 1
 
    while (start <= end):
        middle = (end + start) // 2
        if li[middle] >= num:
            answer = middle
            end = middle - 1
        else:
            start = middle + 1
    return answer  # min index where x is not less than num
 
 
def upper_bound(li, num):
    answer = -1
    start = 0
    end = len(li) - 1
 
    while (start <= end):
        middle = (end + start) // 2
 
        if li[middle] <= num:
            answer = middle
            start = middle + 1
 
        else:
            end = middle - 1
    return answer  # max index where x is not greater than num
def tir(a,b,c):
    if(0==c):
        return 1
    if(len(a)<=b):
        return 0
    
    if(c!=-1):
        return (tir(a,1+b,c+a[b]) or tir(a,b+1,c-a[b]) or tir(a,1+b,c)) 
        
        
    else:
        return (tir(a,1+b,a[b]) or tir(a,b+1,-a[b]) or tir(a,1+b,-1))
   
 
def abs(x):
    return x if x >= 0 else -x
 
 
def binary_search(li, val, lb, ub):
    # print(lb, ub, li)
    ans = -1
    while (lb <= ub):
        mid = (lb + ub) // 2
        # print('mid is',mid, li[mid])
        if li[mid] > val:
            ub = mid - 1
        elif val > li[mid]:
            lb = mid + 1
        else:
            ans = mid  # return index
            break
    return ans
 
 
def kadane(x):  # maximum sum contiguous subarray
    sum_so_far = 0
    current_sum = 0
    for i in x:
        current_sum += i
        if current_sum < 0:
            current_sum = 0
        else:
            sum_so_far = max(sum_so_far, current_sum)
    return sum_so_far

                    
def pref(li):
    pref_sum = [0]
    for i in li:
        pref_sum.append(pref_sum[-1] + i)
    return pref_sum
 

        
        
def SieveOfEratosthenes(n):
    prime = [True for i in range(n + 1)]
    p = 2
    li = []
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
 
    for p in range(2, len(prime)):
        if prime[p]:
            li.append(p)
    return li
 
 
def primefactors(n):
    factors = []
    while (n % 2 == 0):
        factors.append(2)
        n //= 2
    for i in range(3, int(sqrt(n)) + 1, 2):  # only odd factors left
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:  # incase of prime
        factors.append(n)
    return factors
         
    
def read():
    sys.stdin  = open('input.txt', 'r')  
    sys.stdout = open('output.txt', 'w') 
def tr(n):
    return n*(n+1)//2
boi=int(998244353)
doi=int(1e9+7)
hoi=int(1e6+1e5+5)
poi=int(1009)
y=""YES""
n=""NO""
def gosa(x, y): 
  
   while(y): 
       x, y = y, x % y 
  
   return x

L=[0]*hoi
M=[0]*hoi
N=[0]*hoi
O=[0]*hoi














    
        

        


            

def bulli(x):
    return bin(x).count('1')




        
    
    
        




            
def iu():
    import sys
    import math as my
    import functools
    input=sys.stdin.readline
    from collections import deque, defaultdict
    bec=0
    m=so()
    P=le()
    for i in range(1,1+m):
        L[i]=P[i-1]
    for i in range(20,-1,-1):
        M[0]=0
        for j in range(1,1<<20):
            M[j]=-1
        for j in range(1,1+m):
            
            N[j]=(L[j]>>i&1)+N[j-1]
            O[j]=O[j]^((N[j]%2)<<i)
            z=(N[j]%2)
            zz=O[j]
            if(-1==zz):
                M[zz]=j
            else:
                if(j-N[j]==M[zz]-N[M[zz]]):
                    bec=max(j-M[zz],bec)
                else:
                    M[zz]=j
    print(bec)
            
    
    
    
    
        
                
            
        
        
    
    
            
    
    
    
    
    
    
        
            
        
    
    
    
    
        
            
    
        
        
        
def main():
    for i in range(1):
        #print(""Case #""+str(i+1)+"": "",end="""")
        iu()        
    
    
    
    
        
        
    
        
    
    
            
    
    
    
                
            
            
    
        

                
    
        
        

            
                    
                
                    
                    
                    
                    
                    
                    
        
                
        
        
       
    
           
          
          
                
            
        
                
    
        
        
        
       
            
                
        




# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion


if __name__ == ""__main__"":
    #read()
    main()
    #dmain()

# Comment Read()","['bitmasks', 'greedy', 'math', 'two pointers']"
"You have an array $$$a_1,a_2, \dots, a_n$$$. Each element initially has value $$$0$$$ and color $$$1$$$. You are also given $$$q$$$ queries to perform:   Color $$$l$$$ $$$r$$$ $$$c$$$: Change the color of elements $$$a_l,a_{l+1},\cdots,a_r$$$ to $$$c$$$ ($$$1 \le l \le r \le n$$$, $$$1 \le c \le n$$$).  Add $$$c$$$ $$$x$$$: Add $$$x$$$ to values of all elements $$$a_i$$$ ($$$1 \le i \le n$$$) of color $$$c$$$ ($$$1 \le c \le n$$$, $$$-10^9 \le x \le 10^9$$$).  Query $$$i$$$: Print $$$a_i$$$ ($$$1 \le i \le n$$$).","''' E. Colorful Operations
https://codeforces.com/contest/1638/problem/E
'''

import io, os, sys
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str
output = sys.stdout.write

DEBUG = os.environ.get('debug') not in [None, '0']

if DEBUG:
    from inspect import currentframe, getframeinfo
    from re import search

def debug(*args):
    if not DEBUG: return
    frame = currentframe().f_back
    s = getframeinfo(frame).code_context[0]
    r = search(r""\((.*)\)"", s).group(1)
    vnames = r.split(', ')
    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]
    prefix = f'{currentframe().f_back.f_lineno:02d}: '
    print(f'{prefix}{"", "".join(var_and_vals)}')


INF = float('inf')

# -----------------------------------------

class SortedList:
    def __init__(self, iterable=[], _load=200):
        '''Initialize sorted list instance.'''
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def add(self, value):
        '''Add `value` to sorted list.'''
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):
        '''Remove `value` from sorted list if it is a member.'''
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):
        '''Remove `value` from sorted list; `value` must be a member.'''
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):
        '''Remove and return value at `index` in sorted list.'''
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):
        '''Return the first index to insert `value` in the sorted list.'''
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):
        '''Return the last index to insert `value` in the sorted list.'''
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):
        '''Return number of occurrences of `value` in the sorted list.'''
        return self.bisect_right(value) - self.bisect_left(value)

    def _fen_build(self):
        '''Build a fenwick tree instance.'''
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):
        '''Update `fen_tree[index] += value`.'''
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):
        '''Return `sum(_fen_tree[:end])`.'''
        if self._rebuild: self._fen_build()
        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):
        '''Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).'''
        _list_lens = self._list_lens
        if k < _list_lens[0]: return 0, k
        if k >= self._len - _list_lens[-1]: return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild: self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):
        '''Delete value at the given `(pos, idx)`.'''
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):
        '''Return an index pair that corresponds to the first position of `value` in the sorted list.'''
        if not self._len: return 0, 0
        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]: pos = mi
            else: lo = mi

        if pos and value <= _lists[pos - 1][-1]: pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]: idx = mi
            else: lo = mi

        return pos, idx

    def _loc_right(self, value):
        '''Return an index pair that corresponds to the last position of `value` in the sorted list.'''
        if not self._len: return 0, 0
        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]: hi = mi
            else: pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]: idx = mi
            else: lo = mi

        return pos, idx

    def __len__(self):
        '''Return the size of the sorted list.'''
        return self._len

    def __getitem__(self, index):
        '''Lookup value at `index` in sorted list.'''
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):
        '''Remove value at `index` from sorted list.'''
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):
        '''Return true if `value` is an element of the sorted list.'''
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):
        '''Return an iterator over the sorted list.'''
        return (value for _list in self._lists for value in _list)

    def __reversed__(self):
        '''Return a reverse iterator over the sorted list.'''
        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):
        '''Return string representation of sorted list.'''
        return 'SortedList({0})'.format(list(self))
 
    def val(self, it):  # added
        '''Return the value of the `it` in the sorted list.'''
        pos, idx = it
        return self._lists[pos][idx]
 
    def erase(self, it):  # added
        '''Remove `it` from sorted list; `it` must be a member.'''
        pos, idx = it
        self._delete(pos, idx)
 
    def begin(self):  # added
        '''Return the begin of the it in the sorted list.'''
        return (0, 0)
 
    def end(self):  # added
        '''Return the end of the it in the sorted list.'''
        return (len(self._lists)-1, len(self._lists[-1])) if self._lists else (0, 0)
 
    def prev(self, it):  # added
        '''Return the previous `it` in the sorted list.'''
        pos, idx = it
        return (pos, idx-1) if idx else (pos-1, len(self._lists[pos-1])-1)
 
    def next(self, it):  # added
        '''Return the next `it` in the sorted list.'''
        pos, idx = it
        return (pos, idx+1) if pos+1 == len(self._lists) or idx+1 != len(self._lists[pos]) else (pos+1, 0)


class FenwickTreeSum:
    def __init__(self, N):
        '''transform list into BIT'''
        self.tree = [0] * N

    def query(self, end):
        '''calc sum(bit[:end])'''
        x = 0
        while end:
            x += self.tree[end - 1]
            end &= end - 1  # 110 -> 100
        return x

    def update(self, idx, x):
        '''updates bit[idx] += x'''
        while idx < len(self.tree):
            self.tree[idx] += x
            idx |= idx + 1   # 101 -> 110


# maintain 
# * intervals of single color (initially 1 interval of color 1)
# * add[c] = pending update to all intervals with color c

# https://codeforces.com/contest/1638/submission/146415172

def solve():
    N, Q = list(map(int, input().split()))

    # intervals of single color
    starts = SortedList([0])  # start idx of current intervals
    colors = [1] + [0] * N
    def split(x): # split interval (s, e) containing x into (s, x-1), (x, e)
        it = starts.prev(starts._loc_right(x))
        s = starts.val(it)
        if s == x: return 
        starts.add(x)
        colors[x] = colors[s]

    # color -> add
    add = [0] * (N+1)

    # fen.query(i) = adj to A[i] from changing colors
    fen = FenwickTreeSum(N+1)
    def add_range(s, e, v):  # add v to A[s]..A[e]
        fen.update(s, v)
        fen.update(e+1, -v)

    res = []
    for _ in range(Q):
        ts = input().decode().strip().split()
        if ts[0] == 'Color':
            l, r, c = int(ts[1]) - 1, int(ts[2]), int(ts[3])
            
            # split intervals containing endpoints
            split(l)
            split(r)

            # erase all starts inside l..r
            it = starts.prev(starts._loc_right(l))
            remove = []
            while starts.val(it) != r:
                s = starts.val(it)
                nit = starts.next(it)
                add_range(s, starts.val(nit)-1, add[colors[s]] - add[c])
                it = nit
                # starts.erase(it)
                remove.append(s)
            for s in remove: starts.remove(s)

            # add back left endpoint
            colors[l] = c
            starts.add(l)

        elif ts[0] == 'Add':
            c, x = int(ts[1]), int(ts[2])
            add[c] += x
        elif ts[0] == 'Query':
            x = int(ts[1]) - 1
            i = starts.bisect_right(x) - 1
            v = fen.query(x+1) + add[colors[starts[i]]]
            res.append(v)

    print('\n'.join(map(str, res)))


if __name__ == '__main__':
    solve()","['brute force', 'data structures', 'implementation']"
"You are given a string $$$s$$$ consisting of the characters '0', '1', and '?'. You need to replace all the characters with '?' in the string $$$s$$$ by '0' or '1' so that the string becomes a palindrome and has exactly $$$a$$$ characters '0' and exactly $$$b$$$ characters '1'. Note that each of the characters '?' is replaced independently from the others.A string $$$t$$$ of length $$$n$$$ is called a palindrome if the equality $$$t[i] = t[n-i+1]$$$ is true for all $$$i$$$ ($$$1 \le i \le n$$$).For example, if $$$s=$$$""01?????0"", $$$a=4$$$ and $$$b=4$$$, then you can replace the characters '?' in the following ways:   ""01011010"";  ""01100110"". For the given string $$$s$$$ and the numbers $$$a$$$ and $$$b$$$, replace all the characters with '?' in the string $$$s$$$ by '0' or '1' so that the string becomes a palindrome and has exactly $$$a$$$ characters '0' and exactly $$$b$$$ characters '1'.","for _ in range(int(input())):
    a,b=[int(x) for x in input().split()]
    s=[x for x in input()]
    needa=a-s.count('0')
    needb=b-s.count('1')
    n=(a+b)
    done=True
    direct=False
    a=a-s.count('0')
    b=b-s.count('1')

    for i in range(n):
        if s[i]!='?':
            if s[n-1-i]=='?':
                s[n-1-i]=s[i]
                if s[i]=='0':
                    a-=1

                if s[i]=='1':
                    b-=1

            elif s[i]!=s[n-1-i]:
                direct=True
                print(-1)
                break

    if direct:
        continue

    if n%2!=0:
        if s[n//2]=='?':
            if a%2!=0:
                s[n//2]='0'
                a-=1

            elif b%2!=0:
                s[n//2]='1'
                b-=1

            else:
                print(-1)
                continue


    for i in range(n):
        if s[i]=='?':
            if a>1:
                s[i]='0'
                s[n-1-i]='0'
                a-=2

            elif b>1:
                s[i]='1'
                s[n-1-i]='1'
                b-=2


    if s != s[::-1]:
        print(-1)
        continue

    if a!=0 or b!=0:
        print(-1)
        continue

    else:
        for i in s:
            print(i,end="""")
        print()","['constructive algorithms', 'implementation', 'strings']"
"Let us denote by $$$d(n)$$$ the sum of all divisors of the number $$$n$$$, i.e. $$$d(n) = \sum\limits_{k | n} k$$$.For example, $$$d(1) = 1$$$, $$$d(4) = 1+2+4=7$$$, $$$d(6) = 1+2+3+6=12$$$.For a given number $$$c$$$, find the minimum $$$n$$$ such that $$$d(n) = c$$$.","import sys
input = sys.stdin.readline
n=10**7
l=[0]+[1]*n
for i in range(2,n+1):
    j=i
    while(j<=n):
        l[j]+=i
        j+=i
l1=[-1]*(n+1)
for i in range(n,0,-1):
    if(l[i]<=n):
        l1[l[i]]=i
for w in range(int(input())):
    print(l1[int(input())])","['brute force', 'dp', 'math', 'number theory']"
"You were dreaming that you are traveling to a planet named Planetforces on your personal spaceship. Unfortunately, its piloting system was corrupted and now you need to fix it in order to reach Planetforces.  Space can be represented as the $$$XY$$$ plane. You are starting at point $$$(0, 0)$$$, and Planetforces is located in point $$$(p_x, p_y)$$$.The piloting system of your spaceship follows its list of orders which can be represented as a string $$$s$$$. The system reads $$$s$$$ from left to right. Suppose you are at point $$$(x, y)$$$ and current order is $$$s_i$$$:   if $$$s_i = \text{U}$$$, you move to $$$(x, y + 1)$$$;  if $$$s_i = \text{D}$$$, you move to $$$(x, y - 1)$$$;  if $$$s_i = \text{R}$$$, you move to $$$(x + 1, y)$$$;  if $$$s_i = \text{L}$$$, you move to $$$(x - 1, y)$$$. Since string $$$s$$$ could be corrupted, there is a possibility that you won't reach Planetforces in the end. Fortunately, you can delete some orders from $$$s$$$ but you can't change their positions.Can you delete several orders (possibly, zero) from $$$s$$$ in such a way, that you'll reach Planetforces after the system processes all orders?","t = int(input())

for i in range(1,t+1):
    x,y = input().split()
    x, y = int(x), int(y)
    s = input()
    d = """"
    if x > 0:
        d += x * ""R""
    if x < 0:
        d += abs(x) * ""L""
    if y > 0:
        d += y * ""U""
    if y < 0:
        d += abs(y) * ""D""
    for i in range(0,len(d)):
        if (d[i] in s) == False:
            print(""NO"")
            break
        else:
            s = s[0:s.index(d[i])] + s[s.index(d[i]) + 1:len(s)]
        if len(d) - 1 == i:
            print(""YES"")","['greedy', 'strings']"
"You are given a string $$$s$$$, consisting only of Latin letters 'a', and a string $$$t$$$, consisting of lowercase Latin letters.In one move, you can replace any letter 'a' in the string $$$s$$$ with a string $$$t$$$. Note that after the replacement string $$$s$$$ might contain letters other than 'a'.You can perform an arbitrary number of moves (including zero). How many different strings can you obtain? Print the number, or report that it is infinitely large.Two strings are considered different if they have different length, or they differ at some index.","'''
# Submitted By Ala3rjMo7@gmail.com
Don't Copy This Code, Try To Solve It By Yourself
'''
# Problem Name = ""Infinite Replacement""
# Class: C
 
def Solve():
    ss, rs = [], []
    for t in range(int(input())):
        ss.append(input())
        rs.append(input())
    for s, r in zip(ss, rs):
        if ""a"" in s:
            if r==""a"":
                print(1)
            elif ""a"" in r:
                print(-1)
            else:
                print(2**len(s))
        else:
            print(0)
 
 
if __name__ == ""__main__"":
    Solve()","['combinatorics', 'implementation', 'strings']"
"You are given three arrays $$$a$$$, $$$b$$$ and $$$c$$$. Initially, array $$$a$$$ consists of $$$n$$$ elements, arrays $$$b$$$ and $$$c$$$ are empty.You are performing the following algorithm that consists of two steps:   Step $$$1$$$: while $$$a$$$ is not empty, you take the last element from $$$a$$$ and move it in the middle of array $$$b$$$. If $$$b$$$ currently has odd length, you can choose: place the element from $$$a$$$ to the left or to the right of the middle element of $$$b$$$. As a result, $$$a$$$ becomes empty and $$$b$$$ consists of $$$n$$$ elements.  Step $$$2$$$: while $$$b$$$ is not empty, you take the middle element from $$$b$$$ and move it to the end of array $$$c$$$. If $$$b$$$ currently has even length, you can choose which of two middle elements to take. As a result, $$$b$$$ becomes empty and $$$c$$$ now consists of $$$n$$$ elements.  Refer to the Note section for examples.Can you make array $$$c$$$ sorted in non-decreasing order?","import sys
input = sys.stdin.readline
rounds=int(input())
for ii in range(rounds):
  length=int(input())
  arr=list(map(int,input().split()))
  arr2=sorted(arr)
  out='YES'
  if length%2==1:
    if (arr[0])!=arr2[0]:
      out='NO'
    else:
      for u in range(length):
        if arr[u]!=arr2[u]:
          if u%2==1:
            if arr[u+1]!=arr2[u] or arr[u+1]==arr2[u+1]:
              out='NO'
              break
          else:
            if arr[u-1]!=arr2[u] or arr[u-1]==arr2[u-1]:
              out='NO'
              break
  else:
    for t in range(length):
      if arr[t]!=arr2[t]:
        if t%2==1:
          if arr[t-1]!=arr2[t] or arr[t-1]==arr2[t-1]:
            out='NO'
            break
        else:
          if arr[t+1]!=arr2[t] or arr[t+1]==arr2[t+1]:
            out='NO'
            break
  print(out)","['constructive algorithms', 'implementation', 'sortings']"
"Your friend Ivan asked you to help him rearrange his desktop. The desktop can be represented as a rectangle matrix of size $$$n \times m$$$ consisting of characters '.' (empty cell of the desktop) and '*' (an icon).The desktop is called good if all its icons are occupying some prefix of full columns and, possibly, the prefix of the next column (and there are no icons outside this figure). In other words, some amount of first columns will be filled with icons and, possibly, some amount of first cells of the next (after the last full column) column will be also filled with icons (and all the icons on the desktop belong to this figure). This is pretty much the same as the real life icons arrangement.In one move, you can take one icon and move it to any empty cell in the desktop.Ivan loves to add some icons to his desktop and remove them from it, so he is asking you to answer $$$q$$$ queries: what is the minimum number of moves required to make the desktop good after adding/removing one icon?Note that queries are permanent and change the state of the desktop.","from sys import stdin,stdout
raw_input = lambda: stdin.readline().rstrip()
input = lambda: int(raw_input())
I=lambda: map(int, raw_input().split())

def f(i,j):
	return (j-1)*n + i-1
	
def fn(c):
	return c%n + 1, c//n + 1

n,m,q = I()
mat = []
c = 0
for _ in xrange(n):
	s = raw_input()
	c += s.count('*')
	mat.append(list(s))

# pI = c//n + 1
# pJ = c%n + 1
r = 0
for i in xrange(n):
	for j in xrange(m):
		if mat[i][j]=='*':
			if f(i+1,j+1)>=c:
				r += 1

for _ in xrange(q):
	x,y = I()
	if mat[x-1][y-1]=='*':
		c -= 1
		c1 = f(x,y)
		if c1>=c:
			r -= 1
		i,j = fn(c)
		if mat[i-1][j-1]=='*':
			r += 1
		mat[x-1][y-1] = '.'
	else:
		c += 1
		c1 = f(x,y)
		if c1>=c:
			r += 1
		i,j = fn(c-1)
		if mat[i-1][j-1]=='*':
			r -= 1
		mat[x-1][y-1] = '*'
	# print c1, c
	stdout.write(str(r)+'\n')","['data structures', 'greedy', 'implementation']"
"There are $$$n$$$ cats in a line, labeled from $$$1$$$ to $$$n$$$, with the $$$i$$$-th cat at position $$$i$$$. They are bored of gyrating in the same spot all day, so they want to reorder themselves such that no cat is in the same place as before. They are also lazy, so they want to minimize the total distance they move. Help them decide what cat should be at each location after the reordering.For example, if there are $$$3$$$ cats, this is a valid reordering: $$$[3, 1, 2]$$$. No cat is in its original position. The total distance the cats move is $$$1 + 1 + 2 = 4$$$ as cat $$$1$$$ moves one place to the right, cat $$$2$$$ moves one place to the right, and cat $$$3$$$ moves two places to the left.","for i in range(int(input())):
    n=int(input())
    lst=[]
    if n%2==0:
        for i in range(1,n+1,+2):
            lst.append(i+1)
            lst.append(i)
    else:
        lst.append(3)
        lst.append(1)
        lst.append(2)
        for i in range(3,n,+2):
            lst.append(i+2)
            lst.append(i+1)
    for ele in lst:
        print(ele, end="" "")
    print()","['constructive algorithms', 'greedy', 'implementation']"
"People worry that computers will get too smart and take over the world, but the real problem is that they're too stupid and they've already taken over the world.— Pedro DomingosYou work for a well-known department store that uses leading technologies and employs mechanistic work — that is, robots!The department you work in sells $$$n \cdot k$$$ items. The first item costs $$$1$$$ dollar, the second item costs $$$2$$$ dollars, and so on: $$$i$$$-th item costs $$$i$$$ dollars. The items are situated on shelves. The items form a rectangular grid: there are $$$n$$$ shelves in total, and each shelf contains exactly $$$k$$$ items. We will denote by $$$a_{i,j}$$$ the price of $$$j$$$-th item (counting from the left) on the $$$i$$$-th shelf, $$$1 \le i \le n, 1 \le j \le k$$$.Occasionally robots get curious and ponder on the following question: what is the mean price (arithmetic average) of items $$$a_{i,l}, a_{i,l+1}, \ldots, a_{i,r}$$$ for some shelf $$$i$$$ and indices $$$l \le r$$$? Unfortunately, the old robots can only work with whole numbers. If the mean price turns out not to be an integer, they break down.You care about robots' welfare. You want to arrange the items in such a way that the robots cannot theoretically break. Formally, you want to choose such a two-dimensional array $$$a$$$ that:  Every number from $$$1$$$ to $$$n \cdot k$$$ (inclusively) occurs exactly once.  For each $$$i, l, r$$$, the mean price of items from $$$l$$$ to $$$r$$$ on $$$i$$$-th shelf is an integer. Find out if such an arrangement is possible, and if it is, give any example of such arrangement.","t = int(input())
for x in range(t):
    n,k = map(int, input().split("" "")) 
    if(k== 1):
        print(""YES"")
        for y in range(n):
            print(y+1)

    elif(n*k % 2 ==0 and n % 2 == 0):
        
        print(""YES"")
        arr = [[0 for i in range(k)] for j in range(n)]
        
        cou = 1
        for q in range(k): 
            for z in range(n):
                arr[z][q] = str(cou) 
                cou+=1
            
            

        
        for b in range(n):
            print("" "".join(arr[b]))


    else: 
        print(""NO"")",['constructive algorithms']
"There is a sheet of paper that can be represented with a grid of size $$$n \times m$$$: $$$n$$$ rows and $$$m$$$ columns of cells. All cells are colored in white initially.$$$q$$$ operations have been applied to the sheet. The $$$i$$$-th of them can be described as follows:   $$$x_i$$$ $$$y_i$$$ — choose one of $$$k$$$ non-white colors and color the entire row $$$x_i$$$ and the entire column $$$y_i$$$ in it. The new color is applied to each cell, regardless of whether the cell was colored before the operation. The sheet after applying all $$$q$$$ operations is called a coloring. Two colorings are different if there exists at least one cell that is colored in different colors.How many different colorings are there? Print the number modulo $$$998\,244\,353$$$.","columns = []
rows = []
for _ in range(int(input())):
    n, m, k, q = map(int, input().split())

    columns += [False] * max(0, n - len(columns))
    rows += [False] * max(0, m - len(rows))

    ls = [None] * q

    for i in range(q):
        x, y = map(int, input().split())
        ls[i] = (x - 1, y - 1)

    cf = 0
    rf = 0

    r = 1

    for x, y in ls[::-1]:
        fl = False
        if not columns[x]:
            columns[x] = True
            cf += 1
            fl = True
        if not rows[y]:
            rows[y] = True
            rf += 1
            fl = True
        if fl:
            r = r * k % 998244353
        if cf == n or rf == m:
            break

    for x, y in ls:
        columns[x] = False
        rows[y] = False

    print(r)","['data structures', 'implementation', 'math']"
"Given an array a1, a2, ..., an of n integers, find the largest number in the array that is not a perfect square.A number x is said to be a perfect square if there exists an integer y such that x = y2.","import math


def is_sqrt(y):
    if y < 0:
        return False
    elif y == 0:
        return True
    x = int(math.sqrt(y))
    return x * x == y


m = -1000001
n = int(input())
ints = list(map(int, input().split()))
for z in ints:
    if not is_sqrt(z) and z > m:
        m = z

print(m)","['implementation', 'brute force', 'math']"
"This is an interactive problem.There are $$$n$$$ words in a text editor. The $$$i$$$-th word has length $$$l_i$$$ ($$$1 \leq l_i \leq 2000$$$). The array $$$l$$$ is hidden and only known by the grader. The text editor displays words in lines, splitting each two words in a line with at least one space. Note that a line does not have to end with a space. Let the height of the text editor refer to the number of lines used. For the given width, the text editor will display words in such a way that the height is minimized.More formally, suppose that the text editor has width $$$w$$$. Let $$$a$$$ be an array of length $$$k+1$$$ where $$$1=a_1 &lt; a_2 &lt; \ldots &lt; a_{k+1}=n+1$$$. $$$a$$$ is a valid array if for all $$$1 \leq i \leq k$$$, $$$l_{a_i}+1+l_{a_i+1}+1+\ldots+1+l_{a_{i+1}-1} \leq w$$$. Then the height of the text editor is the minimum $$$k$$$ over all valid arrays.Note that if $$$w &lt; \max(l_i)$$$, the text editor cannot display all the words properly and will crash, and the height of the text editor will be $$$0$$$ instead.You can ask $$$n+30$$$ queries. In one query, you provide a width $$$w$$$. Then, the grader will return the height $$$h_w$$$ of the text editor when its width is $$$w$$$.Find the minimum area of the text editor, which is the minimum value of $$$w \cdot h_w$$$ over all $$$w$$$ for which $$$h_w \neq 0$$$.The lengths are fixed in advance. In other words, the interactor is not adaptive.","import sys
input = sys.stdin.readline

n = int(input())
left, right = 1, 10000000
while left < right:
    mid = (left + right) // 2
    print('?', mid); sys.stdout.flush()
    val = int(input())
    if val == 1:
        right = mid
    else:
        left = mid + 1
k = left
ans = k
for i in range(2, n+1):
    print('?', k // i); sys.stdout.flush()
    val = int(input())
    if val != 0: ans = min(ans, val * (k // i))
    else: break
print('!', ans)","['binary search', 'constructive algorithms', 'greedy', 'interactive']"
"You are given $$$n$$$ dominoes. Each domino has a left and a right cell. Each cell can be colored either black or white. Some cells are already colored, while some aren't yet.The coloring is said to be valid if and only if it is possible to rearrange the dominoes in some order such that for each $$$1 \le i \le n$$$ the color of the right cell of the $$$i$$$-th domino is different from the color of the left cell of the $$$((i \bmod n)+1)$$$-st domino. Note that you can't rotate the dominoes, so the left cell always remains the left cell, and the right cell always remains the right cell.Count the number of valid ways to color the yet uncolored cells of dominoes. Two ways are considered different if there is a cell that is colored white in one way and black in the other. In particular, colorings BW WB and WB BW different (and both invalid).As this number can be very big, output it modulo $$$998\,244\,353$$$.","MOD = 998244353


facts = [1]
for i in range(1, 100001):
    facts.append(facts[-1] * i % MOD)


def qpow(x, y):
    ret = 1
    b = x
    while y > 0:
        if y & 1:
            ret = ret * b % MOD
        b = b * b % MOD
        y >>= 1
    return ret


def inv(x):
    return qpow(x, MOD - 2)


def CC(n, m):
    return facts[n] * inv(facts[m]) % MOD * inv(facts[n - m]) % MOD


n = int(input())
rec = {}
WL, WR, BL, BR = 0, 0, 0, 0
for i in range(n):
    d = input().strip()
    if d[0] == 'W':
        WL += 1
    if d[0] == 'B':
        BL += 1
    if d[1] == 'W':
        WR += 1
    if d[1] == 'B':
        BR += 1
    rec[d] = rec.get(d, 0) + 1
QL = n - BL - WL
QR = n - BR - WR
ans = 0
for i in range(BL, n - WL + 1):
    j = n - i
    if BR + QR < j or BR > j:
        continue
    else:
        cnt = CC(QL, i - BL) % MOD * CC(QR, j - BR) % MOD
        ans = (ans + cnt) % MOD
if rec.get('BB', 0) == 0 and rec.get('WW', 0) == 0:
    ans += (MOD - qpow(2, rec.get('??', 0))) % MOD
if BL == 0 and WR == 0 or WL == 0 and BR == 0:
    if BL > 0 or BR > 0 or WL > 0 or WR > 0:
        ans += 1
    else:
        ans += 2
print(ans % MOD)","['combinatorics', 'fft', 'graphs', 'math', 'number theory']"
"Consider a hallway, which can be represented as the matrix with $$$2$$$ rows and $$$n$$$ columns. Let's denote the cell on the intersection of the $$$i$$$-th row and the $$$j$$$-th column as $$$(i, j)$$$. The distance between the cells $$$(i_1, j_1)$$$ and $$$(i_2, j_2)$$$ is $$$|i_1 - i_2| + |j_1 - j_2|$$$.There is a cleaning robot in the cell $$$(1, 1)$$$. Some cells of the hallway are clean, other cells are dirty (the cell with the robot is clean). You want to clean the hallway, so you are going to launch the robot to do this.After the robot is launched, it works as follows. While at least one cell is dirty, the robot chooses the closest (to its current cell) cell among those which are dirty, moves there and cleans it (so the cell is no longer dirty). After cleaning a cell, the robot again finds the closest dirty cell to its current cell, and so on. This process repeats until the whole hallway is clean.However, there is a critical bug in the robot's program. If at some moment, there are multiple closest (to the robot's current position) dirty cells, the robot malfunctions.You want to clean the hallway in such a way that the robot doesn't malfunction. Before launching the robot, you can clean some (possibly zero) of the dirty cells yourself. However, you don't want to do too much dirty work yourself while you have this nice, smart (yet buggy) robot to do this. Note that you cannot make a clean cell dirty.Calculate the maximum possible number of cells you can leave dirty before launching the robot, so that it doesn't malfunction.","import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    N = int(input())
    G = [[int(x) for x in input()] + [0] for _ in range(2)]
    
    dp = [[0] * 2  for _ in range(N + 1)]   # number of 1 cells robot will clean when it arrives at cell (j, i) from the left
    for j in range(2):
        dp[N - 1][j] = G[1 - j][N - 1]
    
    for i in range(N - 2, - 1, -1):
        for j in range(2):
            dp[i][j] = G[j][i + 1] + dp[i + 1][j]   # base case: ignore row 1 - j and proceed right
            if G[1 - j][i]:
                dp[i][j] = max(dp[i][j], 1 + G[1 - j][i + 1] + G[1 - j][i + 2] + dp[i + 2][1 - j])

    print(dp[0][0])
    return

solve()","['bitmasks', 'dp']"
"You have $$$n$$$ students under your control and you have to compose exactly two teams consisting of some subset of your students. Each student had his own skill, the $$$i$$$-th student skill is denoted by an integer $$$a_i$$$ (different students can have the same skills).So, about the teams. Firstly, these two teams should have the same size. Two more constraints:  The first team should consist of students with distinct skills (i.e. all skills in the first team are unique).  The second team should consist of students with the same skills (i.e. all skills in the second team are equal). Note that it is permissible that some student of the first team has the same skill as a student of the second team.Consider some examples (skills are given):  $$$[1, 2, 3]$$$, $$$[4, 4]$$$ is not a good pair of teams because sizes should be the same;  $$$[1, 1, 2]$$$, $$$[3, 3, 3]$$$ is not a good pair of teams because the first team should not contain students with the same skills;  $$$[1, 2, 3]$$$, $$$[3, 4, 4]$$$ is not a good pair of teams because the second team should contain students with the same skills;  $$$[1, 2, 3]$$$, $$$[3, 3, 3]$$$ is a good pair of teams;  $$$[5]$$$, $$$[6]$$$ is a good pair of teams. Your task is to find the maximum possible size $$$x$$$ for which it is possible to compose a valid pair of teams, where each team size is $$$x$$$ (skills in the first team needed to be unique, skills in the second team should be the same between them). A student cannot be part of more than one team.You have to answer $$$t$$$ independent test cases.","z,zz=input,lambda:list(map(int,z().split()))
zzz=lambda:[int(i) for i in stdin.readline().split()]
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from string import *
from collections import *
from queue import *
from sys import *
from collections import *
from math import *
from heapq import *
from itertools import *
from bisect import *
from collections import Counter as cc
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
        
    return 1
def dfs(u,visit,graph):
    visit[u]=True
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)

###########################---Test-Case---#################################
""""""



""""""
###########################---START-CODING---##############################


     
num=int(z())
 
for _ in range( num ):
    n=int(z())

    ll=dict(cc(zzz()))
    l=sorted(list(ll.values()))
   
    ans=len(l)-1
   

    if l[-1]>ans:
        if l[-1]>=ans+2:
            ans+=1
    else:
        ans=l[-1]
        

    print(ans)","['sortings', 'binary search', 'implementation', 'greedy']"
"You are given a tree of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$, with edges numbered from $$$1$$$ to $$$n-1$$$. A tree is a connected undirected graph without cycles. You have to assign integer weights to each edge of the tree, such that the resultant graph is a prime tree.A prime tree is a tree where the weight of every path consisting of one or two edges is prime. A path should not visit any vertex twice. The weight of a path is the sum of edge weights on that path.Consider the graph below. It is a prime tree as the weight of every path of two or less edges is prime. For example, the following path of two edges: $$$2 \to 1 \to 3$$$ has a weight of $$$11 + 2 = 13$$$, which is prime. Similarly, the path of one edge: $$$4 \to 3$$$ has a weight of $$$5$$$, which is also prime.  Print any valid assignment of weights such that the resultant tree is a prime tree. If there is no such assignment, then print $$$-1$$$. It can be proven that if a valid assignment exists, one exists with weights between $$$1$$$ and $$$10^5$$$ as well.","from collections import defaultdict
 
class Graph:
    def __init__(self):
        self.graph = defaultdict(list)
        
    def addEdge(self,u,v):
        self.graph[u].append(v)
        self.graph[v].append(u)
        

    # 2.DFS from a vertex 
    def DFS(self,vertex):
        path=[]
        stack=[vertex]
        visited=defaultdict(lambda:0)
        while len(stack):
            u=stack.pop(-1)
            if visited[u]==0:
                path.append(u)
                visited[u]=1
            for neighbour in self.graph[u]:
                if visited[neighbour]==0:
                    stack.append(neighbour)
        return path
                


    
t=int(input())
for _ in range(t):
    n=int(input())
    g=Graph()
    
    edges=[]
    for i in range(n-1):
        u,v=list(map(int,input().split()))
        g.addEdge(u,v)
        if u>v:
            edges.append((v,u))
        else:
            edges.append((u,v))
    data=g.graph
    for vertex in data:
        if len(data[vertex])>=3:
            print(-1)
            break
    else:
        path=g.DFS(1)
        path=g.DFS(path[-1])

        res=defaultdict(lambda:0)
        for i in range(n-1):
            if i%2==0:
                if path[i]<path[i+1]:
                    res[(path[i],path[i+1])]=2
                else:
                    res[(path[i+1],path[i])]=2
            else:
                if path[i]<path[i+1]:
                    res[(path[i],path[i+1])]=3
                else:
                    res[(path[i+1],path[i])]=3
        for num in edges:
            print(res[num],end="" "")
        print()","['constructive algorithms', 'dfs and similar', 'number theory', 'trees']"
"You are given three integers $$$a$$$, $$$b$$$, $$$k$$$.Find two binary integers $$$x$$$ and $$$y$$$ ($$$x \ge y$$$) such that   both $$$x$$$ and $$$y$$$ consist of $$$a$$$ zeroes and $$$b$$$ ones;  $$$x - y$$$ (also written in binary form) has exactly $$$k$$$ ones.  You are not allowed to use leading zeros for $$$x$$$ and $$$y$$$.","try:
        import sys
        from functools import lru_cache, cmp_to_key
        from heapq import merge, heapify, heappop, heappush
        from math import *
        from collections import defaultdict as dd, deque, Counter as Cntr
        from itertools import combinations as comb, permutations as perm
        from bisect import bisect_left as bl, bisect_right as br, bisect, insort
        from time import perf_counter
        from fractions import Fraction
        import copy
        from copy import deepcopy
        import time
        starttime = time.time()
        mod = int(pow(10, 9) + 7)
        mod2 = 998244353

        def data(): return sys.stdin.readline().strip()
        def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
        def L(): return list(sp())
        def sl(): return list(ssp())
        def sp(): return map(int, data().split())
        def ssp(): return map(str, data().split())
        def l1d(n, val=0): return [val for i in range(n)]
        def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
        def A2(n,m): return [[0]*m for i in range(n)]
        def A(n):return [0]*n
        # sys.setrecursionlimit(int(pow(10,6)))
        # from sys import stdin
        # input = stdin.buffer.readline
        # I = lambda : list(map(int,input().split()))
        # import sys
        # input=sys.stdin.readline
        

        sys.stdin = open(""input.txt"", ""r"")
        sys.stdout = open(""output.txt"", ""w"")
except:
        pass


a,b,k = L()
if b==1 or a==0:
        if k==0:
                print(""Yes"")
                print(""1""*b+""0""*a)
                print(""1""*b+""0""*a)
        else:
                print(""No"")
        exit()
if k>a+b-2:
        print(""No"")
        exit()


print(""Yes"")
A = [1]*b+[0]*a
B = [1]*b+[0]*a
K = [0]*(a+b)
cnt = k
i=b-1
last = a+b-1
while(cnt and i):
        final = min(i+cnt,last)
        B[i]=0
        B[final]=1
        cnt -= final-i
        last=i
        i-=1
print(*A,sep="""")
print(*B,sep="""")","['bitmasks', 'constructive algorithms', 'greedy', 'math']"
"You and your friends live in $$$n$$$ houses. Each house is located on a 2D plane, in a point with integer coordinates. There might be different houses located in the same point. The mayor of the city is asking you for places for the building of the Eastern exhibition. You have to find the number of places (points with integer coordinates), so that the summary distance from all the houses to the exhibition is minimal. The exhibition can be built in the same point as some house. The distance between two points $$$(x_1, y_1)$$$ and $$$(x_2, y_2)$$$ is $$$|x_1 - x_2| + |y_1 - y_2|$$$, where $$$|x|$$$ is the absolute value of $$$x$$$.","import os
DEBUG = 'DEBUG' in os.environ

def debug(*args):
  if DEBUG:
    print("">"", *args)

def solution(houses):
  if len(houses) == 1:
    return 1

  housesX = []
  housesY = []

  for house in houses:
    housesX.append(house[0])
    housesY.append(house[1])

  housesX.sort()
  housesY.sort()

  leftX = -1
  rightX = -1
  topY = -1
  bottomY = -1

  # if even
  # 0 1 2 3
  if len(houses) % 2 == 0:
    leftX = housesX[len(houses) // 2 - 1]
    rightX = housesX[len(houses) // 2]
    bottomY = housesY[len(houses) // 2 - 1]
    topY = housesY[len(houses) // 2]
    return (rightX - leftX + 1) * (topY - bottomY + 1)

  # if odd
  # 0 1 2
  if len(houses) % 2 == 1:
    return 1

  debug(leftX, rightX, topY, bottomY)

  return ""NO""

for t in range(int(input())):
  houses = []
  for t2 in range(int(input())):
    houses.append(list(map(int, input().split())))

  print(solution(houses))","['binary search', 'geometry', 'shortest paths', 'sortings']"
"A group of $$$n$$$ friends decide to go to a restaurant. Each of the friends plans to order meals for $$$x_i$$$ burles and has a total of $$$y_i$$$ burles ($$$1 \le i \le n$$$). The friends decide to split their visit to the restaurant into several days. Each day, some group of at least two friends goes to the restaurant. Each of the friends visits the restaurant no more than once (that is, these groups do not intersect). These groups must satisfy the condition that the total budget of each group must be not less than the amount of burles that the friends in the group are going to spend at the restaurant. In other words, the sum of all $$$x_i$$$ values in the group must not exceed the sum of $$$y_i$$$ values in the group.What is the maximum number of days friends can visit the restaurant?For example, let there be $$$n = 6$$$ friends for whom $$$x$$$ = [$$$8, 3, 9, 2, 4, 5$$$] and $$$y$$$ = [$$$5, 3, 1, 4, 5, 10$$$]. Then:   first and sixth friends can go to the restaurant on the first day. They will spend $$$8+5=13$$$ burles at the restaurant, and their total budget is $$$5+10=15$$$ burles. Since $$$15 \ge 13$$$, they can actually form a group.  friends with indices $$$2, 4, 5$$$ can form a second group. They will spend $$$3+2+4=9$$$ burles at the restaurant, and their total budget will be $$$3+4+5=12$$$ burles ($$$12 \ge 9$$$). It can be shown that they will not be able to form more groups so that each group has at least two friends and each group can pay the bill.So, the maximum number of groups the friends can split into is $$$2$$$. Friends will visit the restaurant for a maximum of two days. Note that the $$$3$$$-rd friend will not visit the restaurant at all.Output the maximum number of days the friends can visit the restaurant for given $$$n$$$, $$$x$$$ and $$$y$$$.","for tcases in range(int(input())):
	n = int(input())
	x = list(map(int, input().split()))
	y = list(map(int, input().split()))

	kusur = [y[i] - x[i] for i in range(n)]
	kusur.sort()

	l, r =0, n-1
	ans = 0
	while l < r:
		while l < r and kusur[l] + kusur[r] < 0: l += 1
		if l < r:
			ans += 1
		l += 1
		r -= 1

	print(ans)","['greedy', 'sortings', 'two pointers']"
"You are given two non-empty strings $$$s$$$ and $$$t$$$, consisting of Latin letters.In one move, you can choose an occurrence of the string $$$t$$$ in the string $$$s$$$ and replace it with dots.Your task is to remove all occurrences of the string $$$t$$$ in the string $$$s$$$ in the minimum number of moves, and also calculate how many different sequences of moves of the minimum length exist.Two sequences of moves are considered different if the sets of indices at which the removed occurrences of the string $$$t$$$ in $$$s$$$ begin differ. For example, the sets $$$\{1, 2, 3\}$$$ and $$$\{1, 2, 4\}$$$ are considered different, the sets $$$\{2, 4, 6\}$$$ and $$$\{2, 6\}$$$ — too, but sets $$$\{3, 5\}$$$ and $$$\{5, 3\}$$$ — not.For example, let the string $$$s =$$$ ""abababacababa"" and the string $$$t =$$$ ""aba"". We can remove all occurrences of the string $$$t$$$ in $$$2$$$ moves by cutting out the occurrences of the string $$$t$$$ at the $$$3$$$th and $$$9$$$th positions. In this case, the string $$$s$$$ is an example of the form ""ab...bac...ba"". It is also possible to cut occurrences of the string $$$t$$$ at the $$$3$$$th and $$$11$$$th positions. There are two different sequences of minimum length moves.Since the answer can be large, output it modulo $$$10^9 + 7$$$.","from typing import List, Dict, Set, Sequence, Tuple, Deque, AnyStr, Optional
# from sortedcontainers import SortedDict, SortedSet, SortedList
from collections import deque, Counter, OrderedDict
import bisect

case_num = int(input())
for case_index in range(case_num):
    s = input()
    t = input()
    t_indexes = []  # 记录t在s中出现的起点索引的位置
    for i in range(len(s)):
        if s[i:i + len(t)] == t:
            t_indexes.append(i)
    if len(t_indexes) == 0:
        print('0 1')
        continue
    if len(t) == 1:
        print(f'{len(t_indexes)} 1')
        continue
    dp1 = [0 for i in range(len(t_indexes) + 1)]  # dp[i]表示从t_indexes[i]开始（包括）且t_indexes[i]处的t被删去时的最少操作次数
    min1 = 1000000  # 总体的最少操作次数
    for i in range(len(t_indexes) - 1, -1, -1):
        j = bisect.bisect_left(t_indexes, t_indexes[i] + len(t))  # 因为t_indexes[i]要被删去，那么，接下来可能要被删去的就是t_indexes[j]处开始的t
        dp1[i] = 100000000
        if j >= len(t_indexes):
            dp1[i] = 1
        else:
            l = bisect.bisect_left(t_indexes, t_indexes[j] + len(t))  # 从t_indexes[j]开始到t_indexes[l]（不包括）为止，必须有一个t被删去
            for k in range(j, l):  # 遍历j，l间被删去的t，选择其中最小的，就是i开始且删除i时的最少操作次数
                dp1[i] = min(dp1[i], 1 + dp1[k])
        if t_indexes[i] - t_indexes[0] < len(
                t):  # 当当前s中的索引t_indexes[i]已经和最小的t的索引t_indexes[0]相差小于len(t)时，说明再往前已经没有t可以删了，可以更新min1了
            min1 = min(min1, dp1[i])
    dp2 = [[0 for i in range(len(t_indexes) + 1)] for j in
           range(len(t_indexes) + 1)]  # dp2[i][j]表示从t_indexes[i]开始（包括）且t_indexes[i]处的t被删去且总删除次数为j时的删除方式种数
    dp2[len(t_indexes)][0] = 1
    for i in range(len(t_indexes) - 1, -1, -1):
        j = bisect.bisect_left(t_indexes, t_indexes[i] + len(t))  # 同dp1计算时中j的作用
        if j >= len(t_indexes):
            dp2[i][1] = 1
            continue
        # 只需要计算t_indexes[i]开始的最少删除次数时的操作种数，因为如果从当前索引开始的删除次数不是最少的，且总体删除次数最少时用到了当前这种方式，那么可以选择当前索引开始的最少删除次数，使总体删除次数更少，就矛盾了
        l = bisect.bisect_left(t_indexes, t_indexes[j] + len(t))  # 同dp1计算时的l的作用
        dp2[i][dp1[i]] = sum(dp2[k][dp1[i] - 1] for k in range(j, l)) % 1000000007
    # print(min1)
    # print(t_indexes)
    # print(dp1)
    # print(dp2)
    ans = 0
    for i in range(len(t_indexes)):
        if t_indexes[i] - t_indexes[0] >= len(t):
            break
        ans = (ans + dp2[i][min1]) % 1000000007
    print(f'{min1} {ans}')","['combinatorics', 'dp', 'hashing', 'strings', 'two pointers']"
"Team Red and Team Blue competed in a competitive FPS. Their match was streamed around the world. They played a series of $$$n$$$ matches.In the end, it turned out Team Red won $$$r$$$ times and Team Blue won $$$b$$$ times. Team Blue was less skilled than Team Red, so $$$b$$$ was strictly less than $$$r$$$.You missed the stream since you overslept, but you think that the match must have been neck and neck since so many people watched it. So you imagine a string of length $$$n$$$ where the $$$i$$$-th character denotes who won the $$$i$$$-th match  — it is R if Team Red won or B if Team Blue won. You imagine the string was such that the maximum number of times a team won in a row was as small as possible. For example, in the series of matches RBBRRRB, Team Red won $$$3$$$ times in a row, which is the maximum.You must find a string satisfying the above conditions. If there are multiple answers, print any.","t = int(input())
for _ in range(t):
    n, r, b = [int(c) for c in input().split()]
    if b == 1:
        print('R' * (r // 2) + 'B' + 'R' * (r - r // 2))
        continue
    s = ['R' * (r // (b + 1)) + 'B'] * b + ['R' * (r // (b + 1))]
    left = r % (b + 1)
    for i in range(left):
        s[i] += 'R'
    print(''.join(s))","['constructive algorithms', 'greedy', 'implementation', 'math']"
"You are given four integers $$$n$$$, $$$B$$$, $$$x$$$ and $$$y$$$. You should build a sequence $$$a_0, a_1, a_2, \dots, a_n$$$ where $$$a_0 = 0$$$ and for each $$$i \ge 1$$$ you can choose:   either $$$a_i = a_{i - 1} + x$$$  or $$$a_i = a_{i - 1} - y$$$. Your goal is to build such a sequence $$$a$$$ that $$$a_i \le B$$$ for all $$$i$$$ and $$$\sum\limits_{i=0}^{n}{a_i}$$$ is maximum possible.","def maxAi(N,B,x,y):
    a0=0
    maxi=a0
    sum=a0
    for i in range(N):
        var1=a0+x
        var2=a0-y
        if var1<=B:
            maxi=var1
            if var2<=B and var2>=var1:
                maxi=var2
        else:
            if var2<=B:
                maxi=var2
        
        a1=maxi
        sum+=maxi
        a0=a1
    print(sum)

t=int(input())

for i in range(t):
    n,B,x,y=[int(x) for x in input().split()]
    maxAi(n,B,x,y)",['greedy']
"The city Valera lives in is going to hold elections to the city Parliament.The city has n districts and n - 1 bidirectional roads. We know that from any district there is a path along the roads to any other district. Let's enumerate all districts in some way by integers from 1 to n, inclusive. Furthermore, for each road the residents decided if it is the problem road or not. A problem road is a road that needs to be repaired.There are n candidates running the elections. Let's enumerate all candidates in some way by integers from 1 to n, inclusive. If the candidate number i will be elected in the city Parliament, he will perform exactly one promise — to repair all problem roads on the way from the i-th district to the district 1, where the city Parliament is located.Help Valera and determine the subset of candidates such that if all candidates from the subset will be elected to the city Parliament, all problem roads in the city will be repaired. If there are several such subsets, you should choose the subset consisting of the minimum number of candidates.","import sys
from math import sqrt, gcd, ceil, log
# from bisect import bisect, bisect_left
from collections import defaultdict, Counter, deque
# from heapq import heapify, heappush, heappop
input = sys.stdin.readline
read = lambda: list(map(int, input().strip().split()))

sys.setrecursionlimit(200000)


def main(): 
	n = int(input()); 
	adj = defaultdict(list)
	problem = set()
	for i in range(n-1):
		x, y, t = read()
		adj[x].append(y)
		adj[y].append(x)
		if t == 2:problem.add((x, y))


	parent = defaultdict(int)
	order = []
	def dfs():
		stk = [(1, 0)]
		while stk:
			node, par = stk.pop()
			order.append(node); parent[node] = par
			for child in adj[node]:
				if child != par:
					stk.append((child, node))
		# return(order)
		# lis = []
		# for child in adj[node]:
		# 	if child != par:
		# 		tem = dfs(child, node)
		# 		if (node, child) in problem or (child, node) in problem:
		# 			if tem == []:lis.append(child)
		# 			else:lis.extend(tem)
		# 		elif tem:
		# 			lis.extend(tem)
		# return(lis)
	dfs()
	# print(order)
	# print(parent)
	dic = defaultdict(int)
	ans = []
	for i in range(n-1, -1, -1):
		child = order[i]; par = parent[order[i]]
		if dic[child]:
			dic[par] += dic[child]
		elif (child, par) in problem or (par, child) in problem:
			ans.append(child)
			dic[par] += 1
	print(len(ans))
	print(*ans)



			






if __name__ == ""__main__"":
	main()","['dfs and similar', 'trees', 'graphs']"
"Levko loves tables that consist of n rows and n columns very much. He especially loves beautiful tables. A table is beautiful to Levko if the sum of elements in each row and column of the table equals k.Unfortunately, he doesn't know any such table. Your task is to help him to find at least one of them.","size, k = map(int,input().split())
for r in range(size):
    for c in range(size):
        if r==c:
            print(k,end="" "")
        else:
            print(0,end="" "")
    print()","['constructive algorithms', 'implementation']"
You are given two integers $$$n$$$ and $$$k$$$. Your task is to find if $$$n$$$ can be represented as a sum of $$$k$$$ distinct positive odd (not divisible by $$$2$$$) integers or not.You have to answer $$$t$$$ independent test cases.,"t=int(input())
for i in range(t):
    n,x=[int(y) for y in input().split()]
    if (n%2!=x%2 or x**2>n):
        print('NO')
        
    else:
        print('YES')",['math']
"Polygon is not only the best platform for developing problems but also a square matrix with side $$$n$$$, initially filled with the character 0.On the polygon, military training was held. The soldiers placed a cannon above each cell in the first row and a cannon to the left of each cell in the first column. Thus, exactly $$$2n$$$ cannons were placed.    Initial polygon for $$$n=4$$$. Cannons shoot character 1. At any moment of time, no more than one cannon is shooting. When a 1 flies out of a cannon, it flies forward (in the direction of the shot) until it collides with a polygon border or another 1. After that, it takes the cell in which it was before the collision and remains there. Take a look at the examples for better understanding.More formally:   if a cannon stands in the row $$$i$$$, to the left of the first column, and shoots with a 1, then the 1 starts its flight from the cell ($$$i, 1$$$) and ends in some cell ($$$i, j$$$);  if a cannon stands in the column $$$j$$$, above the first row, and shoots with a 1, then the 1 starts its flight from the cell ($$$1, j$$$) and ends in some cell ($$$i, j$$$). For example, consider the following sequence of shots:   1. Shoot the cannon in the row $$$2$$$.                         2. Shoot the cannon in the row $$$2$$$.                         3. Shoot the cannon in column $$$3$$$. You have a report from the military training on your desk. This report is a square matrix with side length $$$n$$$ consisting of 0 and 1. You wonder if the training actually happened. In other words, is there a sequence of shots such that, after the training, you get the given matrix?Each cannon can make an arbitrary number of shots. Before the training, each cell of the polygon contains 0.","T = input()

for _ in xrange(T):
    N = input()
    ll = []

    for _ in xrange(N):
        ll.append(raw_input())

    oc = 0
    for i in xrange(N-1, -1, -1):
        for j in xrange(N-1, -1, -1):
            if ll[i][j] == ""1"":
                oc += 1

    seen = set()
    for i in xrange(N-1, -1, -1):
        for j in xrange(N-1, -1, -1):
            if ll[i][j] == ""0"":
                break

            if ll[i][j] == ""1"" and (i, j) not in seen:
                q = [(i, j)]
                seen.add((i, j))

                while len(q) > 0:
                    x, y = q.pop(-1)

                    if x > 0 and ll[x-1][y] == ""1"" and (x-1, y) not in seen:
                        q.append((x-1, y))
                        seen.add((x-1, y))

                    if y > 0 and ll[x][y-1] == ""1"" and (x,y-1) not in seen:
                        q.append((x, y-1))
                        seen.add((x, y-1))


    for j in xrange(N-1, -1, -1):
        for i in xrange(N-1, -1, -1):
            if ll[i][j] == ""0"":
                break

            if ll[i][j] == ""1"" and (i, j) not in seen:
                q = [(i, j)]
                seen.add((i, j))

                while len(q) > 0:
                    x, y = q.pop(-1)

                    if x > 0 and ll[x-1][y] == ""1"" and (x-1, y) not in seen:
                        q.append((x-1, y))
                        seen.add((x-1, y))

                    if y > 0 and ll[x][y-1] == ""1"" and (x,y-1) not in seen:
                        q.append((x, y-1))
                        seen.add((x, y-1))

    if oc != len(seen):
        print ""NO""
    else:
        print ""YES""","['dp', 'implementation', 'graphs', 'shortest paths']"
"Boboniu gives you  $$$r$$$ red balls,  $$$g$$$ green balls,  $$$b$$$ blue balls,  $$$w$$$ white balls. He allows you to do the following operation as many times as you want:   Pick a red ball, a green ball, and a blue ball and then change their color to white. You should answer if it's possible to arrange all the balls into a palindrome after several (possibly zero) number of described operations.","Nombre = int(input()) ; 
for m in range(Nombre) : 
    Tab = list(map(int,input().split())) ; 
    odd = 0 ;
    null = 0 ; 
    for n in Tab : 
        if (n % 2) == 1 : 
            odd += 1 ;
    if (odd ==1) or (odd== 4) or (odd ==0) : 
        print(""Yes"") ; 
    elif (odd == 3) : 
        for n in range(3) : 
            if Tab[n] == 0 : 
                null += 1 ; 
        if null > 0 : 
            print(""No"") ;
        else : 
            print(""Yes"") ; 
    else : 
        print(""No"") ;","['brute force', 'math']"
"On the well-known testing system MathForces, a draw of $$$n$$$ rating units is arranged. The rating will be distributed according to the following algorithm: if $$$k$$$ participants take part in this event, then the $$$n$$$ rating is evenly distributed between them and rounded to the nearest lower integer, At the end of the drawing, an unused rating may remain — it is not given to any of the participants.For example, if $$$n = 5$$$ and $$$k = 3$$$, then each participant will recieve an $$$1$$$ rating unit, and also $$$2$$$ rating units will remain unused. If $$$n = 5$$$, and $$$k = 6$$$, then none of the participants will increase their rating.Vasya participates in this rating draw but does not have information on the total number of participants in this event. Therefore, he wants to know what different values of the rating increment are possible to get as a result of this draw and asks you for help.For example, if $$$n=5$$$, then the answer is equal to the sequence $$$0, 1, 2, 5$$$. Each of the sequence values (and only them) can be obtained as $$$\lfloor n/k \rfloor$$$ for some positive integer $$$k$$$ (where $$$\lfloor x \rfloor$$$ is the value of $$$x$$$ rounded down): $$$0 = \lfloor 5/7 \rfloor$$$, $$$1 = \lfloor 5/5 \rfloor$$$, $$$2 = \lfloor 5/2 \rfloor$$$, $$$5 = \lfloor 5/1 \rfloor$$$.Write a program that, for a given $$$n$$$, finds a sequence of all possible rating increments.","from math import sqrt
from sys import stdin, stdout
for i in range(int(input())):
  n = int(input())
  s,j,l = set([0,1]), 2, sqrt(n)
  while j <= l:
    s.add(j)
    s.add(int(n//j))
    j += 1
  s.add(n)
  a,l = sorted(s), len(s)
  stdout.write('%d\n' % l)
  for j in range(l):
    stdout.write('%d ' % a[j])
  stdout.write('\n')","['binary search', 'meet-in-the-middle', 'number theory', 'math']"
"You are given two arrays $$$a$$$ and $$$b$$$, each consisting of $$$n$$$ positive integers, and an integer $$$x$$$. Please determine if one can rearrange the elements of $$$b$$$ so that $$$a_i + b_i \leq x$$$ holds for each $$$i$$$ ($$$1 \le i \le n$$$).","from collections import Counter


def foo():
    return map(int, input().split())


for _ in range(int(input())):
    if _:
        input()
    _, s = foo()
    a, b = foo(), foo()
    cnt = Counter((*b,))
    for i in a:
        canfind = False
        for j in range(s - i, 0, -1):
            if cnt[j] > 0:
                canfind = True
                cnt[j] -= 1
                break
    print(""NO"" if not canfind else ""YES"")","['sortings', 'greedy']"
"Arkady's morning seemed to be straight of his nightmare. He overslept through the whole morning and, still half-asleep, got into the tram that arrived the first. Some time after, leaving the tram, he realized that he was not sure about the line number of the tram he was in.During his ride, Arkady woke up several times and each time he saw the tram stopping at some stop. For each stop he knows which lines of tram stop there. Given this information, can you help Arkady determine what are the possible lines of the tram he was in?","from collections import Counter as c
x=int(input())
l=[]
for i in range(x):
    l=l+list(map(int,input().split()))[1:]
l=dict(c(l))
for a,b in l.items():
    if b==x:
        print(a,end=' ')",['implementation']
"After learning a lot about space exploration, a little girl named Ana wants to change the subject.Ana is a girl who loves palindromes (string that can be read the same backwards as forward). She has learned how to check for a given string whether it's a palindrome or not, but soon she grew tired of this problem, so she came up with a more interesting one and she needs your help to solve it:You are given an array of strings which consist of only small letters of the alphabet. Your task is to find how many palindrome pairs are there in the array. A palindrome pair is a pair of strings such that the following condition holds: at least one permutation of the concatenation of the two strings is a palindrome. In other words, if you have two strings, let's say ""aab"" and ""abcac"", and you concatenate them into ""aababcac"", we have to check if there exists a permutation of this new string such that it is a palindrome (in this case there exists the permutation ""aabccbaa""). Two pairs are considered different if the strings are located on different indices. The pair of strings with indices $$$(i,j)$$$ is considered the same as the pair $$$(j,i)$$$.","from collections import Counter

n = int(input())
strings = []

for i in range(0,n):
  counter = { x: 0 for x in range(ord('a'), ord('z')+1) }
  napis = input()
  for val in napis:
    counter[ord(val)] = (counter[ord(val)] + 1) % 2
  
  napis = """"
  for key, val in counter.items():
    if val != 0:
      napis+=chr(key)
  
  strings.append(napis)

c = Counter(strings)
strings = sorted(c.most_common(), key=lambda i: i[0])
#print(strings)

count = 0
for key, val in strings:
  if val > 1:
    count += val*(val-1)/2

for charInt in range(ord('a'), ord('z')+1):
  char = chr(charInt)
  copy = {}
  for key, val in strings:
    if char in key:
      copy[key.replace(char, """")] = copy.get(key.replace(char, """"), 0) + val
  #print(copy)
  for key, val in strings:
    if copy.get(key,0) != 0:
      count+=val * copy[key]
      #print(""pokrywa : "", key, "" "", val*copy[key])

print(int(count))","['hashing', 'strings']"
"Galya is playing one-dimensional Sea Battle on a 1 × n grid. In this game a ships are placed on the grid. Each of the ships consists of b consecutive cells. No cell can be part of two ships, however, the ships can touch each other.Galya doesn't know the ships location. She can shoot to some cells and after each shot she is told if that cell was a part of some ship (this case is called ""hit"") or not (this case is called ""miss"").Galya has already made k shots, all of them were misses.Your task is to calculate the minimum number of cells such that if Galya shoot at all of them, she would hit at least one ship.It is guaranteed that there is at least one valid ships placement.","n,a,b,k=map(int,input().split())
A=input()
B=A.split('1')
C=[]
l=1

for i in B:
    if len(i)>=b:
        for j in range(b-1,len(i),b):
            C.append(j+l)
    l+=len(i)+1
C=C[:len(C)-a+1]
print(len(C))
print(' '.join(list(map(str,C))))





# Made By Mostafa_Khaled","['constructive algorithms', 'implementation', 'greedy', 'math']"
"Alice and Bob have received three big piles of candies as a gift. Now they want to divide these candies as fair as possible. To do this, Alice takes one pile of candies, then Bob takes one of the other two piles. The last pile is split between Alice and Bob as they want: for example, it is possible that Alice takes the whole pile, and Bob gets nothing from it.After taking the candies from the piles, if Alice has more candies than Bob, she discards some candies so that the number of candies she has is equal to the number of candies Bob has. Of course, Bob does the same if he has more candies.Alice and Bob want to have as many candies as possible, and they plan the process of dividing candies accordingly. Please calculate the maximum number of candies Alice can have after this division process (of course, Bob will have the same number of candies).You have to answer $$$q$$$ independent queries.Let's see the following example: $$$[1, 3, 4]$$$. Then Alice can choose the third pile, Bob can take the second pile, and then the only candy from the first pile goes to Bob — then Alice has $$$4$$$ candies, and Bob has $$$4$$$ candies.Another example is $$$[1, 10, 100]$$$. Then Alice can choose the second pile, Bob can choose the first pile, and candies from the third pile can be divided in such a way that Bob takes $$$54$$$ candies, and Alice takes $$$46$$$ candies. Now Bob has $$$55$$$ candies, and Alice has $$$56$$$ candies, so she has to discard one candy — and after that, she has $$$55$$$ candies too.","import math

q_count = int(input())
for i in range(q_count):
  nums = input().split(' ')
  piles_fair = sum(map(lambda x: int(x), nums))//2
  print(piles_fair)","['constructive algorithms', 'brute force', 'math']"
"There are $$$n$$$ models in the shop numbered from $$$1$$$ to $$$n$$$, with sizes $$$s_1, s_2, \ldots, s_n$$$.Orac will buy some of the models and will arrange them in the order of increasing numbers (i.e. indices, but not sizes).Orac thinks that the obtained arrangement is beatiful, if for any two adjacent models with indices $$$i_j$$$ and $$$i_{j+1}$$$ (note that $$$i_j &lt; i_{j+1}$$$, because Orac arranged them properly), $$$i_{j+1}$$$ is divisible by $$$i_j$$$ and $$$s_{i_j} &lt; s_{i_{j+1}}$$$.For example, for $$$6$$$ models with sizes $$$\{3, 6, 7, 7, 7, 7\}$$$, he can buy models with indices $$$1$$$, $$$2$$$, and $$$6$$$, and the obtained arrangement will be beautiful. Also, note that the arrangement with exactly one model is also considered beautiful.Orac wants to know the maximum number of models that he can buy, and he may ask you these queries many times.","def DFC(maxm, u):
    maxm += 1
    e[u] = maxm
    if len(st[u]) == 0:
        maxms.append(maxm)
        return 0
    for i in st[u]:
        if e[i] <= maxm:
            DFC(maxm, i)
    return 0

# list( map(int, input().split()) )
rw = int(input())
for ewqr in range(rw):
    n = int(input())
    maxms = []
    maxm = 0
    s = [0] + list( map(int, input().split()) )
    st = [[] for i in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(i, n + 1, i):
            if s[i] < s[j]:
                st[i].append(j)
    e = [0] * (n + 1)
    for i in range(1, n + 1):
        if e[i] == 0:
            DFC(maxm, i)
    print(max(maxms))","['dp', 'number theory', 'math']"
"The game of Berland poker is played with a deck of $$$n$$$ cards, $$$m$$$ of which are jokers. $$$k$$$ players play this game ($$$n$$$ is divisible by $$$k$$$).At the beginning of the game, each player takes $$$\frac{n}{k}$$$ cards from the deck (so each card is taken by exactly one player). The player who has the maximum number of jokers is the winner, and he gets the number of points equal to $$$x - y$$$, where $$$x$$$ is the number of jokers in the winner's hand, and $$$y$$$ is the maximum number of jokers among all other players. If there are two or more players with maximum number of jokers, all of them are winners and they get $$$0$$$ points.Here are some examples:  $$$n = 8$$$, $$$m = 3$$$, $$$k = 2$$$. If one player gets $$$3$$$ jokers and $$$1$$$ plain card, and another player gets $$$0$$$ jokers and $$$4$$$ plain cards, then the first player is the winner and gets $$$3 - 0 = 3$$$ points;  $$$n = 4$$$, $$$m = 2$$$, $$$k = 4$$$. Two players get plain cards, and the other two players get jokers, so both of them are winners and get $$$0$$$ points;  $$$n = 9$$$, $$$m = 6$$$, $$$k = 3$$$. If the first player gets $$$3$$$ jokers, the second player gets $$$1$$$ joker and $$$2$$$ plain cards, and the third player gets $$$2$$$ jokers and $$$1$$$ plain card, then the first player is the winner, and he gets $$$3 - 2 = 1$$$ point;  $$$n = 42$$$, $$$m = 0$$$, $$$k = 7$$$. Since there are no jokers, everyone gets $$$0$$$ jokers, everyone is a winner, and everyone gets $$$0$$$ points. Given $$$n$$$, $$$m$$$ and $$$k$$$, calculate the maximum number of points a player can get for winning the game.","for i in range(int(input())):
    n,m,k = [int(i) for i in input().split()]
    card = n//k
    if m<=card:
        print(m)
    elif card == 1:
        print(0)
    else:

        rem = (m-card)//(k-1)
        if (m-card)%(k-1) != 0:
            rem += 1
            # print(rem,m,k)
        print(card-rem)","['greedy', 'math', 'brute force']"
"A schoolboy named Vasya loves reading books on programming and mathematics. He has recently read an encyclopedia article that described the method of median smoothing (or median filter) and its many applications in science and engineering. Vasya liked the idea of the method very much, and he decided to try it in practice.Applying the simplest variant of median smoothing to the sequence of numbers a1, a2, ..., an will result a new sequence b1, b2, ..., bn obtained by the following algorithm:  b1 = a1, bn = an, that is, the first and the last number of the new sequence match the corresponding numbers of the original sequence.  For i = 2, ..., n - 1 value bi is equal to the median of three values ai - 1, ai and ai + 1. The median of a set of three numbers is the number that goes on the second place, when these three numbers are written in the non-decreasing order. For example, the median of the set 5, 1, 2 is number 2, and the median of set 1, 0, 1 is equal to 1.In order to make the task easier, Vasya decided to apply the method to sequences consisting of zeros and ones only.Having made the procedure once, Vasya looked at the resulting sequence and thought: what if I apply the algorithm to it once again, and then apply it to the next result, and so on? Vasya tried a couple of examples and found out that after some number of median smoothing algorithm applications the sequence can stop changing. We say that the sequence is stable, if it does not change when the median smoothing is applied to it.Now Vasya wonders, whether the sequence always eventually becomes stable. He asks you to write a program that, given a sequence of zeros and ones, will determine whether it ever becomes stable. Moreover, if it ever becomes stable, then you should determine what will it look like and how many times one needs to apply the median smoothing algorithm to initial sequence in order to obtain a stable one.","import sys
lines = sys.stdin.readlines()
n = int(lines[0].strip())
arr = list(map(int, lines[1].strip().split("" "")))
arr.append(arr[-1])
res = []
maxChange = 0

left = 0
for i in range(1, n+1):
    if arr[i] == arr[i-1]:
        L = i - left
        res += [arr[left]]*(L//2) + [arr[i-1]]*(L-L//2)
        maxChange = max(maxChange, (L-1)//2)
        left = i

print(maxChange)
print("" "".join(map(str, res)))","['constructive algorithms', 'implementation']"
"Given a string $$$s$$$ of length $$$n$$$ and integer $$$k$$$ ($$$1 \le k \le n$$$). The string $$$s$$$ has a level $$$x$$$, if $$$x$$$ is largest non-negative integer, such that it's possible to find in $$$s$$$:  $$$x$$$ non-intersecting (non-overlapping) substrings of length $$$k$$$,  all characters of these $$$x$$$ substrings are the same (i.e. each substring contains only one distinct character and this character is the same for all the substrings). A substring is a sequence of consecutive (adjacent) characters, it is defined by two integers $$$i$$$ and $$$j$$$ ($$$1 \le i \le j \le n$$$), denoted as $$$s[i \dots j]$$$ = ""$$$s_{i}s_{i+1} \dots s_{j}$$$"".For example, if $$$k = 2$$$, then:  the string ""aabb"" has level $$$1$$$ (you can select substring ""aa""),  the strings ""zzzz"" and ""zzbzz"" has level $$$2$$$ (you can select two non-intersecting substrings ""zz"" in each of them),  the strings ""abed"" and ""aca"" have level $$$0$$$ (you can't find at least one substring of the length $$$k=2$$$ containing the only distinct character). Zuhair gave you the integer $$$k$$$ and the string $$$s$$$ of length $$$n$$$. You need to find $$$x$$$, the level of the string $$$s$$$.","n, k = map(int, input().split())

seq = input()

sseq = {}
cur = 1
for i in range(1, len(seq)):
    s = seq[i]
    if s == seq[i - 1]:
        cur += 1
    else:
        try:
            # print(s, cur, k)
            sseq[seq[i - 1]] += cur // k
        except KeyError:
            sseq[seq[i - 1]] = cur // k
        cur = 1


try:
    sseq[seq[-1]] += cur // k
except KeyError:
    sseq[seq[-1]] = cur // k

# print(sseq)

mx = 0
for key, val in sseq.items():
    mx = max(val, mx)
print(mx)","['implementation', 'brute force', 'strings']"
"Sengoku still remembers the mysterious ""colourful meteoroids"" she discovered with Lala-chan when they were little. In particular, one of the nights impressed her deeply, giving her the illusion that all her fancies would be realized.On that night, Sengoku constructed a permutation p1, p2, ..., pn of integers from 1 to n inclusive, with each integer representing a colour, wishing for the colours to see in the coming meteor outburst. Two incredible outbursts then arrived, each with n meteorids, colours of which being integer sequences a1, a2, ..., an and b1, b2, ..., bn respectively. Meteoroids' colours were also between 1 and n inclusive, and the two sequences were not identical, that is, at least one i (1 ≤ i ≤ n) exists, such that ai ≠ bi holds.Well, she almost had it all — each of the sequences a and b matched exactly n - 1 elements in Sengoku's permutation. In other words, there is exactly one i (1 ≤ i ≤ n) such that ai ≠ pi, and exactly one j (1 ≤ j ≤ n) such that bj ≠ pj.For now, Sengoku is able to recover the actual colour sequences a and b through astronomical records, but her wishes have been long forgotten. You are to reconstruct any possible permutation Sengoku could have had on that night.","n = int(raw_input())
A = map(int, raw_input().split())
B = map(int, raw_input().split())
C = [a for a in A]

backet = [0 for _ in xrange(n)]
missing = -1
for i, a in enumerate(sorted(A)):
    backet[a-1] += 1

missing = backet.index(0) + 1
dup = backet.index(2) + 1

for i in xrange(n):
    if A[i] == dup:
        C[i] = missing
        cnt = 0
        for j in xrange(n):
            if C[j] != B[j]:
                cnt += 1
        if cnt == 1:
            print ' '.join(map(str, C))
            exit()
        C[i] = A[i]",['constructive algorithms']
"You helped Dima to have a great weekend, but it's time to work. Naturally, Dima, as all other men who have girlfriends, does everything wrong.Inna and Dima are now in one room. Inna tells Dima off for everything he does in her presence. After Inna tells him off for something, she goes to another room, walks there in circles muttering about how useless her sweetheart is. During that time Dima has time to peacefully complete k - 1 tasks. Then Inna returns and tells Dima off for the next task he does in her presence and goes to another room again. It continues until Dima is through with his tasks.Overall, Dima has n tasks to do, each task has a unique number from 1 to n. Dima loves order, so he does tasks consecutively, starting from some task. For example, if Dima has 6 tasks to do in total, then, if he starts from the 5-th task, the order is like that: first Dima does the 5-th task, then the 6-th one, then the 1-st one, then the 2-nd one, then the 3-rd one, then the 4-th one.Inna tells Dima off (only lovingly and appropriately!) so often and systematically that he's very well learned the power with which she tells him off for each task. Help Dima choose the first task so that in total he gets told off with as little power as possible.","n,k=map(int,input().split())
A=list(map(int,input().split()))
B=A+A
time=[]
for i in range(k):
   a=i
   summ=0
   for j in range(n//k):
            summ+=B[a]
            a+=k
   time.append([summ,i+1])
time.sort()
print(time[0][1])","['implementation', 'brute force']"
"You have a given picture with size $$$w \times h$$$. Determine if the given picture has a single ""+"" shape or not. A ""+"" shape is described below:  A ""+"" shape has one center nonempty cell.  There should be some (at least one) consecutive non-empty cells in each direction (left, right, up, down) from the center. In other words, there should be a ray in each direction.  All other cells are empty. Find out if the given picture has single ""+"" shape.","n,m=map(int,input().split())
a=[]
for i in range(n):
    a.append(list(input()))
b=0
for i in a:
    b+=i.count('*')
x=y=-1
for i in range(1,n-1):
    for j in range(1,m-1):
        if a[i][j]==a[i][j-1]==a[i][j+1]==a[i-1][j]==a[i+1][j]=='*':
            x=i
            y=j
            break
if x==y==-1:
    exit(print('NO'))
r=1
for i in range(x+1,n):
    if a[i][y]=='*':
        r+=1
    else:
        break
for i in range(x-1,-1,-1):
    if a[i][y]=='*':
        r+=1
    else:
        break
for i in range(y+1,m):
    if a[x][i]=='*':
        r+=1
    else:
        break
for i in range(y-1,-1,-1):
    if a[x][i]=='*':
        r+=1
    else:
        break
if r==b:
    print('YES')
else:
    print('NO')","['implementation', 'dfs and similar', 'strings']"
"Anton is playing a very interesting computer game, but now he is stuck at one of the levels. To pass to the next level he has to prepare n potions.Anton has a special kettle, that can prepare one potions in x seconds. Also, he knows spells of two types that can faster the process of preparing potions.  Spells of this type speed up the preparation time of one potion. There are m spells of this type, the i-th of them costs bi manapoints and changes the preparation time of each potion to ai instead of x.  Spells of this type immediately prepare some number of potions. There are k such spells, the i-th of them costs di manapoints and instantly create ci potions. Anton can use no more than one spell of the first type and no more than one spell of the second type, and the total number of manapoints spent should not exceed s. Consider that all spells are used instantly and right before Anton starts to prepare potions.Anton wants to get to the next level as fast as possible, so he is interested in the minimum number of time he needs to spent in order to prepare at least n potions.","import bisect
n, m, k = map(int, input().split())
x, s = map(int, input().split())
a1 = [int(x) for x in input().split()]
a2 = [int(x) for x in input().split()]
b1 = [int(x) for x in input().split()]
b2 = [int(x) for x in input().split()]
a1.append(x)
a2.append(0)
ans = n*x
for i in range(m+1):
    if a2[i] > s:
        continue
    if s - a2[i] < b2[0]:
        ans = min(ans, n*a1[i])
        continue
    t = bisect.bisect_right(b2, s - a2[i]) - 1
    ans = min(ans, a1[i]*(n-b1[t]))
print(ans)","['dp', 'two pointers', 'binary search', 'greedy']"
"Vasya has recently got a job as a cashier at a local store. His day at work is $$$L$$$ minutes long. Vasya has already memorized $$$n$$$ regular customers, the $$$i$$$-th of which comes after $$$t_{i}$$$ minutes after the beginning of the day, and his service consumes $$$l_{i}$$$ minutes. It is guaranteed that no customer will arrive while Vasya is servicing another customer. Vasya is a bit lazy, so he likes taking smoke breaks for $$$a$$$ minutes each. Those breaks may go one after another, but Vasya must be present at work during all the time periods he must serve regular customers, otherwise one of them may alert his boss. What is the maximum number of breaks Vasya can take during the day?","n, l, a = map(int, input().split())
b = 0
c = 0
for i in range(n):
    x, y = map(int, input().split())
    c += (x - b) //a
    b = x + y
c += (l - b) / a
print(int(c))",['implementation']
"You have a string $$$s$$$ consisting of $$$n$$$ characters. Each character is either 0 or 1.You can perform operations on the string. Each operation consists of two steps:  select an integer $$$i$$$ from $$$1$$$ to the length of the string $$$s$$$, then delete the character $$$s_i$$$ (the string length gets reduced by $$$1$$$, the indices of characters to the right of the deleted one also get reduced by $$$1$$$);  if the string $$$s$$$ is not empty, delete the maximum length prefix consisting of the same characters (the indices of the remaining characters and the string length get reduced by the length of the deleted prefix). Note that both steps are mandatory in each operation, and their order cannot be changed.For example, if you have a string $$$s =$$$ 111010, the first operation can be one of the following:  select $$$i = 1$$$: we'll get 111010 $$$\rightarrow$$$ 11010 $$$\rightarrow$$$ 010;  select $$$i = 2$$$: we'll get 111010 $$$\rightarrow$$$ 11010 $$$\rightarrow$$$ 010;  select $$$i = 3$$$: we'll get 111010 $$$\rightarrow$$$ 11010 $$$\rightarrow$$$ 010;  select $$$i = 4$$$: we'll get 111010 $$$\rightarrow$$$ 11110 $$$\rightarrow$$$ 0;  select $$$i = 5$$$: we'll get 111010 $$$\rightarrow$$$ 11100 $$$\rightarrow$$$ 00;  select $$$i = 6$$$: we'll get 111010 $$$\rightarrow$$$ 11101 $$$\rightarrow$$$ 01. You finish performing operations when the string $$$s$$$ becomes empty. What is the maximum number of operations you can perform?","for _ in range(input()):
    n=input()
    s=raw_input()
    length=[]
    p=0
    while p!=n:
        cur=s[p]
        ln=1
        p+=1
        if p==n:
            length.append(ln)
            break
        while s[p]==cur:

            ln+=1
            p+=1
            if p==n:
                break
        length.append(ln)
    extra=[0 for i in range(len(length))]
    for i in range(len(length)-1,0,-1):
        extra[i-1]=extra[i]+max(0,length[i]-2)
    moves=0
    leftover=0
    skip=0
    for i in range(len(length)):
        if skip==1 and length[i]==1:
            skip=0
            continue
        if length[i]>1:
            moves+=1
            leftover=max(0,leftover-(length[i]-2))
        else:
            if extra[i]-leftover>0:
                leftover+=1
                moves+=1
            else:
                moves+=1
                skip=1
    print moves","['data structures', 'two pointers', 'binary search', 'greedy']"
"Today, Wet Shark is given n bishops on a 1000 by 1000 grid. Both rows and columns of the grid are numbered from 1 to 1000. Rows are numbered from top to bottom, while columns are numbered from left to right.Wet Shark thinks that two bishops attack each other if they share the same diagonal. Note, that this is the only criteria, so two bishops may attack each other (according to Wet Shark) even if there is another bishop located between them. Now Wet Shark wants to count the number of pairs of bishops that attack each other.","n = int(input())
R = lambda : map(int, input().split())

from collections import defaultdict
l1 = defaultdict(int)
l2 = defaultdict(int)

for i in range(n):
    x,y=R()
    l1[y-x]+=1; l2[1001-y-x]+=1;

s = 0
for d in l1.values():
    s+=(d*(d-1))//2
for d in l2.values():
    s+=(d*(d-1))//2
print(s)","['combinatorics', 'implementation']"
"You can't possibly imagine how cold our friends are this winter in Nvodsk! Two of them play the following game to warm up: initially a piece of paper has an integer q. During a move a player should write any integer number that is a non-trivial divisor of the last written number. Then he should run this number of circles around the hotel. Let us remind you that a number's divisor is called non-trivial if it is different from one and from the divided number itself. The first person who can't make a move wins as he continues to lie in his warm bed under three blankets while the other one keeps running. Determine which player wins considering that both players play optimally. If the first player wins, print any winning first move.","#!/usr/bin/env python
from sys import stdin as cin

def find_div(q):
	d = 0
	if q == 1:
		return 1
	if q % 2 == 0:
		return 2
	else:
		for d in range(3, int(q**0.5) + 3, 2):
			if q % d == 0:
				return d
	return q


def main():
	q = int(next(cin))
	if q == 1:
		return 1,0
	
	d = find_div(q)
	if d in (1, q):
		return 1,0

	q = q // d
	e = find_div(q)
	if e in (1, q):
		return 2,
	else:
		return 1, e * d

print '\n'.join(map(str, main()))","['greedy', 'number theory', 'games', 'math']"
"This is the easy version of the problem. The difference between the versions is that in the easy version all prices $$$a_i$$$ are different. You can make hacks if and only if you solved both versions of the problem.Today is Sage's birthday, and she will go shopping to buy ice spheres. All $$$n$$$ ice spheres are placed in a row and they are numbered from $$$1$$$ to $$$n$$$ from left to right. Each ice sphere has a positive integer price. In this version all prices are different.An ice sphere is cheap if it costs strictly less than two neighboring ice spheres: the nearest to the left and the nearest to the right. The leftmost and the rightmost ice spheres are not cheap. Sage will choose all cheap ice spheres and then buy only them.You can visit the shop before Sage and reorder the ice spheres as you wish. Find out the maximum number of ice spheres that Sage can buy, and show how the ice spheres should be reordered.","n = int(input())
*arr, = map(int, input().split())
arr.sort()

half = n // 2
res = [-1] * n
print((n - 1) // 2)
if n % 2 == 0:
    res[::2] = arr[-half:]
    res[1::2] = arr[:-half]
else:
    res[::2] = arr[-half - 1:]
    res[1::2] = arr[:-half - 1]

print(*res)","['constructive algorithms', 'binary search', 'sortings', 'greedy']"
"You are given a rebus of form ? + ? - ? + ? = n, consisting of only question marks, separated by arithmetic operation '+' and '-', equality and positive integer n. The goal is to replace each question mark with some positive integer from 1 to n, such that equality holds.","import math
import sys
import os
def low( a , b):
	if(a<b):
		return a
	return b

def main():
	T = raw_input()
	S = T.split()
	plus = S.count('+')
	min =  S.count('-')
	N = S[-1]
	N = int(N)
	L1 = []
	L2 = []
	if((plus+1)*N-min<N or (plus+1) - N * min>N  ):
		print 'Impossible'
		return 0
	else:
		plus = plus + 1
		for x in range(0,plus):
			L1.append(1)
		for x in range(0,min):
			L2.append(1)

		while( sum(L1) - sum(L2)  < N ):
			for x in range(0,len(L1)):
				if(L1[x]<N):
					break
			L1[x] = L1[x]+ low(N-L1[x],N - int(sum(L1)) + int(sum(L2)))
		while( sum(L1) - sum(L2)  > N ):
			for x in range(0,len(L2)):
				if(L2[x]<N):
					break
			L2[x] = L2[x]+ low(N-L2[x],int(sum(L1)-sum(L2)) - N)

	out = ''
	last = 0

	for i in range(0, len(T)):
		if (T[i] != '?'):
			out = out + T[i]
			if (T[i] == '+'):
				last = 0
			elif (T[i] == '-'):
				last = 1
		else:
			if (last == 0):
				out = out + str(L1[-1])
				L1.pop()
			else:
				out = out + str(L2[-1])
				L2.pop()
	print 'Possible'
	print out


main()",['greedy']
"According to rules of the Berland fashion, a jacket should be fastened by all the buttons except only one, but not necessarily it should be the last one. Also if the jacket has only one button, it should be fastened, so the jacket will not swinging open.You are given a jacket with n buttons. Determine if it is fastened in a right way.","#!/usr/bin/env python
#-*- coding:utf-8 -*-

import sys, math, random, operator
from string import ascii_lowercase
from string import ascii_uppercase
from fractions import Fraction, gcd
from decimal import Decimal, getcontext
from itertools import product, permutations, combinations
from Queue import Queue, PriorityQueue
from collections import deque, defaultdict, Counter
getcontext().prec = 100

MOD = 10**9 + 7
INF = float(""+inf"")

if sys.subversion[0] != ""CPython"":  # PyPy?
    raw_input = lambda: sys.stdin.readline().rstrip()
pr = lambda *args: sys.stdout.write("" "".join(str(x) for x in args) + ""\n"")
epr = lambda *args: sys.stderr.write("" "".join(str(x) for x in args) + ""\n"")
die = lambda *args: pr(*args) ^ exit(0)

read_str = raw_input
read_strs = lambda: raw_input().split()
read_int = lambda: int(raw_input())
read_ints = lambda: map(int, raw_input().split())
read_float = lambda: float(raw_input())
read_floats = lambda: map(float, raw_input().split())

""---------------------------------------------------------------""

# abcdefghijklmnopqrstuvwxyz
# ABCDEFGHIJKLMNOPQRSTUVWXYZ
# pairs = ""bd
# sym = ""AHIMOTUVWXYilmn

n = read_int()
arr = read_ints()
if arr == [1] or len(arr) > 1 and sum(arr) == len(arr) - 1:
    print ""YES""
else:
    print ""NO""",['implementation']
"You are given two segments $$$[l_1; r_1]$$$ and $$$[l_2; r_2]$$$ on the $$$x$$$-axis. It is guaranteed that $$$l_1 &lt; r_1$$$ and $$$l_2 &lt; r_2$$$. Segments may intersect, overlap or even coincide with each other.    The example of two segments on the $$$x$$$-axis. Your problem is to find two integers $$$a$$$ and $$$b$$$ such that $$$l_1 \le a \le r_1$$$, $$$l_2 \le b \le r_2$$$ and $$$a \ne b$$$. In other words, you have to choose two distinct integer points in such a way that the first point belongs to the segment $$$[l_1; r_1]$$$ and the second one belongs to the segment $$$[l_2; r_2]$$$.It is guaranteed that the answer exists. If there are multiple answers, you can print any of them.You have to answer $$$q$$$ independent queries.","n=int(input())
for i in range(n):
   k=list(map(int,input().split()))
   print(k[0],end=' ')
   if k[0]!=k[2]:
     print(k[2])
   else:
     print(k[3])",['implementation']
"Recently, the Fair Nut has written $$$k$$$ strings of length $$$n$$$, consisting of letters ""a"" and ""b"". He calculated $$$c$$$ — the number of strings that are prefixes of at least one of the written strings. Every string was counted only one time.Then, he lost his sheet with strings. He remembers that all written strings were lexicographically not smaller than string $$$s$$$ and not bigger than string $$$t$$$. He is interested: what is the maximum value of $$$c$$$ that he could get.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds: $$$a$$$ is a prefix of $$$b$$$, but $$$a \ne b$$$; in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$.","n, k = map(int, input().split())
a = input()
b = input()
res = 0
ans = 0
for i in range(0, n):
    res = min(res * 2 + (b[i] == 'b') - (a[i] == 'b'), k)
    ans += min(res + 1, k)
print(ans)","['greedy', 'strings']"
"You are running through a rectangular field. This field can be represented as a matrix with 3 rows and m columns. (i, j) denotes a cell belonging to i-th row and j-th column.You start in (2, 1) and have to end your path in (2, m). From the cell (i, j) you may advance to:  (i - 1, j + 1) — only if i &gt; 1,  (i, j + 1), or  (i + 1, j + 1) — only if i &lt; 3. However, there are n obstacles blocking your path. k-th obstacle is denoted by three integers ak, lk and rk, and it forbids entering any cell (ak, j) such that lk ≤ j ≤ rk.You have to calculate the number of different paths from (2, 1) to (2, m), and print it modulo 109 + 7.","from __future__ import print_function, division
from collections import OrderedDict
mod = 1000000007

def mat(s, m):
	t = [[0,0,0],[0,0,0],[0,0,0]]
	for i in xrange(3):
		for j in xrange(3):
			t[i][j] = (s[i][0] * m[0][j] + s[i][1] * m[1][j] + s[i][2] * m[2][j]) % mod
	for i in xrange(3):
		s[i] = t[i][:]

def matmul(matrix, v, times):
	if times == 0:
		return
	tmatrix = [[1,1,0],[1,1,1],[0,1,1]]
	for i in xrange(3):
		if v[i] > 0:
			tmatrix[0][i], tmatrix[1][i], tmatrix[2][i] = 0, 0, 0

	ans = [[1,0,0],[0,1,0],[0,0,1]]
	while times > 0:
		if times % 2 == 1:
			# ans = np.matmul(ans, tmatrix)
			mat(ans, tmatrix)
		# tmatrix = np.matmul(tmatrix, tmatrix)
		mat(tmatrix, tmatrix)
		times //= 2

	mat(matrix, ans)
	# matrix = np.matmul(matrix, ans)
def getans():
	run = {}

	n, m = map(int, raw_input().split())

	for i in xrange(n):
		a, l, r = map(int, raw_input().split())
		if not (l-1 in run):
			run[l-1] = [0, 0, 0]
		run[l-1][a-1] += 1

		if not (r in run):
			run[r] = [0, 0, 0]
		run[r][a-1] -= 1

	current = (0, 0, 0)
	run = OrderedDict(sorted(run.items(), key=lambda t: t[0]))

	for k, v in run.iteritems():
		run[k] = (current[0] + v[0], current[1] + v[1], current[2] + v[2])
		current = run[k]

	init_pos = 1
	current = (0, 0, 0)
	matrix = [[1,0,0],[0,1,0],[0,0,1]]
	for k, v in run.iteritems():
		matmul(matrix, current, k - init_pos)
		current = v
		init_pos = k
	matmul(matrix, current, m - init_pos)

	return matrix[1][1]
	
ans = getans()
print(""%d"" % ans)","['dp', 'sortings', 'matrices']"
"You and your $$$n - 1$$$ friends have found an array of integers $$$a_1, a_2, \dots, a_n$$$. You have decided to share it in the following way: All $$$n$$$ of you stand in a line in a particular order. Each minute, the person at the front of the line chooses either the first or the last element of the array, removes it, and keeps it for himself. He then gets out of line, and the next person in line continues the process.You are standing in the $$$m$$$-th position in the line. Before the process starts, you may choose up to $$$k$$$ different people in the line, and persuade them to always take either the first or the last element in the array on their turn (for each person his own choice, not necessarily equal for all people), no matter what the elements themselves are. Once the process starts, you cannot persuade any more people, and you cannot change the choices for the people you already persuaded.Suppose that you're doing your choices optimally. What is the greatest integer $$$x$$$ such that, no matter what are the choices of the friends you didn't choose to control, the element you will take from the array will be greater than or equal to $$$x$$$?Please note that the friends you don't control may do their choice arbitrarily, and they will not necessarily take the biggest element available.","def inp(dtype=str, strip=True):
    s = input()
    res = [dtype(p) for p in s.split()]
    res = res[0] if len(res) == 1 and strip else res
    return res


def problemA():
    t = int(input())
    for _ in range(t):
        n = int(input())
        s = input()
        s = [int(el) for el in s]

        res = '-1'
        cum = sum(s)
        i = 1
        while i <= n:
            if s[-i] % 2 != 0 and cum % 2 == 0:
                res = ''.join([str(s[j]) for j in range(n - i + 1)])
                break
            cum -= s[-i]
            i += 1

        print(res)


def problemB():
    t = int(input())
    for tcase in range(t):
        n = int(input())
        a = inp(int, strip=False)

        next = a[0] + 1 if a[0] <= 0 else 1
        i = 1
        while i < n and a[i] >= next:
            if a[i] < 0:
                next = a[i] + 1
            elif next <= 0:
                next = 1
            else:
                next += 1
            i += 1

        if i == n:
            print('YES')
            continue

        ileft = i - 1
        gapleft = a[ileft] < next - 1

        i = n - 1
        next = a[i] + 1 if a[i] <= 0 else 1
        i -= 1
        while i >= 0 and a[i] >= next:
            if a[i] < 0:
                next = a[i] + 1
            elif next <= 0:
                next = 1
            else:
                next += 1
            i -= 1

        if i < 0:
            print('YES')
            continue

        iright = i + 1
        gapright = a[iright] < next - 1

        # print(tcase, ileft, iright)

        if ileft + 1 > iright:
            print('YES')
        elif ileft + 1 == iright:
            if a[ileft] != a[iright]:
                print('YES')
            elif a[ileft] > 0 and (gapleft or gapright):
                print('YES')
            else:
                print('NO')
        else:
            print('NO')


def problemC():
    t = int(input())
    for _ in range(t):
        n, m, k = inp(int)
        k = min(k, m - 1)
        a = inp(int, strip=False)

        b = [max(a[i], a[i + (n - m)]) for i in range(0, m)]

        x = max(min(b[i:i+(m-k)]) for i in range(k+1))

        print(x)


if __name__ == '__main__':
    # problemA()
    # problemB()
    problemC()","['data structures', 'greedy', 'math', 'brute force']"
"Your friend Jeff Zebos has been trying to run his new online company, but it's not going very well. He's not getting a lot of sales on his website which he decided to call Azamon. His big problem, you think, is that he's not ranking high enough on the search engines. If only he could rename his products to have better names than his competitors, then he'll be at the top of the search results and will be a millionaire.After doing some research, you find out that search engines only sort their results lexicographically. If your friend could rename his products to lexicographically smaller strings than his competitor's, then he'll be at the top of the rankings!To make your strategy less obvious to his competitors, you decide to swap no more than two letters of the product names.Please help Jeff to find improved names for his products that are lexicographically smaller than his competitor's!Given the string $$$s$$$ representing Jeff's product name and the string $$$c$$$ representing his competitor's product name, find a way to swap at most one pair of characters in $$$s$$$ (that is, find two distinct indices $$$i$$$ and $$$j$$$ and swap $$$s_i$$$ and $$$s_j$$$) such that the resulting new name becomes strictly lexicographically smaller than $$$c$$$, or determine that it is impossible.Note: String $$$a$$$ is strictly lexicographically smaller than string $$$b$$$ if and only if one of the following holds:  $$$a$$$ is a proper prefix of $$$b$$$, that is, $$$a$$$ is a prefix of $$$b$$$ such that $$$a \neq b$$$;  There exists an integer $$$1 \le i \le \min{(|a|, |b|)}$$$ such that $$$a_i &lt; b_i$$$ and $$$a_j = b_j$$$ for $$$1 \le j &lt; i$$$.","""""""
// Author : snape_here - Susanta Mukherjee
     
""""""
 
from __future__ import division, print_function
 
import os,sys
from io import BytesIO, IOBase
 
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
 
 
def ii(): return int(input())
def si(): return input()
def mi(): return map(str,input().split())
def li(): return list(mi())
 
 
def read():
    sys.stdin = open('input.txt', 'r')  
    sys.stdout = open('output.txt', 'w') 
 
def gcd(x, y):
    while y:
        x, y = y, x % y
    return x
    
import collections 

def CountFrequency(arr): 
    return collections.Counter(arr)
    

def main():
    
    for i in range(ii()):
        s,t=mi()
        if s<t:
            print(s)
            continue
        s=list(s)
        t=list(t)
        x=sorted(s)
        if s==x:
            if s<t:
                print(s)
            else:
                print(""---"")
            continue
        for j in range(len(s)):
            if s[j]!=x[j]:
                pos=j 
                c=x[j]
                break 
        for j in range(len(s)-1,pos,-1):
            if s[j]==c:
                s[pos],s[j]=s[j],s[pos] 
                break 
        if s<t:
            print("""".join(s))
        else:
            print(""---"")

    
# region fastio
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()
 
 
if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
 
if __name__ == ""__main__"":
    #read()
    main()",['greedy']
"Bessie the cow has just intercepted a text that Farmer John sent to Burger Queen! However, Bessie is sure that there is a secret message hidden inside.The text is a string $$$s$$$ of lowercase Latin letters. She considers a string $$$t$$$ as hidden in string $$$s$$$ if $$$t$$$ exists as a subsequence of $$$s$$$ whose indices form an arithmetic progression. For example, the string aab is hidden in string aaabb because it occurs at indices $$$1$$$, $$$3$$$, and $$$5$$$, which form an arithmetic progression with a common difference of $$$2$$$. Bessie thinks that any hidden string that occurs the most times is the secret message. Two occurrences of a subsequence of $$$S$$$ are distinct if the sets of indices are different. Help her find the number of occurrences of the secret message!For example, in the string aaabb, a is hidden $$$3$$$ times, b is hidden $$$2$$$ times, ab is hidden $$$6$$$ times, aa is hidden $$$3$$$ times, bb is hidden $$$1$$$ time, aab is hidden $$$2$$$ times, aaa is hidden $$$1$$$ time, abb is hidden $$$1$$$ time, aaab is hidden $$$1$$$ time, aabb is hidden $$$1$$$ time, and aaabb is hidden $$$1$$$ time. The number of occurrences of the secret message is $$$6$$$.","from string import ascii_lowercase


s = input()
lc = {c: 0 for c in ascii_lowercase}
llc = dict()

for c in s:
    for v in lc:
        if v + c not in llc:
            llc[v + c] = lc[v]
        else:
            llc[v + c] += lc[v]
    lc[c] += 1

print(max(*lc.values(), *llc.values()))","['dp', 'brute force', 'math', 'strings']"
"You are given an integer $$$n$$$ ($$$n &gt; 1$$$).Your task is to find a sequence of integers $$$a_1, a_2, \ldots, a_k$$$ such that:  each $$$a_i$$$ is strictly greater than $$$1$$$;  $$$a_1 \cdot a_2 \cdot \ldots \cdot a_k = n$$$ (i. e. the product of this sequence is $$$n$$$);  $$$a_{i + 1}$$$ is divisible by $$$a_i$$$ for each $$$i$$$ from $$$1$$$ to $$$k-1$$$;  $$$k$$$ is the maximum possible (i. e. the length of this sequence is the maximum possible). If there are several such sequences, any of them is acceptable. It can be proven that at least one valid sequence always exists for any integer $$$n &gt; 1$$$.You have to answer $$$t$$$ independent test cases.","def decompose(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(number**(1/2)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i
    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def check_double(A):
    S = set(A)
    my_dict = {x: A.count(x) for x in S if A.count(x)>1}
    try:
        return max(my_dict.keys(), key=(lambda k: my_dict[k]))
    except ValueError:
        return False

def prod(L):
    result = 1
    for x in L:
        result *= x
    return result

for _ in range(int(input())):
    n = int(input())
    prems = decompose(n)
    comp = check_double(prems)
    if comp == False:
        print(1, n, sep='\n')
    else:
        remainder = int(comp*prod([prem for prem in prems if prem != comp]))
        count = prems.count(comp)
        print(count, end='\n')
        for k in range(count-1):
            print(comp, end=' ')
        print(remainder, end='\n')","['constructive algorithms', 'number theory', 'math']"
"A telephone number is a sequence of exactly 11 digits, where the first digit is 8. For example, the sequence 80011223388 is a telephone number, but the sequences 70011223388 and 80000011223388 are not.You are given a string $$$s$$$ of length $$$n$$$, consisting of digits.In one operation you can delete any character from string $$$s$$$. For example, it is possible to obtain strings 112, 111 or 121 from string 1121.You need to determine whether there is such a sequence of operations (possibly empty), after which the string $$$s$$$ becomes a telephone number.","for i in range(int(input())):
    n = int(input())
    s = input()
    print('YES' if '8' in s and n - s.index('8') >= 11 else 'NO')","['brute force', 'greedy', 'strings']"
"Anna is a girl so brave that she is loved by everyone in the city and citizens love her cookies. She is planning to hold a party with cookies. Now she has $$$a$$$ vanilla cookies and $$$b$$$ chocolate cookies for the party.She invited $$$n$$$ guests of the first type and $$$m$$$ guests of the second type to the party. They will come to the party in some order. After coming to the party, each guest will choose the type of cookie (vanilla or chocolate) to eat. There is a difference in the way how they choose that type:If there are $$$v$$$ vanilla cookies and $$$c$$$ chocolate cookies at the moment, when the guest comes, then  if the guest of the first type: if $$$v&gt;c$$$ the guest selects a vanilla cookie. Otherwise, the guest selects a chocolate cookie.  if the guest of the second type: if $$$v&gt;c$$$ the guest selects a chocolate cookie. Otherwise, the guest selects a vanilla cookie. After that:  If there is at least one cookie of the selected type, the guest eats one.  Otherwise (there are no cookies of the selected type), the guest gets angry and returns to home. Anna wants to know if there exists some order of guests, such that no one guest gets angry. Your task is to answer her question.","FAST_IO = 1
if FAST_IO:
    import io, sys, atexit
    rr = iter(sys.stdin.read().splitlines()).next
    sys.stdout = _OUTPUT_BUFFER = io.BytesIO()

    @atexit.register
    def write():
        sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())
else:
    rr = raw_input
rri = lambda: int(rr())
rrm = lambda: map(int, rr().split())
rrmm = lambda n: [rrm() for _ in xrange(n)]
rrd = lambda: map(float, rr().split())


def solve(a,b,c,d):
    if (a+b)<(c+d):
        print(""No"")
    else:
        if min(a,b)<d:
            print(""No"")
        else:
            print(""Yes"")
t = rri()
for _ in range(t):
    a, b, c, d = rrm()
    solve(a,b,c,d)
    
    
""""""
4
3
1
28
510049495001
""""""","['implementation', 'greedy', 'math']"
"You are looking at the floor plan of the Summer Informatics School's new building. You were tasked with SIS logistics, so you really care about travel time between different locations: it is important to know how long it would take to get from the lecture room to the canteen, or from the gym to the server room.The building consists of n towers, h floors each, where the towers are labeled from 1 to n, the floors are labeled from 1 to h. There is a passage between any two adjacent towers (two towers i and i + 1 for all i: 1 ≤ i ≤ n - 1) on every floor x, where a ≤ x ≤ b. It takes exactly one minute to walk between any two adjacent floors of a tower, as well as between any two adjacent towers, provided that there is a passage on that floor. It is not permitted to leave the building. The picture illustrates the first example. You have given k pairs of locations (ta, fa), (tb, fb): floor fa of tower ta and floor fb of tower tb. For each pair you need to determine the minimum walking time between these locations.","from sys import stdin
n,h,a,b,k = map(int,stdin.readline().split())
for _ in xrange(k):
    t1,f1,t2,f2 = map(int,stdin.readline().split())
    ans = abs(t1-t2)
    if t1 !=t2:
        if f1 < a:
            ans += a-f1
            f1 = a
        if f1 > b:
            ans += f1 - b
            f1 = b
    ans += abs(f1-f2)
    print ans",['math']
"Gena loves sequences of numbers. Recently, he has discovered a new type of sequences which he called an almost arithmetical progression. A sequence is an almost arithmetical progression, if its elements can be represented as:  a1 = p, where p is some integer;  ai = ai - 1 + ( - 1)i + 1·q (i &gt; 1), where q is some integer. Right now Gena has a piece of paper with sequence b, consisting of n integers. Help Gena, find there the longest subsequence of integers that is an almost arithmetical progression.Sequence s1,  s2,  ...,  sk is a subsequence of sequence b1,  b2,  ...,  bn, if there is such increasing sequence of indexes i1, i2, ..., ik (1  ≤  i1  &lt;  i2  &lt; ...   &lt;  ik  ≤  n), that bij  =  sj. In other words, sequence s can be obtained from b by crossing out some elements.","from sys import stdin; input=stdin.readline
volt=[0]*(10**6+8)

n=int(input())
INF=n+9
first=[INF]*INF
nxt=[0]*INF
arr=[0]*INF
frek=[0]*INF

def merge(i,j):
  i,j=first[i],first[j]
  ans=0
  while i!=INF or j!=INF:
    if(i<j):
      while i<j: i=nxt[i]
      ans+=1
    else:
      while j<i: j=nxt[j]
      ans+=1
  return ans

i=1
ndiff=0
for v in input().split():
  v=int(v)
  if volt[v]==0:
    ndiff+=1
    volt[v]=ndiff
  vv=volt[v]
  arr[i]=vv; i+=1
  frek[vv]+=1

for i in range(n,0,-1):
  v=arr[i]
  nxt[i]=first[v]
  first[v]=i

#print(nxt[:ndiff+1])
ans=max(frek[1:ndiff+1])
for i in range(1,ndiff):
  for j in range(i+1,ndiff+1):
    
    if frek[i]+frek[j]<=ans: continue
    ans=max(ans,merge(i,j))      

print(ans)","['dp', 'brute force']"
"There are n banks in the city where Vasya lives, they are located in a circle, such that any two banks are neighbouring if their indices differ by no more than 1. Also, bank 1 and bank n are neighbours if n &gt; 1. No bank is a neighbour of itself.Vasya has an account in each bank. Its balance may be negative, meaning Vasya owes some money to this bank.There is only one type of operations available: transfer some amount of money from any bank to account in any neighbouring bank. There are no restrictions on the size of the sum being transferred or balance requirements to perform this operation.Vasya doesn't like to deal with large numbers, so he asks you to determine the minimum number of operations required to change the balance of each bank account to zero. It's guaranteed, that this is possible to achieve, that is, the total balance of Vasya in all banks is equal to zero.","n = int(input())
b = list(map(int, input().split()))

from collections import Counter
from itertools import accumulate
cum = list(accumulate(b))
cnt = Counter(cum)
print (n - cnt.most_common(1)[0][1])","['data structures', 'constructive algorithms', 'sortings', 'greedy']"
"Koa the Koala and her best friend want to play a game.The game starts with an array $$$a$$$ of length $$$n$$$ consisting of non-negative integers. Koa and her best friend move in turns and each have initially a score equal to $$$0$$$. Koa starts.Let's describe a move in the game:  During his move, a player chooses any element of the array and removes it from this array, xor-ing it with the current score of the player. More formally: if the current score of the player is $$$x$$$ and the chosen element is $$$y$$$, his new score will be $$$x \oplus y$$$. Here $$$\oplus$$$ denotes bitwise XOR operation. Note that after a move element $$$y$$$ is removed from $$$a$$$.  The game ends when the array is empty. At the end of the game the winner is the player with the maximum score. If both players have the same score then it's a draw.If both players play optimally find out whether Koa will win, lose or draw the game.","import sys
input=sys.stdin.buffer.readline

t=int(input())
for _ in range(t):
    n=int(input())
    arr=[int(x) for x in input().split()]
    
    zeroBitCnt=[0 for _ in range(30)] #largest no is 10**9
    oneBitCnt=[0 for _ in range(30)] #largest no is 10**9
    for x in arr:
        for i in range(30):
            if (x&(1<<i))>0:
                oneBitCnt[i]+=1
            else:
                zeroBitCnt[i]+=1
    
    ok=False
    for i in range(29,-1,-1):
        if oneBitCnt[i]%2==0:
            continue
        else:
            if oneBitCnt[i]%4==3 and zeroBitCnt[i]%2==0:
                print('LOSE')
            else:
                print('WIN')
            ok=True
            break
    if ok==False:
        print('DRAW')","['dp', 'greedy', 'constructive algorithms', 'bitmasks', 'games', 'math']"
"A positive integer $$$x$$$ is called a power of two if it can be represented as $$$x = 2^y$$$, where $$$y$$$ is a non-negative integer. So, the powers of two are $$$1, 2, 4, 8, 16, \dots$$$.You are given two positive integers $$$n$$$ and $$$k$$$. Your task is to represent $$$n$$$ as the sum of exactly $$$k$$$ powers of two.","from heapq import heappush
from heapq import heappop

a = []
x = 0
i = 0
while x < 1000000000:
    x = pow(2, i)
    a.append(x)
    i += 1

n, k = map(int, raw_input().split())

x = n
h = []
i = len(a) - 1
while x > 0:
    if x >= a[i]:
        x -= a[i]
        heappush(h, -a[i])
    else: i -= 1

if k > n or len(h) > k:
    print 'NO'
else:
    while len(h) < k:
        x = -heappop(h)
        if x == 1: break
        heappush(h, -x / 2)
        heappush(h, -x / 2)

    if len(h) == k:
        print 'YES'
        print ' '.join(map(lambda x: str(-x), h))
    else:
        print 'NO'","['bitmasks', 'greedy']"
"The winner of the card game popular in Berland ""Berlogging"" is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line ""name score"", where name is a player's name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to m) at the end of the game, than wins the one of them who scored at least m points first. Initially each player has 0 points. It's guaranteed that at the end of the game at least one player has a positive number of points.","n,k,s=eval(input()),{},[]
for i in range(n):
    a,b=input().split()
    k[a]=k.get(a,0)+int(b)
    s.append([a,k[a]])
n=max(k.values())
for i,j in s:
    if k[i]==n and int(j)>=n:
        print(i)
        break","['implementation', 'hashing']"
"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.","from sys import exit

n, k = map(int, raw_input().split(' '))

ds = list(map(int, raw_input().split(' ')))


count = {}

for d in ds:
    if not d in count:
        count[d] = 1
    else:
        count[d] += 1


left, right = 0, n-1

distinct = len(count)
if distinct < k:
    print '-1 -1'
    exit()

while distinct >= k and left <= right:
    count[ds[right]] -= 1
    if not count[ds[right]]:
        distinct -= 1
    right -= 1
right += 1
distinct += 1

while distinct >= k and left <= right:
    count[ds[left]] -= 1
    if not count[ds[left]]:
        distinct -= 1
    left += 1
left -= 1
distinct += 1


print '%s %s\n' % (left+1,right+1)","['two pointers', 'implementation', 'bitmasks']"
"Dreamoon is a big fan of the Codeforces contests.One day, he claimed that he will collect all the places from $$$1$$$ to $$$54$$$ after two more rated contests. It's amazing!Based on this, you come up with the following problem:There is a person who participated in $$$n$$$ Codeforces rounds. His place in the first round is $$$a_1$$$, his place in the second round is $$$a_2$$$, ..., his place in the $$$n$$$-th round is $$$a_n$$$.You are given a positive non-zero integer $$$x$$$.Please, find the largest $$$v$$$ such that this person can collect all the places from $$$1$$$ to $$$v$$$ after $$$x$$$ more rated contests.In other words, you need to find the largest $$$v$$$, such that it is possible, that after $$$x$$$ more rated contests, for each $$$1 \leq i \leq v$$$, there will exist a contest where this person took the $$$i$$$-th place.For example, if $$$n=6$$$, $$$x=2$$$ and $$$a=[3,1,1,5,7,10]$$$ then answer is $$$v=5$$$, because if on the next two contest he will take places $$$2$$$ and $$$4$$$, then he will collect all places from $$$1$$$ to $$$5$$$, so it is possible to get $$$v=5$$$.","t = int(input())
for _ in range(t):
    n,x = list(map(int,input().split()))
    a = list(map(int, input().split()))
    a = list(set(a))
    a.sort()
    for i in a:
        if i<=x+1:
            x+=1
    print(x)",['implementation']
"A coordinate line has n segments, the i-th segment starts at the position li and ends at the position ri. We will denote such a segment as [li, ri].You have suggested that one of the defined segments covers all others. In other words, there is such segment in the given set, which contains all other ones. Now you want to test your assumption. Find in the given set the segment which covers all other segments, and print its number. If such a segment doesn't exist, print -1.Formally we will assume that segment [a, b] covers segment [c, d], if they meet this condition a ≤ c ≤ d ≤ b.","def main():
    number = int(raw_input())
    min0 = -1
    max0 = -1
    covn = -1
    for k in range(0, number):
        line = raw_input()
        words = line.split(' ', 1)
        l0 = int(words[0])
        r0 = int(words[1])
        if min0 == -1 or l0 < min0:
            min0 = l0
            covn = -1
        if max0 == -1 or r0 > max0:
            max0 = r0
            covn = -1
        if min0 == l0 and max0 == r0:
            covn = k+1
    print(covn)
main()","['implementation', 'sortings']"
"In some social network, there are $$$n$$$ users communicating with each other in $$$m$$$ groups of friends. Let's analyze the process of distributing some news between users.Initially, some user $$$x$$$ receives the news from some source. Then he or she sends the news to his or her friends (two users are friends if there is at least one group such that both of them belong to this group). Friends continue sending the news to their friends, and so on. The process ends when there is no pair of friends such that one of them knows the news, and another one doesn't know.For each user $$$x$$$ you have to determine what is the number of users that will know the news if initially only user $$$x$$$ starts distributing it.","import sys,bisect

from sys  import stdin,stdout

from bisect import bisect_left,bisect_right,bisect,insort,insort_left,insort_right

from math import gcd,ceil,floor,sqrt

from collections import Counter,defaultdict,deque,OrderedDict

from queue import Queue,PriorityQueue

from string import ascii_lowercase

from heapq import *

from itertools import islice


sys.setrecursionlimit(10**6)
INF = float('inf')
MOD = 998244353
mod = 10**9+7

def st():
    return list(stdin.readline().strip())

def inp():
    return int(stdin.readline())

def li():
    return list(map(int,stdin.readline().split()))

def mp():
    return map(int,stdin.readline().split())

def solve():
    n,m=mp()
    d={i:[] for i in range(1,n+1)}
    for _ in range(m):
        l=li()
        x=l[0]
        if x>1:
            for i in range(1,x):
                d[l[i]].append(l[i+1])
                d[l[i+1]].append(l[i])

    
                
    ans=[-1 for i in range(n+1)]
    vi=[-1 for i in range(n+1)]
    for i in range(1,n+1):
        
        if vi[i]==-1:
            
            vi[i]=i
            stack=[i]
            ans[i]=1
            while stack:
                a=stack.pop()
                for x in d[a]:
                    if vi[x]==-1:
                        ans[i]+=1
                        vi[x]=i
                        stack.append(x)
                    

    print(' '.join((str(ans[vi[i]]) for i in range(1,n+1))))
    

for _ in range(1):
    solve()
##    print(""Case #{}:"".format(_+1),c)
##","['dsu', 'dfs and similar', 'graphs']"
"Dark is going to attend Motarack's birthday. Dark decided that the gift he is going to give to Motarack is an array $$$a$$$ of $$$n$$$ non-negative integers.Dark created that array $$$1000$$$ years ago, so some elements in that array disappeared. Dark knows that Motarack hates to see an array that has two adjacent elements with a high absolute difference between them. He doesn't have much time so he wants to choose an integer $$$k$$$ ($$$0 \leq k \leq 10^{9}$$$) and replaces all missing elements in the array $$$a$$$ with $$$k$$$.Let $$$m$$$ be the maximum absolute difference between all adjacent elements (i.e. the maximum value of $$$|a_i - a_{i+1}|$$$ for all $$$1 \leq i \leq n - 1$$$) in the array $$$a$$$ after Dark replaces all missing elements with $$$k$$$.Dark should choose an integer $$$k$$$ so that $$$m$$$ is minimized. Can you help him?","for _ in range(int(input())):
    n = int(input())
    *a, = map(int, input().split())
    c = a.copy()
    ans, ans2 = 0, 0
    a.append(-1)
    b = [0] * n
    for i in range(n):
        if a[i] == -1:
            if i:
                if a[i - 1] + 1:
                    b[i - 1] = 1
            if n - i - 1:
                if a[i + 1] + 1:
                    b[i + 1] = 1
    b = [a[i] for i in range(n) if b[i]]
    if not b:
        print(0, 0)
        continue
    b, bb = (max(b) + min(b)) // 2, (max(b) + min(b) + 1) // 2
    for i in range(n):
        if a[i] == -1:
            a[i] = b
            c[i] = bb
    for i in range(n - 1):
        ans = max(ans, abs(a[i] - a[i + 1]))
    for i in range(n - 1):
        ans2 = max(ans2, abs(c[i] - c[i + 1]))
    if ans > ans2:
        print(ans2, bb)
    else:
        print(ans, bb)","['binary search', 'greedy', 'ternary search']"
"An online contest will soon be held on ForceCoders, a large competitive programming platform. The authors have prepared $$$n$$$ problems; and since the platform is very popular, $$$998244351$$$ coder from all over the world is going to solve them.For each problem, the authors estimated the number of people who would solve it: for the $$$i$$$-th problem, the number of accepted solutions will be between $$$l_i$$$ and $$$r_i$$$, inclusive.The creator of ForceCoders uses different criteria to determine if the contest is good or bad. One of these criteria is the number of inversions in the problem order. An inversion is a pair of problems $$$(x, y)$$$ such that $$$x$$$ is located earlier in the contest ($$$x &lt; y$$$), but the number of accepted solutions for $$$y$$$ is strictly greater.Obviously, both the creator of ForceCoders and the authors of the contest want the contest to be good. Now they want to calculate the probability that there will be no inversions in the problem order, assuming that for each problem $$$i$$$, any integral number of accepted solutions for it (between $$$l_i$$$ and $$$r_i$$$) is equally probable, and all these numbers are independent.","import sys
from itertools import chain
readline = sys.stdin.readline

MOD = 998244353
def compress(L):
    L2 = list(set(L))
    L2.sort()
    C = {v : k for k, v in enumerate(L2)}
    return L2, C


N = int(readline())
LR = [tuple(map(int, readline().split())) for _ in range(N)]
LR = [(a-1, b) for a, b in LR]
LR2 = LR[:]
ml = LR[-1][0]
res = 0
for i in range(N-2, -1, -1):
    l, r = LR[i]
    if r <= ml:
        break
    l = max(ml, l)
    ml = l
    LR[i] = (l, r)
else:
    Z = list(chain(*LR))
    Z2, Dc = compress(Z)
    
    NN = len(Z2)
    seglen = [0] + [n - p for p, n in zip(Z2, Z2[1:])]
    
    hc = [[0]*(N+3) for _ in range(NN)]
    for j in range(NN):
        hc[j][0] = 1
        for k in range(1, N+3):
            hc[j][k] = hc[j][k-1]*pow(k, MOD-2, MOD)*(seglen[j]-1+k)%MOD

    mask = [[[True]*NN]]

    dp = [[[0]*(N+1) for _ in range(NN+1)] for _ in range(N+1)]
    Dp = [[1]*(NN+1)] + [[0]*(NN+1) for _ in range(N)]
    for i in range(1, N+1):
        mask2 = [False]*NN
        l, r = LR[i-1]
        dl, dr = Dc[l], Dc[r]
        for j in range(dr, dl, -1):
            mask2[j] = True
        mm = [[m1&m2 for m1, m2 in zip(mask[-1][idx], mask2)] for idx in range(i)] + [mask2]
        mask.append(mm)
        for j in range(NN):
            for k in range(1, i+1):
                if mask[i][i-k+1][j]:
                    dp[i][j][k] = Dp[i-k][j+1]*hc[j][k]%MOD
        
        for j in range(NN-1, -1, -1):
            res = Dp[i][j+1]
            if dl < j <= dr:
                for k in range(1, i+1):        
                    res = (res + dp[i][j][k])%MOD
            Dp[i][j] = res
    
    res = Dp[N][0]
    for l, r in LR2:
        res = res*(pow(r-l, MOD-2, MOD))%MOD
print(res)","['dp', 'combinatorics', 'probabilities']"
"This problem is actually a subproblem of problem G from the same contest.There are $$$n$$$ candies in a candy box. The type of the $$$i$$$-th candy is $$$a_i$$$ ($$$1 \le a_i \le n$$$).You have to prepare a gift using some of these candies with the following restriction: the numbers of candies of each type presented in a gift should be all distinct (i. e. for example, a gift having two candies of type $$$1$$$ and two candies of type $$$2$$$ is bad). It is possible that multiple types of candies are completely absent from the gift. It is also possible that not all candies of some types will be taken to a gift.Your task is to find out the maximum possible size of the single gift you can prepare using the candies you have.You have to answer $$$q$$$ independent queries.If you are Python programmer, consider using PyPy instead of Python when you submit your code.","from __future__ import division, print_function

import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip


def ii():  return int(input())
def si():  return input()
def mi():  return map(int,input().strip().split("" ""))
def msi(): return map(str,input().strip().split("" ""))
def li():  return list(mi())

def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
    
from collections import deque,defaultdict,Counter,OrderedDict
#from collections import deque, Counter, OrderedDict,defaultdict
#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace
#from math import log,sqrt,factorial,cos,tan,sin,radians
#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
#from decimal import *
#import threading
#from itertools import permutations
#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy

abc='abcdefghijklmnopqrstuvwxyz'
abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod=1000000007
#mod=998244353
inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]
def getKey(item): return item[1] 
def sort2(l):return sorted(l, key=getKey,reverse=True)
def d2(n,m,num):return [[num for x in range(m)] for y in range(n)]
def isPowerOfTwo (x): return (x and (not(x & (x - 1))) )
def decimalToBinary(n): return bin(n).replace(""0b"","""")
def ntl(n):return [int(i) for i in str(n)]
def ncr(n,r): return factorial(n)//(factorial(r)*factorial(max(n-r,1)))

def ceil(x,y):
    if x%y==0:
        return x//y
    else:
        return x//y+1

def powerMod(x,y,p):
    res = 1
    x %= p
    while y > 0:
        if y&1:
            res = (res*x)%p
        y = y>>1
        x = (x*x)%p
    return res

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x
    
def isPrime(n) : # Check Prime Number or not 
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) : 
        if (n % i == 0 or n % (i + 2) == 0) : 
            return False
        i = i + 6
    return True



def read():
    sys.stdin = open('venv\CodeForces\input.txt', 'r')  
    sys.stdout = open('venv\CodeForces\output.txt', 'w') 

def main():
    for i in range(int(input())):
        n = int(input())
        arr= list(map(int,input().split()))
        c = Counter(arr)
        cnt = dict(c)

        done = set()
        ans = 0
        for i,j in cnt.items():
            while j in done and j>0:
                j-=1
            else:
                ans+=j
                done.add(j)

        print(ans)



    

        






# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion


if __name__ == ""__main__"":
    # read()
    main()
    # dmain()

# Comment Read()","['sortings', 'greedy']"
"You are given an array of integers $$$a_1,a_2,\ldots,a_n$$$. Find the maximum possible value of $$$a_ia_ja_ka_la_t$$$ among all five indices $$$(i, j, k, l, t)$$$ ($$$i&lt;j&lt;k&lt;l&lt;t$$$).","l=[]
for _ in range(int(input())):
    N=int(input())
    a=list(map(int,input().split()))
    a.sort()
    n=0
    p=0
    z=0
    for i in range(N):
        if a[i]<0:
            n=n+1
        elif a[i]==0:
            z=z+1
        else:
            p=p+1
    if N-z<5 and z!=0:
        l.append(0)
    elif p==0 and z!=0:
        l.append(0)
    elif p==0:
        l.append(a[-1]*a[-5]*a[-2]*a[-3]*a[-4])
    else:
        if p==1:
            l.append(a[-1]*a[0]*a[1]*a[2]*a[3])
        elif p==2:
            l.append(a[-1] * a[0] * a[1] * a[2] * a[3])
        elif p==3:
            l.append(max(a[-1] * a[0] * a[1] * a[2] * a[3],a[-1] * a[0] * a[1] * a[-3] * a[-2]))
        elif p==4:
            l.append(max(a[-1] * a[0] * a[1] * a[2] * a[3],a[-1] * a[0] * a[1] * a[-3] * a[-2]))
        elif p>=5:
            l.append(max(a[-1] * a[0] * a[1] * a[2] * a[3],a[-1] * a[0] * a[1] * a[-3] * a[-2],a[-1]*a[-2]*a[-3]*a[-4]*a[-5]))
for i in l:
    print(i)","['dp', 'greedy', 'implementation', 'sortings', 'brute force']"
