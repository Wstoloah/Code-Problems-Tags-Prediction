description,code,tags
"Polycarp has a checkered sheet of paper of size n × m. Polycarp painted some of cells with black, the others remained white. Inspired by Malevich's ""Black Square"", Polycarp wants to paint minimum possible number of white cells with black so that all black cells form a square.You are to determine the minimum possible number of cells needed to be painted black so that the black cells form a black square with sides parallel to the painting's sides. All the cells that do not belong to the square should be white. The square's side should have positive length.","from sys import stdin

n, m = map(int, stdin.readline().strip().split())
u = float('inf')
d = -float('inf')
l = float('inf')
r = -float('inf')
num_blacks = 0
for i in xrange(n):
    row = stdin.readline().strip()
    for j in xrange(m):
        if row[j] == 'B':
            if i <= u:
                u = i
            if i >= d:
                d = i
            if j <= l:
                l = j
            if j >= r:
                r = j
            num_blacks += 1

if num_blacks == 0:
    print 1
else:    
    s = max(d-u, r-l)+1
    if s > m or s > n:
        print -1
    else:
        print s*s - num_blacks",['implementation']
"You are given a text consisting of n lines. Each line contains some space-separated words, consisting of lowercase English letters.We define a syllable as a string that contains exactly one vowel and any arbitrary number (possibly none) of consonants. In English alphabet following letters are considered to be vowels: 'a', 'e', 'i', 'o', 'u' and 'y'.Each word of the text that contains at least one vowel can be divided into syllables. Each character should be a part of exactly one syllable. For example, the word ""mamma"" can be divided into syllables as ""ma"" and ""mma"", ""mam"" and ""ma"", and ""mamm"" and ""a"". Words that consist of only consonants should be ignored.The verse patterns for the given text is a sequence of n integers p1, p2, ..., pn. Text matches the given verse pattern if for each i from 1 to n one can divide words of the i-th line in syllables in such a way that the total number of syllables is equal to pi.You are given the text and the verse pattern. Check, if the given text matches the given verse pattern.","n=int(input())
patterns=list(map(int,input().split()))
texts=[]
for i in range(n):
	texts.append(input().split())

test=True

for i in range(n):
	pattern=patterns[i]
	text=texts[i]
	voyels=0
	for ch in text:
		voyels+=ch.count(""a"")+ch.count(""e"")+ch.count(""i"")+ch.count(""o"")+ch.count(""u"")+ch.count(""y"")
	if voyels!=pattern:
		test=False
		break

if test:
	print(""YES"")
else:
	print(""NO"")","['implementation', 'strings']"
"Vasiliy likes to rest after a hard work, so you may often meet him in some bar nearby. As all programmers do, he loves the famous drink ""Beecola"", which can be bought in n different shops in the city. It's known that the price of one bottle in the shop i is equal to xi coins.Vasiliy plans to buy his favorite drink for q consecutive days. He knows, that on the i-th day he will be able to spent mi coins. Now, for each of the days he want to know in how many different shops he can buy a bottle of ""Beecola"".","from bisect import bisect
n = int(input())
f = list(map(int, input().split()))
f.sort()
q = int(input())
for j in range(q):
    c = int(input())
    print(bisect(f, c) )","['dp', 'binary search', 'implementation']"
"Vasya has got three integers $$$n$$$, $$$m$$$ and $$$k$$$. He'd like to find three integer points $$$(x_1, y_1)$$$, $$$(x_2, y_2)$$$, $$$(x_3, y_3)$$$, such that $$$0 \le x_1, x_2, x_3 \le n$$$, $$$0 \le y_1, y_2, y_3 \le m$$$ and the area of the triangle formed by these points is equal to $$$\frac{nm}{k}$$$.Help Vasya! Find such points (if it's possible). If there are multiple solutions, print any of them.","#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict


BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------game starts now-----------------------------------------------------
n,m,k=map(int,input().split())
g=math.gcd(n*m,k)
d=(n*m)//g
f=k//g
#print(d,f)
if d%f!=0 and f!=2:
    print(""NO"")
else:
    j=1
    l=1
    copy1,copy2=n,m
    ch=1
    if k%2==0:
        k//=2
        ch=0
    while k%2==0:
        k//=2
        if n%2==0:
            n//=2
        else:
            m//=2
    for i in range (3,int(math.sqrt(k))+1,2):
        while k%i==0:
            k//=i
            if n%i==0:
                n//=i
            else:
                m//=i
    if k>2:
        if n%k==0:
            n//=k
        else:
            m//=k
    if ch==1:
        if n*2<=copy1:
            n*=2
        else:
            m*=2
    print(""YES"")
    print(""0 0"")
    print(0,m)
    print(n,0)","['number theory', 'geometry']"
"You are given one integer number $$$n$$$. Find three distinct integers $$$a, b, c$$$ such that $$$2 \le a, b, c$$$ and $$$a \cdot b \cdot c = n$$$ or say that it is impossible to do it.If there are several answers, you can print any.You have to answer $$$t$$$ independent test cases.","def factors(n):
    factor = []
    for i in range(2, int(n**0.5)+1):
        if n % i == 0:
            factor.append(i)
    return factor


t = int(input())
for l in range(t):
    n = int(input())
    x = 0
    factor = factors(n)
    lenfactor = len(factor)
    for i in range(lenfactor):
        for j in range(i+1, lenfactor):
            k = n/(factor[i]*factor[j])
            if k%1 == 0 and k != factor[i] and k != factor[j]:
                print('YES')
                print(str(factor[i]) + ' ' + str(factor[j]) + ' ' + str(int(k))  )
                x = 1 
                break
        if x == 1:
            break
    if x == 0:
        print('NO')","['number theory', 'greedy', 'math']"
"There are $$$n$$$ children numbered from $$$1$$$ to $$$n$$$ in a kindergarten. Kindergarten teacher gave $$$a_i$$$ ($$$1 \leq a_i \leq n$$$) candies to the $$$i$$$-th child. Children were seated in a row in order from $$$1$$$ to $$$n$$$ from left to right and started eating candies. While the $$$i$$$-th child was eating candies, he calculated two numbers $$$l_i$$$ and $$$r_i$$$ — the number of children seating to the left of him that got more candies than he and the number of children seating to the right of him that got more candies than he, respectively.Formally, $$$l_i$$$ is the number of indices $$$j$$$ ($$$1 \leq j &lt; i$$$), such that $$$a_i &lt; a_j$$$ and $$$r_i$$$ is the number of indices $$$j$$$ ($$$i &lt; j \leq n$$$), such that $$$a_i &lt; a_j$$$.Each child told to the kindergarten teacher the numbers $$$l_i$$$ and $$$r_i$$$ that he calculated. Unfortunately, she forgot how many candies she has given to each child. So, she asks you for help: given the arrays $$$l$$$ and $$$r$$$ determine whether she could have given the candies to the children such that all children correctly calculated their values $$$l_i$$$ and $$$r_i$$$, or some of them have definitely made a mistake. If it was possible, find any way how she could have done it.","import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))

def num():
	return map(int , input().split())

def nu():
	return int(input())

def find_gcd(x , y):
	while (y):
		x , y = y , x % y
	return x

n=nu()
a=li()
b=li()
z=[]
for i in range(n):
	z.append((a[i]+b[i],i))
z.sort()
fl=True
x=[]
cc=0
xp=0
mp={}
np=[]
for i in range(n):
	if(a[i]>i):
		fl=False
	if(b[i]>(n-i-1)):
		fl=False
	if((n-a[i]-b[i])<=0):
		fl=False

if(fl==False):
	print(""NO"")
else:
	zz=[0]*n
	for i in range(n):
		zz[i]=(n-a[i]-b[i])
	for i in range(n):
		xl = 0
		xr = 0
		for j in range(i + 1 , n):
			if (zz[j] > zz[i]):
				xr += 1
		for j in range(i - 1 , -1 , -1):
			if (zz[j] > zz[i]):
				xl += 1
		if (xl != a[i] or xr != b[i]):
			fl = False
			break
	if (fl == True):
		print(""YES"")
		print(*zz)
	else:
		print(""NO"")","['constructive algorithms', 'implementation']"
"A boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.","n, s = map(int, input().split())
a = sorted(map(int, input().split()), reverse = True)
b = sorted(map(int, input().split()))
i = j = 0
while i < n and j < n:
    if a[i] + b[j] < s: j += 1
    else: 
        i += 1
        j += 1
print(1, i)","['two pointers', 'binary search', 'sortings', 'greedy']"
"The Little Elephant has array a, consisting of n positive integers, indexed from 1 to n. Let's denote the number with index i as ai.The Little Elephant wants to count, how many pairs of integers l and r are there, such that 1 ≤ l &lt; r ≤ n and sequence b = a1a2... alarar + 1... an has no more than k inversions. An inversion in sequence b is a pair of elements of the sequence b, that change their relative order after a stable sorting of the sequence. In other words, an inversion is a pair of integers i and j, such that 1 ≤ i &lt; j ≤ |b| and bi &gt; bj, where |b| is the length of sequence b, and bj is its j-th element.Help the Little Elephant and count the number of the described pairs.","# 220E
import sys
from collections import defaultdict
 
class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * n
    
    def _F(self, i):
        return i & (i + 1)
    
    def _get_sum(self, r):
        '''
        sum on interval [0, r)
        '''
        result = 0
        while r > 0:
            result += self.tree[r-1]
            r = self._F(r-1)
        return result
    
    def get_sum(self, l, r):
        '''
        sum on interval [l, r)
        '''
        return self._get_sum(r) - self._get_sum(l)
    
    def _H(self, i):
        return i | (i + 1)
    
    def add(self, i, value=1):
        while i < self.n:
            self.tree[i] += value
            i = self._H(i)

reader = (line.rstrip() for line in sys.stdin)
input = reader.__next__

n, k = map(int, input().split())
a = list(map(int, input().split()))

pos = defaultdict(list)
for i, val in enumerate(a):
    pos[val].append(i)

i = 0
prev = -1
for val in sorted(a):
    if prev == val: continue
    for j in pos[val]:
        a[j] = i
    i += 1
    prev = val

left = BIT(n)
right = BIT(n)
total_inv = 0

left.add(a[0])
for t in range(1, n):
    i = a[t]
    total_inv += right.get_sum(i+1, n)
    right.add(i)
    if i < a[0]:
        total_inv += 1

if total_inv <= k:
    print((n*(n-1))>>1)
    sys.exit()

l = 0
r = 1
while r < n and total_inv > k:
    total_inv -= left.get_sum(a[r]+1, n) + right.get_sum(0, a[r])
    right.add(a[r], -1)
    r += 1

pairs = 0
while r < n:
    while True:
        add = left.get_sum(a[l+1]+1, n) + right.get_sum(0, a[l+1])
        if total_inv + add > k:
            pairs += l + 1
            break
        else:
            l += 1
            total_inv += add
            left.add(a[l])
    total_inv -= left.get_sum(a[r]+1, n) + right.get_sum(0, a[r])
    right.add(a[r], -1)
    r += 1
print(pairs)","['data structures', 'two pointers']"
"The spring is coming and it means that a lot of fruits appear on the counters. One sunny day little boy Valera decided to go shopping. He made a list of m fruits he wanted to buy. If Valera want to buy more than one fruit of some kind, he includes it into the list several times. When he came to the fruit stall of Ashot, he saw that the seller hadn't distributed price tags to the goods, but put all price tags on the counter. Later Ashot will attach every price tag to some kind of fruits, and Valera will be able to count the total price of all fruits from his list. But Valera wants to know now what can be the smallest total price (in case of the most «lucky» for him distribution of price tags) and the largest total price (in case of the most «unlucky» for him distribution of price tags).","t, f = [int(x) for x in raw_input().split()]
prices1 = sorted([int(x) for x in raw_input().split()])
prices2 = prices1[::-1]
fruit = {}
for n in xrange(f):
    s = raw_input()
    if s in fruit:
        fruit[s] += 1
    else:
        fruit[s] = 1
l = []
for k in fruit:
    l.append(fruit[k])
l = sorted(l)[::-1]
low = 0
high = 0
for i, li in enumerate(l):
    low += li * prices1[i]
    high += li * prices2[i]
print low, high","['implementation', 'sortings', 'greedy']"
"Vasya's telephone contains n photos. Photo number 1 is currently opened on the phone. It is allowed to move left and right to the adjacent photo by swiping finger over the screen. If you swipe left from the first photo, you reach photo n. Similarly, by swiping right from the last photo you reach photo 1. It takes a seconds to swipe from photo to adjacent.For each photo it is known which orientation is intended for it — horizontal or vertical. Phone is in the vertical orientation and can't be rotated. It takes b second to change orientation of the photo.Vasya has T seconds to watch photos. He want to watch as many photos as possible. If Vasya opens the photo for the first time, he spends 1 second to notice all details in it. If photo is in the wrong orientation, he spends b seconds on rotating it before watching it. If Vasya has already opened the photo, he just skips it (so he doesn't spend any time for watching it or for changing its orientation). It is not allowed to skip unseen photos.Help Vasya find the maximum number of photos he is able to watch during T seconds.","def main():
    n, a, b, t = map(int, input().split())
    b += 1
    l = [b if char == ""w"" else 1 for char in input()]
    t -= sum(l) - a * (n + 2)
    hi, n2 = n, n * 2
    n21 = n2 + 1
    lo = res = 0
    l *= 2
    while lo <= n and hi < n2:
        t -= l[hi]
        hi += 1
        b = hi - n
        while lo < b or (hi - lo + min(hi, n21 - lo)) * a > t:
            t += l[lo]
            lo += 1
        if res < hi - lo:
            res = hi - lo
            if res == n:
                break
    print(res)


if __name__ == '__main__':
    main()","['dp', 'two pointers', 'binary search', 'brute force']"
"First-rate specialists graduate from Berland State Institute of Peace and Friendship. You are one of the most talented students in this university. The education is not easy because you need to have fundamental knowledge in different areas, which sometimes are not related to each other. For example, you should know linguistics very well. You learn a structure of Reberland language as foreign language. In this language words are constructed according to the following rules. First you need to choose the ""root"" of the word — some string which has more than 4 letters. Then several strings with the length 2 or 3 symbols are appended to this word. The only restriction —  it is not allowed to append the same string twice in a row. All these strings are considered to be suffixes of the word (this time we use word ""suffix"" to describe a morpheme but not the few last characters of the string as you may used to). Here is one exercise that you have found in your task list. You are given the word s. Find all distinct strings with the length 2 or 3, which can be suffixes of this word according to the word constructing rules in Reberland language. Two strings are considered distinct if they have different length or there is a position in which corresponding characters do not match. Let's look at the example: the word abacabaca is given. This word can be obtained in the following ways: , where the root of the word is overlined, and suffixes are marked by ""corners"". Thus, the set of possible suffixes for this word is {aca, ba, ca}.","s = input()
n = len(s)
res = set()

from collections import defaultdict

two = [""$"", """", ""$""]
thr = [""$"", """", ""$""]

works = lambda w, i : (two[i] != ""$"" and w != two[i]) or (thr[i] != ""$"" and w != thr[i])

i = n - 2
while i > 4:
    ntwo = s[i: i + 2]
    if works(ntwo, 1):
        res.add(ntwo)
    else:
        ntwo = ""$""    

    if (i <= n - 3):
        nthr = s[i: i + 3]
        if works(nthr, 2):
            res.add(nthr)
        else:
            nthr = ""$""
    else:
        nthr = ""$""

    two = [ntwo] + two[0:2]
    thr = [nthr] + thr[0:2]
    i -= 1

res = list(res)
res.sort()

print(len(res))
for word in res:
    print(word)","['dp', 'strings']"
"You are given an array $$$a$$$ consisting of $$$n$$$ non-negative integers. You have to choose a non-negative integer $$$x$$$ and form a new array $$$b$$$ of size $$$n$$$ according to the following rule: for all $$$i$$$ from $$$1$$$ to $$$n$$$, $$$b_i = a_i \oplus x$$$ ($$$\oplus$$$ denotes the operation bitwise XOR).An inversion in the $$$b$$$ array is a pair of integers $$$i$$$ and $$$j$$$ such that $$$1 \le i &lt; j \le n$$$ and $$$b_i &gt; b_j$$$.You should choose $$$x$$$ in such a way that the number of inversions in $$$b$$$ is minimized. If there are several options for $$$x$$$ — output the smallest one.","#!/usr/bin/env python
from __future__ import division, print_function

import os
import sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip


def main():
    n = int(input())
    l = list(map(int, input().split()))

    inv = 0
    out = 0
    mult = 1
    for i in range(32):
        curr = dict()
        opp = 0
        same = 0

        for v in l:
            if v ^ 1 in curr:
                if v & 1:
                    opp += curr[v ^ 1]
                else:
                    same += curr[v ^ 1]

            if v not in curr:
                curr[v] = 0
            curr[v] += 1

        for i in range(n):
            l[i] >>= 1

        if same <= opp:
            inv += same
        else:
            inv += opp
            out += mult
        mult *= 2
    print(inv, out)


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()","['dp', 'greedy', 'bitmasks', 'math', 'divide and conquer', 'sortings', 'data structures', 'trees', 'strings']"
"One Big Software Company has n employees numbered from 1 to n. The director is assigned number 1. Every employee of the company except the director has exactly one immediate superior. The director, of course, doesn't have a superior.We will call person a a subordinates of another person b, if either b is an immediate supervisor of a, or the immediate supervisor of a is a subordinate to person b. In particular, subordinates of the head are all other employees of the company.To solve achieve an Important Goal we need to form a workgroup. Every person has some efficiency, expressed by a positive integer ai, where i is the person's number. The efficiency of the workgroup is defined as the total efficiency of all the people included in it.The employees of the big software company are obsessed with modern ways of work process organization. Today pair programming is at the peak of popularity, so the workgroup should be formed with the following condition. Each person entering the workgroup should be able to sort all of his subordinates who are also in the workgroup into pairs. In other words, for each of the members of the workgroup the number of his subordinates within the workgroup should be even.Your task is to determine the maximum possible efficiency of the workgroup formed at observing the given condition. Any person including the director of company can enter the workgroup.","n = int(input())
t = [list(map(int, input().split())) for q in range(n)]
n += 1
u = [-1e7] * n
v = [0] * n
for i, (j, a) in list(enumerate(t, 1))[::-1]:
    u[i] = max(u[i], v[i] + a)
    v[j], u[j] = max(v[j] + v[i], u[j] + u[i]), max(v[j] + u[i], u[j] + v[i])
print(u[1])","['dp', 'graphs', 'dfs and similar', 'trees', 'strings']"
"In Chelyabinsk lives a much respected businessman Nikita with a strange nickname ""Boss"". Once Nikita decided to go with his friend Alex to the Summer Biathlon World Cup. Nikita, as a very important person, received a token which allows to place bets on each section no more than on one competitor.To begin with friends learned the rules: in the race there are n sections of equal length and m participants. The participants numbered from 1 to m. About each participant the following is known: li — the number of the starting section,  ri — the number of the finishing section (li ≤ ri), ti — the time a biathlete needs to complete an section of the path, ci — the profit in roubles. If the i-th sportsman wins on one of the sections, the profit will be given to the man who had placed a bet on that sportsman. The i-th biathlete passes the sections from li to ri inclusive. The competitor runs the whole way in (ri - li + 1)·ti time units. It takes him exactly ti time units to pass each section. In case of the athlete's victory on k sections the man who has betted on him receives k·ci roubles.In each section the winner is determined independently as follows: if there is at least one biathlete running this in this section, then among all of them the winner is the one who has ran this section in minimum time (spent minimum time passing this section). In case of equality of times the athlete with the smaller index number wins. If there are no participants in this section, then the winner in this section in not determined. We have to say that in the summer biathlon all the participants are moving at a constant speed.We should also add that Nikita can bet on each section and on any contestant running in this section.Help the friends find the maximum possible profit.","n,m = map(int,input().split())
l = []
for i in range(m):
    la,r,t,c = map(int,input().split())
    l.append([la,r,t,c])
cost = 0
for i in range(n):
    min_time = 10**12
    for j in range(m):
        if l[j][0]<=i+1<=l[j][1]:
            if l[j][2]<min_time:
                min_time = l[j][2]
                ans = j
    if min_time!=10**12:
        cost+=l[ans][3]

print(cost)","['implementation', 'greedy']"
"Vasya the Great Magician and Conjurer loves all kinds of miracles and wizardry. In one wave of a magic wand he can turn an object into something else. But, as you all know, there is no better magic in the Universe than the magic of numbers. That's why Vasya adores math and spends a lot of time turning some numbers into some other ones.This morning he has n cards with integers lined up in front of him. Each integer is not less than 1, but not greater than l. When Vasya waves his magic wand, two rightmost cards vanish from the line and a new card magically appears in their place. It contains the difference between the left and the right numbers on the two vanished cards. Vasya was very interested to know what would happen next, and so he waved with his magic wand on and on, until the table had a single card left.Suppose that Vasya originally had the following cards: 4, 1, 1, 3 (listed from left to right). Then after the first wave the line would be: 4, 1, -2, and after the second one: 4, 3, and after the third one the table would have a single card with number 1.Please note that in spite of the fact that initially all the numbers on the cards were not less than 1 and not greater than l, the numbers on the appearing cards can be anything, no restrictions are imposed on them.It is now evening. Vasya is very tired and wants to return everything back, but does not remember which cards he had in the morning. He only remembers that there were n cards, they contained integers from 1 to l, and after all magical actions he was left with a single card containing number d.Help Vasya to recover the initial set of cards with numbers.","n,d,l=map(int,input().split())
e=(n+1)//2
o=n-e
ans=[1]*n
#if n%2 and d==0 and l==1:
#	print(-1)
#	exit()
#elif d==0:
#	ans[1]+=n%2
#	print(*ans)
#	exit()	

if d>0:
	cur=e-o
	rem=d-cur
	for i in range(0,n,2):
		if rem>0:
			ans[i]+=min(l-1,rem)
			rem-=min((l-1),rem)
	if rem>0:
		print(-1)
		exit()
	print(*ans)
else:
	cur=e-o
	rem=d-cur
	for i in range(1,n,2):
		if rem<0:
			ans[i]+=min(l-1,-rem)
			rem+=min(l-1,-rem)
	if rem<0:
		print(-1)
		exit()
	print(*ans)","['constructive algorithms', 'greedy']"
"Little C loves number «3» very much. He loves all things about it.Now he has a positive integer $$$n$$$. He wants to split $$$n$$$ into $$$3$$$ positive integers $$$a,b,c$$$, such that $$$a+b+c=n$$$ and none of the $$$3$$$ integers is a multiple of $$$3$$$. Help him to find a solution.","n = int(input())

if n % 2 != 0:
    n = n - 1
    a = n // 2
    b = n - a
    while a % 3 == 0 or b % 3 == 0:
        a = a + 1
        b = b - 1
    print(1 , a , b)
else:
    n = n - 2
    a = n // 2
    b = n - a
    while a % 3 == 0 or b % 3 == 0:
        a = a + 1
        b = b - 1
    print(2 , a , b)",['math']
"Little beaver is a beginner programmer, so informatics is his favorite subject. Soon his informatics teacher is going to have a birthday and the beaver has decided to prepare a present for her. He planted n flowers in a row on his windowsill and started waiting for them to grow. However, after some time the beaver noticed that the flowers stopped growing. The beaver thinks it is bad manners to present little flowers. So he decided to come up with some solutions. There are m days left to the birthday. The height of the i-th flower (assume that the flowers in the row are numbered from 1 to n from left to right) is equal to ai at the moment. At each of the remaining m days the beaver can take a special watering and water w contiguous flowers (he can do that only once at a day). At that each watered flower grows by one height unit on that day. The beaver wants the height of the smallest flower be as large as possible in the end. What maximum height of the smallest flower can he get?","n,m,w=map(int,input().split())
a=list(map(int,input().split()))

def check(x):
    b=[0]*n
    cur=cnt=0
    for i in range(n):
        if i-w>=0:
            cur-=b[i-w]
        if a[i]+cur<x:
            b[i]=x-a[i]-cur
            cur+=b[i]
            cnt+=b[i]
        if cnt>m:
            return 0
    return 1

left=1
right=1e9+1e6
ans=0
while left<=right:
    mid=(left+right)//2
    if check(mid):
        left=mid+1
        ans=mid
    else:
        right=mid-1

print(int(ans))","['data structures', 'binary search', 'greedy']"
"ZS the Coder and Chris the Baboon arrived at the entrance of Udayland. There is a n × n magic grid on the entrance which is filled with integers. Chris noticed that exactly one of the cells in the grid is empty, and to enter Udayland, they need to fill a positive integer into the empty cell.Chris tried filling in random numbers but it didn't work. ZS the Coder realizes that they need to fill in a positive integer such that the numbers in the grid form a magic square. This means that he has to fill in a positive integer so that the sum of the numbers in each row of the grid (), each column of the grid (), and the two long diagonals of the grid (the main diagonal —  and the secondary diagonal — ) are equal. Chris doesn't know what number to fill in. Can you help Chris find the correct positive integer to fill in or determine that it is impossible?","n=input()
if n<2:
  print 1
  exit(0)
N=range(n)
a=[map(int,raw_input().split()) for _ in N]
i=[i for i in N if 0 in a[i]][0]
a[i][a[i].index(0)]=x=sum(a[not i])-sum(a[i])
b=zip(*a)
print x if x>0 and len(set(map(sum,a)+map(sum,b)+[sum(a[i][i] for i in N)]+[sum(a[i][-1-i] for i in N)]))==1 else -1","['constructive algorithms', 'implementation']"
"Yura is tasked to build a closed fence in shape of an arbitrary non-degenerate simple quadrilateral. He's already got three straight fence segments with known lengths $$$a$$$, $$$b$$$, and $$$c$$$. Now he needs to find out some possible integer length $$$d$$$ of the fourth straight fence segment so that he can build the fence using these four segments. In other words, the fence should have a quadrilateral shape with side lengths equal to $$$a$$$, $$$b$$$, $$$c$$$, and $$$d$$$. Help Yura, find any possible length of the fourth side.A non-degenerate simple quadrilateral is such a quadrilateral that no three of its corners lie on the same line, and it does not cross itself.","for _ in range(int(input())):
    num = list(map(int, input().split()))
    q = 0
    num.sort()
    c = num[0]
    a = num[1]
    b = num[2]
    print(int((((b - c) ** 2 + a ** 2) ** 0.5)))","['geometry', 'math']"
"Some time ago Leonid have known about idempotent functions. Idempotent function defined on a set {1, 2, ..., n} is such function , that for any  the formula g(g(x)) = g(x) holds.Let's denote as f(k)(x) the function f applied k times to the value x. More formally, f(1)(x) = f(x), f(k)(x) = f(f(k - 1)(x)) for each k &gt; 1.You are given some function . Your task is to find minimum positive integer k such that function f(k)(x) is idempotent.","from random import randint
from copy import deepcopy

n = int(input())
a = list(map(int, input().split()))
for i in range(n):
    a[i] -= 1

def gen(n):
    a = []
    for i in range(n):
        a.append(randint(0, n - 1))
    return a

def stupid(a, v=False):
    n = len(a)
    init = [a[i] for i in range(n)]
        
    k = 1
    good = False
    while not good:
        good = True
        if v:
            print(a)
        for i in range(n):
            if a[a[i]] != a[i]:
                good = False
        if good:
            break
        k += 1
        b = [0 for i in range(n)]
        for i in range(n):
            b[i] = init[a[i]]

        a = [b[i] for i in range(n)]

    return k

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def get_lcm(a, b):
    return a * b // gcd(a, b)

def solve(a, v=False):
    n = len(a)
    d = [0 for i in range(n)]
    on_cycle = [False for i in range(n)]
    cycle_length = [0 for i in range(n)]
    until = [0 for i in range(n)]
    to_len = [0 for i in range(n)]

    for i in range(n):
        if a[i] == i:
            on_cycle[i] = True
            cycle_length[i] = 1
            continue
        cur = i
        cnt = 1
        for j in range(3 * n):
            cur = a[cur]
            cnt += cur == i
        on_cycle[i] = cnt > 1

        if on_cycle[i]:
            cur = i
            steps = 0
            for j in range(3 * n):
                cur = a[cur]
                steps += 1
                if cur == i:
                    break
            cycle_length[i] = steps


    for i in range(n):
        if not on_cycle[i]:
            cur = i
            steps = 0
            for j in range(n + 1):
                cur = a[cur]
                steps += 1
                if on_cycle[cur]:
                    break
            until[i] = steps
            to_len[i] = cycle_length[cur]

    if v:
        print('cycle', cycle_length)
        print('until', until)
    lcm = 1
    low = 0
    for i in range(n):
        if on_cycle[i]:
            lcm = get_lcm(lcm, cycle_length[i])
        else:
            low = max(low, until[i])
            continue
            to = to_len[i]
            p = until[i]
            
            if p % to:
                p = ((p // to) + 1) * to
            low = max(low, p)
            if v:
                print(i, p, to)
    ans = lcm
    while ans < low:
        ans += lcm
    return ans

print(solve(a))
while False:
    a = gen(randint(1, 15))
    print(a)
    print(stupid(deepcopy(a)))
    print(solve(deepcopy(a)))
    assert(stupid(deepcopy(a)) == solve(deepcopy(a)))","['constructive algorithms', 'graphs', 'math']"
"You are given a range of positive integers from $$$l$$$ to $$$r$$$.Find such a pair of integers $$$(x, y)$$$ that $$$l \le x, y \le r$$$, $$$x \ne y$$$ and $$$x$$$ divides $$$y$$$.If there are multiple answers, print any of them.You are also asked to answer $$$T$$$ independent queries.","t=int(input())
for _ in range(t):
    l,r=map(int,input().split())
    print(l,l*2)","['implementation', 'greedy', 'math']"
Little Petya likes points a lot. Recently his mom has presented him n points lying on the line OX. Now Petya is wondering in how many ways he can choose three distinct points so that the distance between the two farthest of them doesn't exceed d.Note that the order of the points inside the group of three chosen points doesn't matter.,"import bisect

N, D = map(int, input().split())

A = list(map(int, input().split()))
A.sort()

ans = 0
for i in range(N):
    X = bisect.bisect_left(A, A[i] - D)
    temp = i - X
    ans += max(0, (temp * (temp - 1))//2)
print(ans)","['combinatorics', 'binary search', 'two pointers']"
"John Doe started thinking about graphs. After some thought he decided that he wants to paint an undirected graph, containing exactly k cycles of length 3. A cycle of length 3 is an unordered group of three distinct graph vertices a, b and c, such that each pair of them is connected by a graph edge. John has been painting for long, but he has not been a success. Help him find such graph. Note that the number of vertices there shouldn't exceed 100, or else John will have problems painting it.","n, k = 0, int(input())
p = [['0'] * 100 for i in range(100)]
while k:
    for i in range(n):
        if i > k: break
        p[n][i] = p[i][n] = '1'
        k -= i
    n += 1
print(n)
for i in range(n): print(''.join(p[i][:n]))","['constructive algorithms', 'binary search', 'greedy', 'graphs']"
"Berland scientists noticed long ago that the world around them depends on Berland population. Due to persistent research in this area the scientists managed to find out that the Berland chronology starts from the moment when the first two people came to that land (it is considered to have happened in the first year). After one Berland year after the start of the chronology the population had already equaled 13 people (the second year). However, tracing the population number during the following years was an ultimately difficult task, still it was found out that if di — the number of people in Berland in the year of i, then either di = 12di - 2, or di = 13di - 1 - 12di - 2. Of course no one knows how many people are living in Berland at the moment, but now we can tell if there could possibly be a year in which the country population equaled A. That's what we ask you to determine. Also, if possible, you have to find out in which years it could be (from the beginning of Berland chronology). Let's suppose that it could be in the years of a1, a2, ..., ak. Then you have to define how many residents could be in the country during those years apart from the A variant. Look at the examples for further explanation.","a = int(input())
ans = set()
def work(i, z, y):
    z.add(y)
    # print("">>"", i, y)
    if y == a:
        ans.add(i)
    if len(z) > 1000:
        z.remove(max(z))

pos = [set(), set([2])]
for i in range(2):
    for x in pos[i]:
        if x == a:
            ans.add(i)

def dfs(i, last, cur):
    if i > 988:
        return
    while len(pos) - 1 < i:
        pos.append(set())
    if len(pos[i]) == 0 and cur > a:
        return
    if cur in pos[i]:
        return
    work(i, pos[i], cur)
    dfs(i + 1, cur, last * 12)
    dfs(i + 1, cur, cur * 13 - last * 12)

dfs(2, 2, 13)

if len(ans) == 0:
    print(""NO"")
else:
    print(""YES"")
    count = 0
    print(min(1000, len(ans)))
    z = set()
    for i in sorted(ans):
        if count < 1000:
            print(i)
            count += 1
        for y in pos[i]:
            if y != a:
                z.add(y)
            if len(z) > 1000:
                z.remove(max(z))
    count = 0
    print(min(1000, len(z)))
    for i in sorted(z):
        print(i)
        count += 1
        if count >= 1000:
            break",['math']
"Alice and Bob play ping-pong with simplified rules.During the game, the player serving the ball commences a play. The server strikes the ball then the receiver makes a return by hitting the ball back. Thereafter, the server and receiver must alternately make a return until one of them doesn't make a return.The one who doesn't make a return loses this play. The winner of the play commences the next play. Alice starts the first play.Alice has $$$x$$$ stamina and Bob has $$$y$$$. To hit the ball (while serving or returning) each player spends $$$1$$$ stamina, so if they don't have any stamina, they can't return the ball (and lose the play) or can't serve the ball (in this case, the other player serves the ball instead). If both players run out of stamina, the game is over.Sometimes, it's strategically optimal not to return the ball, lose the current play, but save the stamina. On the contrary, when the server commences a play, they have to hit the ball, if they have some stamina left.Both Alice and Bob play optimally and want to, firstly, maximize their number of wins and, secondly, minimize the number of wins of their opponent.Calculate the resulting number of Alice's and Bob's wins.","from collections import Counter, defaultdict, deque
import bisect
from sys import stdin, stdout
from itertools import repeat
import math


def inp(force_list=False):
    re = map(int, raw_input().split())
    if len(re) == 1 and not force_list:
        return re[0]
    return re

def inst():
    return raw_input().strip()

def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

mod = 1000000007

def my_main():
    kase = inp()
    ans = []
    for i in range(kase):
        x, y = inp()
        if x==y:
            ans.append(""%s %s"" % (x-1, x))
        elif x>y:
            ans.append(""%s %s"" % (x-1, y))
        else:
            ans.append(""%s %s"" % (x-1, y))
    print '\n'.join(ans)
my_main()","['constructive algorithms', 'games', 'math']"
"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.You are given an integer n no less than 12, express it as a sum of two composite numbers.","n = int(raw_input().strip())
if n%2==0:
  print '4 ' +str(n-4)
else:
  print '9 ' +str(n-9)","['number theory', 'math']"
"You wrote down all integers from $$$0$$$ to $$$10^n - 1$$$, padding them with leading zeroes so their lengths are exactly $$$n$$$. For example, if $$$n = 3$$$ then you wrote out 000, 001, ..., 998, 999.A block in an integer $$$x$$$ is a consecutive segment of equal digits that cannot be extended to the left or to the right.For example, in the integer $$$00027734000$$$ there are three blocks of length $$$1$$$, one block of length $$$2$$$ and two blocks of length $$$3$$$.For all integers $$$i$$$ from $$$1$$$ to $$$n$$$ count the number of blocks of length $$$i$$$ among the written down integers.Since these integers may be too large, print them modulo $$$998244353$$$.","#                                               |
#   _` |  __ \    _` |   __|   _ \   __ \    _` |   _` |
#  (   |  |   |  (   |  (     (   |  |   |  (   |  (   |
# \__,_| _|  _| \__,_| \___| \___/  _|  _| \__,_| \__,_|

import sys

def read_line():
	return sys.stdin.readline()[:-1]
 
def read_int():
	return int(sys.stdin.readline())
 
def read_int_line():
	return [int(v) for v in sys.stdin.readline().split()]

def power(x, y, p) : 
    res = 1     # Initialize result 
  
    # Update x if it is more 
    # than or equal to p 
    x = x % p  
  
    while (y > 0) : 
          
        # If y is odd, multiply 
        # x with result 
        if ((y & 1) == 1) : 
            res = (res * x) % p 
  
        # y must be even now 
        y = y >> 1      # y = y/2 
        x = (x * x) % p 
          
    return res 

n = read_int()
d = [0]*n
p = 998244353
d[n-1] = 10
if n>1:
	d[n-2] = 180
	for i in range(n-3,-1,-1):
		a1 = ((10*(n-i)*9*9)%p*power(10,n-i-3,p))%p
		a2 = (2*10*9*power(10,n-i-3,p))%p
		d[i] = (a1+a2)%p

print(*d)","['dp', 'combinatorics', 'math']"
"Okabe likes to take walks but knows that spies from the Organization could be anywhere; that's why he wants to know how many different walks he can take in his city safely. Okabe's city can be represented as all points (x, y) such that x and y are non-negative. Okabe starts at the origin (point (0, 0)), and needs to reach the point (k, 0). If Okabe is currently at the point (x, y), in one step he can go to (x + 1, y + 1), (x + 1, y), or (x + 1, y - 1).Additionally, there are n horizontal line segments, the i-th of which goes from x = ai to x = bi inclusive, and is at y = ci. It is guaranteed that a1 = 0, an ≤ k ≤ bn, and ai = bi - 1 for 2 ≤ i ≤ n. The i-th line segment forces Okabe to walk with y-value in the range 0 ≤ y ≤ ci when his x value satisfies ai ≤ x ≤ bi, or else he might be spied on. This also means he is required to be under two line segments when one segment ends and another begins.Okabe now wants to know how many walks there are from the origin to the point (k, 0) satisfying these conditions, modulo 109 + 7.","def mul(a, b):
    n = len(a)
    c = [[0] * n for i in xrange(n)]
    for k in xrange(n):
        for i in xrange(n):
            for j in xrange(n):
                c[i][j] += a[i][k] * b[k][j]
                c[i][j] %= 1000000007
    return c
def mulv(a, v):
    l = len(v)
    n = len(a)
    r = [0] * l
    for i in xrange(n):
        for j in xrange(n):
            r[i] += a[i][j] * v[j]
            r[i] %= 1000000007
    return r
B = []
for c in xrange(16):
    A = [[0] * (c + 1) for i in xrange(c + 1)]
    for i in xrange(c + 1):
        if i:
            A[i][i-1] = 1
        A[i][i] = 1
        if i < c:
            A[i][i+1] = 1
    l = [A]
    for j in xrange(60):
        l.append(mul(l[-1], l[-1]))
    B.append(l)
def getb(c, l, dp):
    for i in xrange(60):
        if l >> i & 1:
            dp = mulv(B[c][i], dp)
    return dp
n, k = map(int, raw_input().split())
x = 0
dp = [0] * 16
dp[0] = 1
for _ in xrange(n):
    a, b, c = map(int, raw_input().split())
    if b == a:
        for i in xrange(c + 1, 16):
            dp[i] = 0
    elif b >= k > a:
        dp = getb(c, k - a, dp)
        print dp[0]
        quit()
    else:
        dp = getb(c, b - a, dp)
    x = b
print dp[0]","['dp', 'matrices']"
"A recently found Ancient Prophesy is believed to contain the exact Apocalypse date. The prophesy is a string that only consists of digits and characters ""-"".We'll say that some date is mentioned in the Prophesy if there is a substring in the Prophesy that is the date's record in the format ""dd-mm-yyyy"". We'll say that the number of the date's occurrences is the number of such substrings in the Prophesy. For example, the Prophesy ""0012-10-2012-10-2012"" mentions date 12-10-2012 twice (first time as ""0012-10-2012-10-2012"", second time as ""0012-10-2012-10-2012"").The date of the Apocalypse is such correct date that the number of times it is mentioned in the Prophesy is strictly larger than that of any other correct date.A date is correct if the year lies in the range from 2013 to 2015, the month is from 1 to 12, and the number of the day is strictly more than a zero and doesn't exceed the number of days in the current month. Note that a date is written in the format ""dd-mm-yyyy"", that means that leading zeroes may be added to the numbers of the months or days if needed. In other words, date ""1-1-2013"" isn't recorded in the format ""dd-mm-yyyy"", and date ""01-01-2013"" is recorded in it.Notice, that any year between 2013 and 2015 is not a leap year.","import re

def c(d):
    d,m,y=map(int,d.split('-'))
    M=set([1,3,5,7,8,10,12])
    return y > 2012 and y< 2016 and d>0and(d<29 and m==2 or d<32 and m in M or d<30 and m in (set(range(4,13))-M))
    
    
d=re.findall(""(?=(\d\d-\d\d-\d{4}))"", raw_input())
r={}
for i in d:
    r[i]=r.get(i,0)+c(i)

print max(r.items(), key=lambda y:y[1])[0]","['implementation', 'brute force', 'strings']"
This is the easy version of the problem. The difference between the versions is in the number of possible operations that can be made. You can make hacks if and only if you solved both versions of the problem.You are given a binary table of size $$$n \times m$$$. This table consists of symbols $$$0$$$ and $$$1$$$.You can make such operation: select $$$3$$$ different cells that belong to one $$$2 \times 2$$$ square and change the symbols in these cells (change $$$0$$$ to $$$1$$$ and $$$1$$$ to $$$0$$$).Your task is to make all symbols in the table equal to $$$0$$$. You are allowed to make at most $$$3nm$$$ operations. You don't need to minimize the number of operations.It can be proved that it is always possible.,"for tc in range(int(input())):
    n,m = map(int,input().split())
    l = []
    ans = []
    cnt = 0
    def c(i,j):
        l[i][j] = 1 - l[i][j]
    for i in range(n):
        l.append(list(map(int,list(input()))))
    for i in range(n-1):
        for j in range(m-1):
            if l[i][j] == 1:
                #print(i+1,j+1,i+2,j+1,i+2,j+2)
                ans.append([i+1,j+1,i+2,j+1,i+2,j+2])
                c(i,j)
                c(i+1,j)
                c(i+1,j+1)
                cnt += 1
        if l[i][-1] == 1:
            #print(i+1,m,i+2,m,i+2,m-1)
            ans.append([i+1,m,i+2,m,i+2,m-1])
            c(i,m-1)
            c(i+1,m-1)
            c(i+1,m-2)
            cnt += 1
    for i in range(m-1):
        if l[-1][i] == 1:
            #print(n,i+1,n-1,i+1,n-1,i+2)
            #print(n-1,i+2,n,i+1,n,i+2)
            #print(n-1,i+1,n,i+1,n,i+2)
            ans.append([n,i+1,n-1,i+1,n-1,i+2])
            ans.append([n-1,i+2,n,i+1,n,i+2])
            ans.append([n-1,i+1,n,i+1,n,i+2])
            cnt += 3
            l[-1][i] = 0
    if l[-1][-1] == 1:
        #print(n,m,n-1,m-1,n-1,m)
        #print(n-1,m,n,m,n,m-1)
        #print(n,m,n,m-1,n-1,m-1)
        ans.append([n,m,n-1,m-1,n-1,m])
        ans.append([n-1,m,n,m,n,m-1])
        ans.append([n,m,n,m-1,n-1,m-1])
        cnt += 3
    print(cnt)
    for i in ans:
        print(' '.join([str(j) for j in i]))","['constructive algorithms', 'implementation']"
"Limak is a little polar bear. He plays by building towers from blocks. Every block is a cube with positive integer length of side. Limak has infinitely many blocks of each side length.A block with side a has volume a3. A tower consisting of blocks with sides a1, a2, ..., ak has the total volume a13 + a23 + ... + ak3.Limak is going to build a tower. First, he asks you to tell him a positive integer X — the required total volume of the tower. Then, Limak adds new blocks greedily, one by one. Each time he adds the biggest block such that the total volume doesn't exceed X.Limak asks you to choose X not greater than m. Also, he wants to maximize the number of blocks in the tower at the end (however, he still behaves greedily). Secondarily, he wants to maximize X.Can you help Limak? Find the maximum number of blocks his tower can have and the maximum X ≤ m that results this number of blocks.","MAX = 100005

def big_pow3(n):
    l = 0; p = MAX
    while p-l != 1:
        mid = (p+l+1)//2
        if (mid*mid*mid <= n):
            l = mid
        else:
            p = mid
    return l

def f(n):
    if n < 8:
        return [n, n]
    a = int((n+ 0.5) ** 0.33333333333333333)
    r1 = f(n-a**3)
    r1 = [r1[0] + 1, r1[1] + a**3]
    a -= 1
    r2 = f(3*a*(a+1))
    r2 = [r2[0] + 1, r2[1] + a**3]
    return max(r1, r2)
        

if __name__ == ""__main__"":
    m = int(input()) 
    print(*f(m))","['dp', 'binary search', 'greedy']"
"Let's denote correct match equation (we will denote it as CME) an equation $$$a + b = c$$$ there all integers $$$a$$$, $$$b$$$ and $$$c$$$ are greater than zero.For example, equations $$$2 + 2 = 4$$$ (||+||=||||) and $$$1 + 2 = 3$$$ (|+||=|||) are CME but equations $$$1 + 2 = 4$$$ (|+||=||||), $$$2 + 2 = 3$$$ (||+||=|||), and $$$0 + 1 = 1$$$ (+|=|) are not.Now, you have $$$n$$$ matches. You want to assemble a CME using all your matches. Unfortunately, it is possible that you can't assemble the CME using all matches. But you can buy some extra matches and then assemble CME!For example, if $$$n = 2$$$, you can buy two matches and assemble |+|=||, and if $$$n = 5$$$ you can buy one match and assemble ||+|=|||.   Calculate the minimum number of matches which you have to buy for assembling CME.Note, that you have to answer $$$q$$$ independent queries.","import math
q=int(input())
b=[]
for i in range(q):
  a=int(input())
  if a%2==0 and a!=2:
    b.append(0)
  elif a==2:
    b.append(2)
  else:
    b.append(math.ceil(a/2)*2 - a)
for i in range(q):
  print(b[i])",['math']
"Valera had an undirected connected graph without self-loops and multiple edges consisting of n vertices. The graph had an interesting property: there were at most k edges adjacent to each of its vertices. For convenience, we will assume that the graph vertices were indexed by integers from 1 to n.One day Valera counted the shortest distances from one of the graph vertices to all other ones and wrote them out in array d. Thus, element d[i] of the array shows the shortest distance from the vertex Valera chose to vertex number i.Then something irreparable terrible happened. Valera lost the initial graph. However, he still has the array d. Help him restore the lost graph.","n, k = map(int, raw_input().split())

numbers = map(int, raw_input().split())
indices = range(1, len(numbers) + 1)

pairs = zip(numbers, indices)
pairs = sorted(pairs)

edges = []

valid = True

if pairs[0][0] != 0:
    valid = False
else:
    parent = 0
    remaining_edges = k
    for i in range(1, len(pairs)):
        while (pairs[parent][0] != pairs[i][0]-1 or not remaining_edges)and parent < i:
            parent += 1
            remaining_edges = k - 1
        if parent >= i or remaining_edges == 0:
            valid = False
            break
        edges.append((pairs[parent][1], pairs[i][1]))
        remaining_edges -= 1
if not valid:
    print -1
else:
    print len(edges)
    for edge in edges:
        print edge[0], edge[1]","['sortings', 'graphs', 'dfs and similar']"
"You might have remembered Theatre square from the problem 1A. Now it's finally getting repaved.The square still has a rectangular shape of $$$n \times m$$$ meters. However, the picture is about to get more complicated now. Let $$$a_{i,j}$$$ be the $$$j$$$-th square in the $$$i$$$-th row of the pavement.You are given the picture of the squares:  if $$$a_{i,j} = $$$ ""*"", then the $$$j$$$-th square in the $$$i$$$-th row should be black;  if $$$a_{i,j} = $$$ ""."", then the $$$j$$$-th square in the $$$i$$$-th row should be white. The black squares are paved already. You have to pave the white squares. There are two options for pavement tiles:  $$$1 \times 1$$$ tiles — each tile costs $$$x$$$ burles and covers exactly $$$1$$$ square;  $$$1 \times 2$$$ tiles — each tile costs $$$y$$$ burles and covers exactly $$$2$$$ adjacent squares of the same row. Note that you are not allowed to rotate these tiles or cut them into $$$1 \times 1$$$ tiles. You should cover all the white squares, no two tiles should overlap and no black squares should be covered by tiles.What is the smallest total price of the tiles needed to cover all the white squares?","for _ in range(int(input())):
    n, m, x, y = map(int, input().split())
    still = []
    count1, count2=0,0
    for _ in range(n):
        still.append(input())
    for i in still:
        m = i.split('*')
        for j in m:
            if len(j) == 1:
                count1 += 1
            elif len(j) >=2:
                count2 += len(j)//2
                count1 += len(j)%2
    if x*2<=y:
        print(x*(count1+count2*2))
    else:
        print(count1*x+count2*y)","['dp', 'greedy', 'two pointers', 'implementation', 'brute force']"
"This is an interactive problem.Ayush devised a new scheme to set the password of his lock. The lock has $$$k$$$ slots where each slot can hold integers from $$$1$$$ to $$$n$$$. The password $$$P$$$ is a sequence of $$$k$$$ integers each in the range $$$[1, n]$$$, $$$i$$$-th element of which goes into the $$$i$$$-th slot of the lock.To set the password of his lock, Ayush comes up with an array $$$A$$$ of $$$n$$$ integers each in the range $$$[1, n]$$$ (not necessarily distinct). He then picks $$$k$$$ non-empty mutually disjoint subsets of indices $$$S_1, S_2, ..., S_k$$$ $$$(S_i \underset{i \neq j} \cap S_j = \emptyset)$$$ and sets his password as $$$P_i = \max\limits_{j \notin S_i} A[j]$$$. In other words, the $$$i$$$-th integer in the password is equal to the maximum over all elements of $$$A$$$ whose indices do not belong to $$$S_i$$$.You are given the subsets of indices chosen by Ayush. You need to guess the password. To make a query, you can choose a non-empty subset of indices of the array and ask the maximum of all elements of the array with index in this subset. You can ask no more than 12 queries.","from sys import stdin,stdout
T=int(stdin.readline().strip())
def query(l,r):
    print(""?"",end="" "")
    c=0
    for i in range(l,r+1):
        for j in s[i]:
            c+=1
    print(c,end="" "")
    for i in range(l,r+1):
        for j in s[i]:
            print(j,end="" "")
    print()
    stdout.flush()
    
    x=int(stdin.readline().strip())
    return x
    
for caso in range(T):
    n,m=map(int,stdin.readline().strip().split())
    s=[list(map(int,stdin.readline().strip().split()))[1::] for i in range(m)]
    l=0
    r=m
    aux=[]
    for i in range(1,n+1):
        f=False
        for j in s:
            if i in j:
                f=True
        if f==False:
            aux.append(i)
    s.append(aux)
    x=query(l,r)
    ans=[x for i in range(m+1)]
    for i in range(10):
        l1=l
        r1=(l+r)//2

        if(l1>r1):
            break
        x1=query(l1,r1)
        if x1!=x:
            for j in range(l1,r1+1):
                ans[j]=x
            l=r1+1
        else:
            for j in range(r1+1,r+1):
                ans[j]=x
            r=r1
    c=0
    for i in range(m+1):
        if i==l:
            continue
        for j in s[i]:
            c+=1
    print(""?"",end="" "")
    print(c,end="" "")
    for i in range(m+1):
        if l==i:
            continue
        for j in s[i]:
            print(j,end="" "")
    print()
    stdout.flush()
    
    x=int(stdin.readline().strip())
    ans[l]=x
    print(""! "",*ans[0:m])
    stdout.flush()
    ans=stdin.readline().strip()
    if ans!=""Correct"":
        print(""Malll"")
        exit(-77)","['math', 'binary search', 'implementation', 'interactive']"
"For a given array $$$a$$$ consisting of $$$n$$$ integers and a given integer $$$m$$$ find if it is possible to reorder elements of the array $$$a$$$ in such a way that $$$\sum_{i=1}^{n}{\sum_{j=i}^{n}{\frac{a_j}{j}}}$$$ equals $$$m$$$? It is forbidden to delete elements as well as insert new elements. Please note that no rounding occurs during division, for example, $$$\frac{5}{2}=2.5$$$.","t = int(input())
 
while t>0:
    t = t-1
    n,m = map(int,input().split())
    arr = list(map(int,input().split()))
    if (sum(arr) == m):
        print(""Yes"")
    else:
        print(""No"")",['math']
"The only difference between easy and hard versions is the constraints.Polycarp has to write a coursework. The coursework consists of $$$m$$$ pages.Polycarp also has $$$n$$$ cups of coffee. The coffee in the $$$i$$$-th cup Polycarp has $$$a_i$$$ caffeine in it. Polycarp can drink some cups of coffee (each one no more than once). He can drink cups in any order. Polycarp drinks each cup instantly and completely (i.e. he cannot split any cup into several days).Surely, courseworks are not being written in a single day (in a perfect world of Berland, at least).Let's consider some day of Polycarp's work. Consider Polycarp drinks $$$k$$$ cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are $$$a_{i_1}, a_{i_2}, \dots, a_{i_k}$$$. Then the first cup he drinks gives him energy to write $$$a_{i_1}$$$ pages of coursework, the second cup gives him energy to write $$$max(0, a_{i_2} - 1)$$$ pages, the third cup gives him energy to write $$$max(0, a_{i_3} - 2)$$$ pages, ..., the $$$k$$$-th cup gives him energy to write $$$max(0, a_{i_k} - k + 1)$$$ pages.If Polycarp doesn't drink coffee during some day, he cannot write coursework at all that day.Polycarp has to finish his coursework as soon as possible (spend the minimum number of days to do it). Your task is to find out this number of days or say that it is impossible.","n, m = [int(x) for x in input().split()]
a = [int(x) for x in input().split()]
a.sort(reverse=True)
if sum(a) < m:
    print(-1)
else:
    l = 1
    r = n
    while l < r:
        mid = (l+r) >> 1
        s = 0
        for j in range(n):
            s += max(0, a[j] - j//mid)
        if s >= m:
            r = mid
        else:
            l = mid + 1
    else:
        print(l)","['binary search', 'greedy']"
"You are given a prime number $$$p$$$, $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$, and an integer $$$k$$$. Find the number of pairs of indexes $$$(i, j)$$$ ($$$1 \le i &lt; j \le n$$$) for which $$$(a_i + a_j)(a_i^2 + a_j^2) \equiv k \bmod p$$$.","n,p,k = [int(i) for i in input().split()]
data =  [int(i) for i in input().split()]
dic = {}
for d in data:
    val = (pow(d, 4, p) - d * k)%p
    if val in dic:
        dic[val] += 1
    else:
        dic[val] = 1
ans = 0
for am in dic.values():
    ans += (am * (am-1))//2
print(ans)",['number theory']
"You are given n numbers a1, a2, ..., an. You can perform at most k operations. For each operation you can multiply one of the numbers by x. We want to make  as large as possible, where  denotes the bitwise OR. Find the maximum possible value of  after performing at most k operations optimally.","n,k,x = map( int,input().split() )
*Arr, = map( int,input().split() )

Prfx = [0]*(n+2)
Sffx = [0]*(n+2)

for i in range(0,n):
    Prfx[i+1] = Prfx[i]|Arr[i]
    Sffx[n-i-1] = Sffx[n-i]|Arr[n-i-1]
now = x**k
Res = 0
for i in range(0,n):
    Res = max( Prfx[i]|(Arr[i]*now)|Sffx[i+1],Res );
print(Res)","['greedy', 'brute force']"
"One evening Rainbow Dash and Fluttershy have come up with a game. Since the ponies are friends, they have decided not to compete in the game but to pursue a common goal. The game starts on a square flat grid, which initially has the outline borders built up. Rainbow Dash and Fluttershy have flat square blocks with size $$$1\times1$$$, Rainbow Dash has an infinite amount of light blue blocks, Fluttershy has an infinite amount of yellow blocks. The blocks are placed according to the following rule: each newly placed block must touch the built on the previous turns figure by a side (note that the outline borders of the grid are built initially). At each turn, one pony can place any number of blocks of her color according to the game rules.Rainbow and Fluttershy have found out that they can build patterns on the grid of the game that way. They have decided to start with something simple, so they made up their mind to place the blocks to form a chess coloring. Rainbow Dash is well-known for her speed, so she is interested in the minimum number of turns she and Fluttershy need to do to get a chess coloring, covering the whole grid with blocks. Please help her find that number!Since the ponies can play many times on different boards, Rainbow Dash asks you to find the minimum numbers of turns for several grids of the games.The chess coloring in two colors is the one in which each square is neighbor by side only with squares of different colors.","for t in range(int(input())):
    a = int(input())
    if (a == 1 or a == 2):
        print(a)
    else:
        print(2+(a-2)//2)","['greedy', 'math']"
"Hooray! Polycarp turned $$$n$$$ years old! The Technocup Team sincerely congratulates Polycarp!Polycarp celebrated all of his $$$n$$$ birthdays: from the $$$1$$$-th to the $$$n$$$-th. At the moment, he is wondering: how many times he turned beautiful number of years?According to Polycarp, a positive integer is beautiful if it consists of only one digit repeated one or more times. For example, the following numbers are beautiful: $$$1$$$, $$$77$$$, $$$777$$$, $$$44$$$ and $$$999999$$$. The following numbers are not beautiful: $$$12$$$, $$$11110$$$, $$$6969$$$ and $$$987654321$$$.Of course, Polycarpus uses the decimal numeral system (i.e. radix is 10).Help Polycarpus to find the number of numbers from $$$1$$$ to $$$n$$$ (inclusive) that are beautiful.","t = int(input())

for i in range(t):
    n = int(input())

    if n < 10:
        print(n // 1)
    elif n > 9 and n < 100:
        print(9 + n // 11)
    elif n > 99 and n < 1000:
        print(18 + n // 111)
    elif n > 999 and n < 10000:
        print(27 + n // 1111)
    elif n > 9999 and n < 100000:
        print(36 + n // 11111)
    elif n > 99999 and n < 1000000:
        print(45 + n // 111111)
    elif n > 999999 and n < 10000000:
        print(54 + n // 1111111)
    elif n > 9999999 and n < 100000000:
        print(63 + n // 11111111)
    elif n > 99999999 and n < 1000000000:
        print(72 + n // 111111111)
    else:
        print(81)",['implementation']
"There is a bookshelf which can fit $$$n$$$ books. The $$$i$$$-th position of bookshelf is $$$a_i = 1$$$ if there is a book on this position and $$$a_i = 0$$$ otherwise. It is guaranteed that there is at least one book on the bookshelf.In one move, you can choose some contiguous segment $$$[l; r]$$$ consisting of books (i.e. for each $$$i$$$ from $$$l$$$ to $$$r$$$ the condition $$$a_i = 1$$$ holds) and:  Shift it to the right by $$$1$$$: move the book at index $$$i$$$ to $$$i + 1$$$ for all $$$l \le i \le r$$$. This move can be done only if $$$r+1 \le n$$$ and there is no book at the position $$$r+1$$$.  Shift it to the left by $$$1$$$: move the book at index $$$i$$$ to $$$i-1$$$ for all $$$l \le i \le r$$$. This move can be done only if $$$l-1 \ge 1$$$ and there is no book at the position $$$l-1$$$. Your task is to find the minimum number of moves required to collect all the books on the shelf as a contiguous (consecutive) segment (i.e. the segment without any gaps).For example, for $$$a = [0, 0, 1, 0, 1]$$$ there is a gap between books ($$$a_4 = 0$$$ when $$$a_3 = 1$$$ and $$$a_5 = 1$$$), for $$$a = [1, 1, 0]$$$ there are no gaps between books and for $$$a = [0, 0,0]$$$ there are also no gaps between books.You have to answer $$$t$$$ independent test cases.","import sys

input = sys.stdin.readline

def ok(a):
	c = a[0]
	for i in a:
		if c!=i:
			return False
	return True

def solve():	
	n = int(input())
	al = list(map(int,input().split()))

	i = 0
	while al[i]==0:
		i+=1

	while  al[len(al)-1]==0:
		al.pop()

	n = len(al)

	ans = 0
	while i<n:
		j = i
		while j<n and al[j]==0:
			j+=1
		ans+=j-i
		i = j+1

	print(ans)
	
def main():
	n = int(input())
	for i in range(n):
		solve()

main()","['implementation', 'greedy']"
"Given a sequence of integers a1, ..., an and q queries x1, ..., xq on it. For each query xi you have to count the number of pairs (l, r) such that 1 ≤ l ≤ r ≤ n and gcd(al, al + 1, ..., ar) = xi. is a greatest common divisor of v1, v2, ..., vn, that is equal to a largest positive integer that divides all vi.","from math import gcd
from collections import defaultdict
from sys import stdin, stdout

##This method is better cause for all the same results we only calculate once
def main():
    GCD_count = defaultdict(int)
    GCD_map = defaultdict(int)
    arr_len = int(stdin.readline())
    arr = [int(x) for x in stdin.readline().split()]
    for start in range(arr_len):
        temp = defaultdict(int)
        GCD_count[arr[start]] += 1
        temp[arr[start]] += 1
        for gcd_now, occurence in GCD_map.items():
            res = gcd(gcd_now, arr[start])
            temp[res] += occurence
            GCD_count[res] += occurence
        GCD_map = temp
    num_queries = int(stdin.readline())
    for _ in range(num_queries):
        print(GCD_count[int(stdin.readline())])


main()","['data structures', 'brute force', 'math']"
"You are given $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$.For each $$$a_i$$$ find its two divisors $$$d_1 &gt; 1$$$ and $$$d_2 &gt; 1$$$ such that $$$\gcd(d_1 + d_2, a_i) = 1$$$ (where $$$\gcd(a, b)$$$ is the greatest common divisor of $$$a$$$ and $$$b$$$) or say that there is no such pair.","n=int(input())

l=list(map(int, input().split(' ')))
k1, k2=[],[]


def smallPrimes(num=10000007):
#prepare smallest prime factor array
	smallestPrimes = [0]*(num+1)
	#smallestPrimes[2] = 2
	p=2
	while(p<num+1):

		if(smallestPrimes[p]==0):
			for j in range(p, num+1,p):
				if(smallestPrimes[j]==0):
					smallestPrimes[j]=p

		p+=1

	return smallestPrimes


def getFactors(num):
	factors=set()
	global smallestPrimes;
	while(num>1):
		sp=smallestPrimes[num]
		factors.add(sp)
		num//=sp

	return factors


def products(ll):
	p=1
	for j in ll[1:]:
		p*=j
	return p




smallestPrimes = smallPrimes()

for kk in l:
	if(kk==1):
		k1+=[-1]
		k2+=[-1]


	else:
		factorList = list(getFactors(kk))
		if(len(factorList)==1):
			k1+=[-1]
			k2+=[-1]

		else:
			k1+=[factorList[0]]
			k2+=[products(factorList)]


for a in k1:
	print(a, end=' ')
print()
for a in k2:
	print(a, end=' ')","['constructive algorithms', 'number theory', 'math']"
"You are given a string $$$s$$$ such that each its character is either 1, 2, or 3. You have to choose the shortest contiguous substring of $$$s$$$ such that it contains each of these three characters at least once.A contiguous substring of string $$$s$$$ is a string that can be obtained from $$$s$$$ by removing some (possibly zero) characters from the beginning of $$$s$$$ and some (possibly zero) characters from the end of $$$s$$$.","from collections import defaultdict

def findLen(s):
    N = len(s)
    def checkFor(size):
        left, right = 0, size-1
        c = defaultdict(int)
        for i in range(left, right+1):
            c[s[i]] += 1
        
        while right < N-1:
            if c[""1""]>0 and c[""2""]>0 and c[""3""]>0: return True
            c[s[left]] -= 1
            left += 1
            right += 1
            c[s[right]] += 1
        
        if c[""1""]>0 and c[""2""]>0 and c[""3""]>0: return True
        else: return False 

    left, right = 0, N
    while left < right:
        mid = (left+right)//2
        if checkFor(mid):
            right = mid
        else:
            left = mid + 1
    
    if left <N or left==N and checkFor(N): return left

    else: return 0        

t = int(input())
for i in range(t):
    s = input()
    print(findLen(s))","['dp', 'two pointers', 'implementation', 'binary search']"
"Andre has very specific tastes. Recently he started falling in love with arrays.Andre calls an nonempty array $$$b$$$ good, if sum of its elements is divisible by the length of this array. For example, array $$$[2, 3, 1]$$$ is good, as sum of its elements — $$$6$$$ — is divisible by $$$3$$$, but array $$$[1, 1, 2, 3]$$$ isn't good, as $$$7$$$ isn't divisible by $$$4$$$. Andre calls an array $$$a$$$ of length $$$n$$$ perfect if the following conditions hold:   Every nonempty subarray of this array is good.  For every $$$i$$$ ($$$1 \le i \le n$$$), $$$1 \leq a_i \leq 100$$$. Given a positive integer $$$n$$$, output any perfect array of length $$$n$$$. We can show that for the given constraints such an array always exists.An array $$$c$$$ is a subarray of an array $$$d$$$ if $$$c$$$ can be obtained from $$$d$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.","t = int(input(""""))
for i in range(t):
    n = int(input(""""))
    s = """"
    for k in range(n):
        s += ""1 ""
    print(s)","['constructive algorithms', 'implementation']"
"You are given a positive integer $$$n$$$, it is guaranteed that $$$n$$$ is even (i.e. divisible by $$$2$$$).You want to construct the array $$$a$$$ of length $$$n$$$ such that:   The first $$$\frac{n}{2}$$$ elements of $$$a$$$ are even (divisible by $$$2$$$);  the second $$$\frac{n}{2}$$$ elements of $$$a$$$ are odd (not divisible by $$$2$$$);  all elements of $$$a$$$ are distinct and positive;  the sum of the first half equals to the sum of the second half ($$$\sum\limits_{i=1}^{\frac{n}{2}} a_i = \sum\limits_{i=\frac{n}{2} + 1}^{n} a_i$$$). If there are multiple answers, you can print any. It is not guaranteed that the answer exists.You have to answer $$$t$$$ independent test cases.","lst=[]
t = int(input())
for i in range(t):
    n=int(input())
    lst.append(n)
for j in lst:
    if j%4==0:
        lst2=[]
        lst1 = [k for k in range(2,j+1,2)] 
        for m in range(len(lst1)-1):
            lst2.append(lst1[m]-1)   
        lst2.append(lst1[-1]+len(lst1)-1)
        print('YES')
        for f in lst1+lst2:
            print(f,end="" "")
        print()
    else:
        print('NO')","['constructive algorithms', 'math']"
"Consider the following game for two players. There is one white token and some number of black tokens. Each token is placed on a plane in a point with integer coordinates x and y.The players take turn making moves, white starts. On each turn, a player moves all tokens of their color by 1 to up, down, left or right. Black player can choose directions for each token independently.After a turn of the white player the white token can not be in a point where a black token is located. There are no other constraints on locations of the tokens: positions of black tokens can coincide, after a turn of the black player and initially the white token can be in the same point with some black point. If at some moment the white player can't make a move, he loses. If the white player makes 10100500 moves, he wins.You are to solve the following problem. You are given initial positions of all black tokens. It is guaranteed that initially all these positions are distinct. In how many places can the white token be located initially so that if both players play optimally, the black player wins?","from sys import stdin
from itertools import repeat
def solve(a):
    inf = 1001001001
    C = 400010
    lmn = [inf] * 400010
    lmx = [-inf] * 400010
    for x, y in a:
        x = (x - 1) / 2 + 100005
        if lmn[x] > y:
            lmn[x] = y
        if lmx[x] < y:
            lmx[x] = y
    rmn = lmn[:]
    rmx = lmx[:]
    for i in xrange(200009):
        if lmn[i+1] > lmn[i]:
            lmn[i+1] = lmn[i]
    for i in xrange(200009):
        if lmx[i+1] < lmx[i]:
            lmx[i+1] = lmx[i]
    for i in xrange(200009, 0, -1):
        if rmn[i-1] > rmn[i]:
            rmn[i-1] = rmn[i]
    for i in xrange(200009, 0, -1):
        if rmx[i-1] < rmx[i]:
            rmx[i-1] = rmx[i]
    for i in xrange(200010):
        if lmn[i] < rmn[i]:
            lmn[i] = rmn[i]
    for i in xrange(200010):
        if lmx[i] > rmx[i]:
            lmx[i] = rmx[i]
    ans = 0
    for i in xrange(200009):
        if lmn[i] < lmn[i+1]:
            lmn[i] = lmn[i+1]
    for i in xrange(200009):
        if lmx[i] > lmx[i+1]:
            lmx[i] = lmx[i+1]
    for i in xrange(200009):
        if lmn[i] < lmx[i]:
            ans += (lmx[i] - lmn[i]) / 2
    return ans
    
def main():
    n = int(stdin.readline())
    dat = map(int, stdin.read().split(), repeat(10, 2 * n))
    s = [[], []]
    for i in xrange(n):
        x, y = dat[i*2:i*2+2]
        s[(x+y)&1].append((-x+y, x+y))
    print solve(s[0]) + solve(s[1])
main()","['data structures', 'implementation', 'games']"
"«Polygon» is a system which allows to create programming tasks in a simple and professional way. When you add a test to the problem, the corresponding form asks you for the test index. As in most cases it is clear which index the next test will have, the system suggests the default value of the index. It is calculated as the smallest positive integer which is not used as an index for some previously added test.You are to implement this feature. Create a program which determines the default index of the next test, given the indexes of the previously added tests.","n=int(input())
arr=list(map(int,input().split("" "")))
arr.sort()
x=-1
for i in range(n):
    if arr[i]!=i+1:
        x=i+1
        break
if x==-1:
    print(arr[n-1]+1)
else:
    print(x)","['implementation', 'sortings']"
"Little Petya likes to play very much. And most of all he likes to play the following game:He is given a sequence of N integer numbers. At each step it is allowed to increase the value of any number by 1 or to decrease it by 1. The goal of the game is to make the sequence non-decreasing with the smallest number of steps. Petya is not good at math, so he asks for your help.The sequence a is called non-decreasing if a1 ≤ a2 ≤ ... ≤ aN holds, where N is the length of the sequence.","import heapq
input()
ans=0
a=[]
inf=10**9
for x in map(int,input().split()):
    x=inf-x
    heapq.heappush(a,x)
    ans+=a[0]-x
    heapq.heappop(a)
    heapq.heappush(a,x)
print(-ans)","['dp', 'sortings']"
"Kuroni is very angry at the other setters for using him as a theme! As a punishment, he forced them to solve the following problem:You have an array $$$a$$$ consisting of $$$n$$$ positive integers. An operation consists of choosing an element and either adding $$$1$$$ to it or subtracting $$$1$$$ from it, such that the element remains positive. We say the array is good if the greatest common divisor of all its elements is not $$$1$$$. Find the minimum number of operations needed to make the array good.Unable to match Kuroni's intellect, the setters failed to solve the problem. Help them escape from Kuroni's punishment!","import random

n = int(raw_input())
a = list(map(int, raw_input().split()))

limit = min(8, n)
iterations = [x for x in range(n)]
random.shuffle(iterations)
iterations = iterations[:limit]

def factorization(x):
	primes = []
	i = 2
	while i * i <= x:
		if x % i == 0:
			primes.append(i)
			while x % i == 0: x //= i
		i = i + 1
	if x > 1: primes.append(x)
	return primes

def solve_with_fixed_gcd(arr, gcd):
	result = 0
	for x in arr:
		if x < gcd: result += (gcd - x)
		else:
			remainder = x % gcd
			result += min(remainder, gcd - remainder)
	return result

answer = float(""inf"")
prime_list = set()
for index in iterations:
	for x in range(-1, 2):
		tmp = factorization(a[index]-x)
		for z in tmp: prime_list.add(z)

for prime in prime_list:
	answer = min(answer, solve_with_fixed_gcd(a, prime))
	if answer == 0: break

print(answer)","['number theory', 'probabilities', 'math']"
"The only difference between easy and hard versions is constraints.Nauuo is a girl who loves random picture websites.One day she made a random picture website by herself which includes $$$n$$$ pictures.When Nauuo visits the website, she sees exactly one picture. The website does not display each picture with equal probability. The $$$i$$$-th picture has a non-negative weight $$$w_i$$$, and the probability of the $$$i$$$-th picture being displayed is $$$\frac{w_i}{\sum_{j=1}^nw_j}$$$. That is to say, the probability of a picture to be displayed is proportional to its weight.However, Nauuo discovered that some pictures she does not like were displayed too often. To solve this problem, she came up with a great idea: when she saw a picture she likes, she would add $$$1$$$ to its weight; otherwise, she would subtract $$$1$$$ from its weight.Nauuo will visit the website $$$m$$$ times. She wants to know the expected weight of each picture after all the $$$m$$$ visits modulo $$$998244353$$$. Can you help her?The expected weight of the $$$i$$$-th picture can be denoted by $$$\frac {q_i} {p_i}$$$ where $$$\gcd(p_i,q_i)=1$$$, you need to print an integer $$$r_i$$$ satisfying $$$0\le r_i&lt;998244353$$$ and $$$r_i\cdot p_i\equiv q_i\pmod{998244353}$$$. It can be proved that such $$$r_i$$$ exists and is unique.","P = 998244353
N, M = map(int, raw_input().split())
A = [int(a) for a in raw_input().split()]
B = [int(a) for a in raw_input().split()]
li = sum([A[i]*B[i] for i in range(N)])
di = sum([(A[i]^1)*B[i] for i in range(N)])
X = [1]
SU = li+di
PO = [0] * (5*M+10)
for i in range(-M-5, 2*M+5):
    PO[i] = pow((SU+i)%P, P-2, P)
def calc(L):
    su = sum(L)
    pl = 0
    pd = 0
    RE = []
    for i in range(len(L)):
        a = li + i
        b = di - (len(L) - 1 - i)
        pd = b * L[i] * PO[a+b-SU]
        RE.append((pl+pd)%P)
        pl = a * L[i] * PO[a+b-SU]
    RE.append(pl%P)
    return RE
for i in range(M):
    X = calc(X)
ne = 0
po = 0
for i in range(M+1):
    po = (po + X[i] * (li + i)) % P
    ne = (ne + X[i] * (di - M + i)) % P
invli = pow(li, P-2, P)
invdi = pow(di, P-2, P)
for i in range(N):
    print(po * B[i] * invli % P if A[i] else ne * B[i] * invdi % P)","['dp', 'probabilities']"
"In number world, two different numbers are friends if they have a lot in common, but also each one has unique perks.More precisely, two different numbers $$$a$$$ and $$$b$$$ are friends if $$$gcd(a,b)$$$, $$$\frac{a}{gcd(a,b)}$$$, $$$\frac{b}{gcd(a,b)}$$$ can form sides of a triangle.Three numbers $$$a$$$, $$$b$$$ and $$$c$$$ can form sides of a triangle if $$$a + b &gt; c$$$, $$$b + c &gt; a$$$ and $$$c + a &gt; b$$$.In a group of numbers, a number is lonely if it doesn't have any friends in that group.Given a group of numbers containing all numbers from $$$1, 2, 3, ..., n$$$, how many numbers in that group are lonely?","from sys import stdin


def count_prime(n):
    for i in range(2, n):
        if prim[i] == 1:
            if i * i < Max:
                prim[i * i] = -1
            for j in range(i * i + i, n, i):
                prim[j] = 0

    for i in range(2, n):
        prim[i] += prim[i - 1]


n, a, Max = int(input()), [int(x) for x in stdin.readline().split()], 1000001
prim = [1] * Max
count_prime(Max)
print('\n'.join(map(str, [prim[i] for i in a])))","['two pointers', 'binary search', 'number theory', 'math']"
"You are given an array of $$$n$$$ integers $$$a_1,a_2,\dots,a_n$$$.You have to create an array of $$$n$$$ integers $$$b_1,b_2,\dots,b_n$$$ such that:   The array $$$b$$$ is a rearrangement of the array $$$a$$$, that is, it contains the same values and each value appears the same number of times in the two arrays. In other words, the multisets $$$\{a_1,a_2,\dots,a_n\}$$$ and $$$\{b_1,b_2,\dots,b_n\}$$$ are equal.For example, if $$$a=[1,-1,0,1]$$$, then $$$b=[-1,1,1,0]$$$ and $$$b=[0,1,-1,1]$$$ are rearrangements of $$$a$$$, but $$$b=[1,-1,-1,0]$$$ and $$$b=[1,0,2,-3]$$$ are not rearrangements of $$$a$$$.  For all $$$k=1,2,\dots,n$$$ the sum of the first $$$k$$$ elements of $$$b$$$ is nonzero. Formally, for all $$$k=1,2,\dots,n$$$, it must hold $$$$$$b_1+b_2+\cdots+b_k\not=0\,.$$$$$$ If an array $$$b_1,b_2,\dots, b_n$$$ with the required properties does not exist, you have to print NO.","def all_perms(elements):
    if len(elements) <= 1:
        yield elements
    else:
        for perm in all_perms(elements[1:]):
            for i in range(len(elements)):
                # nb elements[0:1] works in both string and list contexts
                yield perm[:i] + elements[0:1] + perm[i:]


tests_no = int(input())
for _ in range(tests_no):
    n = int(input())
    a = list(map(int, input().split()))
    whole_sum = sum(a)
    if whole_sum == 0:
        print(""NO"")
    elif whole_sum < 0:
        ri = n-1
        li = 0
        b = [0]*n
        for i in range(n):
            if a[i] >= 0:
                b[ri] = a[i]
                ri -= 1
            else:
                b[li] = a[i]
                li += 1
        print(""YES"")
        print(*b)
    else:
        ri = n - 1
        li = 0
        b = [0] * n
        for i in range(n):
            if a[i] <= 0:
                b[ri] = a[i]
                ri -= 1
            else:
                b[li] = a[i]
                li += 1
        print(""YES"")
        print(*b)



'''
100
1
-2
1
-1
1
0
1
1
1
2
2
-2 -2
2
-1 -2
2
0 -2
2
1 -2
2
2 -2
2
-2 -1
2
-1 -1
2
0 -1
2
1 -1
2
2 -1
2
-2 0
2
-1 0
2
0 0
2
1 0
2
2 0
2
-2 1
2
-1 1
2
0 1
2
1 1



'''","['sortings', 'math']"
"Twilight Sparkle learnt that the evil Nightmare Moon would return during the upcoming Summer Sun Celebration after one thousand years of imprisonment on the moon. She tried to warn her mentor Princess Celestia, but the princess ignored her and sent her to Ponyville to check on the preparations for the celebration.  Twilight Sparkle wanted to track the path of Nightmare Moon. Unfortunately, she didn't know the exact path. What she knew is the parity of the number of times that each place Nightmare Moon visited. Can you help Twilight Sparkle to restore any path that is consistent with this information?Ponyville can be represented as an undirected graph (vertices are places, edges are roads between places) without self-loops and multi-edges. The path can start and end at any place (also it can be empty). Each place can be visited multiple times. The path must not visit more than 4n places.","#
# Uian Sol Gorgonio <sol.uian@gmail.com>
# Aug 9 2014
# Little Pony and Summer Sun Celebration
# http://codeforces.com/contest/454/problem/E
#
# Graph
#

def dfs(node, color, node_colors):
    node_colors[node] = color
    for child in village_graph[node]:
        if node_colors[child] != color:
            dfs(child, color, node_colors)

def satisfiable():
    node_colors = [-1] * num_places

    components_with_odd_parity = 0
    color = 0
    for node in range(num_places):
        if node_colors[node] == -1:
            dfs(node, color, node_colors)

            for node_aux in range(num_places):
                if node_colors[node_aux] == color and parity[node_aux] == 1:
                    components_with_odd_parity += 1
                    break

            color += 1

    if components_with_odd_parity > 1:
        return False
    else:
        return True

def read_village_graph():
    for i in range(num_roads):
        orig, dest = map(int, raw_input().split())
        village_graph[orig - 1].append(dest - 1)
        village_graph[dest - 1].append(orig - 1)

def calculate_root():
    for i in range(num_places):
        if parity[i] == 1:
            return i
    return 0

def needToCorrectParity(node):
    return (new_parity[node] % 2 == 1 and parity[node] == 0) or (new_parity[node] % 2 == 0 and parity[node] == 1)

def solve_path(node, parent):
    visit[node] = True
    path.append(node + 1)
    new_parity[node] += 1

    for child in village_graph[node]:
        if not visit[child]:
            solve_path(child, node)
            path.append(node + 1)
            new_parity[node] += 1

    if needToCorrectParity(node) and parent != -1:
        path.append(parent + 1)
        new_parity[parent] += 1
        path.append(node + 1)
        new_parity[node] += 1


num_places, num_roads = map(int, raw_input().split())
village_graph = [[] for i in range(num_places)]
read_village_graph()
parity = map(int, raw_input().split())

path = []
new_parity = [0] * num_places
visit = [False] * num_places
if satisfiable():
    visit = [False] * num_places
    root = calculate_root()
    solve_path(root, -1)
    
    if needToCorrectParity(root):
        path.pop()

    print len(path)
    if len(path) != 0:
        print ' '.join(map(str, path))
else:
    print -1",['dfs and similar']
"Bear Limak has n colored balls, arranged in one long row. Balls are numbered 1 through n, from left to right. There are n possible colors, also numbered 1 through n. The i-th ball has color ti.For a fixed interval (set of consecutive elements) of balls we can define a dominant color. It's a color occurring the biggest number of times in the interval. In case of a tie between some colors, the one with the smallest number (index) is chosen as dominant.There are  non-empty intervals in total. For each color, your task is to count the number of intervals in which this color is dominant.","N = int(5e3+3)
n = int(input())
res = [0] * N
cum = list([0] * N for _ in range(N))
a = list(map(int, input().split()))
for i in range(n):
    c = [0] * N
    for j in range(i, n):
        c[a[j]] += 1
        cum[i][j] = c[a[j]]
for i in range(n):
    curr_max, curr_idx = 0, N-1
    j = 0
    while cum[i][j] == 0: 
        j += 1
    while j < n:
        if cum[i][j] > curr_max or cum[i][j] == curr_max and a[j] < curr_idx:
            curr_max = cum[i][j]
            curr_idx = a[j]
        res[curr_idx] += 1
        j += 1
print(*res[1:n+1])","['data structures', 'implementation', 'brute force']"
"An African crossword is a rectangular table n × m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","n, m = list(map(int, input().strip().split()))
A = [[0] * m] * n


for r in range(n):
    A[r] = list(input().strip())


def in_row(A, r, c):
    x = A[r][c]
    left, right = A[r][:c], A[r][c + 1:]
    if (x in left) or (x in right):
        return True


def in_col(A, r, c):
    x = A[r][c]
    for row in range(n):
        if row == r:
            continue
        if A[row][c] == x:
            return True

out = ''
for r in range(n):
    for c in range(m):
        if not in_row(A, r, c) and not in_col(A, r, c): 
            out += A[r][c]

print(out)","['implementation', 'strings']"
"There were n groups of students which came to write a training contest. A group is either one person who can write the contest with anyone else, or two people who want to write the contest in the same team.The coach decided to form teams of exactly three people for this training. Determine the maximum number of teams of three people he can form. It is possible that he can't use all groups to form teams. For groups of two, either both students should write the contest, or both should not. If two students from a group of two will write the contest, they should be in the same team.","n=int(input())
l=list(map(int,input().split()))
x=l.count(2)
y=l.count(1)
m=min(x,y)
c=(y-m)//3
print(c+m)","['constructive algorithms', 'greedy', 'math']"
"Natasha is going to fly on a rocket to Mars and return to Earth. Also, on the way to Mars, she will land on $$$n - 2$$$ intermediate planets. Formally: we number all the planets from $$$1$$$ to $$$n$$$. $$$1$$$ is Earth, $$$n$$$ is Mars. Natasha will make exactly $$$n$$$ flights: $$$1 \to 2 \to \ldots n \to 1$$$.Flight from $$$x$$$ to $$$y$$$ consists of two phases: take-off from planet $$$x$$$ and landing to planet $$$y$$$. This way, the overall itinerary of the trip will be: the $$$1$$$-st planet $$$\to$$$ take-off from the $$$1$$$-st planet $$$\to$$$ landing to the $$$2$$$-nd planet $$$\to$$$ $$$2$$$-nd planet $$$\to$$$ take-off from the $$$2$$$-nd planet $$$\to$$$ $$$\ldots$$$ $$$\to$$$ landing to the $$$n$$$-th planet $$$\to$$$ the $$$n$$$-th planet $$$\to$$$ take-off from the $$$n$$$-th planet $$$\to$$$ landing to the $$$1$$$-st planet $$$\to$$$ the $$$1$$$-st planet.The mass of the rocket together with all the useful cargo (but without fuel) is $$$m$$$ tons. However, Natasha does not know how much fuel to load into the rocket. Unfortunately, fuel can only be loaded on Earth, so if the rocket runs out of fuel on some other planet, Natasha will not be able to return home. Fuel is needed to take-off from each planet and to land to each planet. It is known that $$$1$$$ ton of fuel can lift off $$$a_i$$$ tons of rocket from the $$$i$$$-th planet or to land $$$b_i$$$ tons of rocket onto the $$$i$$$-th planet. For example, if the weight of rocket is $$$9$$$ tons, weight of fuel is $$$3$$$ tons and take-off coefficient is $$$8$$$ ($$$a_i = 8$$$), then $$$1.5$$$ tons of fuel will be burnt (since $$$1.5 \cdot 8 = 9 + 3$$$). The new weight of fuel after take-off will be $$$1.5$$$ tons. Please note, that it is allowed to burn non-integral amount of fuel during take-off or landing, and the amount of initial fuel can be non-integral as well.Help Natasha to calculate the minimum mass of fuel to load into the rocket. Note, that the rocket must spend fuel to carry both useful cargo and the fuel itself. However, it doesn't need to carry the fuel which has already been burnt. Assume, that the rocket takes off and lands instantly.","""""""for p in range(int(input())):

	n,k=map(int,input().split("" ""))
	number=input().split("" "")
	chances=[k for i in range(n)]

	prev=-1
	prev_updated=-1
	last_used=False
	toSub=0
	start=0

	prevSub=0

	if(number[0]=='1'):
		prev=0
		prev_updated=0
		start=1

	for i in range(start,n):
		
		if(number[i]=='1'):
		#	print(""\ni"",i,""\ntoSub"",toSub,""\nprevUpadted"",prev_updated,""\nprev"",prev,""\nlast_used"",last_used)
			f1=False
#			toSub+=1
			toSub=0

			zeros=i - prev_updated - 1

			if(last_used):
				zeros-=1

			#chances[i]-=toSub

			#print(prevSub,(i - prev - 1 ) +1)
			if(i - prev - 1 <= prevSub):
				chances[i]-= prevSub - (i - prev - 1 ) +1
				if(chances[i]<zeros):
					chances[i]=zeros
				toSub+= prevSub - (i - prev - 1 ) +1
				f1=True

			if(zeros==0 or chances[i]==0):
				prev_updated=i
				prev=i
				last_used=False
				prevSub=toSub
				continue
		#	print(""\nchances:  "",chances[i],""\t\tzeroes :   "",zeros,""\t\tprevSub :"",prevSub)

			if(chances[i]>zeros):
		#		print(""\t\t\t\t1"")
				number[i-zeros]='1'
				number[i]='0'
				prev_updated=i-zeros
				last_used=False
			elif(chances[i]==zeros):
		#		print(""\t\t\t\t2"")
				number[i]='0'
				number[i-chances[i]]='1'
				prev_updated=i-chances[i]
				last_used=True
			else:
		#		print(""\t\t\t\t3"")
				number[i]='0'
				number[i-chances[i]]='1'
				prev_updated=i-chances[i]
				last_used=True
			prev=i

			prevSub=toSub

			if(prev_updated>2 and f1):
				if(number[prev_updated]=='1' and number[prev_updated-1]=='0' and number[prev_updated-2]=='1'):
					last_used=False
				#if()

		#	print(""\ni"",i,""\ntoSub"",toSub,""\nprevUpadted"",prev_updated,""\nprev"",prev,""\nlast_used"",last_used)
		#	print(number)
		else:
			toSub=0

	print(*number)
#	print(chances)""""""

""""""class offer:
	def __init__(self, n, fre):
		self.num = n
		self.free = fre
		self.delta= n-fre
		

n,m,k=map(int,input().split("" ""))

shovel=list(map(int,input().split("" "")))

#dicti={}

offers=[]
temp_arr=[False for i in range(n)]

for i in range(m):
	p,q=map(int,input().split("" ""))
	if(p>k):
		continue
	offers.append(offer(p,q))
#	dicti[p]=q

#for i in dicti:
#	dicti[i].sort()	

shovel.sort()
shovel=shovel[:k+1]

offers.sort(key=lambda x: x.delta/x.num,reverse=True)

bestoffer=[]

for i in offers:
	if(not temp_arr[i.num]):
		temp_arr[i.num]=True
		bestoffer.append(i)

cost=0

for i in bestoffer:
	
	
for p in range(int(input())):
	arr=list(input())

	n=len(arr)
	for i in range(n):
		arr[i]=ord(arr[i])-96

	arr.sort()

	arr1=arr[:n//2]
	arr2=arr[n//2:]
	arr=[]
	#print(arr,arr1,arr2)
	i1=n//2-1
	i2=n-i1-2

	while (i1!=-1 and i2!=-1):
		arr.append(arr1[i1])
		arr.append(arr2[i2])
		i1-=1
		i2-=1
	if(i1!=-1):
		arr.append(arr1[i1])
	elif(i2!=-1):
		arr.append(arr2[i2])

	#print(arr)

	s=""""
	for i in range(n-1):
		if(abs(arr[i]-arr[i+1])==1):
			s=-1
			print(""No answer"")
			break
		else:
			s+=chr(arr[i]+96)

	if(s!=-1):
		s+=chr(arr[-1]+96)
		print(s)""""""

""""""
n,m=map(int,input().split("" ""))

seti=[]
ans=[1 for i in range(n)]


for i in range(m):
	arr=list(map(int,input().split("" "")))
	
	if(arr[0]>1):
		seti.append(set(arr[1:]))
	else:
		m-=1

parent=[-1 for i in range(m)]
#print(seti)
for i in range(m-1):
	for j in range(i+1,m):
		if(parent[j]==-1):
			if(len(seti[i].intersection(seti[j]))>0):
				seti[i]=seti[i].union(seti[j])
				parent[j]=i

#print(parent)

for i in range(m):
	if(parent[i]==-1):
		temp=list(seti[i])
		store=len(temp)
		for j in temp:
			ans[j-1]=store

print(*ans)


for p in range(int(input())):
	arr=list(input())

	n=len(arr)
	for i in range(n):
		arr[i]=ord(arr[i])-96

	arr.sort()

	arr1=arr[:n//2]
	arr2=arr[n//2:]
	arr=[]
	#print(arr,arr1,arr2)
	i1=n//2-1
	i2=n-i1-2

	while (i1!=-1 and i2!=-1):
		arr.append(arr1[i1])
		arr.append(arr2[i2])
		i1-=1
		i2-=1
	if(i1!=-1):
		arr.append(arr1[i1])
	elif(i2!=-1):
		arr.append(arr2[i2])

	s=""""
	for i in range(n-1):
		if(abs(arr[i]-arr[i+1])==1):
			s=-1
			print(""No answer"")
			break
		else:
			s+=chr(arr[i]+96)

	if(s!=-1):
		s+=chr(arr[-1]+96)
		print(s)
#n=0""""""

n=int(input())
p=int(input())

arr1=list(map(int,input().split("" "")))
arr2=list(map(int,input().split("" "")))

a=1
flag=False
for i in range(n):
	a*=((arr1[i]-1)*(arr2[i]-1))/(arr1[i]*arr2[i])
	if(a==0):
		flag=True
		break

if(flag):
	print(-1)	
else:
	print(p*((1-a)/a))","['binary search', 'math']"
"The only difference between easy and hard versions is constraints.There are $$$n$$$ kids, each of them is reading a unique book. At the end of any day, the $$$i$$$-th kid will give his book to the $$$p_i$$$-th kid (in case of $$$i = p_i$$$ the kid will give his book to himself). It is guaranteed that all values of $$$p_i$$$ are distinct integers from $$$1$$$ to $$$n$$$ (i.e. $$$p$$$ is a permutation). The sequence $$$p$$$ doesn't change from day to day, it is fixed.For example, if $$$n=6$$$ and $$$p=[4, 6, 1, 3, 5, 2]$$$ then at the end of the first day the book of the $$$1$$$-st kid will belong to the $$$4$$$-th kid, the $$$2$$$-nd kid will belong to the $$$6$$$-th kid and so on. At the end of the second day the book of the $$$1$$$-st kid will belong to the $$$3$$$-th kid, the $$$2$$$-nd kid will belong to the $$$2$$$-th kid and so on.Your task is to determine the number of the day the book of the $$$i$$$-th child is returned back to him for the first time for every $$$i$$$ from $$$1$$$ to $$$n$$$.Consider the following example: $$$p = [5, 1, 2, 4, 3]$$$. The book of the $$$1$$$-st kid will be passed to the following kids:  after the $$$1$$$-st day it will belong to the $$$5$$$-th kid,  after the $$$2$$$-nd day it will belong to the $$$3$$$-rd kid,  after the $$$3$$$-rd day it will belong to the $$$2$$$-nd kid,  after the $$$4$$$-th day it will belong to the $$$1$$$-st kid. So after the fourth day, the book of the first kid will return to its owner. The book of the fourth kid will return to him for the first time after exactly one day.You have to answer $$$q$$$ independent queries.","from sys import stdin, stdout 
t = int(stdin.readline())

def getRoot(i,par):
    while i!=par[i]:
        i = par[i]
    return i

def find(a,b,par):
    return getRoot(a,par)==getRoot(b,par)

def doUnion(a,b,par,size):
    if find(a,b,par):
        return False
    r1 = getRoot(a,par)
    r2 = getRoot(b,par)
    s1 = size[r1]
    s2 = size[r2]
    if s1 > s2:
        par[r2] = r1
        size[r1] += s2
    else:
        par[r1] = r2
        size[r2] += s1
    return True


while t>0:
    n = int(stdin.readline())
    a = list( map(int,stdin.readline().split()) )
    par,size = [ i for i in range(n+1) ], [ 1 for i in range(n+1) ]
    for i in range(n):
        x,y = i+1,a[i]
        doUnion(x,y,par,size)
    

    ans = []
    for i in range(n):
        c = size[ getRoot(i+1,par) ]
        ans.append(c)
    for i in range(len(ans)):
        stdout.write(""{} "".format(ans[i]))
    stdout.write(""\n"")
    t-=1","['dsu', 'dfs and similar', 'math']"
"Jamie is preparing a Codeforces round. He has got an idea for a problem, but does not know how to solve it. Help him write a solution to the following problem:Find k integers such that the sum of two to the power of each number equals to the number n and the largest integer in the answer is as small as possible. As there may be multiple answers, you are asked to output the lexicographically largest one. To be more clear, consider all integer sequence with length k (a1, a2, ..., ak) with . Give a value  to each sequence. Among all sequence(s) that have the minimum y value, output the one that is the lexicographically largest.For definitions of powers and lexicographical order see notes.","import math
x, k = map(int, input().split())
kori = k
a = bin(x)

# s = a[2:len(a)]
qtz = 0;
s = []
for i in range(2, len(a)):
    if a[i] == ""1"":
        k-=1
        s.append(1)
    else:
        qtz+=1
        s.append(0)



v = []
for i in range(len(s)):
    if s[i] != 0:
        v.append((len(s)-1)-i)
    # else:
        # v.append(""x"")

# print(qtz, k)
if k < 0:
    print(""No"")
    exit()
else:
    tam = len(s)
    # print(tam)
    print(""Yes"")
    # print(k, s)
    if k > 0:
        p = 0
        #diminui o y máximo
        while(1):
            # print(p, s[p], len(s))
            if tam - 1 <= p:
                s.append(0)
            if s[p] > k:
                break
            else:
                k-= s[p]
                s[p+1] += s[p]*2
                s[p] = 0
                p+=1
        #se k ainda for maior que zero
        if k > 0:
            j = len(s)-1
            while k > 0:
                while s[j] == 0:
                    j-=1
                s[j] -= 1
                if j == len(s)-1:
                    s.append(2)
                    j+=1
                else:
                    s[j+1] += 2
                    j+=1
                k-=1


            # print(s)
        v = []
        for i in range(len(s)):
            for j in range(s[i]):
                v.append((tam-1) -i)
        print(*v)
    else:
        v = []
        for i in range(len(s)):
            for j in range(s[i]):
                v.append(len(s)-1 -i)
        print(*v)","['bitmasks', 'greedy', 'math']"
"Dreamoon likes coloring cells very much.There is a row of $$$n$$$ cells. Initially, all cells are empty (don't contain any color). Cells are numbered from $$$1$$$ to $$$n$$$.You are given an integer $$$m$$$ and $$$m$$$ integers $$$l_1, l_2, \ldots, l_m$$$ ($$$1 \le l_i \le n$$$)Dreamoon will perform $$$m$$$ operations.In $$$i$$$-th operation, Dreamoon will choose a number $$$p_i$$$ from range $$$[1, n-l_i+1]$$$ (inclusive) and will paint all cells from $$$p_i$$$ to $$$p_i+l_i-1$$$ (inclusive) in $$$i$$$-th color. Note that cells may be colored more one than once, in this case, cell will have the color from the latest operation.Dreamoon hopes that after these $$$m$$$ operations, all colors will appear at least once and all cells will be colored. Please help Dreamoon to choose $$$p_i$$$ in each operation to satisfy all constraints.","n, m = [int(i) for i in input().split()]
d = [int(i) for i in input().split()]
if sum(d) < n:
    print(-1)
    exit()
# d = [(dd[i], i) for i in range(m)]
# d.sort()
pos = [0]*m
ind = n
for i in range(m-1, -1, -1):
    ind = min(ind - 1, n - d[i])
    pos[i] = ind

if pos[0] < 0:
    print(-1)
    exit()
lind = -1
for i in range(m):
    if pos[i] <= lind+1:
        break
    pos[i] = lind+1
    lind += d[i]

ppos = [ppp+1 for ppp in pos]
print(*ppos)","['constructive algorithms', 'greedy']"
"The rules of Sith Tournament are well known to everyone. n Sith take part in the Tournament. The Tournament starts with the random choice of two Sith who will fight in the first battle. As one of them loses, his place is taken by the next randomly chosen Sith who didn't fight before. Does it need to be said that each battle in the Sith Tournament ends with a death of one of opponents? The Tournament ends when the only Sith remains alive.Jedi Ivan accidentally appeared in the list of the participants in the Sith Tournament. However, his skills in the Light Side of the Force are so strong so he can influence the choice of participants either who start the Tournament or who take the loser's place after each battle. Of course, he won't miss his chance to take advantage of it. Help him to calculate the probability of his victory.","import math
import sys
n=int(raw_input())
A=[]
#print ""hi""
#sys.stdout.flush()
for j in range(n):
    A+=[[float(x) for x in raw_input().split()]]
#print ""hi""
while(True):
    #print n
    #print A
    if n==1:
        print ""1.0""
        break
    if n==2:
        print A[0][1]
        break
    M=0
    j0=1
    for j in range(1,n):
        if A[0][j]>M:
            j0=j
            M=A[0][j]
    B=[]
    for i in range(n):
        if i==j0:
            continue
        B+=[[]]
        for j in range(n):
            if j==j0:
                continue
            if i!=0 and j!=0:
                B[-1]+=[A[i][j]]
            elif i==0 and j==0:
                B[-1]+=[0]
            elif i==0 and j!=0:
                B[-1]+=[A[0][j]*A[j][j0]+A[0][j0]*A[j0][j]]
            elif i!=0 and j==0:
                B[-1]+=[A[j][0]*A[j][j0]+A[j0][0]*A[j0][j]]
    A=B
    n-=1","['dp', 'bitmasks', 'probabilities', 'math']"
"A colored stripe is represented by a horizontal row of n square cells, each cell is pained one of k colors. Your task is to repaint the minimum number of cells so that no two neighbouring cells are of the same color. You can use any color from 1 to k to repaint the cells.","def f(s, i, flag):
    if s[i] == s[i+1] or s[i] == s[i-1]:
        if not flag and i < n - 2 and s[i] == s[i+2]:
            f(s, i + 1, True)
        elif s[i] >= 'C':
            s[i] = 'A'
            f(s, i, True)
        else:
            s[i] = chr(ord(s[i]) + 1)
            f(s, i, True)

n, k = map(int, raw_input().split())
s = list(raw_input())
c = 0

if n == 1:
    pass
elif k == 2:
    ss = list(s)
    c1 = 0
    c2 = 0
    for i in xrange(n):
        if s[i] != chr(ord('A') + i % 2):
            s[i] = chr(ord('A') + i % 2)
            c1 += 1
        if ss[i] != chr(ord('B') - i % 2):
            ss[i] = chr(ord('B') - i % 2)
            c2 += 1
    if c1 < c2:
        c = c1
    else:
        c = c2
        s = ss
else:
    for i in xrange(0, n - 1):
        if s[i] == s[i+1]:
            f(s, i, False)
            c += 1

print c
print """".join(s)","['dp', 'greedy', 'brute force']"
"A queen is the strongest chess piece. In modern chess the queen can move any number of squares in any horizontal, vertical or diagonal direction (considering that there're no other pieces on its way). The queen combines the options given to the rook and the bishop.There are m queens on a square n × n chessboard. You know each queen's positions, the i-th queen is positioned in the square (ri, ci), where ri is the board row number (numbered from the top to the bottom from 1 to n), and ci is the board's column number (numbered from the left to the right from 1 to n). No two queens share the same position.For each queen one can count w — the number of other queens that the given queen threatens (attacks). For a fixed attack direction only the first queen in this direction is under attack if there are many queens are on the ray of the attack. Obviously, for any queen w is between 0 and 8, inclusive.Print the sequence t0, t1, ..., t8, where ti is the number of queens that threaten exactly i other queens, i.e. the number of queens that their w equals i.","n,m=list(map(int,input().split()))
f=[]
maxx=[-999999999]*n
minx=[999999999]*n
maxy=[-999999999]*n
miny=[999999999]*n
maxm=[-999999999]*(2*n-1)
minm=[999999999]*(2*n-1)
maxs=[-999999999]*(2*n-1)
mins=[999999999]*(2*n-1)
r=[0 for i in range(9)]
for i in range(m):
    y,x=list(map(int,input().split()))
    a,b,c,d=y-1,x-1,y+x-2,y-x+n-1
    f.append((a,b,c,d))
    if a>maxx[b]:maxx[b]=a
    if a<minx[b]:minx[b]=a
    if x-1>maxy[a]:maxy[a]=x-1
    if x-1<miny[a]:miny[a]=x-1
    if c>maxs[d]:maxs[d]=c
    if c<mins[d]:mins[d]=c
    if d>maxm[c]:maxm[c]=d
    if d<minm[c]:minm[c]=d
for i in f:
    k=0
    if i[0]<maxx[i[1]]:k+=1
    if i[0]>minx[i[1]]:k+=1
    if i[1]<maxy[i[0]]:k+=1
    if i[1]>miny[i[0]]:k+=1
    if i[2]<maxs[i[3]]:k+=1
    if i[2]>mins[i[3]]:k+=1
    if i[3]<maxm[i[2]]:k+=1
    if i[3]>minm[i[2]]:k+=1
    r[k]+=1
print(*r)",['sortings']
"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i + 1. Reaching a certain rank i having not reached all the previous i - 1 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","n = int(input())
d = [int(x) for x in input().split()]
a, b = [int(x) for x in input().split()]
print(d[a-1]+sum(d[a:b-1]))",['implementation']
"Hanh lives in a shared apartment. There are $$$n$$$ people (including Hanh) living there, each has a private fridge. $$$n$$$ fridges are secured by several steel chains. Each steel chain connects two different fridges and is protected by a digital lock. The owner of a fridge knows passcodes of all chains connected to it. A fridge can be open only if all chains connected to it are unlocked. For example, if a fridge has no chains connected to it at all, then any of $$$n$$$ people can open it.    For exampe, in the picture there are $$$n=4$$$ people and $$$5$$$ chains. The first person knows passcodes of two chains: $$$1-4$$$ and $$$1-2$$$. The fridge $$$1$$$ can be open by its owner (the person $$$1$$$), also two people $$$2$$$ and $$$4$$$ (acting together) can open it. The weights of these fridges are $$$a_1, a_2, \ldots, a_n$$$. To make a steel chain connecting fridges $$$u$$$ and $$$v$$$, you have to pay $$$a_u + a_v$$$ dollars. Note that the landlord allows you to create multiple chains connecting the same pair of fridges. Hanh's apartment landlord asks you to create exactly $$$m$$$ steel chains so that all fridges are private. A fridge is private if and only if, among $$$n$$$ people living in the apartment, only the owner can open it (i.e. no other person acting alone can do it). In other words, the fridge $$$i$$$ is not private if there exists the person $$$j$$$ ($$$i \ne j$$$) that the person $$$j$$$ can open the fridge $$$i$$$.For example, in the picture all the fridges are private. On the other hand, if there are $$$n=2$$$ fridges and only one chain (which connects them) then both fridges are not private (both fridges can be open not only by its owner but also by another person).Of course, the landlord wants to minimize the total cost of all steel chains to fulfill his request. Determine whether there exists any way to make exactly $$$m$$$ chains, and if yes, output any solution that minimizes the total cost.","t=int(input())
while t>0:
	n,m =map(int,input().split())
	a=[int(x) for x in input().split()]
	if(n==2):
		print(-1)
	elif(n>m):
		print(-1)
	else:
		print(2*sum(a))
		for _ in range(0,n):
			print(_+1,(_+1)%n+1)
	t-=1","['implementation', 'graphs']"
"The bear has a string s = s1s2... s|s| (record |s| is the string's length), consisting of lowercase English letters. The bear wants to count the number of such pairs of indices i, j (1 ≤ i ≤ j ≤ |s|), that string x(i, j) = sisi + 1... sj contains at least one string ""bear"" as a substring.String x(i, j) contains string ""bear"", if there is such index k (i ≤ k ≤ j - 3), that sk = b, sk + 1 = e, sk + 2 = a, sk + 3 = r.Help the bear cope with the given problem.","import sys, math
def rs():
    return sys.stdin.readline().strip()
def ri():
    return int(sys.stdin.readline().strip())
def ras():
    return list(sys.stdin.readline().strip())
def rai():
    return map(int,sys.stdin.readline().strip().split())




def solve():
    # s = ""bear""*(5000/4)
    s = rs()
    l = len(s)

    sm = 0

    bears = 0

    c = 0

    for x in xrange(l - 3):
        if s[x] == ""b"" and s[x+1] == ""e"" and s[x+2] == ""a"" and s[x+3] == ""r"":
            if bears:
                con = (x-c)
            else:
                con = (x+1)
            sm += con*(l-3-x)
            c = x
            bears +=1
    return sm

print solve()","['greedy', 'math', 'implementation', 'brute force', 'strings']"
"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","import itertools
import math

import time
def timer(f):
    def tmp(*args, **kwargs):
        t = time.time()
        res = f(*args, **kwargs)
        print(""Время выполнения функции: %f"" % (time.time()-t))
        return res

    return tmp

#n = int(input())

n, m = map(int, input().split(' '))
array = list(map(int, input().split(' ')))
matrix = [[0 for j in range(n)] for i in range(n)]
for i in range(m):
    a, b = map(int, input().split(' '))
    a-=1
    b-=1
    matrix[a][b] = 1
    matrix[b][a] = 1

price = 100000000000000
u = 0;
uu = 0;
uuu = 0;
for i in range(n):
    for j in range(n):
        for k in range(n):
            if i!=j and j!=k and i!=k:
                if matrix[i][j]==1 and matrix[i][k]==1 and matrix[j][k]==1:
                    cp = array[i]+array[j]+array[k]
                    if cp<price:
                        price = cp
                        u = i
                        uu = j
                        uuu = k
                else:
                    #print(i, j, k)
                    pass


if price == 100000000000000:
    print(-1)
else:
    print(price)",['brute force']
"Anton likes to play chess. Also, he likes to do programming. That is why he decided to write the program that plays chess. However, he finds the game on 8 to 8 board to too simple, he uses an infinite one instead.The first task he faced is to check whether the king is in check. Anton doesn't know how to implement this so he asks you to help.Consider that an infinite chess board contains one white king and the number of black pieces. There are only rooks, bishops and queens, as the other pieces are not supported yet. The white king is said to be in check if at least one black piece can reach the cell with the king in one move. Help Anton and write the program that for the given position determines whether the white king is in check.Remainder, on how do chess pieces move:   Bishop moves any number of cells diagonally, but it can't ""leap"" over the occupied cells.  Rook moves any number of cells horizontally or vertically, but it also can't ""leap"" over the occupied cells.  Queen is able to move any number of cells horizontally, vertically or diagonally, but it also can't ""leap"".","n=input()
x,y=map(int,raw_input().split())
v=[(10**11,'?')]*8
for _ in range(n):
  c,i,j=raw_input().split()
  i,j=int(i),int(j)
  if i==x:
    d=j-y
    if d>0 and d<v[0][0]:
      v[0]=(d,c)
    elif d<0 and -d<v[1][0]:
      v[1]=(-d,c)
  if j==y:
    d=i-x
    if d>0 and d<v[2][0]:
      v[2]=(d,c)
    elif d<0 and -d<v[3][0]:
      v[3]=(-d,c)
  if i-x==j-y:
    d=i-x
    if d>0 and d<v[4][0]:
      v[4]=(d,c)
    elif d<0 and -d<v[5][0]:
      v[5]=(-d,c)
  if i-x==y-j:
    d=i-x
    if d>0 and d<v[6][0]:
      v[6]=(d,c)
    elif d<0 and -d<v[7][0]:
      v[7]=(-d,c)
print 'YES' if v[0][1] in 'RQ' or v[1][1] in 'RQ' or v[2][1] in 'RQ' or v[3][1] in 'RQ' or v[4][1] in 'BQ' or v[5][1] in 'BQ' or v[6][1] in 'BQ' or v[7][1] in 'BQ' else 'NO'",['implementation']
"You are given an array $$$a$$$ of $$$n$$$ integers, where $$$n$$$ is odd. You can make the following operation with it:  Choose one of the elements of the array (for example $$$a_i$$$) and increase it by $$$1$$$ (that is, replace it with $$$a_i + 1$$$). You want to make the median of the array the largest possible using at most $$$k$$$ operations.The median of the odd-sized array is the middle element after the array is sorted in non-decreasing order. For example, the median of the array $$$[1, 5, 2, 3, 5]$$$ is $$$3$$$.","# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
 
#N = int(input())
#s = input()
N,K = [int(x) for x in stdin.readline().split()]
arr = [int(x) for x in stdin.readline().split()]
 
arr.sort()
 
half = N//2
s = sum(arr[half:])
 
bound = s + K
res = 0
for i in range(N-1,(N//2)-1,-1):
    if bound//(i-half+1)>arr[i]:
        res = max(res,bound//(i-half+1))
        if i!=N-1 and res>arr[i+1]:
            res = arr[i+1]
        break
    else:
        bound -= arr[i]
 
print(res)","['binary search', 'sortings', 'greedy', 'math']"
"Kevin Sun wants to move his precious collection of n cowbells from Naperthrill to Exeter, where there is actually grass instead of corn. Before moving, he must pack his cowbells into k boxes of a fixed size. In order to keep his collection safe during transportation, he won't place more than two cowbells into a single box. Since Kevin wishes to minimize expenses, he is curious about the smallest size box he can use to pack his entire collection. Kevin is a meticulous cowbell collector and knows that the size of his i-th (1 ≤ i ≤ n) cowbell is an integer si. In fact, he keeps his cowbells sorted by size, so si - 1 ≤ si for any i &gt; 1. Also an expert packer, Kevin can fit one or two cowbells into a box of size s if and only if the sum of their sizes does not exceed s. Given this information, help Kevin determine the smallest s for which it is possible to put all of his cowbells into k boxes of size s.","n,k=map(int,raw_input().split())
ar=map(int,raw_input().split())
sz=0
st=0
en=n-1
while n!=0:
	if 2*k>n:
		sz=max(sz,ar[en])
		en-=1
		k-=1
		n-=1
	else:
		if(st!=en):
			sz=max(sz,ar[st]+ar[en])
			st+=1
			en-=1
			n-=2
		else:
			sz=max(sz,ar[st])
			n-=1
		k-=1
print sz","['binary search', 'greedy']"
"Johnny drives a truck and must deliver a package from his hometown to the district center. His hometown is located at point 0 on a number line, and the district center is located at the point d.Johnny's truck has a gas tank that holds exactly n liters, and his tank is initially full. As he drives, the truck consumes exactly one liter per unit distance traveled. Moreover, there are m gas stations located at various points along the way to the district center. The i-th station is located at the point xi on the number line and sells an unlimited amount of fuel at a price of pi dollars per liter. Find the minimum cost Johnny must pay for fuel to successfully complete the delivery.","from sys import stdin
from itertools import repeat
from heapq import heappush, heappop
def main():
    d, n, m = map(int, stdin.readline().split())
    dat = map(int, stdin.read().split(), repeat(10, 2 * m))
    a = [(d, 0)] + [(dat[i*2], dat[i*2+1]) for i in xrange(m)]
    a.sort(reverse=True)
    if a[-1][0] > n:
        print -1
        return
    v = []
    while a and a[-1][0] <= n:
        t, x = a.pop()
        heappush(v, (x, t))
    ans = 0
    p = n
    for t, x in reversed(a):
        if t - p > n:
            print -1
            return
        while p < t:
            y, s = v[0]
            f = s + n - p
            if f > 0:
                if f > t - p:
                    f = t - p
                ans += y * f
                p += f
            else:
                heappop(v)
        heappush(v, (x, t))
    print ans
main()","['data structures', 'divide and conquer', 'greedy']"
"Sereja has two sequences a and b and number p. Sequence a consists of n integers a1, a2, ..., an. Similarly, sequence b consists of m integers b1, b2, ..., bm. As usual, Sereja studies the sequences he has. Today he wants to find the number of positions q (q + (m - 1)·p ≤ n; q ≥ 1), such that sequence b can be obtained from sequence aq, aq + p, aq + 2p, ..., aq + (m - 1)p by rearranging elements.Sereja needs to rush to the gym, so he asked to find all the described positions of q.","from collections import Counter

n, m, p = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))


def try_from(start, a, b):
    result = []
    seq = a[start::p]
    i = 0
    if len(seq) < len(b):
        return []

    counts_a = Counter(seq[:len(b)])
    counts_b = Counter(b)
    if counts_a == counts_b:
        result.append(start)

    for i in range(1, len(seq) - len(b) + 1):
        counts_a[seq[i-1]] -= 1
        counts_a[seq[i+len(b) - 1]] += 1
        if not counts_a[seq[i-1]]:
            del counts_a[seq[i-1]]

        ok = counts_a == counts_b
        #ok = sorted(seq[i:i+len(b)]) == sorted(b)

        if ok:
            result.append(start + p * i)

    return [x + 1 for x in result]


result = []
for start in range(p):
    result += try_from(start, a, b)

print(len(result))
print(' '.join(map(str, sorted(result))))","['data structures', 'two pointers']"
"As it's the first of April, Heidi is suspecting that the news she reads today are fake, and she does not want to look silly in front of all the contestants. She knows that a newspiece is fake if it contains heidi as a subsequence. Help Heidi assess whether the given piece is true, but please be discreet about it...","x =[i for i in input()]

def charpos(c1,arr):
	for i in range(len(arr)):
		if arr[i] ==c1:
			return i
	return -1
temp=0
result =True
for i in ""heidi"":	
	temp = charpos(i,x)
	x = x[temp:]
	if temp==-1:
		result=False
		break
	
if result:
	print(""YES"")
else:
	print(""NO"")","['implementation', 'strings']"
"Inaka has a disc, the circumference of which is $$$n$$$ units. The circumference is equally divided by $$$n$$$ points numbered clockwise from $$$1$$$ to $$$n$$$, such that points $$$i$$$ and $$$i + 1$$$ ($$$1 \leq i &lt; n$$$) are adjacent, and so are points $$$n$$$ and $$$1$$$.There are $$$m$$$ straight segments on the disc, the endpoints of which are all among the aforementioned $$$n$$$ points.Inaka wants to know if her image is rotationally symmetrical, i.e. if there is an integer $$$k$$$ ($$$1 \leq k &lt; n$$$), such that if all segments are rotated clockwise around the center of the circle by $$$k$$$ units, the new image will be the same as the original one.","n, m = [int(i) for i in input().split()]
s = {tuple(sorted([int(i) - 1 for i in input().split()])) for i in range(m)}
for i in range(1, n):
    if n % i == 0 and all((n // i) % j for j in range(2, min(n // i, int((n // i) ** 0.5) + 2))):
        if {tuple(sorted([(t[0] + i) % n, (t[1] + i) % n])) for t in s} == s:
            print(""Yes"")
            break
else:
    print(""No"")","['implementation', 'hashing', 'strings']"
"You are given three strings $$$s$$$, $$$t$$$ and $$$p$$$ consisting of lowercase Latin letters. You may perform any number (possibly, zero) operations on these strings.During each operation you choose any character from $$$p$$$, erase it from $$$p$$$ and insert it into string $$$s$$$ (you may insert this character anywhere you want: in the beginning of $$$s$$$, in the end or between any two consecutive characters). For example, if $$$p$$$ is aba, and $$$s$$$ is de, then the following outcomes are possible (the character we erase from $$$p$$$ and insert into $$$s$$$ is highlighted):  aba $$$\rightarrow$$$ ba, de $$$\rightarrow$$$ ade;  aba $$$\rightarrow$$$ ba, de $$$\rightarrow$$$ dae;  aba $$$\rightarrow$$$ ba, de $$$\rightarrow$$$ dea;  aba $$$\rightarrow$$$ aa, de $$$\rightarrow$$$ bde;  aba $$$\rightarrow$$$ aa, de $$$\rightarrow$$$ dbe;  aba $$$\rightarrow$$$ aa, de $$$\rightarrow$$$ deb;  aba $$$\rightarrow$$$ ab, de $$$\rightarrow$$$ ade;  aba $$$\rightarrow$$$ ab, de $$$\rightarrow$$$ dae;  aba $$$\rightarrow$$$ ab, de $$$\rightarrow$$$ dea; Your goal is to perform several (maybe zero) operations so that $$$s$$$ becomes equal to $$$t$$$. Please determine whether it is possible.Note that you have to answer $$$q$$$ independent queries.","t=int(input())
for _ in range(t):
    s=input()
    t=input()
    p=input()
    
    
    if(len(t)<len(s)):
        print('NO')
    elif(len(t)==len(s)):
        if(t==s):
            print('YES')
        else:
            print('NO')
    else:
        j=0
        c=0
        for i in s:
            while(j<len(t)):
                if(t[j]==i):
                    c+=1
                    j+=1
                    break
                j+=1
        if(c==len(s)):
            f=0
            s=s+' '
            for i in range(len(t)):
                #print(t[i])
                if(t[i]!=s[i]):
                    if(t[i] in p):
                        s=s[:i]+t[i]+s[i:]
                        index=p.index(t[i])
                        p=p[:index]+p[index+1:]
                        #print(p)
                    else:
                        print('NO')
                        f=1
                        break
            if(f==0):
                print('YES')
        else:
            print('NO')","['implementation', 'strings']"
"This is the hard version of this problem. The only difference is the constraint on $$$k$$$ — the number of gifts in the offer. In this version: $$$2 \le k \le n$$$.Vasya came to the store to buy goods for his friends for the New Year. It turned out that he was very lucky — today the offer ""$$$k$$$ of goods for the price of one"" is held in store.Using this offer, Vasya can buy exactly $$$k$$$ of any goods, paying only for the most expensive of them. Vasya decided to take this opportunity and buy as many goods as possible for his friends with the money he has.More formally, for each good, its price is determined by $$$a_i$$$ — the number of coins it costs. Initially, Vasya has $$$p$$$ coins. He wants to buy the maximum number of goods. Vasya can perform one of the following operations as many times as necessary:  Vasya can buy one good with the index $$$i$$$ if he currently has enough coins (i.e $$$p \ge a_i$$$). After buying this good, the number of Vasya's coins will decrease by $$$a_i$$$, (i.e it becomes $$$p := p - a_i$$$).  Vasya can buy a good with the index $$$i$$$, and also choose exactly $$$k-1$$$ goods, the price of which does not exceed $$$a_i$$$, if he currently has enough coins (i.e $$$p \ge a_i$$$). Thus, he buys all these $$$k$$$ goods, and his number of coins decreases by $$$a_i$$$ (i.e it becomes $$$p := p - a_i$$$). Please note that each good can be bought no more than once.For example, if the store now has $$$n=5$$$ goods worth $$$a_1=2, a_2=4, a_3=3, a_4=5, a_5=7$$$, respectively, $$$k=2$$$, and Vasya has $$$6$$$ coins, then he can buy $$$3$$$ goods. A good with the index $$$1$$$ will be bought by Vasya without using the offer and he will pay $$$2$$$ coins. Goods with the indices $$$2$$$ and $$$3$$$ Vasya will buy using the offer and he will pay $$$4$$$ coins. It can be proved that Vasya can not buy more goods with six coins.Help Vasya to find out the maximum number of goods he can buy.","def idp(a,dp,i,k):
    if (i-k) >= 0:
        return min(a[i]+dp[i-1], a[i]+dp[i-k])
    else:
        return a[i]+dp[i-1]

t = int(input())
for tc in range(t):
    n,p,k = map(int, input().split())
    a = [int(x) for x in input().split()]

    a.sort()
    dp = [0]*n

    dp[0] = a[0]
    for i in range(0,k-1):
        dp[i] = a[i]+dp[i-1]
    
    dp[k-1] = a[k-1]

    for i in range(k,n):
        dp[i] = idp(a,dp,i,k)

    bst = 0
    for i in range(n):
        if dp[i] <= p:
            bst = i+1
    print(bst)","['dp', 'sortings', 'greedy']"
"Everybody seems to think that the Martians are green, but it turns out they are metallic pink and fat. Ajs has two bags of distinct nonnegative integers. The bags are disjoint, and the union of the sets of numbers in the bags is $$$\{0,1,…,M-1\}$$$, for some positive integer $$$M$$$. Ajs draws a number from the first bag and a number from the second bag, and then sums them modulo $$$M$$$.What are the residues modulo $$$M$$$ that Ajs cannot obtain with this action?","import sys
input = sys.stdin.readline

def main():
    n, m = map(int, input().split())
    a = list(map(int, input().split())) + [0]*500000
    ans_S = 0
    a[n] = a[0] + m
    s = [0]*600600
    for i in range(n):
        s[i] = a[i + 1] - a[i]
    s[n] = -1
    for i in range(n):
        s[2*n - i] = s[i]
    for i in range(2*n + 1, 3*n + 1):
        s[i] = s[i - n]
    l, r = 0, 0
    z = [0]*600600
    for i in range(1, 3*n + 1):
        if i < r:
            z[i] = z[i - l]
        while i + z[i] <= 3*n and (s[i + z[i]] == s[z[i]]):
            z[i] += 1
        if i + z[i] > r:
            l = i
            r = i + z[i]
    ans = []
    for i in range(n + 1, 2*n + 1):
        if z[i] < n:
            continue
        ans_S += 1
        ans.append((a[0] + a[2*n - i + 1]) % m)
    ans.sort()
    print(ans_S)
    print(*ans)
    return

if __name__==""__main__"":
    main()","['number theory', 'hashing']"
"You are given a tree (an undirected connected acyclic graph) consisting of $$$n$$$ vertices. You are playing a game on this tree.Initially all vertices are white. On the first turn of the game you choose one vertex and paint it black. Then on each turn you choose a white vertex adjacent (connected by an edge) to any black vertex and paint it black.Each time when you choose a vertex (even during the first turn), you gain the number of points equal to the size of the connected component consisting only of white vertices that contains the chosen vertex. The game ends when all vertices are painted black.Let's see the following example:Vertices $$$1$$$ and $$$4$$$ are painted black already. If you choose the vertex $$$2$$$, you will gain $$$4$$$ points for the connected component consisting of vertices $$$2, 3, 5$$$ and $$$6$$$. If you choose the vertex $$$9$$$, you will gain $$$3$$$ points for the connected component consisting of vertices $$$7, 8$$$ and $$$9$$$.Your task is to maximize the number of points you gain.","import sys
from collections import deque
input = sys.stdin.readline

n=int(input())
E=[[] for i in range(n+1)]

for i in range(n-1):
    x,y=map(int,input().split())

    E[x].append(y)
    E[y].append(x)

H=[-1]*(n+1)

H[1]=0
QUE=deque([1])
fromnode=[-1]*(n+1)

while QUE:
    x=QUE.pop()
    for to in E[x]:
        if H[to]==-1:
            H[to]=H[x]+1
            fromnode[to]=x
            QUE.append(to)
        
S=list(range(1,n+1))
S.sort(key=lambda x:H[x],reverse=True)

DP1=[0]*(n+1) # from the other nodes to 1
Size=[0]*(n+1)
for s in S:
    for to in E[s]:
        if Size[to]!=0:
            Size[s]+=Size[to]
            DP1[s]+=DP1[to]
    Size[s]+=1
    DP1[s]+=Size[s]

ANS=[0]*(n+1)
ANS[1]=DP1[1]

for s in S[::-1][1:]:
    ANS[s]=ANS[fromnode[s]]+n-2*Size[s]

print(max(ANS))","['dp', 'dfs and similar', 'trees']"
"Sereja and Dima play a game. The rules of the game are very simple. The players have n cards in a row. Each card contains a number, all numbers on the cards are distinct. The players take turns, Sereja moves first. During his turn a player can take one card: either the leftmost card in a row, or the rightmost one. The game ends when there is no more cards. The player who has the maximum sum of numbers on his cards by the end of the game, wins.Sereja and Dima are being greedy. Each of them chooses the card with the larger number during his move.Inna is a friend of Sereja and Dima. She knows which strategy the guys are using, so she wants to determine the final score, given the initial state of the game. Help her.","from sys import stdin
n = int(stdin.readline())
l = list(map(int, stdin.readline().split(' ')))
values = [0, 0]

while l != []:
    for v in [0,1]:
        if l[0] >= l[-1]:
            values[v] += l.pop(0)
        else:
            values[v] += l.pop(-1)
        if l == []:
            break

print(values[0], values[1])","['two pointers', 'implementation', 'greedy']"
"A sequence a0, a1, ..., at - 1 is called increasing if ai - 1 &lt; ai for each i: 0 &lt; i &lt; t.You are given a sequence b0, b1, ..., bn - 1 and a positive integer d. In each move you may choose one element of the given sequence and add d to it. What is the least number of moves required to make the given sequence increasing?","I=lambda:map(int,input().split())
n,d=I()
a=*I(),
x=a[0]
r=0
for y in a[1:]:
  z=0--(x+1-y)//d
  if z>=0:
    r+=z
    y+=z*d
  x=y
print(r)","['constructive algorithms', 'implementation', 'math']"
"Today the kindergarten has a new group of $$$n$$$ kids who need to be seated at the dinner table. The chairs at the table are numbered from $$$1$$$ to $$$4n$$$. Two kids can't sit on the same chair. It is known that two kids who sit on chairs with numbers $$$a$$$ and $$$b$$$ ($$$a \neq b$$$) will indulge if:   $$$gcd(a, b) = 1$$$ or,  $$$a$$$ divides $$$b$$$ or $$$b$$$ divides $$$a$$$. $$$gcd(a, b)$$$ — the maximum number $$$x$$$ such that $$$a$$$ is divisible by $$$x$$$ and $$$b$$$ is divisible by $$$x$$$.For example, if $$$n=3$$$ and the kids sit on chairs with numbers $$$2$$$, $$$3$$$, $$$4$$$, then they will indulge since $$$4$$$ is divided by $$$2$$$ and $$$gcd(2, 3) = 1$$$. If kids sit on chairs with numbers $$$4$$$, $$$6$$$, $$$10$$$, then they will not indulge.The teacher really doesn't want the mess at the table, so she wants to seat the kids so there are no $$$2$$$ of the kid that can indulge. More formally, she wants no pair of chairs $$$a$$$ and $$$b$$$ that the kids occupy to fulfill the condition above.Since the teacher is very busy with the entertainment of the kids, she asked you to solve this problem.","from collections import Counter, defaultdict, deque
import bisect
import heapq
from sys import stdin, stdout
from itertools import repeat
import math
import random
import copy

# sys.stdin = open('input')

def mod(x, y, mod):
    re = 1
    now = x
    while y:
        if y&1:
            re *= now
            re %= mod
        y >>= 1
        now = (now*now)%mod
    return re

def inp(force_list=False):
    re = map(int, raw_input().split())
    if len(re) == 1 and not force_list:
        return re[0]
    return re

def inst():
    return raw_input().strip()

def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

def ggcd(x, y):
    if y:
        return ggcd(y, x%y)
    return x

MOD = int(1e9+7)


def my_main():
    T = inp()
    for _ in range(T):
        n = inp()
        c = 4*n
        for i in range(n):
            print c - i*2,
        print ''


my_main()","['constructive algorithms', 'math']"
"You are given a rectangular grid of lattice points from (0, 0) to (n, m) inclusive. You have to choose exactly 4 different points to build a polyline possibly with self-intersections and self-touching. This polyline should be as long as possible.A polyline defined by points p1, p2, p3, p4 consists of the line segments p1 p2, p2 p3, p3 p4, and its length is the sum of the lengths of the individual line segments.","import sys
import itertools
from math import *
n, m = map(int, raw_input().split("" ""))

a, b = None, None
for i in xrange(0, n + 1):
    for j in xrange(0, m + 1):
        if not ((i, j) in [(0, 0), (n, m)]):
            if a == None and b == None:
                a = i
                b = j
            else:
                if (0 - i)**2 + (0 - j)**2 > (0 - a)**2 + (0 - b)**2:
                    a, b = i, j
v = [(a, b), (0, 0)]

c, d = a, b
a, b = None, None
for i in xrange(0, n + 1):
    for j in xrange(0, m + 1):
        if not ((i, j) in [(0, 0), (n, m), (c, d)]):
            if a == None and b == None:
                a = i
                b = j
            else:
                if (n - i)**2 + (m - j)**2 > (n - a)**2 + (m - b)**2:
                    a, b = i, j
v += [(n, m), (a, b)]

#print v

def d(x):
    return sqrt((x[1][0] - x[0][0])**2 + (x[1][1] - x[0][1])**2) + sqrt((x[2][0] - x[1][0])**2 + (x[2][1] - x[1][1])**2) + sqrt((x[3][0] - x[2][0])**2 + (x[3][1] - x[2][1])**2)

v = list(itertools.permutations(v))
if n != 0 and m != 0:
    v += list(itertools.permutations([(0, 0), (n, m), (n, 0), (0, m)]))
for a in sorted(zip(map(d, v), v))[-1][1]:
    print ""%d %d"" % a","['constructive algorithms', 'geometry', 'trees', 'brute force']"
"The annual college sports-ball tournament is approaching, which for trademark reasons we'll refer to as Third Month Insanity. There are a total of 2N teams participating in the tournament, numbered from 1 to 2N. The tournament lasts N rounds, with each round eliminating half the teams. The first round consists of 2N - 1 games, numbered starting from 1. In game i, team 2·i - 1 will play against team 2·i. The loser is eliminated and the winner advances to the next round (there are no ties). Each subsequent round has half as many games as the previous round, and in game i the winner of the previous round's game 2·i - 1 will play against the winner of the previous round's game 2·i.Every year the office has a pool to see who can create the best bracket. A bracket is a set of winner predictions for every game. For games in the first round you may predict either team to win, but for games in later rounds the winner you predict must also be predicted as a winner in the previous round. Note that the bracket is fully constructed before any games are actually played. Correct predictions in the first round are worth 1 point, and correct predictions in each subsequent round are worth twice as many points as the previous, so correct predictions in the final game are worth 2N - 1 points.For every pair of teams in the league, you have estimated the probability of each team winning if they play against each other. Now you want to construct a bracket with the maximum possible expected score.","import sys

N = int(sys.stdin.readline())
P = []
for i in range(2 ** N) :
  P.append([int(x)/100. for x in sys.stdin.readline().split()])

Prounds = [[1 for i in range(2**N)] for j in range(N+1) ]
rounds = [[0 for i in range(2**N)] for j in range(N+1) ]

for i in range(1, N+1) :
  for player_a in range(2 ** N) :
    top = int(player_a / (2 ** i)) * (2 ** i)
    bottom = top + (2 ** i)
    mid = bottom - (2 ** (i - 1))
    
    
    Prounds[i][player_a] = Prounds[i-1][player_a] * sum([P[player_a][player_b]*Prounds[i-1][player_b] for player_b in (range(mid, bottom) if player_a < mid else range(top, mid))])
    
    rounds[i][player_a] = max([rounds[i-1][player_a] + rounds[i-1][player_b] + (2 ** (i-1))*Prounds[i][player_a] for player_b in (range(mid, bottom) if player_a < mid else range(top, mid))])
    
print max(rounds[N])","['dp', 'probabilities', 'trees']"
"Pig is visiting a friend.Pig's house is located at point 0, and his friend's house is located at point m on an axis.Pig can use teleports to move along the axis.To use a teleport, Pig should come to a certain point (where the teleport is located) and choose where to move: for each teleport there is the rightmost point it can move Pig to, this point is known as the limit of the teleport.Formally, a teleport located at point x with limit y can move Pig from point x to any point within the segment [x; y], including the bounds.  Determine if Pig can visit the friend using teleports only, or he should use his car.","[n,m]=[int(i) for i in input().split()]
a=[]
for i in range(n):
    a.append([int(j) for j in input().split()])
a.sort()
b=[a[0]]
for i in a[1:]:
    if i[0]==b[-1][0]:
        b[-1]=i
    else:
        b.append(i)
x=0
for i in b:
    if x <i[0]:
        break
    x=max(x,i[1])
if x==m:
    print(""YES"")
else:
    print(""NO"")","['implementation', 'greedy']"
"You're given an array $$$b$$$ of length $$$n$$$. Let's define another array $$$a$$$, also of length $$$n$$$, for which $$$a_i = 2^{b_i}$$$ ($$$1 \leq i \leq n$$$). Valerii says that every two non-intersecting subarrays of $$$a$$$ have different sums of elements. You want to determine if he is wrong. More formally, you need to determine if there exist four integers $$$l_1,r_1,l_2,r_2$$$ that satisfy the following conditions:   $$$1 \leq l_1 \leq r_1 \lt l_2 \leq r_2 \leq n$$$;  $$$a_{l_1}+a_{l_1+1}+\ldots+a_{r_1-1}+a_{r_1} = a_{l_2}+a_{l_2+1}+\ldots+a_{r_2-1}+a_{r_2}$$$. If such four integers exist, you will prove Valerii wrong. Do they exist?An array $$$c$$$ is a subarray of an array $$$d$$$ if $$$c$$$ can be obtained from $$$d$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.","t = int(input())
for i in range(t):
    n = int(input())
    b = list(map(int, input().split()))
    a = {}
    for x in b:
        a[x] = a.get(x, 0) + 1
    for x in a:
        if a[x] > 1:
            print('YES')
            break
    else:
        print('NO')","['data structures', 'constructive algorithms', 'sortings', 'greedy']"
"Since Sonya is interested in robotics too, she decided to construct robots that will read and recognize numbers.Sonya has drawn $$$n$$$ numbers in a row, $$$a_i$$$ is located in the $$$i$$$-th position. She also has put a robot at each end of the row (to the left of the first number and to the right of the last number). Sonya will give a number to each robot (they can be either same or different) and run them. When a robot is running, it is moving toward to another robot, reading numbers in the row. When a robot is reading a number that is equal to the number that was given to that robot, it will turn off and stay in the same position.Sonya does not want robots to break, so she will give such numbers that robots will stop before they meet. That is, the girl wants them to stop at different positions so that the first robot is to the left of the second one.For example, if the numbers $$$[1, 5, 4, 1, 3]$$$ are written, and Sonya gives the number $$$1$$$ to the first robot and the number $$$4$$$ to the second one, the first robot will stop in the $$$1$$$-st position while the second one in the $$$3$$$-rd position. In that case, robots will not meet each other. As a result, robots will not be broken. But if Sonya gives the number $$$4$$$ to the first robot and the number $$$5$$$ to the second one, they will meet since the first robot will stop in the $$$3$$$-rd position while the second one is in the $$$2$$$-nd position.Sonya understands that it does not make sense to give a number that is not written in the row because a robot will not find this number and will meet the other robot.Sonya is now interested in finding the number of different pairs that she can give to robots so that they will not meet. In other words, she wants to know the number of pairs ($$$p$$$, $$$q$$$), where she will give $$$p$$$ to the first robot and $$$q$$$ to the second one. Pairs ($$$p_i$$$, $$$q_i$$$) and ($$$p_j$$$, $$$q_j$$$) are different if $$$p_i\neq p_j$$$ or $$$q_i\neq q_j$$$.Unfortunately, Sonya is busy fixing robots that broke after a failed launch. That is why she is asking you to find the number of pairs that she can give to robots so that they will not meet.","cnt = int(input())
data = [int(x) for x in input().split()]
#data = [13036,23902,71466,9482,98728,78471,22915,2470,5999,53211,25994,3996,11349,30511,56448,17277,78308,18316,42069,38636,63127,26256,63985,57249,58305,64366,17839,28518,18980,95945,36316,6076,69530,96509,6940,6039,56048,41847,82118,41054,49670,95896,45891,74636,90736,75413,27251,87730,68344,66202,71879,51666,8985,42722,49000,43845,44614,4961,64751,97655,79361,80091,12747,20934,9188,74058,93662,8454,79516,91323,42656,33567,44392,58833,93051,86157,10398,79297,33197,13472,59847,34005,84201,20634,9790,71913]
#data = [1, 3, 5, 7, 3, 10,7,4]
#print(data)
totalSolutions = 0
tset1 = set([data[-1]])
data2 = []
aug = data[:]
aug[-1] = 1
for x in range(-2,-len(data)-1,-1):
    if data[x] not in tset1:
        tset1.add(data[x])
        aug[x] = aug[x+1] +1
    else:
        aug[x] = aug[x+1]

#print(aug)
s = set(data[:])
tset2 = set([])
for i in range(0,len(data)):
    if (data[i] not in tset2):
        if (i < len(data)-1):
            totalSolutions += aug[i+1]
            tset2.add(data[i])
            #print(i,aug[j+1])

print(totalSolutions)","['constructive algorithms', 'implementation']"
"Emuskald is a well-known illusionist. One of his trademark tricks involves a set of magical boxes. The essence of the trick is in packing the boxes inside other boxes.From the top view each magical box looks like a square with side length equal to 2k (k is an integer, k ≥ 0) units. A magical box v can be put inside a magical box u, if side length of v is strictly less than the side length of u. In particular, Emuskald can put 4 boxes of side length 2k - 1 into one box of side length 2k, or as in the following figure:  Emuskald is about to go on tour performing around the world, and needs to pack his magical boxes for the trip. He has decided that the best way to pack them would be inside another magical box, but magical boxes are quite expensive to make. Help him find the smallest magical box that can fit all his boxes.","import math
n = int(input())
arr = []
for i in range(n):
    k,a = list(map(int,input().split()))
    arr.append([k,a])
arr.sort()
ans = 0
for i in arr:
    x = math.log(i[1],4)+i[0]
    ans = max(ans,math.ceil(x))
    if i[1]==1:
        ans = max(ans,i[0]+1)
print(ans)","['greedy', 'math', 'implementation', 'sortings', 'binary search']"
"Ashish has an array $$$a$$$ of size $$$n$$$.A subsequence of $$$a$$$ is defined as a sequence that can be obtained from $$$a$$$ by deleting some elements (possibly none), without changing the order of the remaining elements.Consider a subsequence $$$s$$$ of $$$a$$$. He defines the cost of $$$s$$$ as the minimum between:   The maximum among all elements at odd indices of $$$s$$$.  The maximum among all elements at even indices of $$$s$$$. Note that the index of an element is its index in $$$s$$$, rather than its index in $$$a$$$. The positions are numbered from $$$1$$$. So, the cost of $$$s$$$ is equal to $$$min(max(s_1, s_3, s_5, \ldots), max(s_2, s_4, s_6, \ldots))$$$.For example, the cost of $$$\{7, 5, 6\}$$$ is $$$min( max(7, 6), max(5) ) = min(7, 5) = 5$$$.Help him find the minimum cost of a subsequence of size $$$k$$$.","n, k = map(int,input().split("" ""))

a = list(map(int,input().split("" "")))

a_sorted = sorted(a)

def check(minn,ans):
	array = [0]
	# min at odd
	for i in a:
		if(len(array)%2==0):
			array.append(i)
		else:
			if(i <= minn):
				array.append(i)
	if(len(array)-1 >= ans):
		return True

	array = [0]
	# min at even
	for i in a:
		if(len(array)%2==1):
			array.append(i)
		else:
			if(i <= minn):
				array.append(i)
	if(len(array)-1 >= ans):
		return True

	return False


first = 0
last = len(a_sorted)-1

while(last>first):
	middle = (last + first)//2

	if(check(a_sorted[middle],k) == True):
		last = middle-1
	else:
		first = middle+1
		
#print(first,last)
if(check(a_sorted[0],k)==True):
	print(a_sorted[0])
elif(check(a_sorted[last],k)==True):
	print(a_sorted[last])
else:
	print(a_sorted[last+1])","['dp', 'greedy', 'dsu', 'implementation', 'binary search']"
"John Smith knows that his son, Thomas Smith, is among the best students in his class and even in his school. After the students of the school took the exams in English, German, Math, and History, a table of results was formed.There are $$$n$$$ students, each of them has a unique id (from $$$1$$$ to $$$n$$$). Thomas's id is $$$1$$$. Every student has four scores correspond to his or her English, German, Math, and History scores. The students are given in order of increasing of their ids.In the table, the students will be sorted by decreasing the sum of their scores. So, a student with the largest sum will get the first place. If two or more students have the same sum, these students will be sorted by increasing their ids. Please help John find out the rank of his son.","n=int(input())
k=[];t=[]
for i in range(n):
  a=list(map(int,input().split()))
  k.append(sum(a))
  q=k[0]
for i in k:
  t.append(i)
  t.sort()
  t.reverse()
print(t.index(q)+1)",['implementation']
"You are given a string $$$s$$$ consisting of lowercase Latin letters ""a"", ""b"" and ""c"" and question marks ""?"".Let the number of question marks in the string $$$s$$$ be $$$k$$$. Let's replace each question mark with one of the letters ""a"", ""b"" and ""c"". Here we can obtain all $$$3^{k}$$$ possible strings consisting only of letters ""a"", ""b"" and ""c"". For example, if $$$s = $$$""ac?b?c"" then we can obtain the following strings: $$$[$$$""acabac"", ""acabbc"", ""acabcc"", ""acbbac"", ""acbbbc"", ""acbbcc"", ""accbac"", ""accbbc"", ""accbcc""$$$]$$$.Your task is to count the total number of subsequences ""abc"" in all resulting strings. Since the answer can be very large, print it modulo $$$10^{9} + 7$$$.A subsequence of the string $$$t$$$ is such a sequence that can be derived from the string $$$t$$$ after removing some (possibly, zero) number of letters without changing the order of remaining letters. For example, the string ""baacbc"" contains two subsequences ""abc"" — a subsequence consisting of letters at positions $$$(2, 5, 6)$$$ and a subsequence consisting of letters at positions $$$(3, 5, 6)$$$.","#matthew's bad code
import re
import sys
MOD = 1000000007

# string s of length n
n = input()
s = input()
 
# number of a sequences, ab sequences, and abc sequences in s
# sets is the total number of distinct sets generated
# e.g. {a, ?, b} branches into three sets {a, a, b}; {a, b, b}; {a, c, b}
num_a = 0
num_ab = 0
num_abc = 0
num_sets = 1;

for char in s:
    if char == 'a':
        num_a = (num_a + num_sets + MOD)%MOD
    elif char == 'b':
        num_ab = (num_a + num_ab + MOD)%MOD
    elif char == 'c':
        num_abc = (num_ab + num_abc + MOD)%MOD
    elif char == '?':
        num_abc = (num_ab + 3 * num_abc + MOD)%MOD
        num_ab = (num_a + 3 * num_ab + MOD)%MOD 
        num_a = (num_sets + 3 * num_a + MOD)%MOD
        num_sets = (3 * num_sets + MOD)%MOD
    #print(num_a, num_ab, num_abc)
print(num_abc)","['dp', 'combinatorics', 'strings']"
"According to Berland laws it is only allowed to sell alcohol to people not younger than 18 years. Vasya's job is to monitor the law's enforcement. Tonight he entered a bar and saw n people sitting there. For every one of them Vasya happened to determine either the age or the drink the person is having. Vasya can check any person, i.e. learn his age and the drink he is having at the same time. What minimal number of people should Vasya check additionally to make sure that there are no clients under 18 having alcohol drinks?The list of all alcohol drinks in Berland is: ABSINTH, BEER, BRANDY, CHAMPAGNE, GIN, RUM, SAKE, TEQUILA, VODKA, WHISKEY, WINE","n = input()
count = 0
a = [""ABSINTH"", ""BEER"", ""BRANDY"", 
     ""CHAMPAGNE"", ""GIN"", ""RUM"", 
     ""SAKE"", ""TEQUILA"", ""VODKA"", 
     ""WHISKEY"", ""WINE""]
y = [str(i) for i in range(18)]

for i in range(n):
   s = raw_input()
   if (s in a) or (s in y):
      count = count + 1
print count",['implementation']
"You are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace ""01"" with ""10"" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace ""12"" with ""21"" or vice versa).For example, for string ""010210"" we can perform the following moves:   ""010210"" $$$\rightarrow$$$ ""100210"";  ""010210"" $$$\rightarrow$$$ ""001210"";  ""010210"" $$$\rightarrow$$$ ""010120"";  ""010210"" $$$\rightarrow$$$ ""010201"". Note than you cannot swap ""02"" $$$\rightarrow$$$ ""20"" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \le i \le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j &lt; i$$$ holds $$$a_j = b_j$$$, and $$$a_i &lt; b_i$$$.","from sys import stdin, stdout
ti = lambda : stdin.readline().strip()
ma = lambda fxn, ti : map(fxn, ti.split())
ol = lambda arr : stdout.write(' '.join(str(i) for i in arr) + '\n')
os = lambda i : stdout.write(str(i) + '\n')
olws = lambda arr : stdout.write(''.join(str(i) for i in arr) + '\n')


s = list(ti())
slen = len(s)
snew = []
count_of_1 = 0
for i in range(slen):
	if s[i] == '1':
		count_of_1 += 1
	else:
		snew.append(s[i])

s = snew
slen = len(snew)

two_appeared = False

ans = []

for i in range(slen):
	if s[i] == '0':
		ans.append('0')
	elif s[i] == '1':
		pass
	else:
		if not two_appeared:
			for j in range(count_of_1):
				ans.append('1')
			ans.append('2')
			two_appeared = True
		else:
			ans += '2'

if not two_appeared:
	for j in range(count_of_1):
		ans.append('1')

ans = ''.join(ans)
os(ans)","['implementation', 'greedy']"
"In the beginning of the new year Keivan decided to reverse his name. He doesn't like palindromes, so he changed Naviek to Navick.He is too selfish, so for a given n he wants to obtain a string of n characters, each of which is either 'a', 'b' or 'c', with no palindromes of length 3 appearing in the string as a substring. For example, the strings ""abc"" and ""abca"" suit him, while the string ""aba"" doesn't. He also want the number of letters 'c' in his string to be as little as possible.","s = ['a', 'a', 'b', 'b']
n = int(input())
q = []
for i in range(n):
    q.append(s[i % 4])
print(*q, sep="""")",['constructive algorithms']
"You are given a string $$$s$$$. You have to reverse it — that is, the first letter should become equal to the last letter before the reversal, the second letter should become equal to the second-to-last letter before the reversal — and so on. For example, if your goal is to reverse the string ""abddea"", you should get the string ""aeddba"". To accomplish your goal, you can swap the neighboring elements of the string. Your task is to calculate the minimum number of swaps you have to perform to reverse the given string.","import sys
input = sys.stdin.readline

n = int(input())
S = input().strip()

LIST = [[] for i in range(26)]

for i in range(n):
    LIST[ord(S[i])-97].append(i)

# for i in LIST:
#     print(i)

LEN = n+1
BIT = [0]*(LEN+1)

# print(BIT)


def update(v, w):
    while v <= LEN:
        BIT[v] += w
        v += (v & (-v))


def getvalue(v):
    ANS = 0
    while v != 0:
        ANS += BIT[v]
        v -= (v & (-v))
    return ANS


ANS = 0
moji = [0]*26

for i in range(n-1, -1, -1):
    s = ord(S[i])-97

    x = LIST[s][moji[s]]
    ANS += x-getvalue(x+1)
    moji[s] += 1
    # print(x-getvalue(x+1))
    # print(""*"")
    # print(BIT)
    update(x+1, 1)

    # print(moji)
    # print(""/"")
    # print(BIT)
    # print(""#"")
print(ANS)","['data structures', 'greedy', 'strings']"
"Vova plans to go to the conference by train. Initially, the train is at the point $$$1$$$ and the destination point of the path is the point $$$L$$$. The speed of the train is $$$1$$$ length unit per minute (i.e. at the first minute the train is at the point $$$1$$$, at the second minute — at the point $$$2$$$ and so on).There are lanterns on the path. They are placed at the points with coordinates divisible by $$$v$$$ (i.e. the first lantern is at the point $$$v$$$, the second is at the point $$$2v$$$ and so on).There is also exactly one standing train which occupies all the points from $$$l$$$ to $$$r$$$ inclusive.Vova can see the lantern at the point $$$p$$$ if $$$p$$$ is divisible by $$$v$$$ and there is no standing train at this position ($$$p \not\in [l; r]$$$). Thus, if the point with the lantern is one of the points covered by the standing train, Vova can't see this lantern.Your problem is to say the number of lanterns Vova will see during the path. Vova plans to go to $$$t$$$ different conferences, so you should answer $$$t$$$ independent queries.","k=int(input())
for i in range(k):
    L,v,l,r=map(int,input().split())
    print(L//v-r//v+(l-1)//v)",['math']
"Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters 'A' and 'B'. He can use bombs to bomb a substring which is either ""AB"" or ""BB"". When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated.For example, Zookeeper can use two such operations: AABABBA $$$\to$$$ AABBA $$$\to$$$ AAA.Zookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?","from collections import Counter
import math
import sys
from bisect import bisect,bisect_left,bisect_right
from itertools import permutations
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def mod(): return 10**9+7


for i in range(INT()): 
  #n = INT()
  s = input()
  #n1,n2 = MAP()
  #a = LIST()
  n = len(s)
  ans = 0
  ca = 0
  cb = 0
  for i in range(n-1,-1,-1):
    if s[i] == 'A':
      ca += 1
    if s[i] == 'B':
      cb += 1
    
    if ca>cb:
      ans += 1
      ca = 0
      cb = 0
    else:
      if ca == cb:
        ca = 0
        cb = 0
      else:
        cb -= ca
        ca = 0
  ans += cb%2
  print(ans)","['data structures', 'brute force', 'greedy', 'strings']"
"You are responsible for installing a gas pipeline along a road. Let's consider the road (for simplicity) as a segment $$$[0, n]$$$ on $$$OX$$$ axis. The road can have several crossroads, but for simplicity, we'll denote each crossroad as an interval $$$(x, x + 1)$$$ with integer $$$x$$$. So we can represent the road as a binary string consisting of $$$n$$$ characters, where character 0 means that current interval doesn't contain a crossroad, and 1 means that there is a crossroad.Usually, we can install the pipeline along the road on height of $$$1$$$ unit with supporting pillars in each integer point (so, if we are responsible for $$$[0, n]$$$ road, we must install $$$n + 1$$$ pillars). But on crossroads we should lift the pipeline up to the height $$$2$$$, so the pipeline won't obstruct the way for cars.We can do so inserting several zig-zag-like lines. Each zig-zag can be represented as a segment $$$[x, x + 1]$$$ with integer $$$x$$$ consisting of three parts: $$$0.5$$$ units of horizontal pipe + $$$1$$$ unit of vertical pipe + $$$0.5$$$ of horizontal. Note that if pipeline is currently on height $$$2$$$, the pillars that support it should also have length equal to $$$2$$$ units.  Each unit of gas pipeline costs us $$$a$$$ bourles, and each unit of pillar — $$$b$$$ bourles. So, it's not always optimal to make the whole pipeline on the height $$$2$$$. Find the shape of the pipeline with minimum possible cost and calculate that cost.Note that you must start and finish the pipeline on height $$$1$$$ and, also, it's guaranteed that the first and last characters of the input string are equal to 0.","inf = 10000000000000000000000000000000000000000000000000000000000000000
def solve(n, a, b, s):
    dp = [[]] * 2
    for i in range(2):
        dp[i] = [0] * n
    dp[0][0] = (n + 1) * (a + b) - a
    dp[1][0] = inf
    for i in range(1, n):
        if s[i] == '1':
            dp[1][i] = min(dp[1][i - 1] + b, dp[0][i - 1] + a + 2 * b)
            dp[0][i] = inf
        else:
            dp[0][i] = min(dp[0][i - 1], dp[1][i - 1] + a)
            dp[1][i] = min(dp[1][i - 1] + b, dp[0][i - 1] + a + 2 * b)
    return dp[0][n - 1]
for i in range(int(input())):
    n, a, b = map(int, input().split())
    s = input()
    print(solve(n, a, b, s))","['dp', 'greedy']"
"Constanze is the smartest girl in her village but she has bad eyesight.One day, she was able to invent an incredible machine! When you pronounce letters, the machine will inscribe them onto a piece of paper. For example, if you pronounce 'c', 'o', 'd', and 'e' in that order, then the machine will inscribe ""code"" onto the paper. Thanks to this machine, she can finally write messages without using her glasses.However, her dumb friend Akko decided to play a prank on her. Akko tinkered with the machine so that if you pronounce 'w', it will inscribe ""uu"" instead of ""w"", and if you pronounce 'm', it will inscribe ""nn"" instead of ""m""! Since Constanze had bad eyesight, she was not able to realize what Akko did.The rest of the letters behave the same as before: if you pronounce any letter besides 'w' and 'm', the machine will just inscribe it onto a piece of paper.The next day, I received a letter in my mailbox. I can't understand it so I think it's either just some gibberish from Akko, or Constanze made it using her machine. But since I know what Akko did, I can just list down all possible strings that Constanze's machine would have turned into the message I got and see if anything makes sense.But I need to know how much paper I will need, and that's why I'm asking you for help. Tell me the number of strings that Constanze's machine would've turned into the message I got.But since this number can be quite large, tell me instead its remainder when divided by $$$10^9+7$$$.If there are no strings that Constanze's machine would've turned into the message I got, then print $$$0$$$.","s = raw_input()
flag = True
maxn = int(1e5+5)
fib = [0]*maxn
fib[0] = 1
fib[1] = 1
fib[2] = 2
fib[3] = 3
mod  = int(1e9+7)
for i in range(4,maxn):
	fib[i] = (fib[i-1]+fib[i-2])%mod


for i in range(len(s)):
	if s[i] == ""m"" or s[i] == ""w"":
		flag = False

if not flag:
	print 0
else:
	i = 0
	cnt = 0
	ans = 1
	while i<len(s):
		if s[i]!=""u"" and s[i]!=""n"":

			ans = (ans*fib[cnt])%mod
			cnt = 0
		elif s[i] == s[i-1]:
			cnt += 1
		else:

			ans = (ans*fib[cnt])%mod
			cnt = 1
		i += 1

	ans = (ans*fib[cnt])%mod
	print ans",['dp']
"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.","n=int(input())
a=[input()for _ in range(n)]
k=0
for _ in range(n):
	try:a.remove(input())
	except:k+=1
print(k)","['implementation', 'greedy']"
"Rick and Morty are playing their own version of Berzerk (which has nothing in common with the famous Berzerk game). This game needs a huge space, so they play it with a computer.In this game there are n objects numbered from 1 to n arranged in a circle (in clockwise order). Object number 1 is a black hole and the others are planets. There's a monster in one of the planet. Rick and Morty don't know on which one yet, only that he's not initially in the black hole, but Unity will inform them before the game starts. But for now, they want to be prepared for every possible scenario.  Each one of them has a set of numbers between 1 and n - 1 (inclusive). Rick's set is s1 with k1 elements and Morty's is s2 with k2 elements. One of them goes first and the player changes alternatively. In each player's turn, he should choose an arbitrary number like x from his set and the monster will move to his x-th next object from its current position (clockwise). If after his move the monster gets to the black hole he wins.Your task is that for each of monster's initial positions and who plays first determine if the starter wins, loses, or the game will stuck in an infinite loop. In case when player can lose or make game infinity, it more profitable to choose infinity game.","#!/usr/bin/env python3
from __future__ import absolute_import
from sys import stdin,stdout
from itertools import imap


def ri():
    return imap(int, raw_input().split())

n = int(raw_input())
a = list(ri())
b = list(ri())
a = a[1:]
b = b[1:]

T = [[-1 for i in xrange(2)] for j in xrange(n)]
T[0][0] = 1
T[0][1] = 0

for j in xrange(10**9):
    c = 0
    for i in xrange(n-1, -1, -1):
        #T[i][0]
        flag = 0
        for k in a:
            ii = (i+k)%n
            if ii == 0 or T[ii][1] == 0:
                if T[i][0] !=0:
                    c = 1
                T[i][0] = 0
                break
            if T[ii][1] != 1:
                flag = 1
        else:
            if flag == 0:
                if T[i][0] !=1:
                    c = 1
                T[i][0] = 1
        flag = 0
        for k in b:
            ii = (i+k)%n
            if ii == 0 or T[ii][0] == 1:
                if T[i][1] !=1:
                    c = 1
                T[i][1] = 1
                break
            if T[ii][0] != 0:
                flag = 1
        else:
            if flag == 0:
                if T[i][1] !=0:
                    c = 1
                T[i][1] = 0
    if c == 0:
        break




ansa = [u""Win"", u""Lose"", u""Loop""]
ansb = [u""Lose"", u""Win"", u""Loop""]
aa = [ansa[T[i][0]] for i in xrange(1, n)]
bb = [ansb[T[i][1]] for i in xrange(1, n)]

print u"" "".join(aa)
print u"" "".join(bb)","['dp', 'games']"
"Anton came to a chocolate factory. There he found a working conveyor and decided to run on it from the beginning to the end.The conveyor is a looped belt with a total length of 2l meters, of which l meters are located on the surface and are arranged in a straight line. The part of the belt which turns at any moment (the part which emerges from under the floor to the surface and returns from the surface under the floor) is assumed to be negligibly short.The belt is moving uniformly at speed v1 meters per second. Anton will be moving on it in the same direction at the constant speed of v2 meters per second, so his speed relatively to the floor will be v1 + v2 meters per second. Anton will neither stop nor change the speed or the direction of movement.Here and there there are chocolates stuck to the belt (n chocolates). They move together with the belt, and do not come off it. Anton is keen on the chocolates, but he is more keen to move forward. So he will pick up all the chocolates he will pass by, but nothing more. If a chocolate is at the beginning of the belt at the moment when Anton starts running, he will take it, and if a chocolate is at the end of the belt at the moment when Anton comes off the belt, he will leave it.     The figure shows an example with two chocolates. One is located   in the position a1 = l - d, and is now on the top half of the belt, the second one   is in the position a2 = 2l - d, and is now on the bottom half of the belt.  You are given the positions of the chocolates relative to the initial start position of the belt 0 ≤ a1 &lt; a2 &lt; ... &lt; an &lt; 2l. The positions on the belt from 0 to l correspond to the top, and from l to 2l — to the the bottom half of the belt (see example). All coordinates are given in meters.Anton begins to run along the belt at a random moment of time. This means that all possible positions of the belt at the moment he starts running are equiprobable. For each i from 0 to n calculate the probability that Anton will pick up exactly i chocolates.","R=lambda:map(int,raw_input().split())
n,l,v1,v2=R()
s=v2*l
v1+=v2
l*=v1*2
a=[x*v1 for x in R()]
p,v,i,j=0,0,0,0
c=[0]*(n+1)
b=a[:]
for x in a:b+=[y for y in (x-s,x-s+l,x+l) if 0<=y<l]
b.sort()
b+=[l]
a+=[x+l for x in a]+[a[0]+l*2]
while a[j]<s:j+=1
for x in b:
  c[j-i]+=x-p
  while a[i]<=x:i+=1
  while a[j]<=x+s:j+=1
  p=x
for x in c:print x/1./l","['two pointers', 'sortings']"
Today the «Z» city residents enjoy a shell game competition. The residents are gathered on the main square to watch the breath-taking performance. The performer puts 3 non-transparent cups upside down in a row. Then he openly puts a small ball under one of the cups and starts to shuffle the cups around very quickly so that on the whole he makes exactly 3 shuffles. After that the spectators have exactly one attempt to guess in which cup they think the ball is and if the answer is correct they get a prize. Maybe you can try to find the ball too?,"fil = open(""input.txt"",""r"")
start =  int(fil.readline().strip())
for i in range(3):
	a,b = list(map(int, fil.readline().strip().split("" "")))
	if a == start: start = b
	elif b == start: start = a
fil2 = open(""output.txt"",""w"")
fil2.write(str(start))",['implementation']
"Wabbit is trying to move a box containing food for the rest of the zoo in the coordinate plane from the point $$$(x_1,y_1)$$$ to the point $$$(x_2,y_2)$$$.He has a rope, which he can use to pull the box. He can only pull the box if he stands exactly $$$1$$$ unit away from the box in the direction of one of two coordinate axes. He will pull the box to where he is standing before moving out of the way in the same direction by $$$1$$$ unit.   For example, if the box is at the point $$$(1,2)$$$ and Wabbit is standing at the point $$$(2,2)$$$, he can pull the box right by $$$1$$$ unit, with the box ending up at the point $$$(2,2)$$$ and Wabbit ending at the point $$$(3,2)$$$.Also, Wabbit can move $$$1$$$ unit to the right, left, up, or down without pulling the box. In this case, it is not necessary for him to be in exactly $$$1$$$ unit away from the box. If he wants to pull the box again, he must return to a point next to the box. Also, Wabbit can't move to the point where the box is located.Wabbit can start at any point. It takes $$$1$$$ second to travel $$$1$$$ unit right, left, up, or down, regardless of whether he pulls the box while moving.Determine the minimum amount of time he needs to move the box from $$$(x_1,y_1)$$$ to $$$(x_2,y_2)$$$. Note that the point where Wabbit ends up at does not matter.","import math
o=int(input())
for i in range(o):
    s=input()
    l=s.split()
    f1=math.fabs(int(l[0])-int(l[2]))
    f2=math.fabs(int(l[1])-int(l[3]))
    if int(l[0])!=int(l[2]) and int(l[1])!=int(l[3]):
        print(int(2+f1+f2))
    else:
        print(int(f1+f2))",['math']
"When Sasha was studying in the seventh grade, he started listening to music a lot. In order to evaluate which songs he likes more, he introduced the notion of the song's prettiness. The title of the song is a word consisting of uppercase Latin letters. The prettiness of the song is the prettiness of its title.Let's define the simple prettiness of a word as the ratio of the number of vowels in the word to the number of all letters in the word.Let's define the prettiness of a word as the sum of simple prettiness of all the substrings of the word.More formally, let's define the function vowel(c) which is equal to 1, if c is a vowel, and to 0 otherwise. Let si be the i-th character of string s, and si..j be the substring of word s, staring at the i-th character and ending at the j-th character (sisi + 1... sj, i ≤ j).Then the simple prettiness of s is defined by the formula:The prettiness of s equals Find the prettiness of the given song title.We assume that the vowels are I, E, A, O, U, Y.","from itertools import accumulate
vowels = set('AIUEOY')
s = input()
n = len(s)
vs = list(accumulate(0 if i == 0 else 1 / i for i in range(n + 1)))
r = 0
v = 0
for i in range(n):
    v += vs[n - i] - vs[i]
    if s[i] in vowels:
        r += v
print(r)","['math', 'strings']"
"There is a weighted tree with $$$n$$$ nodes and $$$n-1$$$ edges. The nodes are conveniently labeled from $$$1$$$ to $$$n$$$. The weights are positive integers at most $$$100$$$. Define the distance between two nodes to be the sum of edges on the unique path between the nodes. You would like to find the diameter of the tree. Diameter is the maximum distance between a pair of nodes.Unfortunately, the tree isn't given to you, but you can ask some questions about it. In one question, you can specify two nonempty disjoint sets of nodes $$$p$$$ and $$$q$$$, and the judge will return the maximum distance between a node in $$$p$$$ and a node in $$$q$$$. In the words, maximum distance between $$$x$$$ and $$$y$$$, where $$$x \in p$$$ and $$$y \in q$$$. After asking not more than $$$9$$$ questions, you must report the maximum distance between any pair of nodes.","import sys
t=int(input())

for _ in range(t):
    n=int(input())
    max_dist=0 
    for bit in range(7):
        a=[]
        b=[]        
        for i in range(1,n+1):
            if (i>>bit)%2:
                a.append(i)
            else:
                b.append(i)

        if len(a)==0 or len(b)==0:
            continue

        l=[len(a),len(b)]+a+b
        out="" "".join(map(str,l))
        print(out+""\n"")

        #print(len(a), len(b), *(a+b))
        sys.stdout.flush()
        d=int(input())
        if d>max_dist:
            max_dist=d        
    print(""-1 ""+str(max_dist))","['interactive', 'bitmasks', 'graphs']"
"Artem is building a new robot. He has a matrix $$$a$$$ consisting of $$$n$$$ rows and $$$m$$$ columns. The cell located on the $$$i$$$-th row from the top and the $$$j$$$-th column from the left has a value $$$a_{i,j}$$$ written in it. If two adjacent cells contain the same value, the robot will break. A matrix is called good if no two adjacent cells contain the same value, where two cells are called adjacent if they share a side. Artem wants to increment the values in some cells by one to make $$$a$$$ good.More formally, find a good matrix $$$b$$$ that satisfies the following condition —   For all valid ($$$i,j$$$), either $$$b_{i,j} = a_{i,j}$$$ or $$$b_{i,j} = a_{i,j}+1$$$. For the constraints of this problem, it can be shown that such a matrix $$$b$$$ always exists. If there are several such tables, you can output any of them. Please note that you do not have to minimize the number of increments.","def main():
    t = int(input())
    for i_t in range(t):
        n, m = _read_ints()
        a = tuple(tuple(_read_ints()) for i_row in range(n))
        result = _find_fixed_matrix(a)
        for row in result:
            print(*row)


def _find_fixed_matrix(matrix):
    rows_n = len(matrix)
    columns_n = len(matrix[0])
    elements_n = rows_n * columns_n

    result = tuple(map(list, matrix))
    
    actions = tuple([None]*columns_n for i_row in range(rows_n))
    queue = []
    i_action = 0

    for i_row in range(rows_n):
        for i_column in range(columns_n):
            if actions[i_row][i_column] is None:
                actions[i_row][i_column] = 1
                queue.append(((i_row, i_column), 1))
                
                while i_action != len(queue):
                    (u, v), action = queue[i_action]
                    i_action += 1
                    for du, dv in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                        if 0 <= u+du < rows_n and 0 <= v+dv < columns_n \
                               and actions[u+du][v+dv] is None:
                            try:
                                action = _try_choose_action((u+du, v+dv), matrix, actions)
                            except ValueError:
                                pass
                            else:
                                actions[u+du][v+dv] = action
                                queue.append(((u+du, v+dv), action))
            result[i_row][i_column] += actions[i_row][i_column]
    
    return result



def _try_choose_action(pos, matrix, actions):
    rows_n = len(matrix)
    columns_n = len(matrix[0])
    
    u, v = pos
    for du, dv in ((0, 1), (1, 0), (0, -1), (-1, 0)):
        if 0 <= u+du < rows_n and 0 <= v+dv < columns_n \
                and actions[u+du][v+dv] is not None:
            new_value = matrix[u+du][v+dv] + actions[u+du][v+dv]
            if matrix[u][v] == new_value:
                return 1
            elif matrix[u][v] + 1 == new_value:
                return 0

    raise ValueError


def _read_ints():
    return map(int, input().split())


if __name__ == ""__main__"":
    main()","['constructive algorithms', 'flows', '2-sat', 'chinese remainder theorem', 'fft']"
"Sakuzyo - ImprintingA.R.C. Markland-N is a tall building with $$$n$$$ floors numbered from $$$1$$$ to $$$n$$$. Between each two adjacent floors in the building, there is a staircase connecting them.It's lunchtime for our sensei Colin ""ConneR"" Neumann Jr, and he's planning for a location to enjoy his meal.ConneR's office is at floor $$$s$$$ of the building. On each floor (including floor $$$s$$$, of course), there is a restaurant offering meals. However, due to renovations being in progress, $$$k$$$ of the restaurants are currently closed, and as a result, ConneR can't enjoy his lunch there.CooneR wants to reach a restaurant as quickly as possible to save time. What is the minimum number of staircases he needs to walk to reach a closest currently open restaurant.Please answer him quickly, and you might earn his praise and even enjoy the lunch with him in the elegant Neumanns' way!","a=int(input())
r=0
d=list()
while r<a:
    k=0
    b=[int(b) for b in input().split()]
    #print('b = ',b)
    c=[int(c) for c in input().split()]
    #print('c = ',c)
    if b[1] not in c:
        k=0
    else:
        t=1
        while t<=min(max(b[1],b[0]-b[1]),1005):
            #print(t)
            if (b[1]+t) not in c and b[1]+t<b[0]+1:
                #print('fffffffffffffffff')
                k=k+1
                break
            elif (b[1]-t) not in c and b[1]-t>0:
                k=k+1
                break
            else:
                #print('3333333333333333333333333')
                k=k+1
            #print(b[1]+t)
            t=t+1
    d.append(k)
    #print(k)
    r=r+1
r=0
while r<a:
    print(d[r])
    r=r+1","['binary search', 'implementation', 'brute force']"
"Professor GukiZ is concerned about making his way to school, because massive piles of boxes are blocking his way. In total there are n piles of boxes, arranged in a line, from left to right, i-th pile (1 ≤ i ≤ n) containing ai boxes. Luckily, m students are willing to help GukiZ by removing all the boxes from his way. Students are working simultaneously. At time 0, all students are located left of the first pile. It takes one second for every student to move from this position to the first pile, and after that, every student must start performing sequence of two possible operations, each taking one second to complete. Possible operations are: If i ≠ n, move from pile i to pile i + 1; If pile located at the position of student is not empty, remove one box from it.GukiZ's students aren't smart at all, so they need you to tell them how to remove boxes before professor comes (he is very impatient man, and doesn't want to wait). They ask you to calculate minumum time t in seconds for which they can remove all the boxes from GukiZ's way. Note that students can be positioned in any manner after t seconds, but all the boxes must be removed.","N, M = map(int, input().split())
books_list = list(map(int, input().split()))

while books_list[-1] == 0:
    books_list.pop()
books_list.insert(0, 0)

def check(Time):
    piles = books_list[:]
    last_pile_no = len(piles) - 1
    for i in range(M): #student
        i_time = Time - last_pile_no
        while True:
            if i_time >= piles[last_pile_no]:
                i_time -= piles[last_pile_no]
                last_pile_no -= 1
                if last_pile_no == 0:
                    return True
            else:
                piles[last_pile_no] -= i_time
                break

    return False

l = 0
r = int(sum(books_list)/M) + len(books_list) + 1

while r-l > 1:
    mid = int((l+r)/2)
    if check(mid):
        r = mid
    else:
        l = mid
print(r)","['binary search', 'greedy']"
"Alice has a birthday today, so she invited home her best friend Bob. Now Bob needs to find a way to commute to the Alice's home.In the city in which Alice and Bob live, the first metro line is being built. This metro line contains $$$n$$$ stations numbered from $$$1$$$ to $$$n$$$. Bob lives near the station with number $$$1$$$, while Alice lives near the station with number $$$s$$$. The metro line has two tracks. Trains on the first track go from the station $$$1$$$ to the station $$$n$$$ and trains on the second track go in reverse direction. Just after the train arrives to the end of its track, it goes to the depot immediately, so it is impossible to travel on it after that.Some stations are not yet open at all and some are only partially open — for each station and for each track it is known whether the station is closed for that track or not. If a station is closed for some track, all trains going in this track's direction pass the station without stopping on it.When the Bob got the information on opened and closed stations, he found that traveling by metro may be unexpectedly complicated. Help Bob determine whether he can travel to the Alice's home by metro or he should search for some other transport.","n,s = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
s-=1

if a[0]==0:
    print('NO')
elif a[s]==1:
    print('YES')
elif any([(a[i] and b[i]) for i in range(s+1,n)]) and b[s]==1:
    print('YES')
else:
    print('NO')",['graphs']
"Bob is an avid fan of the video game ""League of Leesins"", and today he celebrates as the League of Leesins World Championship comes to an end! The tournament consisted of $$$n$$$ ($$$n \ge 5$$$) teams around the world. Before the tournament starts, Bob has made a prediction of the rankings of each team, from $$$1$$$-st to $$$n$$$-th. After the final, he compared the prediction with the actual result and found out that the $$$i$$$-th team according to his prediction ended up at the $$$p_i$$$-th position ($$$1 \le p_i \le n$$$, all $$$p_i$$$ are unique). In other words, $$$p$$$ is a permutation of $$$1, 2, \dots, n$$$.As Bob's favorite League player is the famous ""3ga"", he decided to write down every $$$3$$$ consecutive elements of the permutation $$$p$$$. Formally, Bob created an array $$$q$$$ of $$$n-2$$$ triples, where $$$q_i = (p_i, p_{i+1}, p_{i+2})$$$ for each $$$1 \le i \le n-2$$$. Bob was very proud of his array, so he showed it to his friend Alice.After learning of Bob's array, Alice declared that she could retrieve the permutation $$$p$$$ even if Bob rearranges the elements of $$$q$$$ and the elements within each triple. Of course, Bob did not believe in such magic, so he did just the same as above to see Alice's respond.For example, if $$$n = 5$$$ and $$$p = [1, 4, 2, 3, 5]$$$, then the original array $$$q$$$ will be $$$[(1, 4, 2), (4, 2, 3), (2, 3, 5)]$$$. Bob can then rearrange the numbers within each triple and the positions of the triples to get $$$[(4, 3, 2), (2, 3, 5), (4, 1, 2)]$$$. Note that $$$[(1, 4, 2), (4, 2, 2), (3, 3, 5)]$$$ is not a valid rearrangement of $$$q$$$, as Bob is not allowed to swap numbers belong to different triples.As Alice's friend, you know for sure that Alice was just trying to show off, so you decided to save her some face by giving her any permutation $$$p$$$ that is consistent with the array $$$q$$$ she was given.","n=int(input())
vis=[0]*(n+1)
c=[0]*(n+1)
from collections import defaultdict
d=defaultdict(list)
for i in range(n-2):
    a,b,e=list(map(int,input().split()))
    c[a]+=1
    c[b]+=1
    c[e]+=1
    d[a].extend([a,b,e])
    d[b].extend([a,b,e])
    d[e].extend([a,b,e])
res=[]
for i in range(1,n+1):
    if c[i]==1:
        res.append(i)
        vis[i]=1
        break
k=1
while k<n:
    if c[res[-1]]==3:
        ar={}
        for j in d[res[-1]]:
            if j in ar:
                ar[j]+=1
            else:
                ar[j]=1
            
                
        for j in ar:
            if ar[j]==2 and vis[j]==0:
                res.append(j)
                vis[j]=1
        #print(res)
    elif c[res[-1]]==1:
        for i in d[res[-1]]:
            if c[i]==2:
                res.append(i)
                vis[i]=1
                break
    else:
        ar={}
        if k==2:
            for j in d[res[-1]]:
                if j in ar:
                    ar[j]+=1
                else:
                    ar[j]=1
            
                
            for j in ar:
                if ar[j]==2 and vis[j]==0:
                    res.append(j)
                    vis[j]=1
        else:
            for i in d[res[-1]]:
                if c[i]==1:
                    res.append(i)
                    vis[i]=1
                    break
                
            
            
            
    k+=1
print(*res)","['constructive algorithms', 'implementation']"
"You are given a string $$$s$$$ consisting of $$$n$$$ lowercase Latin letters.Let's define a substring as a contiguous subsegment of a string. For example, ""acab"" is a substring of ""abacaba"" (it starts in position $$$3$$$ and ends in position $$$6$$$), but ""aa"" or ""d"" aren't substrings of this string. So the substring of the string $$$s$$$ from position $$$l$$$ to position $$$r$$$ is $$$s[l; r] = s_l s_{l + 1} \dots s_r$$$.You have to choose exactly one of the substrings of the given string and reverse it (i. e. make $$$s[l; r] = s_r s_{r - 1} \dots s_l$$$) to obtain a string that is less lexicographically. Note that it is not necessary to obtain the minimum possible string.If it is impossible to reverse some substring of the given string to obtain a string that is less, print ""NO"". Otherwise print ""YES"" and any suitable substring.String $$$x$$$ is lexicographically less than string $$$y$$$, if either $$$x$$$ is a prefix of $$$y$$$ (and $$$x \ne y$$$), or there exists such $$$i$$$ ($$$1 \le i \le min(|x|, |y|)$$$), that $$$x_i &lt; y_i$$$, and for any $$$j$$$ ($$$1 \le j &lt; i$$$) $$$x_j = y_j$$$. Here $$$|a|$$$ denotes the length of the string $$$a$$$. The lexicographic comparison of strings is implemented by operator &lt; in modern programming languages​​.","'''input
6
aabcfg
'''
from sys import stdin, stdout
import math
from copy import deepcopy
from collections import defaultdict
import heapq


# main starts
n = int(stdin.readline().strip())
string = list(stdin.readline().strip())
for i in range(1, len(string)):
	if string[i - 1] <= string[i]:
		continue
	else:
		string[i - 1], string[i] = string[i], string[i - 1]
		print('YES')
		print(i, i + 1)
		break
else:
	print(""NO"")","['implementation', 'sortings', 'strings']"
"Consider a sequence of digits of length $$$2^k$$$ $$$[a_1, a_2, \ldots, a_{2^k}]$$$. We perform the following operation with it: replace pairs $$$(a_{2i+1}, a_{2i+2})$$$ with $$$(a_{2i+1} + a_{2i+2})\bmod 10$$$ for $$$0\le i&lt;2^{k-1}$$$. For every $$$i$$$ where $$$a_{2i+1} + a_{2i+2}\ge 10$$$ we get a candy! As a result, we will get a sequence of length $$$2^{k-1}$$$.Less formally, we partition sequence of length $$$2^k$$$ into $$$2^{k-1}$$$ pairs, each consisting of 2 numbers: the first pair consists of the first and second numbers, the second of the third and fourth $$$\ldots$$$, the last pair consists of the ($$$2^k-1$$$)-th and ($$$2^k$$$)-th numbers. For every pair such that sum of numbers in it is at least $$$10$$$, we get a candy. After that, we replace every pair of numbers with a remainder of the division of their sum by $$$10$$$ (and don't change the order of the numbers).Perform this operation with a resulting array until it becomes of length $$$1$$$. Let $$$f([a_1, a_2, \ldots, a_{2^k}])$$$ denote the number of candies we get in this process. For example: if the starting sequence is $$$[8, 7, 3, 1, 7, 0, 9, 4]$$$ then:After the first operation the sequence becomes $$$[(8 + 7)\bmod 10, (3 + 1)\bmod 10, (7 + 0)\bmod 10, (9 + 4)\bmod 10]$$$ $$$=$$$ $$$[5, 4, 7, 3]$$$, and we get $$$2$$$ candies as $$$8 + 7 \ge 10$$$ and $$$9 + 4 \ge 10$$$.After the second operation the sequence becomes $$$[(5 + 4)\bmod 10, (7 + 3)\bmod 10]$$$ $$$=$$$ $$$[9, 0]$$$, and we get one more candy as $$$7 + 3 \ge 10$$$. After the final operation sequence becomes $$$[(9 + 0) \bmod 10]$$$ $$$=$$$ $$$[9]$$$. Therefore, $$$f([8, 7, 3, 1, 7, 0, 9, 4]) = 3$$$ as we got $$$3$$$ candies in total.You are given a sequence of digits of length $$$n$$$ $$$s_1, s_2, \ldots s_n$$$. You have to answer $$$q$$$ queries of the form $$$(l_i, r_i)$$$, where for $$$i$$$-th query you have to output $$$f([s_{l_i}, s_{l_i+1}, \ldots, s_{r_i}])$$$. It is guaranteed that $$$r_i-l_i+1$$$ is of form $$$2^k$$$ for some nonnegative integer $$$k$$$.","import sys
#sys.stdin = open('in', 'r')
n = int(input())
a = [int(x) for x in input().split()]
q = int(input())
sm = [0]
for i in range(n):
    sm.append(sm[-1]+a[i])
for qi in range(q):
    l,r = map(int, input().split())
    print((sm[r]-sm[l-1]) // 10)
    
    


#sys.stdout.write('YES\n')
#sys.stdout.write(f'{res}\n')
#sys.stdout.write(f'{y1} {x1} {y2} {x2}\n')","['dp', 'implementation', 'data structures', 'math']"
"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:  They do not intersect (i.e. they are disjoint). Formally, for each pair of blocks $$$(l_i, r_i)$$$ and $$$(l_j, r_j$$$) where $$$i \neq j$$$ either $$$r_i &lt; l_j$$$ or $$$r_j &lt; l_i$$$.  For each block the sum of its elements is the same. Formally, $$$$$$a[l_1]+a[l_1+1]+\dots+a[r_1]=a[l_2]+a[l_2+1]+\dots+a[r_2]=$$$$$$ $$$$$$\dots =$$$$$$ $$$$$$a[l_k]+a[l_k+1]+\dots+a[r_k].$$$$$$  The number of the blocks in the set is maximum. Formally, there does not exist a set of blocks $$$(l_1', r_1'), (l_2', r_2'), \dots, (l_{k'}', r_{k'}')$$$ satisfying the above two requirements with $$$k' &gt; k$$$.     The picture corresponds to the first example. Blue boxes illustrate blocks. Write a program to find such a set of blocks.","franxx = int(input())

life = input()
life = life.split()

darling = {}

oh_pay = ""I love my darling""

for i in range(franxx, 0, -1):
	tmp = 0
	for j in range(i - 1, franxx):
		tmp += int(life[j])
		if (tmp in darling):
			if (darling[tmp][0] > j):
				darling[tmp] = (i - 1, 1 + darling[tmp][1])
		else:
			darling[tmp] = (i - 1, 1)
		if (oh_pay == ""I love my darling"" or darling[tmp][1] > darling[oh_pay][1]):
			oh_pay = tmp

print(darling[oh_pay][1])

strelizia = (franxx, 0)

for i in range(franxx, 0, -1):
	tmp = 0
	for j in range(i - 1, franxx):
		tmp += int(life[j])
		if (tmp != oh_pay):
			continue;
		if (strelizia[0] > j):
			print(i, j + 1)
			strelizia = (i - 1, 1 + strelizia[1])","['data structures', 'greedy']"
"Iahub is very proud of his recent discovery, propagating trees. Right now, he invented a new tree, called xor-tree. After this new revolutionary discovery, he invented a game for kids which uses xor-trees.The game is played on a tree having n nodes, numbered from 1 to n. Each node i has an initial value initi, which is either 0 or 1. The root of the tree is node 1.One can perform several (possibly, zero) operations on the tree during the game. The only available type of operation is to pick a node x. Right after someone has picked node x, the value of node x flips, the values of sons of x remain the same, the values of sons of sons of x flips, the values of sons of sons of sons of x remain the same and so on.The goal of the game is to get each node i to have value goali, which can also be only 0 or 1. You need to reach the goal of the game by using minimum number of operations.","import fileinput

def levels(n, e):
	l = [0 for _ in range(n)]
	q = [(0, -1, 0)]
	while q:
		v, u, d = q.pop()
		l[v] = d

		for w in e[v]:
			if w != u: q.append((w, v, d+1))
	return l

def solve(n, e, x, g):
	l = levels(n, e)

	f = [0, 0]
	q = [(0, -1)]
	z = []
	while q:
		v, u = q.pop()

		if v == -1:
			f = u
			continue
		q.append((-1, f[:]))

		d = l[v]%2
		if (x[v]+f[d])%2 != g[v]:
			f[d] = (f[d]+1)%2
			z.append(v)

		for w in e[v]:
			if w != u: q.append((w, v))

	print(len(z))
	for v in z: print(v+1)

f = fileinput.input()
n = int(f.readline())
e = [[] for _ in range(n)]
for _ in range(n-1):
	v, w = tuple(map(int, f.readline().rstrip().split()))
	e[v-1].append(w-1)
	e[w-1].append(v-1)
x = list(map(int, f.readline().rstrip().split()))
g = list(map(int, f.readline().rstrip().split()))
solve(n, e, x, g)","['data structures', 'dfs and similar', 'trees', 'brute force']"
"We're giving away nice huge bags containing number tiles! A bag we want to present to you contains $$$n$$$ tiles. Each of them has a single number written on it — either $$$1$$$ or $$$2$$$.However, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get.Can you win the prize? Hurry up, the bags are waiting!","rr = raw_input
rri = lambda: int(rr())
rrm = lambda: map(int, rr().split())

def listprimes(n):
    sieve = [True] * n
    for i in xrange(3,int(n**0.5)+1,2):
        if sieve[i]:
            sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)
    return [2] + [i for i in xrange(3,n,2) if sieve[i]]

def solve(N, A):
    ones = twos = 0
    for x in A:
        if x == 1: ones += 1
        else: twos += 1
    primes = listprimes(ones + twos * 2 + 1)
    i = 0
    cur = 0
    ans = []
    while ones or twos:
        while i < len(primes) and cur + 1 > primes[i]:
            i += 1
        if i == len(primes):
            while ones:
                ones -= 1
                ans.append(1)
            while twos:
                twos -= 1
                ans.append(2)
            break
        
        if ones and twos:
            if cur + 2 == primes[i] and not cur + 1 == primes[i]:
                twos -= 1
                ans.append(2)
                cur += 2
                i += 1
            elif cur + 1 == primes[i]:
                ones -= 1
                ans.append(1)
                cur += 1
                i += 1
            else:
                twos -= 1
                ans.append(2)
                cur += 2
        elif ones:
            ones -= 1
            ans.append(1)
            cur += 1
        elif twos:
            twos -= 1
            ans.append(2)
            cur += 2
    return ans

from sys import stdout
N = rri()
A = rrm()
stdout.write("" "".join(map(str, solve(N, A))))
stdout.flush()","['constructive algorithms', 'number theory', 'greedy', 'math']"
"Momiji has got a rooted tree, consisting of n nodes. The tree nodes are numbered by integers from 1 to n. The root has number 1. Momiji decided to play a game on this tree.The game consists of several steps. On each step, Momiji chooses one of the remaining tree nodes (let's denote it by v) and removes all the subtree nodes with the root in node v from the tree. Node v gets deleted as well. The game finishes when the tree has no nodes left. In other words, the game finishes after the step that chooses the node number 1.Each time Momiji chooses a new node uniformly among all the remaining nodes. Your task is to find the expectation of the number of steps in the described game.","n = input()
edge = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, raw_input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)
d = [0] * n
d[0] = 1
p = [0]
for u in p:
    for v in edge[u]:
        if not d[v]:
            d[v] = d[u] + 1
            p.append(v)
print sum((1. / x for x in d))","['probabilities', 'implementation', 'trees', 'math']"
"Vasya is a school PE teacher. Unlike other PE teachers, Vasya doesn't like it when the students stand in line according to their height. Instead, he demands that the children stand in the following order: a1, a2, ..., an, where ai is the height of the i-th student in the line and n is the number of students in the line. The children find it hard to keep in mind this strange arrangement, and today they formed the line in the following order: b1, b2, ..., bn, which upset Vasya immensely. Now Vasya wants to rearrange the children so that the resulting order is like this: a1, a2, ..., an. During each move Vasya can swap two people who stand next to each other in the line. Help Vasya, find the sequence of swaps leading to the arrangement Vasya needs. It is not required to minimize the number of moves.","import sys

n = int(sys.stdin.readline ())
a= [int (x) for x in sys.stdin.readline ().split ()]
assert len(a) == n

b = [int (x) for x in sys.stdin.readline ().split ()]
assert len(b) == n

ans = []

for i in range (n):
    j = i;
    while b[j] != a[i] :
        j += 1
    while j > i:
        ans += [(j, j + 1)]
        b[j - 1], b[j] = b[j], b[j - 1]
        j -= 1
print (len(ans))
for p, q in ans:
    print (p, + q)",['sortings']
"Long story short, shashlik is Miroslav's favorite food. Shashlik is prepared on several skewers simultaneously. There are two states for each skewer: initial and turned over.This time Miroslav laid out $$$n$$$ skewers parallel to each other, and enumerated them with consecutive integers from $$$1$$$ to $$$n$$$ in order from left to right. For better cooking, he puts them quite close to each other, so when he turns skewer number $$$i$$$, it leads to turning $$$k$$$ closest skewers from each side of the skewer $$$i$$$, that is, skewers number $$$i - k$$$, $$$i - k + 1$$$, ..., $$$i - 1$$$, $$$i + 1$$$, ..., $$$i + k - 1$$$, $$$i + k$$$ (if they exist). For example, let $$$n = 6$$$ and $$$k = 1$$$. When Miroslav turns skewer number $$$3$$$, then skewers with numbers $$$2$$$, $$$3$$$, and $$$4$$$ will come up turned over. If after that he turns skewer number $$$1$$$, then skewers number $$$1$$$, $$$3$$$, and $$$4$$$ will be turned over, while skewer number $$$2$$$ will be in the initial position (because it is turned again).As we said before, the art of cooking requires perfect timing, so Miroslav wants to turn over all $$$n$$$ skewers with the minimal possible number of actions. For example, for the above example $$$n = 6$$$ and $$$k = 1$$$, two turnings are sufficient: he can turn over skewers number $$$2$$$ and $$$5$$$.Help Miroslav turn over all $$$n$$$ skewers.","n, k = map(int, input().split())
a = 1000000
af = []
for i in range(k+1):
    f = []
    for j in range(i+1, n+1, 2*k+1):
        f.append(j)
    if i+1 > n:
        break
    if f[-1]+k >= n:
        if a > len(f):
            a = len(f)
            af = f[:]
print(a)
print(*af)","['dp', 'greedy', 'math']"
"There are $$$n$$$ boxers, the weight of the $$$i$$$-th boxer is $$$a_i$$$. Each of them can change the weight by no more than $$$1$$$ before the competition (the weight cannot become equal to zero, that is, it must remain positive). Weight is always an integer number.It is necessary to choose the largest boxing team in terms of the number of people, that all the boxers' weights in the team are different (i.e. unique).Write a program that for given current values ​$$$a_i$$$ will find the maximum possible number of boxers in a team.It is possible that after some change the weight of some boxer is $$$150001$$$ (but no more).","n = int(input())
A = list(map(int, input().split()))
A.sort(reverse=True)

if len(A) == len(set(A)):
    print(n)
    exit()

S = set()
for a in A:
    if a != 1:
        if a+1 not in S:
            S.add(a+1)
        elif a not in S:
            S.add(a)
        elif a-1 not in S:
            S.add(a-1)
        else:
            pass
    else:
        if a+1 not in S:
            S.add(a+1)
        elif a not in S:
            S.add(a)
        else:
            pass
print(len(S))","['sortings', 'greedy']"
"We saw the little game Marmot made for Mole's lunch. Now it's Marmot's dinner time and, as we all know, Marmot eats flowers. At every dinner he eats some red and white flowers. Therefore a dinner can be represented as a sequence of several flowers, some of them white and some of them red.But, for a dinner to be tasty, there is a rule: Marmot wants to eat white flowers only in groups of size k.Now Marmot wonders in how many ways he can eat between a and b flowers. As the number of ways could be very large, print it modulo 1000000007 (109 + 7).","from sys import stdin,stdout
t,k=map(int,stdin.readline().split())
A=[1]*100001
ans=[]
sum=1
for i in range(0,100001):
    if(i<k):
        A[i]=1
    elif(i==k):
        A[i]=2
    else:
        A[i]=(A[i-1]%1000000007+A[i-k]%1000000007)%1000000007
    sum=(sum%1000000007+A[i]%1000000007)%1000000007
    ans.append(sum)
for i in range(0,t):
    a,b=map(int,stdin.readline().split())
    an=ans[b]-ans[a-1]
    an=an%1000000007
    stdout.write(str(an)+'\n')",['dp']
"Andrey needs one more problem to conduct a programming contest. He has n friends who are always willing to help. He can ask some of them to come up with a contest problem. Andrey knows one value for each of his fiends — the probability that this friend will come up with a problem if Andrey asks him.Help Andrey choose people to ask. As he needs only one problem, Andrey is going to be really upset if no one comes up with a problem or if he gets more than one problem from his friends. You need to choose such a set of people that maximizes the chances of Andrey not getting upset.","def C():
    n = int(input())
    tmp = input()
    tmp = tmp.split()
    probability = list(map(float,tmp))

    probability.sort()
    
    current = probability[n-1]
    pre = 1 - probability[n-1]

    for i in range(n-2,-1,-1):
        tmp = current * (1-probability[i]) + pre * (probability[i])
        if (tmp > current):
            current = tmp
            pre = pre * (1-probability[i])

    print(""%.12f"" % current)

if __name__ == ""__main__"":
    C()","['greedy', 'probabilities', 'math']"
"There are three horses living in a horse land: one gray, one white and one gray-and-white. The horses are really amusing animals, which is why they adore special cards. Each of those cards must contain two integers, the first one on top, the second one in the bottom of the card. Let's denote a card with a on the top and b in the bottom as (a, b).Each of the three horses can paint the special cards. If you show an (a, b) card to the gray horse, then the horse can paint a new (a + 1, b + 1) card. If you show an (a, b) card, such that a and b are even integers, to the white horse, then the horse can paint a new  card. If you show two cards (a, b) and (b, c) to the gray-and-white horse, then he can paint a new (a, c) card.Polycarpus really wants to get n special cards (1, a1), (1, a2), ..., (1, an). For that he is going to the horse land. He can take exactly one (x, y) card to the horse land, such that 1 ≤ x &lt; y ≤ m. How many ways are there to choose the card so that he can perform some actions in the horse land and get the required cards?Polycarpus can get cards from the horses only as a result of the actions that are described above. Polycarpus is allowed to get additional cards besides the cards that he requires.","# written with help of editorial
n, m = map(int, input().split())
a = list(map(int, input().split()))

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

g = 0
for x in a:
    g = gcd(g, x - 1)

answer = 0

def process(x):
    global answer
    if x % 2 == 0:
        return 0
    for i in range(30):
        v = 2 ** i * x
        if v > m:
            break
        answer += m - v

for i in range(1, g + 1):
    if i * i > g:
        break
    if g % i:
        continue
    process(i)
    if i * i != g:
        process(g // i)

print(answer)","['constructive algorithms', 'number theory', 'math']"
"You are playing one RPG from the 2010s. You are planning to raise your smithing skill, so you need as many resources as possible. So how to get resources? By stealing, of course.You decided to rob a town's blacksmith and you take a follower with you. You can carry at most $$$p$$$ units and your follower — at most $$$f$$$ units.In the blacksmith shop, you found $$$cnt_s$$$ swords and $$$cnt_w$$$ war axes. Each sword weights $$$s$$$ units and each war axe — $$$w$$$ units. You don't care what to take, since each of them will melt into one steel ingot.What is the maximum number of weapons (both swords and war axes) you and your follower can carry out from the shop?","def controller(p, f, cnt_s, cnt_w, s, w):
    def proc(cap_p, cap_f, cnt, weight):
        sp, sf = cap_p//weight, cap_f//weight
        if cnt >= sp + sf:
            return (0, sp, sf)  # if total == 0, then total == sp + sf
        sp, sf = min(cnt,sp), min(cnt,sf)
        return (cnt, sp, sf)
    if s > w:
        s, w, cnt_s, cnt_w = w, s, cnt_w, cnt_s
    elif s == w:
        cnt_s, cnt_w = cnt_s + cnt_w, 0
    total, sp, sf = proc(p, f, cnt_s, s)
    if total == 0:
        return sp + sf
    elif cnt_w == 0:
        return cnt_s
    pot_p = p - s*sp
    pot_f = f - s*(cnt_s-sp)
    total, sp2, sf2 = proc(pot_p, pot_f, cnt_w, w)
    total = total or sp2 + sf2
    total += cnt_s
    rem = pot_p % w + pot_f % w
    if rem >= w and cnt_w > sp2 + sf2:
        for i in range(sp-(cnt_s-sf)):  # why not sp+1-(cnt_s-sf)? since first choice outside loop
            pot_p += s
            pot_f -= s
            if pot_p % w + pot_f % w < w:
                return total + 1
    return total

def c_in():
    import sys, os.path
    try:
        file = open(os.path.join(sys.argv[0], r'../in-b.txt'))
    except:
        file = sys.stdin
    n_test_case = int(file.readline())
    # print(n_test_case)
    for i in range(n_test_case):
        p, f = [int(i) for i in file.readline().split()]
        cnt_s, cnt_w = [int(i) for i in file.readline().split()]
        s, w = [int(i) for i in file.readline().split()]
        inputs = p, f, cnt_s, cnt_w, s, w
        # print(inputs)
        print(controller(*inputs))

if __name__ == '__main__':
    c_in()","['greedy', 'math', 'brute force']"
"You have a Petri dish with bacteria and you are preparing to dive into the harsh micro-world. But, unfortunately, you don't have any microscope nearby, so you can't watch them.You know that you have $$$n$$$ bacteria in the Petri dish and size of the $$$i$$$-th bacteria is $$$a_i$$$. Also you know intergalactic positive integer constant $$$K$$$.The $$$i$$$-th bacteria can swallow the $$$j$$$-th bacteria if and only if $$$a_i &gt; a_j$$$ and $$$a_i \le a_j + K$$$. The $$$j$$$-th bacteria disappear, but the $$$i$$$-th bacteria doesn't change its size. The bacteria can perform multiple swallows. On each swallow operation any bacteria $$$i$$$ can swallow any bacteria $$$j$$$ if $$$a_i &gt; a_j$$$ and $$$a_i \le a_j + K$$$. The swallow operations go one after another.For example, the sequence of bacteria sizes $$$a=[101, 53, 42, 102, 101, 55, 54]$$$ and $$$K=1$$$. The one of possible sequences of swallows is: $$$[101, 53, 42, 102, \underline{101}, 55, 54]$$$ $$$\to$$$ $$$[101, \underline{53}, 42, 102, 55, 54]$$$ $$$\to$$$ $$$[\underline{101}, 42, 102, 55, 54]$$$ $$$\to$$$ $$$[42, 102, 55, \underline{54}]$$$ $$$\to$$$ $$$[42, 102, 55]$$$. In total there are $$$3$$$ bacteria remained in the Petri dish.Since you don't have a microscope, you can only guess, what the minimal possible number of bacteria can remain in your Petri dish when you finally will find any microscope.","from __future__ import print_function, division
from sys import stdin, stdout
from fractions import gcd
# from math import *
from collections import *
from operator import mul
from functools import reduce
from copy import copy

rstr = lambda: stdin.readline().strip()
rstrs = lambda: [str(x) for x in stdin.readline().split()]
rint = lambda: int(stdin.readline())
rints = lambda: [int(x) for x in stdin.readline().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
pr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\n')
out = []

n, k = rints()
a, ans = rints(), n
mem, ix = Counter(a), 1
keys = sorted(mem.keys())[::-1]

for i in keys:
    for j in range(ix, len(keys)):
        if keys[j] < i - k:
            break
        elif keys[j] < i and keys[j] >= i - k:
            ans -= mem[keys[j]]

        ix += 1

print(ans)","['sortings', 'greedy']"
"You are given an array $$$a$$$ of $$$n$$$ points in $$$k$$$-dimensional space. Let the distance between two points $$$a_x$$$ and $$$a_y$$$ be $$$\sum \limits_{i = 1}^{k} |a_{x, i} - a_{y, i}|$$$ (it is also known as Manhattan distance).You have to process $$$q$$$ queries of the following two types: $$$1$$$ $$$i$$$ $$$b_1$$$ $$$b_2$$$ ... $$$b_k$$$ — set $$$i$$$-th element of $$$a$$$ to the point $$$(b_1, b_2, \dots, b_k)$$$; $$$2$$$ $$$l$$$ $$$r$$$ — find the maximum distance between two points $$$a_i$$$ and $$$a_j$$$, where $$$l \le i, j \le r$$$.","import sys
range = xrange
input = raw_input

big = 10**8

class seg:
    def __init__(self,n,d):
        m = 1
        while m<n:m*=2
        self.n = n
        self.m = m
        self.mindata = [[big]*(2*m) for _ in range(d)]
        self.maxdata = [[-(big)]*(2*m) for _ in range(d)]
        self.d = d

    def diff(self,l,r):
        l += self.m
        r += self.m
        maxi = [-big]*self.d
        mini = [big]*self.d
        while l<r:
            if l%2==1:
                for i in range(self.d):
                    maxi[i] = max(maxi[i],self.maxdata[i][l])
                    mini[i] = min(mini[i],self.mindata[i][l])
                l += 1
            if r%2==1:
                r -= 1
                for i in range(self.d):
                    maxi[i] = max(maxi[i],self.maxdata[i][r])
                    mini[i] = min(mini[i],self.mindata[i][r])
            l //= 2
            r //= 2
        return max(maxi[i]-mini[i] for i in range(self.d))
    def set(self,ind,val):
        ind += self.m
        for i in range(self.d):
            self.mindata[i][ind] = val[i]
            self.maxdata[i][ind] = val[i]
        ind //= 2
        old_ind = ind
        for i in range(self.d):
            ind = old_ind
            while ind>0:
                dum = min(self.mindata[i][2*ind],self.mindata[i][2*ind+1])
                if self.mindata[i][ind] != dum:
                    self.mindata[i][ind] = dum
                else:
                    break
                ind //= 2
            ind = old_ind
            while ind>0:
                dum = max(self.maxdata[i][2*ind],self.maxdata[i][2*ind+1])
                if self.maxdata[i][ind] != dum:
                    self.maxdata[i][ind] = dum
                else:
                    break
                ind //= 2


s = sys.stdin.read()
inp = []
numb = 0
sign = 1
 
for i in range(len(s)):
    if s[i]>='0':
        numb = 10*numb + ord(s[i])-48
    else:
        if s[i]=='-':
            sign = -1
        else:
            inp.append(sign*numb)
            numb = 0
            sign = 1
if s[-1]>='0':
    inp.append(sign*numb)
ii = 0

n,k = inp[ii],inp[ii+1]
ii += 2

ways = []
for numb in range(2**(k-1)):
    tmp = []
    ind = 0
    while numb>0:
        if numb%2==1:
            tmp.append(ind)
        numb //= 2
        ind += 1
    ways.append(tmp)

duper = seg(n,2**(k-1))

for node in range(n):
    total = sum(inp[ii:ii+k])
    vals = [total - 2*sum(inp[ii+s] for s in signs) for signs in ways]
    ii += k
    duper.set(node,vals)

q = inp[ii]
ii+= 1
out = []
for _ in range(q):
    query = inp[ii]
    ii += 1
    if query==1:
        node = inp[ii]-1
        ii += 1

        total = sum(inp[ii:ii+k])
        vals = [total - 2*sum(inp[ii+s] for s in signs) for signs in ways]

        ii += k
        duper.set(node,vals)
    else:
        l,r  = inp[ii]-1,inp[ii+1]
        ii += 2
        out.append(duper.diff(l,r)) 
print '\n'.join(str(x) for x in out)","['data structures', 'bitmasks']"
"You are given n strings s1, s2, ..., sn consisting of characters 0 and 1. m operations are performed, on each of them you concatenate two existing strings into a new one. On the i-th operation the concatenation saisbi is saved into a new string sn + i (the operations are numbered starting from 1). After each operation you need to find the maximum positive integer k such that all possible strings consisting of 0 and 1 of length k (there are 2k such strings) are substrings of the new string. If there is no such k, print 0.","from sys import stdin, stdout

K = 20

def findAllStrings(s):
    n = len(s)
    sDict = {}
    for i in range(1,K+1):
        sDict[i]=set()
        for x in range(n-i+1):
            sDict[i].add(s[x:x+i])
    return sDict

n = int(stdin.readline().rstrip())
stringDicts = []
stringEnd = []
stringBegin = []

for i in range(n):
    s = stdin.readline().rstrip()
    stringDicts.append(findAllStrings(s))
    if len(s)<K:
        stringEnd.append(s)
        stringBegin.append(s)
    else:
        stringEnd.append(s[-20:])
        stringBegin.append(s[:20])

m = int(stdin.readline().rstrip())

for _ in range(m):
    a,b = map(int,stdin.readline().rstrip().split())
    a-=1
    b-=1
    
    sDict1 = findAllStrings(stringEnd[a]+stringBegin[b])
    sDict2 = stringDicts[a]
    sDict3 = stringDicts[b]
    sDict={}
    for i in range(1,K+1):
        sDict[i] = sDict1[i]|sDict2[i]|sDict3[i]
    stringDicts.append(sDict)
    for i in range(1,K+1):
        if len(sDict[i])!=2**i:
            print(i-1)
            break
                
    if len(stringBegin[a])<K and len(stringBegin[a])+len(stringBegin[b])<K:
        stringBegin.append(stringBegin[a]+stringBegin[b])
    elif len(stringBegin[a])<K:
        s = stringBegin[a]+stringBegin[b]
        stringBegin.append(s[:K])
    else:
        stringBegin.append(stringBegin[a])
        
    if len(stringEnd[b])<K and len(stringEnd[a])+len(stringEnd[b])<K:
        stringEnd.append(stringEnd[a]+stringEnd[b])
    elif len(stringEnd[b])<K:
        s = stringEnd[a]+stringEnd[b]
        stringEnd.append(s[-K:])
    else:
        stringEnd.append(stringEnd[b])","['dp', 'bitmasks', 'implementation', 'brute force', 'strings']"
"For a given sequence of distinct non-negative integers $$$(b_1, b_2, \dots, b_k)$$$ we determine if it is good in the following way:  Consider a graph on $$$k$$$ nodes, with numbers from $$$b_1$$$ to $$$b_k$$$ written on them. For every $$$i$$$ from $$$1$$$ to $$$k$$$: find such $$$j$$$ ($$$1 \le j \le k$$$, $$$j\neq i$$$), for which $$$(b_i \oplus b_j)$$$ is the smallest among all such $$$j$$$, where $$$\oplus$$$ denotes the operation of bitwise XOR (https://en.wikipedia.org/wiki/Bitwise_operation#XOR). Next, draw an undirected edge between vertices with numbers $$$b_i$$$ and $$$b_j$$$ in this graph. We say that the sequence is good if and only if the resulting graph forms a tree (is connected and doesn't have any simple cycles). It is possible that for some numbers $$$b_i$$$ and $$$b_j$$$, you will try to add the edge between them twice. Nevertheless, you will add this edge only once.You can find an example below (the picture corresponding to the first test case). Sequence $$$(0, 1, 5, 2, 6)$$$ is not good as we cannot reach $$$1$$$ from $$$5$$$.However, sequence $$$(0, 1, 5, 2)$$$ is good.   You are given a sequence $$$(a_1, a_2, \dots, a_n)$$$ of distinct non-negative integers. You would like to remove some of the elements (possibly none) to make the remaining sequence good. What is the minimum possible number of removals required to achieve this goal?It can be shown that for any sequence, we can remove some number of elements, leaving at least $$$2$$$, so that the remaining sequence is good.","n = int(input())
l = list(map(int,input().split()))

def fun(a):
    if len(a) <= 3:
        return len(a)
    
    maxE = max(a)
    
    if maxE == 0:
        return len(a)
        
    msb = 1
    
    while 2 * msb <= maxE:
        msb *= 2
    
        
    l1 = []
    l2 = []

    for x in a:
        if x >= msb:
            l1.append(x-msb)
        else:
            l2.append(x)
        
        

    max1 = fun(l1)
    max2 = fun(l2)
    
    if max1 == 0:
        return max2
    if max2 == 0:
        return max1
    
    return max(1+max1,1+max2)

print(n - fun(l))","['dp', 'bitmasks', 'divide and conquer', 'data structures', 'binary search', 'trees']"
"Vika has n jars with paints of distinct colors. All the jars are numbered from 1 to n and the i-th jar contains ai liters of paint of color i.Vika also has an infinitely long rectangular piece of paper of width 1, consisting of squares of size 1 × 1. Squares are numbered 1, 2, 3 and so on. Vika decided that she will start painting squares one by one from left to right, starting from the square number 1 and some arbitrary color. If the square was painted in color x, then the next square will be painted in color x + 1. In case of x = n, next square is painted in color 1. If there is no more paint of the color Vika wants to use now, then she stops.Square is always painted in only one color, and it takes exactly 1 liter of paint. Your task is to calculate the maximum number of squares that might be painted, if Vika chooses right color to paint the first square.","n = int(raw_input())
a = [int(i) for i in raw_input().split("" "")]

firstminpos = 0
lastminpos = 0
for i in xrange(1, n):
    if a[i] < a[firstminpos]:
        firstminpos = i
        lastminpos = i
    elif a[i] == a[lastminpos]:
        lastminpos = i

minel = a[firstminpos]

for i in xrange(n):
    a[i] -= minel

longestrunlen = 0
runlen = 0
for i in xrange(n):
    if a[i]:
        runlen += 1
        longestrunlen = max(longestrunlen, runlen)
    else:
        runlen = 0

if runlen > 0:
    for i in xrange(n):
        if a[i]:
            runlen += 1
            longestrunlen = max(longestrunlen, runlen)
        else:
            break

print n * minel + longestrunlen","['constructive algorithms', 'implementation']"
"Erelong Leha was bored by calculating of the greatest common divisor of two factorials. Therefore he decided to solve some crosswords. It's well known that it is a very interesting occupation though it can be very difficult from time to time. In the course of solving one of the crosswords, Leha had to solve a simple task. You are able to do it too, aren't you?Leha has two strings s and t. The hacker wants to change the string s at such way, that it can be found in t as a substring. All the changes should be the following: Leha chooses one position in the string s and replaces the symbol in this position with the question mark ""?"". The hacker is sure that the question mark in comparison can play the role of an arbitrary symbol. For example, if he gets string s=""ab?b"" as a result, it will appear in t=""aabrbb"" as a substring.Guaranteed that the length of the string s doesn't exceed the length of the string t. Help the hacker to replace in s as few symbols as possible so that the result of the replacements can be found in t as a substring. The symbol ""?"" should be considered equal to any other symbol.","n, m = map(int, raw_input().split())

s = raw_input()
t = raw_input()

ans = float('inf')
pos = []

for i in xrange(m-n+1):
    count = 0
    tempPos = []
    for j in xrange(n):
        if t[i+j] != s[j]:
            count += 1
            tempPos.append(j+1)
    if count < ans:
        ans = count
        pos = tempPos
        
print ans
for i in pos:
    print i,","['implementation', 'brute force', 'strings']"
"DZY has a hash table with p buckets, numbered from 0 to p - 1. He wants to insert n numbers, in the order they are given, into the hash table. For the i-th number xi, DZY will put it into the bucket numbered h(xi), where h(x) is the hash function. In this problem we will assume, that h(x) = x mod p. Operation a mod b denotes taking a remainder after division a by b.However, each bucket can contain no more than one element. If DZY wants to insert an number into a bucket which is already filled, we say a ""conflict"" happens. Suppose the first conflict happens right after the i-th insertion, you should output i. If no conflict happens, just output -1.","p,n=map(int,raw_input().split())
a=[0]*500
for i in range(n):
    x=input()
    x=x%p
    #print i,x
    if a[x]==1:
        print i+1
        exit()
    a[x]=1
print -1",['implementation']
"You are given a multiset of n integers. You should select exactly k of them in a such way that the difference between any two of them is divisible by m, or tell that it is impossible.Numbers can be repeated in the original multiset and in the multiset of selected numbers, but number of occurrences of any number in multiset of selected numbers should not exceed the number of its occurrences in the original multiset.","n,k,m = map(int,input().split())
arr = list(map(int,input().split()))
ans = {}
for i in arr:
    if i%m not in ans:
        ans[i%m] = [i]
    else:
        ans[i%m].append(i)
check = False
for i in ans:
    if len(ans[i]) >= k:
        check = True
        break
if check:
    print('Yes')
    j = 0
    while j<=k-1:
        print(ans[i][j],end = ' ')
        j+=1
else:
    print('No')","['implementation', 'number theory', 'math']"
Vitaly has an array of n distinct integers. Vitaly wants to divide this array into three non-empty sets so as the following conditions hold:   The product of all numbers in the first set is less than zero ( &lt; 0).  The product of all numbers in the second set is greater than zero ( &gt; 0).  The product of all numbers in the third set is equal to zero.  Each number from the initial array must occur in exactly one set. Help Vitaly. Divide the given array.,"n=int(input())
L=list(map(int,input().split()))
d={-1:[],0:[0],1:[]}
for i in range(len(L)):
    if L[i]<0:
        d[-1].append(L[i])
    elif L[i]>0:
        d[1].append(L[i])

if len(d[-1])%2!=0:
    if len(d[1])!=0:
        print(len(d[-1]),*d[-1])
        print(len(d[1]),*d[1])
        print(""1 0"")
    else:
        print(len(d[-1])-2,*d[-1][2:])
        print(2,*d[-1][:2])
        print(""1 0"")
else:
    if len(d[1])!=0:
        print(len(d[-1])-1,*d[-1][1:])
        d[0].append(d[-1][0])
        print(len(d[1]),*d[1])
        print(len(d[0]),*d[0])
    else:
        print(len(d[-1])-3,*d[-1][3:])
        d[0].append(d[-1][2])
        print(2,*d[-1][:2])
        print(len(d[0]),*d[0])","['constructive algorithms', 'implementation', 'brute force']"
"Today, hedgehog Filya went to school for the very first time! Teacher gave him a homework which Filya was unable to complete without your help.Filya is given an array of non-negative integers a1, a2, ..., an. First, he pick an integer x and then he adds x to some elements of the array (no more than once), subtract x from some other elements (also, no more than once) and do no change other elements. He wants all elements of the array to be equal.Now he wonders if it's possible to pick such integer x and change some elements of the array using this x in order to make all elements equal.","__author__ = 'Alexander'
import sys
n = int(sys.stdin.readline().strip())
A = set(map(int, sys.stdin.readline().split()))
if len(A) > 3:
    sys.stdout.write(""NO"")
elif len(A) == 3:
    a1 = min(A)
    a3 = max(A)
    a2 = min(A - set([a1, a3]))
    if a2-a1 == a3-a2:
        sys.stdout.write(""YES"")
    else: sys.stdout.write(""NO"")
# elif len(A) == 2:
#     var = max(A) - min(A)
#     if var in A:
#         sys.stdout.write(""YES"")
#     else: sys.stdout.write(""NO"")
else: sys.stdout.write(""YES"")","['implementation', 'sortings']"
"«Next please», — the princess called and cast an estimating glance at the next groom.The princess intends to choose the most worthy groom, this is, the richest one. Whenever she sees a groom who is more rich than each of the previous ones, she says a measured «Oh...». Whenever the groom is richer than all previous ones added together, she exclaims «Wow!» (no «Oh...» in this case). At the sight of the first groom the princess stays calm and says nothing.The fortune of each groom is described with an integer between 1 and 50000. You know that during the day the princess saw n grooms, said «Oh...» exactly a times and exclaimed «Wow!» exactly b times. Your task is to output a sequence of n integers t1, t2, ..., tn, where ti describes the fortune of i-th groom. If several sequences are possible, output any of them. If no sequence exists that would satisfy all the requirements, output a single number -1.","n, a, b = map(int, input().strip().split())
ans = list()
sum1 = 1
ans.append(1)
res = 1
for i in range(2, n+1):
	pass
	if b != 0:
		pass
		res = sum1 + 1
		b = b - 1
	elif a > 0 and i > 2:
		res = res + 1
		a = a - 1
	ans.append(res)
	sum1 += res
if a > 0 or b > 0:
	pass
	print(-1)
else:
	print(1, end = "" "")
	for x in range(1,n):
		pass
		print(ans[x], end="" "")","['constructive algorithms', 'greedy']"
"We often go to supermarkets to buy some fruits or vegetables, and on the tag there prints the price for a kilo. But in some supermarkets, when asked how much the items are, the clerk will say that $$$a$$$ yuan for $$$b$$$ kilos (You don't need to care about what ""yuan"" is), the same as $$$a/b$$$ yuan for a kilo.Now imagine you'd like to buy $$$m$$$ kilos of apples. You've asked $$$n$$$ supermarkets and got the prices. Find the minimum cost for those apples.You can assume that there are enough apples in all supermarkets.","n,m = raw_input().split()
n = int(n)
m = int(m)
minf=0
for i in range(0,n):
	a,b = map(float, raw_input().split("" ""))
	if i==0:
		#print(i)
		minf = m*(a/b)
		#print(minf)
	else:
		new_min = m*(a/b)
		if new_min<minf:
			minf = new_min
print(minf)","['implementation', 'greedy', 'brute force']"
"Suppose you are given a string $$$s$$$ of length $$$n$$$ consisting of lowercase English letters. You need to compress it using the smallest possible number of coins.To compress the string, you have to represent $$$s$$$ as a concatenation of several non-empty strings: $$$s = t_{1} t_{2} \ldots t_{k}$$$. The $$$i$$$-th of these strings should be encoded with one of the two ways:  if $$$|t_{i}| = 1$$$, meaning that the current string consists of a single character, you can encode it paying $$$a$$$ coins;  if $$$t_{i}$$$ is a substring of $$$t_{1} t_{2} \ldots t_{i - 1}$$$, then you can encode it paying $$$b$$$ coins. A string $$$x$$$ is a substring of a string $$$y$$$ if $$$x$$$ can be obtained from $$$y$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.So your task is to calculate the minimum possible number of coins you need to spend in order to compress the given string $$$s$$$.","import sys

sys.setrecursionlimit(10 ** 8)
n, a, b = map(int,input().split())
s = input()


def calc(j):
    if (j >= n): return 0
    if (dp[j] != -1): return dp[j]
    dp[j] = a + calc(j + 1)


    lo = j
    hi = n
    farthest = -1
    # finding best string to reach from a given j such that it eist before i using binary search
    while (lo < hi):
        mid = (lo + hi) // 2
        if (s[j:mid + 1] in s[0:j]):
            farthest = mid
            lo = mid + 1
        else:
            hi = mid
    if (farthest != -1): dp[j] = min(dp[j], b + calc(farthest + 1))
    return dp[j]


dp = [-1 for i in range(n + 5)]
print(calc(0))","['dp', 'strings']"
"You've got a list of program warning logs. Each record of a log stream is a string in this format:  ""2012-MM-DD HH:MM:SS:MESSAGE"" (without the quotes). String ""MESSAGE"" consists of spaces, uppercase and lowercase English letters and characters ""!"", ""."", "","", ""?"". String ""2012-MM-DD"" determines a correct date in the year of 2012. String ""HH:MM:SS"" determines a correct time in the 24 hour format.The described record of a log stream means that at a certain time the record has got some program warning (string ""MESSAGE"" contains the warning's description).Your task is to print the first moment of time, when the number of warnings for the last n seconds was not less than m.","import sys,time,re
n,m=map(int,raw_input().split())
t=[]
i=j=0
for s in sys.stdin:
  t+=[time.mktime(map(int,re.split('[-: ]',s[:19]))+[0]*3)]
  while j<i and t[j]<=t[i]-n:j+=1
  i+=1
  if i-j>=m:
    print s[:19]
    exit()
print -1","['binary search', 'implementation', 'brute force', 'strings']"
"Consider the infinite sequence $$$s$$$ of positive integers, created by repeating the following steps:  Find the lexicographically smallest triple of positive integers $$$(a, b, c)$$$ such that   $$$a \oplus b \oplus c = 0$$$, where $$$\oplus$$$ denotes the bitwise XOR operation.  $$$a$$$, $$$b$$$, $$$c$$$ are not in $$$s$$$.  Here triple of integers $$$(a_1, b_1, c_1)$$$ is considered to be lexicographically smaller than triple $$$(a_2, b_2, c_2)$$$ if sequence $$$[a_1, b_1, c_1]$$$ is lexicographically smaller than sequence $$$[a_2, b_2, c_2]$$$.  Append $$$a$$$, $$$b$$$, $$$c$$$ to $$$s$$$ in this order.  Go back to the first step. You have integer $$$n$$$. Find the $$$n$$$-th element of $$$s$$$.You have to answer $$$t$$$ independent test cases.A sequence $$$a$$$ is lexicographically smaller than a sequence $$$b$$$ if in the first position where $$$a$$$ and $$$b$$$ differ, the sequence $$$a$$$ has a smaller element than the corresponding element in $$$b$$$.","import sys
lines = sys.stdin.readlines()
T = int(lines[0].strip())
partial = [1, 2, 3, 4, 8, 12, 5, 10, 15, 6, 11, 13, 7, 9, 14, 16, 32, 48, 17, 34, 51, 18, 35, 49, 19, 33, 50, 20, 40, 60, 21, 42, 63, 22, 43, 61, 23, 41, 62, 24, 44, 52, 25, 46, 55, 26, 47, 53, 27, 45, 54, 28, 36, 56, 29, 38, 59, 30, 39, 57, 31, 37, 58, 64, 128, 192, 65, 130, 195, 66, 131, 193, 67, 129, 194, 68, 136, 204, 69, 138, 207, 70, 139, 205, 71, 137, 206, 72, 140, 196, 73, 142, 199, 74, 143, 197, 75, 141, 198, 76, 132, 200, 77, 134, 203, 78, 135, 201, 79, 133, 202, 80, 160, 240, 81, 162, 243, 82, 163, 241, 83, 161, 242, 84, 168, 252, 85, 170, 255, 86, 171, 253, 87, 169, 254, 88, 172, 244, 89, 174, 247, 90, 175, 245, 91, 173, 246, 92, 164, 248, 93, 166, 251, 94, 167, 249, 95, 165, 250, 96, 176, 208, 97, 178, 211, 98, 179, 209, 99, 177, 210, 100, 184, 220, 101, 186, 223, 102, 187, 221, 103, 185, 222, 104, 188, 212, 105, 190, 215, 106, 191, 213, 107, 189, 214, 108, 180, 216, 109, 182, 219, 110, 183, 217, 111, 181, 218, 112, 144, 224, 113, 146, 227, 114, 147, 225, 115, 145, 226, 116, 152, 236, 117, 154, 239, 118, 155, 237, 119, 153, 238, 120, 156, 228, 121, 158, 231, 122, 159, 229, 123, 157, 230, 124, 148, 232, 125, 150, 235, 126, 151, 233, 127, 149, 234, 256, 512, 768]
for t in range(T):
    n = int(lines[t+1].strip())
    if n <= 255: print(partial[n-1]); continue
    index = n % 3
    lowPow4 =  4 ** (len(bin(n)[3:])//2)
    first = lowPow4 + (n - lowPow4)//3

    tmp = [0,2,3,1]
    def theSecond(fi):
        if fi < 128:
            j = partial.index(fi)
            return partial[j+1]
        prev = theSecond(fi//4)
        return prev * 4 + tmp[fi%4]
    second = theSecond(first)
    if index == 1: print(first)
    elif index == 2: print(second)
    else: print(first ^ second)","['constructive algorithms', 'implementation', 'bitmasks', 'math']"
"It is a holiday season, and Koala is decorating his house with cool lights! He owns $$$n$$$ lights, all of which flash periodically.After taking a quick glance at them, Koala realizes that each of his lights can be described with two parameters $$$a_i$$$ and $$$b_i$$$. Light with parameters $$$a_i$$$ and $$$b_i$$$ will toggle (on to off, or off to on) every $$$a_i$$$ seconds starting from the $$$b_i$$$-th second. In other words, it will toggle at the moments $$$b_i$$$, $$$b_i + a_i$$$, $$$b_i + 2 \cdot a_i$$$ and so on.You know for each light whether it's initially on or off and its corresponding parameters $$$a_i$$$ and $$$b_i$$$. Koala is wondering what is the maximum number of lights that will ever be on at the same time. So you need to find that out.    Here is a graphic for the first example.","import math
n = int(input())
ini = str(input())
ab = []
maxon = 0
for i in range(n):
    abi = list(map(int, input().split()))
    ab.append(abi)

for t in range(1, 241):
    res = []
    i = 0
    for abi in ab:
        if t-abi[1] <= 0:
            res.append(int(ini[i])==0)
        else:
            res.append(math.ceil((t-abi[1])/abi[0])%2==int(ini[i]))
        i = i + 1
    maxon = max(maxon, n-sum(res))
    if maxon == n:
        break;
print(maxon)","['implementation', 'number theory', 'math']"
"And where the are the phone numbers?You are given a string s consisting of lowercase English letters and an integer k. Find the lexicographically smallest string t of length k, such that its set of letters is a subset of the set of letters of s and s is lexicographically smaller than t.It's guaranteed that the answer exists.Note that the set of letters is a set, not a multiset. For example, the set of letters of abadaba is {a, b, d}.String p is lexicographically smaller than string q, if p is a prefix of q, is not equal to q or there exists i, such that pi &lt; qi and for all j &lt; i it is satisfied that pj = qj. For example, abc is lexicographically smaller than abcd , abd is lexicographically smaller than abec, afa is not lexicographically smaller than ab and a is not lexicographically smaller than a.","n, k = map(int, input().split())
s = input()
a = sorted(set(s))
idx = {}

for i, j in enumerate(a):
	idx[j] = i

if n < k:
	print(s + a[0] * (k - n))
	exit()

t = [*s[:k]]
z = len(idx)
l = 0

for i in range(k - 1, -1, -1):
	r = (idx[s[i]] + 1) % z
	if r == 0:
		l = 1
	else:
		l = 0
	t[i] = a[r]
	if l == 0:
		break

print(''.join(t))","['constructive algorithms', 'implementation', 'strings']"
"Phoenix loves beautiful arrays. An array is beautiful if all its subarrays of length $$$k$$$ have the same sum. A subarray of an array is any sequence of consecutive elements.Phoenix currently has an array $$$a$$$ of length $$$n$$$. He wants to insert some number of integers, possibly zero, into his array such that it becomes beautiful. The inserted integers must be between $$$1$$$ and $$$n$$$ inclusive. Integers may be inserted anywhere (even before the first or after the last element), and he is not trying to minimize the number of inserted integers.","from __future__ import division, print_function
 
import os,sys
from io import BytesIO, IOBase
 
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
 
 
def ii():  return int(input())
def si():  return input()
def mi():  return map(int,input().split("" ""))
def msi(): return map(str,input().split("" ""))
def li():  return list(mi())
 
def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
    
#from math import *
def isPowerOfTwo (x): return (x and (not(x & (x - 1))) )
 
def gcd(x, y):
    while y:
        x, y = y, x % y
    return x
    
def checkPrime(n) : # Check Prime Number or not 
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) : 
        if (n % i == 0 or n % (i + 2) == 0) : 
            return False
        i = i + 6
    return True
 
def read():
    sys.stdin = open('input.txt', 'r')  
    sys.stdout = open('output.txt', 'w') 

def main():
    
    for _ in range(ii()):
        n,k=mi()
        a=list(set(li()))
        if k<len(a):
            print(-1)
            continue
        print(n*k)
        res=a+([1]*(k-len(a)))
        print(*(res*n))
# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()
 
 
if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
 
if __name__ == ""__main__"":
    #read()
    main()
    #dmain()
 
# Comment Read()","['data structures', 'constructive algorithms', 'sortings', 'greedy']"
"HDD hard drives group data by sectors. All files are split to fragments and each of them are written in some sector of hard drive. Note the fragments can be written in sectors in arbitrary order.One of the problems of HDD hard drives is the following: the magnetic head should move from one sector to another to read some file.Find the time need to read file split to n fragments. The i-th sector contains the fi-th fragment of the file (1 ≤ fi ≤ n). Note different sectors contains the different fragments. At the start the magnetic head is in the position that contains the first fragment. The file are reading in the following manner: at first the first fragment is read, then the magnetic head moves to the sector that contains the second fragment, then the second fragment is read and so on until the n-th fragment is read. The fragments are read in the order from the first to the n-th.It takes |a - b| time units to move the magnetic head from the sector a to the sector b. Reading a fragment takes no time.","from bisect import bisect
from itertools import permutations,combinations
n=int(input())
a=list(map(int,input().split()))

cnt=1
b = []
for x in a:
    b.append([x,cnt])
    cnt+=1
b.sort()
res = 0
for i in range(1,n):
    res+=abs(b[i][1]-b[i-1][1])
print(res)","['implementation', 'math']"
"Andryusha is an orderly boy and likes to keep things in their place.Today he faced a problem to put his socks in the wardrobe. He has n distinct pairs of socks which are initially in a bag. The pairs are numbered from 1 to n. Andryusha wants to put paired socks together and put them in the wardrobe. He takes the socks one by one from the bag, and for each sock he looks whether the pair of this sock has been already took out of the bag, or not. If not (that means the pair of this sock is still in the bag), he puts the current socks on the table in front of him. Otherwise, he puts both socks from the pair to the wardrobe.Andryusha remembers the order in which he took the socks from the bag. Can you tell him what is the maximum number of socks that were on the table at the same time?","r=lambda:map(int,raw_input().split())

n=input()
x=r()

s=set()
m=0
for i in x:
    if i not in s:
        s.add(i)
    else:
        s.remove(i)
    m=max(len(s),m)
print m",['implementation']
"In an attempt to escape the Mischievous Mess Makers' antics, Farmer John has abandoned his farm and is traveling to the other side of Bovinia. During the journey, he and his k cows have decided to stay at the luxurious Grand Moo-dapest Hotel. The hotel consists of n rooms located in a row, some of which are occupied.Farmer John wants to book a set of k + 1 currently unoccupied rooms for him and his cows. He wants his cows to stay as safe as possible, so he wishes to minimize the maximum distance from his room to the room of his cow. The distance between rooms i and j is defined as |j - i|. Help Farmer John protect his cows by calculating this minimum possible distance.","from collections import deque
rooms_number, cows_number = map(int, input().split())
rooms = input()
free_rooms = [i for i in range(rooms_number) if rooms[i] == '0']
def binary_search(left, right, item):
    global free_rooms
    while right - left > 1:
        center = left + (right - left)//2
        if free_rooms[center] > item:
            right = center
        else:
            left = center
    return left
min_distation_to_farthest_cow = 10**20
best_min_distation_to_farthest_cow = cows_number//2 + cows_number%2
for i in range(len(free_rooms) - cows_number):
    left = free_rooms[i]
    right = free_rooms[i + cows_number]
    center = left + (right - left)//2
    j = binary_search(i, i + cows_number, center)
    if free_rooms[j] == center:
        distation_to_farthest_cow = right - center
    else:
        distation_to_farthest_cow = min(right - free_rooms[j], free_rooms[j + 1] - left)
    if min_distation_to_farthest_cow > distation_to_farthest_cow:
        min_distation_to_farthest_cow = distation_to_farthest_cow
    if distation_to_farthest_cow == best_min_distation_to_farthest_cow:
        break
print(min_distation_to_farthest_cow)","['two pointers', 'binary search']"
"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0, 0), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi, 0)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu, yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","from math import sqrt

n, v1, v2 = [int(i) for i in input().split()]
x = [int(i) for i in input().split()]
x1, y1 = [int(i) for i in input().split()]

minim = x[1] / v1 + sqrt((x1-x[1])**2 + (y1)**2) / v2 #Время, если студен выйдет на первой остановке и побежит (если он быстрее автобуса)
res = 2
for i in range(2, n):
    t = x[i] / v1 + sqrt((x1-x[i])**2 + (y1)**2) / v2
    if t < minim:
        minim = t
        res = i + 1
    elif t == minim and sqrt((x1-x[res-1])**2 + (y1)**2) > sqrt((x1-x[i])**2 + (y1)**2):
        res = i+1
print(res)","['implementation', 'geometry', 'brute force']"
"Everyone knows that agents in Valorant decide, who will play as attackers, and who will play as defenders. To do that Raze and Breach decided to play $$$t$$$ matches of a digit game...In each of $$$t$$$ matches of the digit game, a positive integer is generated. It consists of $$$n$$$ digits. The digits of this integer are numerated from $$$1$$$ to $$$n$$$ from the highest-order digit to the lowest-order digit. After this integer is announced, the match starts.Agents play in turns. Raze starts. In one turn an agent can choose any unmarked digit and mark it. Raze can choose digits on odd positions, but can not choose digits on even positions. Breach can choose digits on even positions, but can not choose digits on odd positions. The match ends, when there is only one unmarked digit left. If the single last digit is odd, then Raze wins, else Breach wins.It can be proved, that before the end of the match (for every initial integer with $$$n$$$ digits) each agent has an ability to make a turn, i.e. there is at least one unmarked digit, that stands on a position of required parity.For each of $$$t$$$ matches find out, which agent wins, if both of them want to win and play optimally.","'''
# CodeForce Equalize Prices 900 points

# a = old price / b = new price / k =value input
def Computer_Game():

    for _ in range(int(input())):
        k, n, a, b = map(int, input().split())  # init charge, num turns in game, a,b bat value
        max_turns=0
        for turns in range(n):

            if k/b > n and (k-a)/b < n-1 and turns == 0:
                max_turns=0
                break
            else:
                if k > a:
                    k -= a
                    max_turns += 1
                elif k > b:
                    k -= b
                    if k/b == n-turns:
                        max_turns = 1
                        break
                else:
                    max_turns = -1
                    break


        print(max_turns)


    return


def bit_plus_plus():

    summe = 0
    for _ in range(int(input())):

        statement = input()
        if '+' in statement:
            summe += 1
        else:
            summe -= 1
    print(summe)
    return

def petya_and_strings():

    str_a, str_b = input().lower(), input().lower()
    a=(str_a<str_b)
    print((str_a>str_b)-(str_a<str_b))


    return




def beautiful_matrix():

    for idx in range(5):

        row_input = list(map(int,input().split()))
        if 1 in row_input:
            row = idx+1
            for idx1, elem in enumerate(row_input):
                if elem == 1:
                    column = idx1+1

    output = abs(3 - row) + abs(3 - column)
    print(output)
        #for row_num in range(4):
           # if 1 in row(row_num)

    return


def helpful_maths():


    string = sorted(list(input().split('+')))
    print('+'.join(string))

    return


def word_capitalization():

    string = input()
    string_new = string[0].upper()+string[1:]
    print(string_new)

    return

def Stones_on_the_Table():
    _ = input()
    string=list(input())
    color_old = ''
    color_old_old = ''
    take = 0
    for color in string:

        if color == color_old:
            take += 1
        else:
            color_old = color


    print(take)

    return

def Boy_or_girl():
    print([{*input()}])
    string = input()
    new_string = ''
    for _ in string:
        if _ not in new_string:
            new_string = new_string + _
    if len(new_string) % 2 != 0:
        print('IGNORE HIM!')
    else:
        print('CHAT WITH HER!')

    return


def soldier_and_bananas():

    k,n,w = map(int,input().split())
    prize = 0
    for num in range(w):
        prize = prize + (num+1)*k

    print(prize-n if prize-n > 0 else 0)
    return


def bear_and_big_brother():

    a,b = map(int, input().split())
    years = 0
    while a <= b:
        a = a*3
        b = b*2
        years += 1

    print(years)

    return


def Tram():
    passenger = []
    cur_pass = 0
    for _ in range(int(input())):

        exit_passenger, enter_passenger = map(int,input().split())
        cur_pass = cur_pass - exit_passenger + enter_passenger
        passenger.append(cur_pass)

    print(max(passenger))
    return



def subtract_one(number):

    if float(number)%10 == 0:
        result = number / 10
    else:
        result = number - 1

    return int(result)

def wrong_subtraction():

    n, k = map(int, input().split())

    for _ in range(k):
        n = subtract_one(n)

    print(n)
    return

def wet_shark_and_odd_and_even():

    odd = []
    even = []
    odd_cnt = 0
    n = input()
    numbers = list(map(int,input().split()))
    for number in numbers:
        if number%2 == 0:
            even.append(number)
        else:
            odd.append(number)
            odd_cnt += 1

    odd.sort()
    k = int(odd_cnt/2)*2
    if k > 0:
        summe = sum(even) + sum(odd[-k:])
    else:
        summe = sum(even)
    print(summe)


    return





def sorting(volumes):

    sorting_steps = 0
    idx = 0
    cnt = 0
    while(idx < len(volumes)-1):
        a = volumes[idx]
        b = volumes[idx+1]
        # print(volumes)
        if a > b:
            volumes[idx] = b
            volumes[idx+1] = a
            sorting_steps += 1
            if idx > 0:
                idx -= 1

            else:
                cnt = cnt+1
                idx = cnt

        else:
            idx += 1
    return sorting_steps

def cubes_sorting():

    for _ in range(int(input())):

        n = int(input())
        a = list(map(int,input().split()))

        max_sort = n*(n-1)/2-1

        sorting_steps = sorting(a)

        if sorting_steps > max_sort:
            print('NO')
        else:
            print('YES')


    return

def elephant():

    coord = int(input())
    steps_taken = 0
    for steps in range(5,0,-1):
        if (coord / steps) >= 1:
            steps_taken = int(coord / steps) + steps_taken
            coord = int(coord % steps)
    print(steps_taken)
    return

def queue_at_the_school():
    number, time = map(int,input().split())
    queue=list(input())

    i = 0

    while i < time:
        idx = 0
        while idx < len(queue)-1:
            if queue[idx] == 'B' and queue[idx+1] == 'G':
                queue[idx] = 'G'
                queue[idx+1] = 'B'
                idx += 2
            else:
                idx += 1
        i += 1

    print(''.join(queue))
    return

def nearly_lucky_number():
    number = input()
    l_number = 0
    bla=[sum(i in '47' for i in number) in [4, 7]]
    print('4' in number)
    for elem in number:
        if elem == '7' or elem == '4':
            l_number += 1
    print('YES' if l_number == 4 or l_number == 7 else 'NO')

    return

def word():
    string = input()
    count = 0
    for elem in string:
        if elem.isupper():
            count += 1

    print(string.upper() if count > len(string)/2 else string.lower())

    return
'''
def translation():
    word_1 = input()
    word_2 = input()[::-1]
    print([""NO"", ""YES""] [word_1 == word_2])


    return

def anton_and_danik():

    games = int(input())
    wins=input()
    anton_wins = sum(i == 'A' for i in wins)
    if anton_wins*2 > len(wins):
        print('Anton')
    elif anton_wins*2 == len(wins):
        print('Friendship')
    else:
        print('Danik')
    return

def acoomodation():

    cnt = 0
    for _ in range(int(input())):
        p, q = map(int, input().split())
        if q - p >= 2:
            cnt +=1

    print(cnt)


    return

def juicer():

    n, b, d = map(int, input().split())

    sum_orange = 0
    cnt_empty = 0
    for orange in list(map(int, input().split())):

        if orange <= b:
            sum_orange += orange
            if sum_orange > d:
                cnt_empty += 1
                sum_orange = 0
    print(cnt_empty)
    return


def digit_game():

    for game in range(int(input())):
        breach_odd_cnt = 0
        breach_even_cnt = 0
        raze_odd_cnt = 0
        raze_even_cnt = 0
        n = int(input())
        number = input()
        breach_numbers = ''
        raze_numbers = ''
        len_number = len(number)

        idx = 1
        for digit in number:

            if idx%2 == 0:
                breach_numbers += digit
                if digit in '13579':
                    breach_odd_cnt += 1
                else:
                    breach_even_cnt += 1
            else:
                raze_numbers += digit
                if digit in '13579':
                    raze_odd_cnt += 1
                else:
                    raze_even_cnt += 1
            idx += 1
        if len_number == 1:
            if int(number)%2 == 0:
                print(2)
            else:
                print(1)
        elif len_number%2 == 0:  # last pick from raze raze lässt eins übrig
            if breach_even_cnt >= 1:
                print(2)
            else:
                print(1)
        else:  # last pick from breach breach lässt übrig
            if raze_odd_cnt >= 1:
                print(1)
            else:
                print(2)

            # raze only odd breach only even 1 = odd 0 = even raze starts
            # 1 raze wins
            # 2 breach wins

    return


if __name__ == '__main__':

    digit_game()

'''
if __name__ == '__main__':
    num_queries = int(input())

    for querie in range(num_queries):
        num_products, value_products = map(int, input().split())
        price_products = list(map(int, input().split()))
        B_Max = min(price_products)+value_products
        B_Min = max(price_products)-value_products
        if B_Max >= B_Min:
            print(B_Max)
        else:
            print(-1)
'''","['implementation', 'greedy', 'games']"
"One day Vasya came up to the blackboard and wrote out n distinct integers from 1 to n in some order in a circle. Then he drew arcs to join the pairs of integers (a, b) (a ≠ b), that are either each other's immediate neighbors in the circle, or there is number c, such that a and с are immediate neighbors, and b and c are immediate neighbors. As you can easily deduce, in the end Vasya drew 2·n arcs.For example, if the numbers are written in the circle in the order 1, 2, 3, 4, 5 (in the clockwise direction), then the arcs will join pairs of integers (1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 3), (2, 4), (3, 5), (4, 1) and (5, 2).Much time has passed ever since, the numbers we wiped off the blackboard long ago, but recently Vasya has found a piece of paper with 2·n written pairs of integers that were joined with the arcs on the board. Vasya asks you to find the order of numbers in the circle by these pairs.","from collections import defaultdict
ri = lambda: map(int, raw_input().split())
edges = [[] for _ in xrange(200001)]

def dfs(n, k0, k1, k2):
    path = [k0, k1, k2]
    l = 3
    while l < n:
        dk = next((i for i in edges[k1] if i != k0 and i in edges[k2]), None)
        if dk is None: return None
        path.append(dk)
        k0,k1,k2 = k1,k2,dk
        l += 1

    return path if len(set(path)) == n else None
 
def main():
    n = input() 
    for i in xrange(n*2):
        a,b = ri()
        edges[a].append(b)
        edges[b].append(a)

    for i in xrange(1,n+1):
        if len(edges[i]) < 4:
            print -1
            return 

    if n <= 5:
        print ' '.join(map(str, range(1, n + 1)))
        return

    for k1 in edges[1]:
        for k2 in edges[1]:
            if k1 != k2:
                path = dfs(n,1,k1,k2)
                if path:
                    print "" "".join(map(str, path))
                    return
    print ""-1""

main()","['implementation', 'dfs and similar', 'brute force']"
"DZY loves chemistry, and he enjoys mixing chemicals.DZY has n chemicals, and m pairs of them will react. He wants to pour these chemicals into a test tube, and he needs to pour them in one by one, in any order. Let's consider the danger of a test tube. Danger of an empty test tube is 1. And every time when DZY pours a chemical, if there are already one or more chemicals in the test tube that can react with it, the danger of the test tube will be multiplied by 2. Otherwise the danger remains as it is.Find the maximum possible danger after pouring all the chemicals one by one in optimal order.","def dfs (a, vis, mr):
    mr[0]+=1
    vis[a]=1
    for g in range (0,len(r[a])):
        if (vis[r[a][g]]==1):
            continue
        dfs(r[a][g], vis, mr)
        
x=input("""").split(' ')
nodes=int(x[0])
paths=int(x[1])
r=[]
for g in range (3000):
    r.append([])
vis=[0]*3000
for g in range (paths):
    m=input("""").split(' ')
    rrr=int(m[0])
    rr=int(m[1])
    r[rrr].append(rr)
    r[rr].append(rrr)
ans=1
for g in range (1,nodes+1):
    mr=[0]
    if (vis[g]==1):
        continue
    l=dfs(g, vis,mr)
    ans*=pow(2,mr[0]-1)
print(ans)","['dsu', 'dfs and similar', 'greedy']"
"You are given integer $$$n$$$. You have to arrange numbers from $$$1$$$ to $$$2n$$$, using each of them exactly once, on the circle, so that the following condition would be satisfied:For every $$$n$$$ consecutive numbers on the circle write their sum on the blackboard. Then any two of written on the blackboard $$$2n$$$ numbers differ not more than by $$$1$$$.For example, choose $$$n = 3$$$. On the left you can see an example of a valid arrangement: $$$1 + 4 + 5 = 10$$$, $$$4 + 5 + 2 = 11$$$, $$$5 + 2 + 3 = 10$$$, $$$2 + 3 + 6 = 11$$$, $$$3 + 6 + 1 = 10$$$, $$$6 + 1 + 4 = 11$$$, any two numbers differ by at most $$$1$$$. On the right you can see an invalid arrangement: for example, $$$5 + 1 + 6 = 12$$$, and $$$3 + 2 + 4 = 9$$$, $$$9$$$ and $$$12$$$ differ more than by $$$1$$$.","n=int(input())
n*=n%2
a=2*n*[0]
for i in range(2*n):a[i//2+(i^i//2)%2*n]=i+1
print('YNEOS'[n<1::2],*a)","['constructive algorithms', 'math']"
"You have m = n·k wooden staves. The i-th stave has length ai. You have to assemble n barrels consisting of k staves each, you can use any k staves to construct a barrel. Each stave must belong to exactly one barrel.Let volume vj of barrel j be equal to the length of the minimal stave in it.  You want to assemble exactly n barrels with the maximal total sum of volumes. But you have to make them equal enough, so a difference between volumes of any pair of the resulting barrels must not exceed l, i.e. |vx - vy| ≤ l for any 1 ≤ x ≤ n and 1 ≤ y ≤ n.Print maximal total sum of volumes of equal enough barrels or 0 if it's impossible to satisfy the condition above.","def main():
    n, k, l = map(int, input().split())
    a = sorted(map(int, input().split()))

    bound = 1
    while bound < len(a) and a[bound] - a[0] <= l:
        bound += 1

    if bound < n:
        print(0)
        return

    res = 0

    i = 0
    while n > 0:
        res += a[i]
        i = min(i + k, bound - n + 1)
        n -= 1

    print(res)


main()",['greedy']
"The Rebel fleet is on the run. It consists of m ships currently gathered around a single planet. Just a few seconds ago, the vastly more powerful Empire fleet has appeared in the same solar system, and the Rebels will need to escape into hyperspace. In order to spread the fleet, the captain of each ship has independently come up with the coordinate to which that ship will jump. In the obsolete navigation system used by the Rebels, this coordinate is given as the value of an arithmetic expression of the form .To plan the future of the resistance movement, Princess Heidi needs to know, for each ship, how many ships are going to end up at the same coordinate after the jump. You are her only hope!","from collections import Counter
N = int(input())
src = [eval(input()) for i in range(N)]
ctr = Counter(src)
ans = [ctr[a] for a in src]
print(*ans)","['math', 'expression parsing']"
"You are given $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$, such that for each $$$1\le i \le n$$$ holds $$$i-n\le a_i\le i-1$$$.Find some nonempty subset of these integers, whose sum is equal to $$$0$$$. It can be shown that such a subset exists under given constraints. If there are several possible subsets with zero-sum, you can find any of them.","from sys import stdin, stdout

t = input()
inp = stdin.readlines()
out = []

for itr in xrange(t):
    n = int(inp[itr << 1].strip())
    a = map(int, inp[itr << 1 | 1].strip().split())
    
    found = -1
    
    for i in xrange(n):
        if a[i] == 0:
            found = i
            break
        else:
            a[i] = i + 1 - a[i]

    if found != -1:
        out.append(""1"")
        out.append(str(found + 1))
        continue

    vis = [0] * n

    i = 0
    idxlist = []
    start = 0
    while vis[i] == 0:
        vis[i] = 1
        
        i = a[i] - 1
        if vis[i] == 1: start = i

    idxlist.append(str(start + 1))
    
    i = a[start] - 1
    while i != start:
        idxlist.append(str(i + 1))
        i = a[i] - 1
        
    out.append(str(len(idxlist)))
    out.append("" "".join(idxlist))

stdout.write(""\n"".join(out))","['constructive algorithms', 'graphs', 'dfs and similar', 'math']"
"Pashmak's homework is a problem about graphs. Although he always tries to do his homework completely, he can't solve this problem. As you know, he's really weak at graph theory; so try to help him in solving the problem.You are given a weighted directed graph with n vertices and m edges. You need to find a path (perhaps, non-simple) with maximum number of edges, such that the weights of the edges increase along the path. In other words, each edge of the path must have strictly greater weight than the previous edge in the path.Help Pashmak, print the number of edges in the required path.","from sys import stdin
from itertools import repeat, groupby
from operator import itemgetter
def main():
    n, m = map(int, stdin.readline().split())
    d = [[] for _ in xrange(100001)]
    IN = stdin.read().split()
    IN = map(int, IN, repeat(10, len(IN)))
    for i in xrange(0, 3*m, 3):
        d[IN[i+2]].append((IN[i+1], IN[i]))
    dp = [0] * (n + 10)
    for dd in d:
        dd.sort()
        for u, v in [(x, max(dp[y[1]] for y in l)) for x, l in groupby(dd, key=itemgetter(0))]:
            dp[u] = max(dp[u], v + 1)
    print max(dp)
main()","['dp', 'sortings']"
"Fifa and Fafa are sharing a flat. Fifa loves video games and wants to download a new soccer game. Unfortunately, Fafa heavily uses the internet which consumes the quota. Fifa can access the internet through his Wi-Fi access point. This access point can be accessed within a range of r meters (this range can be chosen by Fifa) from its position. Fifa must put the access point inside the flat which has a circular shape of radius R. Fifa wants to minimize the area that is not covered by the access point inside the flat without letting Fafa or anyone outside the flat to get access to the internet.The world is represented as an infinite 2D plane. The flat is centered at (x1, y1) and has radius R and Fafa's laptop is located at (x2, y2), not necessarily inside the flat. Find the position and the radius chosen by Fifa for his access point which minimizes the uncovered area.","R,x1,y1,x2,y2=map(int,input().split())
s=((x1-x2)**2+(y1-y2)**2)**(0.5)
sin=0
cos=1
def dist(x1,x2,y1,y2):
    return ((x1-x2)**2+(y1-y2)**2)**(0.5)
if (s>R):
    print(x1,y1,R)
else:
    r=(s+R)/2
    if s!=0:
        sin=((y2-y1)/s)
        cos=((x2-x1)/s)

    xpos,ypos=x2+r*cos,y2+r*sin
    xneg,yneg=x2-r*cos,y2-r*sin
    dis1=dist(xpos,x1,ypos,y1)
    dis2=dist(xneg,x1,yneg,y1)
    if dis1<dis2:
        print(xpos,ypos,r)
    else:
        print(xneg,yneg,r)",['geometry']
"There are $$$n$$$ children, who study at the school №41. It is well-known that they are good mathematicians. Once at a break, they arranged a challenge for themselves. All children arranged in a row and turned heads either to the left or to the right.Children can do the following: in one second several pairs of neighboring children who are looking at each other can simultaneously turn the head in the opposite direction. For instance, the one who was looking at the right neighbor turns left and vice versa for the second child. Moreover, every second at least one pair of neighboring children performs such action. They are going to finish when there is no pair of neighboring children who are looking at each other. You are given the number $$$n$$$, the initial arrangement of children and the number $$$k$$$. You have to find a way for the children to act if they want to finish the process in exactly $$$k$$$ seconds. More formally, for each of the $$$k$$$ moves, you need to output the numbers of the children who turn left during this move.For instance, for the configuration shown below and $$$k = 2$$$ children can do the following steps:    At the beginning, two pairs make move: $$$(1, 2)$$$ and $$$(3, 4)$$$. After that, we receive the following configuration:    At the second move pair $$$(2, 3)$$$ makes the move. The final configuration is reached. Good job.   It is guaranteed that if the solution exists, it takes not more than $$$n^2$$$ ""headturns"".","from __future__ import division, print_function
def main():
    n, k = map(int, input().split())
    l1 = list(input())
    stages = []
    while 1:
        l2 = []
        temp = []
        i = 0
        while i < n - 1:
            if l1[i] == ""R"" and l1[i+1] == ""L"":
                temp.append(i + 1)
                l2.append(""L"")
                l2.append(""R"")
                i += 2
            else:
                l2.append(l1[i])
                i += 1
        while i < n:
            l2.append(l1[i])
            i += 1
        l1 = l2
        if len(temp) == 0:
            break
        stages.append(temp)
    total_moves = 0
    min_moves = len(stages)
    #print(*stages, sep = ""\n"")
    for x in stages:
        total_moves += len(x)
    if total_moves < k or k < min_moves:
        print(-1)
    else:
        x = len(stages)
        if x == k:
            for i in range(x):
                print(len(stages[i]), end = "" "")
                print(*stages[i])
        else:
            flag = 0
            for i in range(len(stages)):
                for j in range(len(stages[i])):
                    print(1, stages[i][j])
                    k -= 1
                    rows_left = len(stages) - i
                    if j == len(stages[i]) - 1:
                        rows_left -= 1
                    if k  == rows_left:
                        
                        flag = 1
                        row_number = i
                        column_number = j + 1
                        break
                if flag == 1:
                    break
            if flag == 1:
                if column_number != len(stages[row_number]):
                    print(len(stages[row_number][column_number:]), end = "" "")
                    print(*stages[row_number][column_number:])
                row_number += 1
                for i in range(row_number, len(stages)):
                    print(len(stages[i]), end ="" "")
                    print(*stages[i])

            
######## Python 2 and 3 footer by Pajenegod and c1729

# Note because cf runs old PyPy3 version which doesn't have the sped up
# unicode strings, PyPy3 strings will many times be slower than pypy2.
# There is a way to get around this by using binary strings in PyPy3
# but its syntax is different which makes it kind of a mess to use.

# So on cf, use PyPy2 for best string performance.

py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange

import os, sys
from io import IOBase, BytesIO

BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

# Cout implemented in Python
import sys
class ostream:
    def __lshift__(self,a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'

# Read all remaining integers in stdin, type is given by optional argument, this is fast
def readnumbers(zero = 0):
    conv = ord if py2 else lambda x:x
    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0' [0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-' [0]: sign = -1
            elif s[i] != b'\r' [0]:
                A.append(sign*numb)
                numb = zero; sign = 1
            i += 1
    except:pass
    if s and s[-1] >= b'0' [0]:
        A.append(sign*numb)
    return A

if __name__== ""__main__"":
  main()","['greedy', 'graphs', 'constructive algorithms', 'games', 'implementation', 'sortings', 'brute force']"
"Valery is a PE teacher at a school in Berland. Soon the students are going to take a test in long jumps, and Valery has lost his favorite ruler! However, there is no reason for disappointment, as Valery has found another ruler, its length is l centimeters. The ruler already has n marks, with which he can make measurements. We assume that the marks are numbered from 1 to n in the order they appear from the beginning of the ruler to its end. The first point coincides with the beginning of the ruler and represents the origin. The last mark coincides with the end of the ruler, at distance l from the origin. This ruler can be repesented by an increasing sequence a1, a2, ..., an, where ai denotes the distance of the i-th mark from the origin (a1 = 0, an = l).Valery believes that with a ruler he can measure the distance of d centimeters, if there is a pair of integers i and j (1 ≤ i ≤ j ≤ n), such that the distance between the i-th and the j-th mark is exactly equal to d (in other words, aj - ai = d). Under the rules, the girls should be able to jump at least x centimeters, and the boys should be able to jump at least y (x &lt; y) centimeters. To test the children's abilities, Valery needs a ruler to measure each of the distances x and y. Your task is to determine what is the minimum number of additional marks you need to add on the ruler so that they can be used to measure the distances x and y. Valery can add the marks at any integer non-negative distance from the origin not exceeding the length of the ruler.","from collections import defaultdict

class LongJumps():
    def __init__(self, n, l, x, y, a):
        self.n, self.l, self.x, self.y, self.a = n,l,x,y,a

    def get_markers(self):
        st = defaultdict(set)
        req_pts = [self.x,self.y]
        exist_check = defaultdict(bool)
        value_check = defaultdict(bool)
        for v in self.a:
            exist_check[v] = True

        for v in self.a:
            for i in range(len(req_pts)):
                if v - req_pts[i] >= 0:
                    st[v - req_pts[i]].add(i)
                    if exist_check[v - req_pts[i]]:
                        value_check[i] = True
                if v + req_pts[i] <= l:
                    st[v+req_pts[i]].add(i)
                    if exist_check[v + req_pts[i]]:
                        value_check[i] = True

        if value_check[0] and value_check[1]:
            print(0)
            return

        sol_status = 2
        status1_marker = None
        for v in st:
            if len(st[v]) == 2:
                sol_status = 1
                status1_marker = v
            elif len(st[v]) == 1:
                if exist_check[v]:
                    sol_status = 1
                    status1_marker = req_pts[1-st[v].pop()]
        
        if sol_status == 1:
            print(1)
            print(status1_marker)
            return
        else:
            print(2)
            print(x, y)

n, l, x, y = list(map(int,input().strip(' ').split(' ')))
a = list(map(int,input().strip(' ').split(' ')))
lj = LongJumps(n,l,x,y,a)
lj.get_markers()","['binary search', 'implementation', 'greedy']"
"Petya learned a new programming language CALPAS. A program in this language always takes one non-negative integer and returns one non-negative integer as well.In the language, there are only three commands: apply a bitwise operation AND, OR or XOR with a given constant to the current integer. A program can contain an arbitrary sequence of these operations with arbitrary constants from 0 to 1023. When the program is run, all operations are applied (in the given order) to the argument and in the end the result integer is returned.Petya wrote a program in this language, but it turned out to be too long. Write a program in CALPAS that does the same thing as the Petya's program, and consists of no more than 5 lines. Your program should return the same integer as Petya's program for all arguments from 0 to 1023.","import sys, math


def main():
    ops = getops(sys.stdin)

    n1 = 0
    n2 = 1023
    for op in ops:
        n1 = calc(op, n1)
        n2 = calc(op, n2)

    if n2 == 1023 and n1 == 0:
        print(0)
    else:
        and_ = 1023
        or_ = 0
        xor_ = 0
        for i in range(10):
            b1 = n1 % 2
            b2 = n2 % 2
            n1 = n1 // 2
            n2 = n2 // 2
            if b1 == 1 and b2 == 1:
                or_ = or_ | 2**i
            elif b1 == 1 and b2 == 0:
                xor_ = xor_ | 2**i
            elif b1 == 0 and b2 == 0:
                and_ = and_ - 2**i

        print(3)
        print('&', and_)
        print('|', or_)
        print('^', xor_)


def getops(fh):
    n = int(fh.readline())
    ops = []
    for i in range(n):
        opi, numi = fh.readline().split()
        numi = int(numi)
        ops.append((opi, numi))

    return ops


def calc(op, res):
    opi, numi = op
    if opi == '|':
        res = res | numi
    elif opi == '&':
        res = res & numi
    else:
        res = res ^ numi
    return res


if __name__ == ""__main__"":
    main()","['graph matchings', 'constructive algorithms', 'bitmasks']"
"Little penguin Polo has an n × m matrix, consisting of integers. Let's index the matrix rows from 1 to n from top to bottom and let's index the columns from 1 to m from left to right. Let's represent the matrix element on the intersection of row i and column j as aij.In one move the penguin can add or subtract number d from some matrix element. Find the minimum number of moves needed to make all matrix elements equal. If the described plan is impossible to carry out, say so.","##from sys import stdin
##def main():
##    n = int(stdin.readline())
##    a = map(int, stdin.readline().split())
from sys import stdin
def main():
    a,b,c=map(int,stdin.readline().split())
    xxx=[]
    for gg in xrange(a):
        xx=map(int,stdin.readline().split())
        xxx.extend(xx)
    d=a*b
    flag=0
    xxx.sort()
    for hh in xrange(1,d):
        if (((xxx[hh]-xxx[0])%c)!=0):
            flag=1
            break
    if flag==1:
        print ""-1""
    else:
        dd=d/2
        ch1=dd-1
        ch2=dd
        s1=0
        s2=0
        for dd in xrange(0,d):
            s1=s1+abs(xxx[dd]-xxx[ch1])
            s2=s2+abs(xxx[dd]-xxx[ch2])
        if (s1>s2):
            print (s2/c)
        else:
            print (s1/c)
main()","['dp', 'implementation', 'sortings', 'ternary search', 'brute force']"
"Currently Tiny is learning Computational Geometry. When trying to solve a problem called ""The Closest Pair Of Points In The Plane"", he found that a code which gave a wrong time complexity got Accepted instead of Time Limit Exceeded.The problem is the follows. Given n points in the plane, find a pair of points between which the distance is minimized. Distance between (x1, y1) and (x2, y2) is .The pseudo code of the unexpected code is as follows:input nfor i from 1 to n    input the i-th point's coordinates into p[i]sort array p[] by increasing of x coordinate first and increasing of y coordinate secondd=INF        //here INF is a number big enoughtot=0for i from 1 to n    for j from (i+1) to n        ++tot        if (p[j].x-p[i].x&gt;=d) then break    //notice that ""break"" is only to be                                            //out of the loop ""for j""        d=min(d,distance(p[i],p[j]))output dHere, tot can be regarded as the running time of the code. Due to the fact that a computer can only run a limited number of operations per second, tot should not be more than k in order not to get Time Limit Exceeded.You are a great hacker. Would you please help Tiny generate a test data and let the code get Time Limit Exceeded?","n, k = [int(a) for a in input().split()]
if k >= (n*(n-1)//2):
  print(""no solution"")
else:
  for x in range(n):
    print(0, x)","['constructive algorithms', 'implementation']"
"Sagheer is playing a game with his best friend Soliman. He brought a tree with n nodes numbered from 1 to n and rooted at node 1. The i-th node has ai apples. This tree has a special property: the lengths of all paths from the root to any leaf have the same parity (i.e. all paths have even length or all paths have odd length).Sagheer and Soliman will take turns to play. Soliman will make the first move. The player who can't make a move loses.In each move, the current player will pick a single node, take a non-empty subset of apples from it and do one of the following two things:  eat the apples, if the node is a leaf.  move the apples to one of the children, if the node is non-leaf. Before Soliman comes to start playing, Sagheer will make exactly one change to the tree. He will pick two different nodes u and v and swap the apples of u with the apples of v.Can you help Sagheer count the number of ways to make the swap (i.e. to choose u and v) after which he will win the game if both players play optimally? (u, v) and (v, u) are considered to be the same pair.","n= int(input())
a = [int(_) for _ in input().split()]
c = [int(_) for _ in input().split()]
depth = [0] * (n)
for i in range(1,n):
  depth[i] = depth[c[i-1]-1] + 1
MAX = max(depth)
t = 0
store = {}
todo = []
p = 0

for i in range(n):
    if (MAX-depth[i]) % 2 == 0: # odd, useful
        t ^= a[i]
        todo.append(a[i])
    else:
        store[a[i]]  = store.get(a[i],0) + 1
        p += 1

ans = 0
for i in todo:
    ans += store.get(i^t,0)

if t == 0:
    ans += (p*(p-1)//2) + (n-p)*(n-p-1)//2

print(ans)","['trees', 'games']"
"This is an interactive problem.Anton and Harris are playing a game to decide which of them is the king of problemsetting.There are three piles of stones, initially containing $$$a$$$, $$$b$$$, and $$$c$$$ stones, where $$$a$$$, $$$b$$$, and $$$c$$$ are distinct positive integers. On each turn of the game, the following sequence of events takes place:  The first player chooses a positive integer $$$y$$$ and provides it to the second player.  The second player adds $$$y$$$ stones to one of the piles, with the condition that he cannot choose the same pile in two consecutive turns. The second player loses if, at any point, two of the piles contain the same number of stones. The first player loses if $$$1000$$$ turns have passed without the second player losing.Feeling confident in his skills, Anton decided to let Harris choose whether he wants to go first or second. Help Harris defeat Anton and become the king of problemsetting!","l = list(map(int, input().split()))
def play(x):
    global s
    res = int(input(str(x)+'\n'))
    if res == 0: exit(0)
    l[res-1] += x
    s = sorted(l)
BIG = 10**11
print(""First"")
play(BIG)
play(s[2]*2-s[1]-s[0])
play(s[1]-s[0])","['math', 'constructive algorithms', 'games', 'interactive']"
"You are given an array of $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$.You will perform $$$q$$$ operations. In the $$$i$$$-th operation, you have a symbol $$$s_i$$$ which is either ""&lt;"" or ""&gt;"" and a number $$$x_i$$$.You make a new array $$$b$$$ such that $$$b_j = -a_j$$$ if $$$a_j s_i x_i$$$ and $$$b_j = a_j$$$ otherwise (i.e. if $$$s_i$$$ is '&gt;', then all $$$a_j &gt; x_i$$$ will be flipped). After doing all these replacements, $$$a$$$ is set to be $$$b$$$.You want to know what your final array looks like after all operations.","import sys
N, Q = map(int, input().split())
A = list(map(int, input().split()))
Sign = [0]*(3+10**5)
SX = [tuple(sys.stdin.readline().split()) for _ in range(Q)]
mini = 3 + 10**5
Sign = [0]*(3+10**5)
keep = 1
for (s, x) in SX[::-1]:
    x = int(x)
    ax = abs(x) + int((s == '>') ^ (x < 0))
    sin = 1 if s == '<' else -1
    if mini > ax:
        t = sin*keep
        for i in range(mini-1, ax-1, -1):
            Sign[i] = t
        mini = ax
    keep *= (2*(s == '>') - 1) * (2*(0 < x) - 1)
Ans = [None]*N
for i, a in enumerate(A):
    s = Sign[abs(a)]
    if s == 0:
        s = (2*(a > 0) - 1)*keep
    Ans[i] = s*abs(a)
print(*Ans)","['data structures', 'implementation', 'bitmasks', 'divide and conquer']"
"You are at the top left cell $$$(1, 1)$$$ of an $$$n \times m$$$ labyrinth. Your goal is to get to the bottom right cell $$$(n, m)$$$. You can only move right or down, one cell per step. Moving right from a cell $$$(x, y)$$$ takes you to the cell $$$(x, y + 1)$$$, while moving down takes you to the cell $$$(x + 1, y)$$$.Some cells of the labyrinth contain rocks. When you move to a cell with rock, the rock is pushed to the next cell in the direction you're moving. If the next cell contains a rock, it gets pushed further, and so on.The labyrinth is surrounded by impenetrable walls, thus any move that would put you or any rock outside of the labyrinth is illegal.Count the number of different legal paths you can take from the start to the goal modulo $$$10^9 + 7$$$. Two paths are considered different if there is at least one cell that is visited in one path, but not visited in the other.","import sys
range = xrange
input = raw_input
MOD = 10**9 + 7

inp = sys.stdin.read().split(); ii = 0

n = int(inp[ii]); ii += 1
m = int(inp[ii]); ii += 1

matrix = []
for _ in range(n):
    matrix.append([+(c=='R') for c in inp[ii]]); ii += 1

xrook = [list(row) for row in matrix]
for y in range(n):
    for x in reversed(range(m - 1)):
        xrook[y][x] += xrook[y][x + 1]

yrook = [list(row) for row in matrix]
for y in reversed(range(n - 1)):
    for x in range(m):
        yrook[y][x] += yrook[y + 1][x]

xways = [[0]*m for _ in range(n)]
yways = [[0]*m for _ in range(n)]

for x in range(m):
    if xrook[-1][x] == 0:
        xways[-1][x] = 1
        yways[-1][x] = 1

sy = xways[-1][1:]
ystones = matrix[-1][:-1]
for x in range(m - 1):
    if ystones[x]:
        sy[x] = 0

for y in reversed(range(n - 1)):
    sx = 0
    xstones = 0
    for x in reversed(range(m)):
        sx = (sx + yways[y + 1][x]) % MOD
        xstones += matrix[y][x]
        if matrix[y][x]:
            sx = (sx - yways[y + 1][m - xstones]) % MOD
        xways[y][x] = sx

        if x < m - 1:
            sy[x] = (sy[x] + xways[y][x + 1]) % MOD
            ystones[x] += matrix[y][x]
            if matrix[y][x]:
                sy[x] = (sy[x] - xways[n - ystones[x]][x + 1]) % MOD
            yways[y][x] = sy[x]
        else:
            yways[y][x] = +(yrook[y][x] == 0)

print xways[0][0] % MOD","['dp', 'binary search']"
"You are given two strings $$$s$$$ and $$$t$$$ both of length $$$2$$$ and both consisting only of characters 'a', 'b' and 'c'.Possible examples of strings $$$s$$$ and $$$t$$$: ""ab"", ""ca"", ""bb"".You have to find a string $$$res$$$ consisting of $$$3n$$$ characters, $$$n$$$ characters should be 'a', $$$n$$$ characters should be 'b' and $$$n$$$ characters should be 'c' and $$$s$$$ and $$$t$$$ should not occur in $$$res$$$ as substrings.A substring of a string is a contiguous subsequence of that string. So, the strings ""ab"", ""ac"" and ""cc"" are substrings of the string ""abacc"", but the strings ""bc"", ""aa"" and ""cb"" are not substrings of the string ""abacc"".If there are multiple answers, you can print any of them.","from itertools import permutations
n = int(input())

a = input()
b = input()

print(""YES"")
alpha = ['a', 'b', 'c']
doublealpha = alpha * 2
ax = list(permutations(alpha))
ay = ax + list(permutations(doublealpha))

for x in ay:
    hoh = ''.join(x + (x[0],))
    if n == 1:
        hoh = hoh[:-1]
    if not (a in hoh or b in hoh):
        print((''.join(x) * n)[:3 * n])
        exit()

if a[0] == b[0]:
    print(a[1] * n + b[1] * n + a[0] * n)
else:
    print(a[1] * n + a[0] * n + b[0] * n)","['constructive algorithms', 'brute force']"
"To become the king of Codeforces, Kuroni has to solve the following problem.He is given $$$n$$$ numbers $$$a_1, a_2, \dots, a_n$$$. Help Kuroni to calculate $$$\prod_{1\le i&lt;j\le n} |a_i - a_j|$$$. As result can be very big, output it modulo $$$m$$$.If you are not familiar with short notation, $$$\prod_{1\le i&lt;j\le n} |a_i - a_j|$$$ is equal to $$$|a_1 - a_2|\cdot|a_1 - a_3|\cdot$$$ $$$\dots$$$ $$$\cdot|a_1 - a_n|\cdot|a_2 - a_3|\cdot|a_2 - a_4|\cdot$$$ $$$\dots$$$ $$$\cdot|a_2 - a_n| \cdot$$$ $$$\dots$$$ $$$\cdot |a_{n-1} - a_n|$$$. In other words, this is the product of $$$|a_i - a_j|$$$ for all $$$1\le i &lt; j \le n$$$.","from collections import Counter, defaultdict, deque
import bisect
from sys import stdin, stdout
from itertools import repeat
import math

# sys.stdin = open('input')

def inp():
    return map(int, raw_input().split())

def inst():
    return raw_input().strip()

def main():
        n, m = inp()
        da = inp()
        if n>2100:
            print 0
            return
        ans = 1
        for i in range(n):
            for j in range(i+1, n):
                # print da[i],da[j]
                ans *= abs(da[i]-da[j])
                ans %= m
        print ans










main()","['combinatorics', 'number theory', 'brute force', 'math']"
"Haiku is a genre of Japanese traditional poetry.A haiku poem consists of 17 syllables split into three phrases, containing 5, 7 and 5 syllables correspondingly (the first phrase should contain exactly 5 syllables, the second phrase should contain exactly 7 syllables, and the third phrase should contain exactly 5 syllables). A haiku masterpiece contains a description of a moment in those three phrases. Every word is important in a small poem, which is why haiku are rich with symbols. Each word has a special meaning, a special role. The main principle of haiku is to say much using a few words.To simplify the matter, in the given problem we will consider that the number of syllable in the phrase is equal to the number of vowel letters there. Only the following letters are regarded as vowel letters: ""a"", ""e"", ""i"", ""o"" and ""u"".Three phases from a certain poem are given. Determine whether it is haiku or not.","phr1, phr2, phr3 = raw_input(), raw_input(), raw_input()
if sum([phr1.count(k) for k in ""aeiou""]) == 5 and sum([phr2.count(k) for k in ""aeiou""]) == 7 and sum([phr3.count(k) for k in ""aeiou""]) == 5:
    print ""YES""
else:
    print ""NO""","['implementation', 'strings']"
"Madeline has an array $$$a$$$ of $$$n$$$ integers. A pair $$$(u, v)$$$ of integers forms an inversion in $$$a$$$ if:  $$$1 \le u &lt; v \le n$$$.  $$$a_u &gt; a_v$$$. Madeline recently found a magical paper, which allows her to write two indices $$$u$$$ and $$$v$$$ and swap the values $$$a_u$$$ and $$$a_v$$$. Being bored, she decided to write a list of pairs $$$(u_i, v_i)$$$ with the following conditions:  all the pairs in the list are distinct and form an inversion in $$$a$$$.  all the pairs that form an inversion in $$$a$$$ are in the list.  Starting from the given array, if you swap the values at indices $$$u_1$$$ and $$$v_1$$$, then the values at indices $$$u_2$$$ and $$$v_2$$$ and so on, then after all pairs are processed, the array $$$a$$$ will be sorted in non-decreasing order. Construct such a list or determine that no such list exists. If there are multiple possible answers, you may find any of them.","input()
a=list(map(int,input().split()))
b=sorted((i,-a[j],-j)for j in range(len(a))for i in range(j)if a[i]>a[j])
print(len(b))
for i,j,k in b:print(i+1,-k+1)","['constructive algorithms', 'sortings', 'greedy']"
"Vasya has n days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this n days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the i-th day there are four options:  on this day the gym is closed and the contest is not carried out;  on this day the gym is closed and the contest is carried out;  on this day the gym is open and the contest is not carried out;  on this day the gym is open and the contest is carried out. On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","n = int(input())
a = [int(i) for i in input().split()]
action = 0
rest = 0
for i in range(n):
    if a[i] == 0:
        rest += 1
        action = 0
    elif a[i] == 1:
        if action != 1:
            action = 1
        else:
            rest += 1
            action = 0
    elif a[i] == 2:
        if action != 2:
            action = 2
        else:
            rest += 1
            action = 0
    else:
        if action == 1:
            action = 2
        elif action == 2:
            action = 1
        else:
            j = i + 1
            while j < n and a[j] == 3:
                j += 1
            #print(j, i, ((j - i) % 2) + a[j])
            if j != n:
                if ((j - i) % 2) + a[j] == 2:
                    action = 2
                else:
                    action = 1
print(rest)",['dp']
"You are given a rooted tree with vertices numerated from $$$1$$$ to $$$n$$$. A tree is a connected graph without cycles. A rooted tree has a special vertex named root.Ancestors of the vertex $$$i$$$ are all vertices on the path from the root to the vertex $$$i$$$, except the vertex $$$i$$$ itself. The parent of the vertex $$$i$$$ is the nearest to the vertex $$$i$$$ ancestor of $$$i$$$. Each vertex is a child of its parent. In the given tree the parent of the vertex $$$i$$$ is the vertex $$$p_i$$$. For the root, the value $$$p_i$$$ is $$$-1$$$.    An example of a tree with $$$n=8$$$, the root is vertex $$$5$$$. The parent of the vertex $$$2$$$ is vertex $$$3$$$, the parent of the vertex $$$1$$$ is vertex $$$5$$$. The ancestors of the vertex $$$6$$$ are vertices $$$4$$$ and $$$5$$$, the ancestors of the vertex $$$7$$$ are vertices $$$8$$$, $$$3$$$ and $$$5$$$ You noticed that some vertices do not respect others. In particular, if $$$c_i = 1$$$, then the vertex $$$i$$$ does not respect any of its ancestors, and if $$$c_i = 0$$$, it respects all of them.You decided to delete vertices from the tree one by one. On each step you select such a non-root vertex that it does not respect its parent and none of its children respects it. If there are several such vertices, you select the one with the smallest number. When you delete this vertex $$$v$$$, all children of $$$v$$$ become connected with the parent of $$$v$$$.    An example of deletion of the vertex $$$7$$$. Once there are no vertices matching the criteria for deletion, you stop the process. Print the order in which you will delete the vertices. Note that this order is unique.","from heapq import *

n = int(input())
pred = [[] for i in range(n + 1)]
g = [[] for i in range(n + 1)]
for i in range(1, n + 1):
    p, c = map(int, input().split())
    pred[i] = [p, c]
    if p != -1:
        g[p].append([i, c])
heap = []
for i in range(1, n + 1):
    if pred[i][1] == 1:
        ok = True
        for x in g[i]:
            if x[1] == 0:
                ok = False
                break
        if ok:
            heappush(heap, i)
res = []
while heap:
    v = heappop(heap)
    res.append(v)
if not res:
    print(-1)
else:
    print(' '.join(map(str, res)))","['dfs and similar', 'trees']"
"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.","R = lambda : map(int, input().split())

n,s=R()
m = max([sum(R()) for _ in range(n)])
print(max(m,s))","['implementation', 'math']"
"Bizon the Champion isn't just attentive, he also is very hardworking.Bizon the Champion decided to paint his old fence his favorite color, orange. The fence is represented as n vertical planks, put in a row. Adjacent planks have no gap between them. The planks are numbered from the left to the right starting from one, the i-th plank has the width of 1 meter and the height of ai meters.Bizon the Champion bought a brush in the shop, the brush's width is 1 meter. He can make vertical and horizontal strokes with the brush. During a stroke the brush's full surface must touch the fence at all the time (see the samples for the better understanding). What minimum number of strokes should Bizon the Champion do to fully paint the fence? Note that you are allowed to paint the same area of the fence multiple times.","from sys import stdin
import sys
g   = lambda : stdin.readline().strip()
gl  = lambda : g().split()
gil = lambda : [int(var) for var in gl()]
gfl = lambda : [float(var) for var in gl()]
gcl = lambda : list(g())
gbs = lambda : [int(var) for var in g()]
mod = int(1e9)+7
inf = float(""inf"")

from sys import setrecursionlimit
import threading

def main():
	n, = gil()
	a = gil()

	def fun(a):
		ans = 0
		n = len(a)
		off = min(a) 
		for i in range(n):
			a[i] -= off
		ans += off
		# print(a, off)
		buff = []
		while a :
			if a[-1]:
				buff.append(a.pop())
			else:
				a.pop()
				if buff : ans += fun(buff)
				buff = []

		if buff : ans += fun(buff)

		return min(ans, n)

	print(fun(a))


setrecursionlimit(10000)
threading.stack_size(10**8)
t = threading.Thread(target=main)
t.start()
t.join()","['dp', 'divide and conquer', 'greedy']"
The next lecture in a high school requires two topics to be discussed. The $$$i$$$-th topic is interesting by $$$a_i$$$ units for the teacher and by $$$b_i$$$ units for the students.The pair of topics $$$i$$$ and $$$j$$$ ($$$i &lt; j$$$) is called good if $$$a_i + a_j &gt; b_i + b_j$$$ (i.e. it is more interesting for the teacher).Your task is to find the number of good pairs of topics.,"import bisect

n=int(input())
l1 = list(map(int, input().split(' ')))
l2 = list(map(int, input().split(' ')))

diffs = []
for i in range(n):
    diffs.append(l1[i]-l2[i])

diffs = sorted(diffs)

ans=0
for i in range(n):
    if diffs[i]>0:
        ans += i-bisect.bisect_left(diffs, -diffs[i]+1)


print(ans)","['data structures', 'two pointers', 'binary search', 'sortings']"
"Valera is a little boy. Yesterday he got a huge Math hometask at school, so Valera didn't have enough time to properly learn the English alphabet for his English lesson. Unfortunately, the English teacher decided to have a test on alphabet today. At the test Valera got a square piece of squared paper. The length of the side equals n squares (n is an odd number) and each unit square contains some small letter of the English alphabet.Valera needs to know if the letters written on the square piece of paper form letter ""X"". Valera's teacher thinks that the letters on the piece of paper form an ""X"", if:  on both diagonals of the square paper all letters are the same;  all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals. Help Valera, write the program that completes the described task for him.","# -*- coding:utf-8 -*-
import sys
#n_list = map(int, raw_input().split(' '))


def some_func():
    """"""
    """"""
    n =input()
    n_list = []
    for i in range(n):
        n_list.append(raw_input())

    count1 = 0
    count2 = 0
    for i in range(n):
        count1+=n_list[i].count(n_list[0][0])
        count2+=n_list[i].count(n_list[0][1])
    flag = 1
    for i in range(n):
        for j in range(n):
            if i==j  and n_list[i][j] != n_list[0][0]:
                flag = 0
                break
            if i+j == n-1 and  n_list[i][j] !=n_list[0][0]:
                flag = 0
                break
    if flag and count1 == 2*n-1 and count2 == n*n-2*n+1:
        print ""YES""
    else:
        print ""NO""





if __name__ == '__main__':
    some_func()",['implementation']
"DZY loves Physics, and he enjoys calculating density.Almost everything has density, even a graph. We define the density of a non-directed graph (nodes and edges of the graph have some values) as follows:  where v is the sum of the values of the nodes, e is the sum of the values of the edges.Once DZY got a graph G, now he wants to find a connected induced subgraph G' of the graph, such that the density of G' is as large as possible.An induced subgraph G'(V', E') of a graph G(V, E) is a graph that satisfies:  ;  edge  if and only if , and edge ;  the value of an edge in G' is the same as the value of the corresponding edge in G, so as the value of a node. Help DZY to find the induced subgraph with maximum density. Note that the induced subgraph you choose must be connected.","R = lambda:map(int, input().split())
ans = 0
n, m = R()
F = list(R())
for i in range(m):
	a, b, x = R()
	ans = max(ans, (F[a - 1]+ F[b - 1]) / x)
print(ans)","['greedy', 'math']"
"Let's define logical OR as an operation on two logical values (i. e. values that belong to the set {0, 1}) that is equal to 1 if either or both of the logical values is set to 1, otherwise it is 0. We can define logical OR of three or more logical values in the same manner: where  is equal to 1 if some ai = 1, otherwise it is equal to 0.Nam has a matrix A consisting of m rows and n columns. The rows are numbered from 1 to m, columns are numbered from 1 to n. Element at row i (1 ≤ i ≤ m) and column j (1 ≤ j ≤ n) is denoted as Aij. All elements of A are either 0 or 1. From matrix A, Nam creates another matrix B of the same size using formula:.(Bij is OR of all elements in row i and column j of matrix A)Nam gives you matrix B and challenges you to guess matrix A. Although Nam is smart, he could probably make a mistake while calculating matrix B, since size of A can be large.","m,n = map(int,raw_input().split())
B = [map(int,raw_input().split()) for _ in range(m)]
A = [[1]*n for _ in range(m)]

for r in range(m):
    for c in range(n):
        if B[r][c] == 0:
            for cc in range(n): A[r][cc] = 0
            for rr in range(m): A[rr][c] = 0

fail = False
for r in range(m):
    for c in range(n):
        if B[r][c] == 1:
            if 1 not in A[r] and 1 not in [A[rr][c] for rr in range(m)]:
                fail = True
                break
    if fail: break

if fail: print ""NO""
else:
    print ""YES""
    for line in A:
        print "" "".join(map(str,line))","['implementation', 'hashing', 'greedy']"
"The History of Magic is perhaps the most boring subject in the Hogwarts school of Witchcraft and Wizardry. Harry Potter is usually asleep during history lessons, and his magical quill writes the lectures for him. Professor Binns, the history of magic teacher, lectures in such a boring and monotonous voice, that he has a soporific effect even on the quill. That's why the quill often makes mistakes, especially in dates.So, at the end of the semester Professor Binns decided to collect the students' parchments with notes and check them. Ron Weasley is in a panic: Harry's notes may contain errors, but at least he has some notes, whereas Ron does not have any. Ronald also has been sleeping during the lectures and his quill had been eaten by his rat Scabbers. Hermione Granger refused to give Ron her notes, because, in her opinion, everyone should learn on their own. Therefore, Ron has no choice but to copy Harry's notes.Due to the quill's errors Harry's dates are absolutely confused: the years of goblin rebellions and other important events for the wizarding world do not follow in order, and sometimes even dates from the future occur. Now Ron wants to change some of the digits while he copies the notes so that the dates were in the chronological (i.e. non-decreasing) order and so that the notes did not have any dates strictly later than 2011, or strictly before than 1000. To make the resulting sequence as close as possible to the one dictated by Professor Binns, Ron will change no more than one digit in each date into other digit. Help him do it.","import sys

n = int(input())
d = []
for i in range(n):
    d.append(input())
ans = []

bad = 'No solution'
low = 1000
for date in d:
    lowest = 100500
    for i in range(10):
        for j in range(i == 0, 5):
            changed = date[:j] + str(i) + date[j + 1:]
            if lowest > int(changed) >= low:
                lowest = int(changed)
    if lowest > 2011:
        print(bad)
        sys.exit(0)
    ans.append(str(lowest))
    low = lowest

print('\n'.join(ans))","['implementation', 'greedy', 'brute force']"
"Chilly Willy loves playing with numbers. He only knows prime numbers that are digits yet. These numbers are 2, 3, 5 and 7. But Willy grew rather bored of such numbers, so he came up with a few games that were connected with them.Chilly Willy wants to find the minimum number of length n, such that it is simultaneously divisible by all numbers Willy already knows (2, 3, 5 and 7). Help him with that.A number's length is the number of digits in its decimal representation without leading zeros.","n = input()
if n < 3:
		print '-1'
elif n == 3:
		print 210
else :
		x = pow(10, n - 1, 210)
		y = 210 - x
		print '1' + '0' * (n - 4) + ""%03d"" %y","['number theory', 'math']"
Vanya got bored and he painted n distinct points on the plane. After that he connected all the points pairwise and saw that as a result many triangles were formed with vertices in the painted points. He asks you to count the number of the formed triangles with the non-zero area.,"from fractions import gcd

N = input()
points = [map(int, raw_input().split()) for _ in xrange(N)]

ans = N * (N-1) * (N-2) // 6
lines = {}
for i in xrange(N-1):
    for j in range(i+1, N):
        x1, y1 = points[i]
        x2, y2 = points[j]
        g = gcd(x1-x2, y1-y2)
        dx, dy = (x1-x2)//g, (y1-y2)//g
        a, b, c = dy, dx, dx * y1 - dy * x1
        lines[(a, b, c)] = lines.get((a, b, c), 0) + 1

for val in lines.values():
    if val != 1:
        n = (1 + int(pow(1+8*val, 0.5))) // 2
        ans -= n * (n-1) * (n-2) // 6

print(ans)","['geometry', 'combinatorics', 'math', 'sortings', 'data structures', 'brute force']"
"New Year is coming, and Jaehyun decided to read many books during 2015, unlike this year. He has n books numbered by integers from 1 to n. The weight of the i-th (1 ≤ i ≤ n) book is wi.As Jaehyun's house is not large enough to have a bookshelf, he keeps the n books by stacking them vertically. When he wants to read a certain book x, he follows the steps described below.  He lifts all the books above book x.  He pushes book x out of the stack.  He puts down the lifted books without changing their order.  After reading book x, he puts book x on the top of the stack.  He decided to read books for m days. In the j-th (1 ≤ j ≤ m) day, he will read the book that is numbered with integer bj (1 ≤ bj ≤ n). To read the book, he has to use the process described in the paragraph above. It is possible that he decides to re-read the same book several times.After making this plan, he realized that the total weight of books he should lift during m days would be too heavy. So, he decided to change the order of the stacked books before the New Year comes, and minimize the total weight. You may assume that books can be stacked in any possible order. Note that book that he is going to read on certain step isn't considered as lifted on that step. Can you help him?","import copy
n,m=map(int,raw_input().split())
w=map(int,raw_input().split())
b=map(int,raw_input().split())
initial=[]
for i in range(len(b)):
    b[i]-=1
for bb in b:
    if bb not in initial:
        initial.append(bb)
ans=0
for bb in b:
    num=initial.index(bb)
    for i in range(num):
        ans+=w[initial[i]]
    tmp=copy.copy(initial[num])
    del initial[num]
    initial.insert(0,tmp)
print ans","['constructive algorithms', 'implementation', 'greedy', 'math']"
"In a galaxy far, far away Lesha the student has just got to know that he has an exam in two days. As always, he hasn't attended any single class during the previous year, so he decided to spend the remaining time wisely.Lesha knows that today he can study for at most $$$a$$$ hours, and he will have $$$b$$$ hours to study tomorrow. Note that it is possible that on his planet there are more hours in a day than on Earth. Lesha knows that the quality of his knowledge will only depend on the number of lecture notes he will read. He has access to an infinite number of notes that are enumerated with positive integers, but he knows that he can read the first note in one hour, the second note in two hours and so on. In other words, Lesha can read the note with number $$$k$$$ in $$$k$$$ hours. Lesha can read the notes in arbitrary order, however, he can't start reading a note in the first day and finish its reading in the second day.Thus, the student has to fully read several lecture notes today, spending at most $$$a$$$ hours in total, and fully read several lecture notes tomorrow, spending at most $$$b$$$ hours in total. What is the maximum number of notes Lesha can read in the remaining time? Which notes should he read in the first day, and which — in the second?","def check():
    a, b = [int(s) for s in input().split()]
    a1 = min(a, b)
    b1 = max(a, b)
    sum0=0
    i=0
    while(sum0<=a1):
        i += 1
        sum0+=i

    ax=i-1
    sum1=sum0-i
    r=a1-sum1
    if(r==0):
        sum0 = 0
        i = i - 1

        while (sum0 <= b1):
            i += 1
            sum0 += i
        sum2 = sum0 - i
        ay = i - 1
        if(a<=b):
            print(ax)
            for i in range(1,ax+1):
                print(i,end="" "")
                if(i==ax):
                    print()
            if (ax == 0): print( )
            print(ay-ax)
            for j in range(ax+1,ay+1):
                print(j,end="" "")
                if(j==ay): print()
            if (ay - ax == 0): print( )
        else:
            print(ay - ax)
            for j in range(ax + 1, ay + 1):
                print(j, end="" "")
                if(j==ay):
                    print()
            if (ay - ax == 0): print( )
            print(ax)
            for i in range(1,ax+1):
                print(i, end="" "")
                if(i==ax):print()

            if (ax == 0): print( )



    else:
        c=ax+1-r
        sum0=0
        i=ax+1
        b1=b1-c
        while(sum0<=b1):

            i += 1
            sum0+=i
        ay = i - 1
        if a<=b :
            print(ax)
            for i in range(1,ax+2):
                if i==c:
                    continue
                print(i,end="" "")
                if(i==ax+1):print()
            if(ax==0): print( )

            print(ay-ax)
            print(c,end="" "")
            for j in range(ax+2,ay+1):
                print(j,end="" "")
                if(j==ay): print()
            if(ay-ax==0): print( )
        else:

            print(ay - ax)
            print(c, end="" "")
            for j in range(ax + 2, ay + 1):
                print(j, end="" "")
                if(j==ay):print()
            if(ay-ax==0): print( )
            print(ax)

            for i in range(1, ax + 2):
                if i == c:
                    continue
                print(i, end="" "")
                if(i==ax+1): print()
            if(ax==0): print( )


check()","['greedy', 'math']"
"During the last Sereja's Codesecrof round the server crashed many times, so the round was decided to be made unrated for some participants. Let's assume that n people took part in the contest. Let's assume that the participant who got the first place has rating a1, the second place participant has rating a2, ..., the n-th place participant has rating an. Then changing the rating on the Codesecrof site is calculated by the formula .After the round was over, the Codesecrof management published the participants' results table. They decided that if for a participant di &lt; k, then the round can be considered unrated for him. But imagine the management's surprise when they found out that the participants' rating table is dynamic. In other words, when some participant is removed from the rating, he is removed from the results' table and the rating is recalculated according to the new table. And of course, all applications for exclusion from the rating are considered in view of the current table.We know that among all the applications for exclusion from the rating the first application to consider is from the participant with the best rank (the rank with the minimum number), for who di &lt; k. We also know that the applications for exclusion from rating were submitted by all participants.Now Sereja wonders, what is the number of participants to be excluded from the contest rating, and the numbers of the participants in the original table in the order of their exclusion from the rating. Pay attention to the analysis of the first test case for a better understanding of the statement.","n, k = map(int, input().split())
c, v = 0, []
for i, a in enumerate(map(int, input().split())):
    j = i + 1 - len(v)
    d = c - (j - 1) * (n - j) * a
    if d < k:
        v.append(i + 1)
        n -= 1
    else:
        c += a * (j - 1)
print('\n'.join(map(str, v)))",['implementation']
"Vasya has recently found out what a digital root of a number is and he decided to share his knowledge with you.Let's assume that S(n) is the sum of digits of number n, for example, S(4098) = 4 + 0 + 9 + 8 = 21. Then the digital root of number n equals to:   dr(n) = S(n), if S(n) &lt; 10;  dr(n) = dr( S(n) ), if S(n) ≥ 10. For example, dr(4098)  =  dr(21)  =  3.Vasya is afraid of large numbers, so the numbers he works with are at most 101000. For all such numbers, he has proved that dr(n)  =  S( S( S( S(n) ) ) ) (n ≤ 101000).Now Vasya wants to quickly find numbers with the given digital root. The problem is, he hasn't learned how to do that and he asked you to help him. You task is, given numbers k and d, find the number consisting of exactly k digits (the leading zeroes are not allowed), with digital root equal to d, or else state that such number does not exist.","class CodeforcesTask355ASolution:
    def __init__(self):
        self.result = ''
        self.k_d = []

    def read_input(self):
        self.k_d = [int(x) for x in input().split("" "")]

    def process_task(self):
        if self.k_d[0] != 1 and self.k_d[1] == 0:
            self.result = ""No solution""
        else:
            self.result = str(self.k_d[1]) + ""0"" * (self.k_d[0] - 1)

    def get_result(self):
        return self.result


if __name__ == ""__main__"":
    Solution = CodeforcesTask355ASolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())","['constructive algorithms', 'implementation']"
"Inna and Dima bought a table of size n × m in the shop. Each cell of the table contains a single letter: ""D"", ""I"", ""M"", ""A"".Inna loves Dima, so she wants to go through his name as many times as possible as she moves through the table. For that, Inna acts as follows:  initially, Inna chooses some cell of the table where letter ""D"" is written;  then Inna can move to some side-adjacent table cell that contains letter ""I""; then from this cell she can go to one of the side-adjacent table cells that contains the written letter ""M""; then she can go to a side-adjacent cell that contains letter ""A"". Then Inna assumes that she has gone through her sweetheart's name;  Inna's next move can be going to one of the side-adjacent table cells that contains letter ""D"" and then walk on through name DIMA in the similar manner. Inna never skips a letter. So, from the letter ""D"" she always goes to the letter ""I"", from the letter ""I"" she always goes the to letter ""M"", from the letter ""M"" she always goes to the letter ""A"", and from the letter ""A"" she always goes to the letter ""D"". Depending on the choice of the initial table cell, Inna can go through name DIMA either an infinite number of times or some positive finite number of times or she can't go through his name once. Help Inna find out what maximum number of times she can go through name DIMA.","import sys
n, m = map(int, input().split())
m += 1
d = {'I': 0, 'M': 1, 'A': 2, 'D': 3, '\n': -7}
t = list(map(d.get, sys.stdin.read())) + [-7] * m
p = [[] for q in t]
c = [0] * len(t)
for a in range(n * m):
    for b in (a - m, a + m, a - 1, a + 1):
        if abs(t[b] - t[a] + 1) == 2:
            p[a].append(b)
            c[b] += 1
s = [i for i, q in enumerate(c) if not q]
while s:
    a = s.pop()
    for b in p[a]:
        t[b] = max(t[b], t[a] + 1)
        c[b] -= 1
        if c[b] == 0: s.append(b)
k = max(t) - 2 >> 2
print('Poor Inna!' if any(c) else k if k > 0 else 'Poor Dima!')","['dp', 'implementation', 'dfs and similar', 'graphs']"
You are given an undirected unweighted connected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.Your task is to find any spanning tree of this graph such that the maximum degree over all vertices is maximum possible. Recall that the degree of a vertex is the number of edges incident to it.,"n, m = tuple(map(int, input().split()))
data = []
for i in range(n+1):
    data.append(set())
maxn = 0
for i in range(m):
    a, b = tuple(map(int, input().split()))
    data[a].add(b)
    data[b].add(a)
    if len(data[a]) > maxn:
        maxn = len(data[a])
        maxv = a
    if len(data[b]) > maxn:
        maxn = len(data[b])
        maxv = b

found = {maxv}

current = set()



for c in data[maxv]:
    found.add(c)
    current.add(c)
    print(str(maxv) + ' ' + str(c))

while len(found) < n:
    newc = set()
    for el in current:
        for chi in data[el]:
            if chi not in found:
                found.add(chi)
                newc.add(chi)
                print(str(el), str(chi))
    current = newc",['graphs']
"A TV show called ""Guess a number!"" is gathering popularity. The whole Berland, the old and the young, are watching the show.The rules are simple. The host thinks of an integer y and the participants guess it by asking questions to the host. There are four types of acceptable questions:  Is it true that y is strictly larger than number x?  Is it true that y is strictly smaller than number x?  Is it true that y is larger than or equal to number x?  Is it true that y is smaller than or equal to number x? On each question the host answers truthfully, ""yes"" or ""no"".Given the sequence of questions and answers, find any integer value of y that meets the criteria of all answers. If there isn't such value, print ""Impossible"".","n = int(input())
l = -2000000000
r = 2000000000
for _ in range(n):
    s = input().split()
    x = int(s[1])
    if s[0] == "">"" and s[2] == ""Y"":
        l = max(l, x + 1)
    elif s[0] == "">"" and s[2] == ""N"":
        r = min(r, x)
    elif s[0] == "">="" and s[2] == ""Y"":
        l = max(l, x)
    elif s[0] == "">="" and s[2] == ""N"":
        r = min(r, x - 1)
    elif s[0] == ""<"" and s[2] == ""Y"":
        r = min(r, x - 1)
    elif s[0] == ""<"" and s[2] == ""N"":
        l = max(l, x)
    elif s[0] == ""<="" and s[2] == ""Y"":
        r = min(r, x)
    elif s[0] == ""<="" and s[2] == ""N"":
        l = max(l, x + 1)
    # print(l, r)
if r - l >=0:
    print(l)
else:
    print(""Impossible"")","['two pointers', 'implementation', 'greedy']"
"Vasya and Petya take part in a Codeforces round. The round lasts for two hours and contains five problems.For this round the dynamic problem scoring is used. If you were lucky not to participate in any Codeforces round with dynamic problem scoring, here is what it means. The maximum point value of the problem depends on the ratio of the number of participants who solved the problem to the total number of round participants. Everyone who made at least one submission is considered to be participating in the round.Pay attention to the range bounds. For example, if 40 people are taking part in the round, and 10 of them solve a particular problem, then the solvers fraction is equal to 1 / 4, and the problem's maximum point value is equal to 1500.If the problem's maximum point value is equal to x, then for each whole minute passed from the beginning of the contest to the moment of the participant's correct submission, the participant loses x / 250 points. For example, if the problem's maximum point value is 2000, and the participant submits a correct solution to it 40 minutes into the round, this participant will be awarded with 2000·(1 - 40 / 250) = 1680 points for this problem.There are n participants in the round, including Vasya and Petya. For each participant and each problem, the number of minutes which passed between the beginning of the contest and the submission of this participant to this problem is known. It's also possible that this participant made no submissions to this problem.With two seconds until the end of the round, all participants' submissions have passed pretests, and not a single hack attempt has been made. Vasya believes that no more submissions or hack attempts will be made in the remaining two seconds, and every submission will pass the system testing.Unfortunately, Vasya is a cheater. He has registered 109 + 7 new accounts for the round. Now Vasya can submit any of his solutions from these new accounts in order to change the maximum point values of the problems. Vasya can also submit any wrong solutions to any problems. Note that Vasya can not submit correct solutions to the problems he hasn't solved.Vasya seeks to score strictly more points than Petya in the current round. Vasya has already prepared the scripts which allow to obfuscate his solutions and submit them into the system from any of the new accounts in just fractions of seconds. However, Vasya doesn't want to make his cheating too obvious, so he wants to achieve his goal while making submissions from the smallest possible number of new accounts.Find the smallest number of new accounts Vasya needs in order to beat Petya (provided that Vasya's assumptions are correct), or report that Vasya can't achieve his goal.","#!/usr/bin/python3
# Copyright (C) 2017 Sayutin Dmitry.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 3
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

def get_price(a, b):
    # a / b
    if 2 * a > b:
        return 500
    if 4 * a > b:
        return 1000
    if 8 * a > b:
        return 1500
    if 16 * a > b:
        return 2000
    if 32 * a > b:
        return 2500
    return 3000

def main():
    n = int(input())
    we = list(map(int, input().split()))
    fr = list(map(int, input().split()))

    ratio = [0, 0, 0, 0, 0]
    for i in range(5):
        if we[i] != -1:
            ratio[i] += 1
        else:
            we[i] = 250
        
        if fr[i] != -1:
            ratio[i] += 1
        else:
            fr[i] = 250

    for part in range(n - 2):
        lst = list(map(int, input().split()))
        for i in range(5):
            if lst[i] != -1:
                ratio[i] += 1

                
    for mi in range(0, 4500):
        s1 = 0
        s2 = 0

        for i in range(5):
            if we[i] < fr[i]:
               pr = get_price(ratio[i] + 0, n + mi)
               
               s1 += pr - pr * we[i] // 250
               s2 += pr - pr * fr[i] // 250
            elif we[i] > fr[i] and we[i] != 250: # submit as much OK as we can
                pr = get_price(ratio[i] + mi, n + mi)

                s1 += pr - pr * we[i] // 250
                s2 += pr - pr * fr[i] // 250
            elif we[i] > fr[i] and we[i] == 250:
                pr = get_price(ratio[i] + 0, n + mi)

                s1 += pr - pr * we[i] // 250
                s2 += pr - pr * fr[i] // 250
                
        if s1 > s2:
            print(mi)
            return

    lo = 4450
    hi = 10 ** 9 + 8 # OK

    while hi - lo > 1:
        mi = lo + (hi - lo) // 2
        
        s1 = 0
        s2 = 0

        for i in range(5):
            if we[i] < fr[i]:
               pr = get_price(ratio[i] + 0, n + mi)
               
               s1 += pr - pr * we[i] // 250
               s2 += pr - pr * fr[i] // 250
            elif we[i] > fr[i] and we[i] != 250: # submit as much OK as we can
                pr = get_price(ratio[i] + mi, n + mi)

                s1 += pr - pr * we[i] // 250
                s2 += pr - pr * fr[i] // 250
            elif we[i] > fr[i] and we[i] == 250:
                pr = get_price(ratio[i] + 0, n + mi)

                s1 += pr - pr * we[i] // 250
                s2 += pr - pr * fr[i] // 250
                
        if s1 > s2:
            hi = mi
        else:
            lo = mi
    
    print(-1 if hi == 10 ** 9 + 8 else hi)
main()","['greedy', 'brute force']"
"Little Petya has a birthday soon. Due this wonderful event, Petya's friends decided to give him sweets. The total number of Petya's friends equals to n.Let us remind you the definition of the greatest common divisor: GCD(a1, ..., ak) = d, where d represents such a maximal positive number that each ai (1 ≤ i ≤ k) is evenly divisible by d. At that, we assume that all ai's are greater than zero.Knowing that Petya is keen on programming, his friends has agreed beforehand that the 1-st friend gives a1 sweets, the 2-nd one gives a2 sweets, ..., the n-th one gives an sweets. At the same time, for any i and j (1 ≤ i, j ≤ n) they want the GCD(ai, aj) not to be equal to 1. However, they also want the following condition to be satisfied: GCD(a1, a2, ..., an) = 1. One more: all the ai should be distinct.Help the friends to choose the suitable numbers a1, ..., an.","def isprime(a):
    if(a==1 or a==0 or a==2 ):
        return 0
    x=2
    while x*x<=a:
        if a%x==0:
            return 0
        x+=1
    return 1

primes=[]
m=1
cnt=0
for x in range(1,300):
    if(isprime(x)):
         primes.append(x)
n=int(input())
if(n==2):
    print(-1)
else :
   for i in range(0,n-1):
      print(2*primes[i])
      m=m*primes[i]
   print(m)","['constructive algorithms', 'number theory', 'math']"
"There was a big bank robbery in Tablecity. In order to catch the thief, the President called none other than Albert – Tablecity’s Chief of Police. Albert does not know where the thief is located, but he does know how he moves.Tablecity can be represented as 1000 × 2 grid, where every cell represents one district. Each district has its own unique name “(X, Y)”, where X and Y are the coordinates of the district in the grid. The thief’s movement is as Every hour the thief will leave the district (X, Y) he is currently hiding in, and move to one of the districts: (X - 1, Y), (X + 1, Y), (X - 1, Y - 1), (X - 1, Y + 1), (X + 1, Y - 1), (X + 1, Y + 1) as long as it exists in Tablecity. Below is an example of thief’s possible movements if he is located in district (7,1):Albert has enough people so that every hour he can pick any two districts in Tablecity and fully investigate them, making sure that if the thief is located in one of them, he will get caught. Albert promised the President that the thief will be caught in no more than 2015 hours and needs your help in order to achieve that.","print(1998)
[print(i, 1, i, 2) for k in '12' for i in range(1, 1000)]","['constructive algorithms', 'implementation']"
"This is an easier version of the problem. In this version, $$$n \le 2000$$$.There are $$$n$$$ distinct points in three-dimensional space numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th point has coordinates $$$(x_i, y_i, z_i)$$$. The number of points $$$n$$$ is even.You'd like to remove all $$$n$$$ points using a sequence of $$$\frac{n}{2}$$$ snaps. In one snap, you can remove any two points $$$a$$$ and $$$b$$$ that have not been removed yet and form a perfectly balanced pair. A pair of points $$$a$$$ and $$$b$$$ is perfectly balanced if no other point $$$c$$$ (that has not been removed yet) lies within the axis-aligned minimum bounding box of points $$$a$$$ and $$$b$$$.Formally, point $$$c$$$ lies within the axis-aligned minimum bounding box of points $$$a$$$ and $$$b$$$ if and only if $$$\min(x_a, x_b) \le x_c \le \max(x_a, x_b)$$$, $$$\min(y_a, y_b) \le y_c \le \max(y_a, y_b)$$$, and $$$\min(z_a, z_b) \le z_c \le \max(z_a, z_b)$$$. Note that the bounding box might be degenerate. Find a way to remove all points in $$$\frac{n}{2}$$$ snaps.","#from bisect import bisect_left as bl                #c++ lowerbound bl(array,element)
#from bisect import bisect_right as br               #c++ upperbound br(array,element)
#from __future__ import print_function, division    #while using python2

import math
def modinv(n,p):
    return pow(n,p-2,p)

def dist(x1, y1, z1, x2, y2, z2):
    # return math.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)
    return abs(x2 - x1) + abs(y2 - y1) + abs(z2 - z1)

def main():
    #sys.stdin = open('input.txt', 'r')
    #sys.stdout = open('output.txt', 'w')

    n = int(input())
    points = []
    for i in range(n):
        pts = [int(x) for x in input().split()]
        pts.append(i)
        points.append(pts)
    
    answers = []
    visited = [0] * (n+1)
    # print(points)
    for i in range(n):
        if visited[i] == 1:
            continue
        min_d = 1e18
        min_j = -1
        x1, y1, z1, temp = points[i]
        for j in range(i+1,n):
            if visited[j] == 1:
                continue
            x2, y2, z2, temp2 = points[j]
            if dist(x1, y1, z1, x2, y2, z2) < min_d:
                min_d = dist(x1, y1, z1, x2, y2, z2)
                min_j = j
        
        if min_j != -1:
            answers.append([points[i][-1], points[min_j][-1]])
            visited[points[i][-1]] = 1
            visited[points[min_j][-1]] = 1
    # print(answers)
    for p in answers:
        print(p[0] + 1, p[1] + 1)

#------------------ Python 2 and 3 footer by Pajenegod and c1729-----------------------------------------
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange

import os, sys
from io import IOBase, BytesIO

BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0
    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s
    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

if __name__ == '__main__':
   main()","['constructive algorithms', 'geometry', 'greedy']"
Petya recieved a gift of a string s with length up to 105 characters for his birthday. He took two more empty strings t and u and decided to play a game. This game has two possible moves:  Extract the first character of s and append t with this character.  Extract the last character of t and append u with this character. Petya wants to get strings s and t empty and string u lexicographically minimal.You should write a program that will help Petya win the game.,"#! /bin/python

s = input()
resultBase = """"
resultRest = """"
best = len(s) - 1
mini = [0] * len(s)

for i in range(len(s) - 1, -1, -1):
    mini[i] = best
    if s[best] >= s[i]:
        best = i

for i in range(len(s)):
    resultRest += s[i]
    while len(resultRest) > 0 and resultRest[-1] <= s[mini[i]]:
        resultBase += resultRest[-1]
        resultRest = resultRest[:-1]
    
    #  print(resultRest[-1] if len(resultRest) > 0 else '-', s[mini[i]])
    #  print(resultRest)
    #  print(resultBase)
    #  print()
    

print(resultBase + resultRest[::-1])","['data structures', 'greedy', 'strings']"
"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1 ≤ i &lt; j ≤ n, 1 ≤ k ≤ m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names ""CBDAD"" and ""AABRD"" and swap their prefixes with the length of 3, the result will be names ""AABAD"" and ""CBDRD"".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109 + 7).","n, m = map(int, raw_input().split())

nomes = []

for i in xrange(n):
	entrada = raw_input()
	nomes.append(entrada)

total = 1

for k in xrange(m):
	
	parcial = [nomes[0][k]]
	for l in xrange(1, n):
		
		if(nomes[l][k] not in parcial):
			parcial.append(nomes[l][k])
			
	total *= len(parcial)
	
print total % 1000000007",['combinatorics']
"There are $$$n$$$ houses in a row. They are numbered from $$$1$$$ to $$$n$$$ in order from left to right. Initially you are in the house $$$1$$$.You have to perform $$$k$$$ moves to other house. In one move you go from your current house to some other house. You can't stay where you are (i.e., in each move the new house differs from the current house). If you go from the house $$$x$$$ to the house $$$y$$$, the total distance you walked increases by $$$|x-y|$$$ units of distance, where $$$|a|$$$ is the absolute value of $$$a$$$. It is possible to visit the same house multiple times (but you can't visit the same house in sequence).Your goal is to walk exactly $$$s$$$ units of distance in total.If it is impossible, print ""NO"". Otherwise print ""YES"" and any of the ways to do that. Remember that you should do exactly $$$k$$$ moves.","n,k,s=map(int,input().split())
l=s%k*[s//k+1]+(k-s%k)*[s//k]
for i in range(1,k,2):l[i]=-l[i]
l[0]+=1
for i in range(1,k):l[i]+=l[i-1]
b=k<=s<=k*(n-1)
print(('NO','YES')[b])
if b:print(*l)","['constructive algorithms', 'greedy']"
"You are given a sequence of integers of length $$$n$$$ and integer number $$$k$$$. You should print any integer number $$$x$$$ in the range of $$$[1; 10^9]$$$ (i.e. $$$1 \le x \le 10^9$$$) such that exactly $$$k$$$ elements of given sequence are less than or equal to $$$x$$$.Note that the sequence can contain equal elements.If there is no such $$$x$$$, print ""-1"" (without quotes).","n, k = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
if k == 0:
    if a[0] == 1:
        print(-1)
    else:
        print(1)
elif k == n:
    print(10 ** 9)
elif k < n:
    if a[k] > a[k-1]:
        print(a[k]-1)
    else:
        print(-1)",['sortings']
"New Year is coming and you are excited to know how many minutes remain before the New Year. You know that currently the clock shows $$$h$$$ hours and $$$m$$$ minutes, where $$$0 \le hh &lt; 24$$$ and $$$0 \le mm &lt; 60$$$. We use 24-hour time format!Your task is to find the number of minutes before the New Year. You know that New Year comes when the clock shows $$$0$$$ hours and $$$0$$$ minutes.You have to answer $$$t$$$ independent test cases.","testCase = int(input())
Output = 0
while testCase != 0:
   H, Min = map(int, input().split())
   if 0 <= H < 24 and 0 <= Min < 60:
       Output = ((23-H) * 60) + (60 - Min)
       print(Output)
   testCase = testCase - 1",['math']
"You are playing a game where your character should overcome different obstacles. The current problem is to come down from a cliff. The cliff has height $$$h$$$, and there is a moving platform on each height $$$x$$$ from $$$1$$$ to $$$h$$$.Each platform is either hidden inside the cliff or moved out. At first, there are $$$n$$$ moved out platforms on heights $$$p_1, p_2, \dots, p_n$$$. The platform on height $$$h$$$ is moved out (and the character is initially standing there).If you character is standing on some moved out platform on height $$$x$$$, then he can pull a special lever, which switches the state of two platforms: on height $$$x$$$ and $$$x - 1$$$. In other words, the platform you are currently standing on will hide in the cliff and the platform one unit below will change it state: it will hide if it was moved out or move out if it was hidden. In the second case, you will safely land on it. Note that this is the only way to move from one platform to another.Your character is quite fragile, so it can safely fall from the height no more than $$$2$$$. In other words falling from the platform $$$x$$$ to platform $$$x - 2$$$ is okay, but falling from $$$x$$$ to $$$x - 3$$$ (or lower) is certain death. Sometimes it's not possible to come down from the cliff, but you can always buy (for donate currency) several magic crystals. Each magic crystal can be used to change the state of any single platform (except platform on height $$$h$$$, which is unaffected by the crystals). After being used, the crystal disappears.What is the minimum number of magic crystal you need to buy to safely land on the $$$0$$$ ground level?","#!/usr/bin/env pypy
from __future__ import division, print_function
from collections import defaultdict, Counter, deque
from future_builtins import ascii, filter, hex, map, oct, zip
from random import randint
from itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement
from __builtin__ import xrange as range
from math import ceil
from _continuation import continulet
from cStringIO import StringIO
from io import IOBase
import __pypy__
from bisect import bisect, insort, bisect_left, bisect_right
import sys
import os
import re
sys.setrecursionlimit(9999)
inf = float('inf')
mod = int(1e9) + 7
mod_ = 998244353
N = 5001

'''
Check for special cases (n=1)
One wrong submission = 10 mins penalty!
do smth instead of nothing and stay organized
'''


def main():
	for _ in range(int(input())):
		h, n = map(int, input().split())
		arr = list(set(map(int, input().split())))
		if n == 1:
			print(0)
			continue
		cnt = 0
		ind = 0
		while arr[ind] > 2:
			gap = arr[ind]-arr[ind+1]
			# if gap == 2:
			# 	ind += 1
			# else:
			arr[ind] = arr[ind+1]+1
			if ind+2 > n-1:
				if arr[ind] > 2 and arr[ind+1]+1 > 2:
					cnt += 1
				break
			if arr[ind]-arr[ind+2] > 2:
				arr[ind+1] = arr[ind+2]+1
				cnt += 1
				ind += 1
			else:
				ind += 2
			if ind+1 > n-1 or arr[ind] <= 2:
				break
		# print(arr)
		print(cnt)




BUFSIZE = 8192
class FastI(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = StringIO()
		self.newlines = 0
 
	def read(self):
		while True:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			if not b:
				break
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines = 0
		return self.buffer.read()
 
	def readline(self):
		while self.newlines == 0:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			self.newlines = b.count(""\n"") + (not b)
			ptr = self._buffer.tell()
			self._buffer.seek(0, 2), self._buffer.write(
				b), self._buffer.seek(ptr)
		self.newlines -= 1
		return self._buffer.readline()
class FastO(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = __pypy__.builders.StringBuilder()
		self.write = lambda s: self._buffer.append(s)
 
	def flush(self):
		os.write(self._fd, self._buffer.build())
		self._buffer = __pypy__.builders.StringBuilder()
def print(*args, **kwargs):
	sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
	at_start = True
	for x in args:
		if not at_start:
			file.write(sep)
		file.write(str(x))
		at_start = False
	file.write(kwargs.pop(""end"", ""\n""))
	if kwargs.pop(""flush"", False):
		file.flush()
def gcd(x, y):
	while y:
		x, y = y, x % y
	return x
sys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
	def bootstrap(cont):
		call, arg = cont.switch()
		while True:
			call, arg = cont.switch(to=continulet(
				lambda _, f, args: f(*args), call, arg))
	cont = continulet(bootstrap)
	cont.switch()
	main()","['dp', 'greedy', 'math']"
"You are given an array $$$A$$$, consisting of $$$n$$$ positive integers $$$a_1, a_2, \dots, a_n$$$, and an array $$$B$$$, consisting of $$$m$$$ positive integers $$$b_1, b_2, \dots, b_m$$$. Choose some element $$$a$$$ of $$$A$$$ and some element $$$b$$$ of $$$B$$$ such that $$$a+b$$$ doesn't belong to $$$A$$$ and doesn't belong to $$$B$$$. For example, if $$$A = [2, 1, 7]$$$ and $$$B = [1, 3, 4]$$$, we can choose $$$1$$$ from $$$A$$$ and $$$4$$$ from $$$B$$$, as number $$$5 = 1 + 4$$$ doesn't belong to $$$A$$$ and doesn't belong to $$$B$$$. However, we can't choose $$$2$$$ from $$$A$$$ and $$$1$$$ from $$$B$$$, as $$$3 = 2 + 1$$$ belongs to $$$B$$$.It can be shown that such a pair exists. If there are multiple answers, print any.Choose and print any such two numbers.","n = int(input())
a = [int(num) for num in input().split()]
m = int(input())
b = [int(num) for num in input().split()]
print(max(a), max(b))","['sortings', 'math']"
The capital of Berland looks like a rectangle of size n × m of the square blocks of same size.Fire!It is known that k + 1 blocks got caught on fire (k + 1 ≤ n·m). Those blocks are centers of ignition. Moreover positions of k of these centers are known and one of these stays unknown. All k + 1 positions are distinct.The fire goes the following way: during the zero minute of fire only these k + 1 centers of ignition are burning. Every next minute the fire goes to all neighbouring blocks to the one which is burning. You can consider blocks to burn for so long that this time exceeds the time taken in the problem. The neighbouring blocks are those that touch the current block by a side or by a corner.Berland Fire Deparment wants to estimate the minimal time it takes the fire to lighten up the whole city. Remember that the positions of k blocks (centers of ignition) are known and (k + 1)-th can be positioned in any other block.Help Berland Fire Department to estimate the minimal time it takes the fire to lighten up the whole city.,"import sys
from collections import Counter
from operator import itemgetter
from heapq import heappop, heappush

n, m, k = map(int, input().split())
points = [list(map(int, line.split())) for line in sys.stdin]
pts_sorted_x = sorted(points)
pts_sorted_y = sorted(points, key=itemgetter(1, 0))
inf = 10**9+1
OK = (inf, inf)


def solve2(imos, t):
    acc, cur = 0, 0

    for k in sorted(imos.keys()):
        if t < k:
            break
        if acc <= 0 and cur+1 < k or acc + imos[k] <= 0:
            acc = 0
            break
        acc += imos[k]

    return acc <= 0


def add_imos(imos, x, y):
    imos[x] += y
    if imos[x] == 0:
        del imos[x]


def solve(t, px=-1, py=-1):
    set_x = {1, n}
    set_y = {1, m}

    for x, y in points:
        set_x.update((max(1, x-t), max(1, x-t-1), min(n, x+t), min(n, x+t+1)))
        set_y.update((max(1, y-t), max(1, y-t-1), min(m, y+t), min(m, y+t+1)))

    ans_x = ans_y = inf
    pi, imos, hq = 0, Counter(), []
    if px != -1:
        imos[py] += 1
        imos[py+t*2+1] -= 1

    for cx in sorted(set_x):
        while hq and hq[0][0] < cx:
            add_imos(imos, hq[0][1], -1)
            add_imos(imos, hq[0][2], +1)
            heappop(hq)
        while pi < k and pts_sorted_x[pi][0]-t <= cx <= pts_sorted_x[pi][0]+t:
            x, y = pts_sorted_x[pi]
            add_imos(imos, max(1, y-t), 1)
            add_imos(imos, y+t+1, -1)
            heappush(hq, (x+t, max(1, y-t), y+t+1))
            pi += 1

        if solve2(imos, m):
            ans_x = cx
            break

    pi = 0
    imos.clear()
    hq.clear()
    if px != -1:
        imos[px] += 1
        imos[px+t*2+1] -= 1

    for cy in sorted(set_y):
        while hq and hq[0][0] < cy:
            add_imos(imos, hq[0][1], -1)
            add_imos(imos, hq[0][2], +1)
            heappop(hq)
        while pi < k and pts_sorted_y[pi][1]-t <= cy <= pts_sorted_y[pi][1]+t:
            x, y = pts_sorted_y[pi]
            add_imos(imos, max(1, x-t), 1)
            add_imos(imos, x+t+1, -1)
            heappush(hq, (y+t, max(1, x-t), x+t+1))
            pi += 1

        if solve2(imos, n):
            ans_y = cy
            break

    return ans_x, ans_y


ok, ng = 10**9+1, -1
while abs(ok - ng) > 1:
    mid = (ok + ng) >> 1
    p = solve(mid)
    if p == OK:
        ok = mid
        continue

    if solve(mid, p[0], p[1]) == OK:
        ok = mid
    else:
        ng = mid

print(ok)","['data structures', 'binary search']"
"A game field is a strip of 1 × n square cells. In some cells there are Packmen, in some cells — asterisks, other cells are empty.Packman can move to neighboring cell in 1 time unit. If there is an asterisk in the target cell then Packman eats it. Packman doesn't spend any time to eat an asterisk.In the initial moment of time all Packmen begin to move. Each Packman can change direction of its move unlimited number of times, but it is not allowed to go beyond the boundaries of the game field. Packmen do not interfere with the movement of other packmen; in one cell there can be any number of packmen moving in any directions.Your task is to determine minimum possible time after which Packmen can eat all the asterisks.","from math import ceil
def solve(field,size,answer):
    left = 0
    star_pos = -1
    rstar_pos = -1
    p_pos = -1
    distance = 0
    cost = 0
    for i in range(size):
        #print(p_pos,star_pos)
        if field[i] == ""*"":
            if star_pos != -1:
                if p_pos != -1:
                    if star_pos < p_pos and i > p_pos: #*...P.*.* star on both side of P
                        if min(2*(p_pos-star_pos)+(i-p_pos),2*(i-p_pos)+\
                               (p_pos-star_pos)) > answer:
                            star_pos = i
                            p_pos = -1
                            continue
                    elif i-p_pos > answer: #..P..*P when star on the right of P
                        star_pos = i
                        p_pos = -1
                        continue
            else:
                if p_pos != -1:
                    if i - p_pos > answer:
                        p_pos = -1
                star_pos = i
            
        if field[i] == ""P"":
            if p_pos != -1:
                distance = 0
                star_pos = -1
            if star_pos != -1:
                #print(""star_pos:"",star_pos,""current pos"",i)
                if i - star_pos > answer:
                    return -1
                    
            p_pos = i
        
    if p_pos == -1:
        return -1
    return 1
        
                    
                

if __name__ == ""__main__"":
    size = int(raw_input().strip())
    field = raw_input().strip()
    first = 1
    last = 2*size
    best = last + 1
    while first <= last:
        mid = int(first + (last - first)/2) 
        if solve(field,size,mid) == -1:
            first = mid + 1
        else:
            best = mid
            last = mid - 1
    print(best)","['dp', 'binary search']"
"You are given two integers $$$x$$$ and $$$y$$$ (it is guaranteed that $$$x &gt; y$$$). You may choose any prime integer $$$p$$$ and subtract it any number of times from $$$x$$$. Is it possible to make $$$x$$$ equal to $$$y$$$?Recall that a prime number is a positive integer that has exactly two positive divisors: $$$1$$$ and this integer itself. The sequence of prime numbers starts with $$$2$$$, $$$3$$$, $$$5$$$, $$$7$$$, $$$11$$$.Your program should solve $$$t$$$ independent test cases.","t=int(input())
for i in range(t):
    s=input()
    s=s.split( )
    for e in s:
        s[s.index(e)]=int(e)
    if s[0]-s[1]<2:
        print('NO')
    elif ((s[0]-s[1])%2)==0 :
        print('YES')
    elif (s[0]-s[1]-3) >=0:
        print('YES')
    else:
        print('NO')","['number theory', 'math']"
"Medicine faculty of Berland State University has just finished their admission campaign. As usual, about $$$80\%$$$ of applicants are girls and majority of them are going to live in the university dormitory for the next $$$4$$$ (hopefully) years.The dormitory consists of $$$n$$$ rooms and a single mouse! Girls decided to set mouse traps in some rooms to get rid of the horrible monster. Setting a trap in room number $$$i$$$ costs $$$c_i$$$ burles. Rooms are numbered from $$$1$$$ to $$$n$$$.Mouse doesn't sit in place all the time, it constantly runs. If it is in room $$$i$$$ in second $$$t$$$ then it will run to room $$$a_i$$$ in second $$$t + 1$$$ without visiting any other rooms inbetween ($$$i = a_i$$$ means that mouse won't leave room $$$i$$$). It's second $$$0$$$ in the start. If the mouse is in some room with a mouse trap in it, then the mouse get caught into this trap.That would have been so easy if the girls actually knew where the mouse at. Unfortunately, that's not the case, mouse can be in any room from $$$1$$$ to $$$n$$$ at second $$$0$$$.What it the minimal total amount of burles girls can spend to set the traps in order to guarantee that the mouse will eventually be caught no matter the room it started from?","n = int(input())
C = [int(s) for s in input().split("" "")]
A = [int(s)-1 for s in input().split("" "")]
al = [False for i in range(0, n)]
ans = 0
for v in range(0, n):
    if al[v]:
        continue
    sequence = []
    while not al[v]:
        sequence.append(v)
        al[v] = True
        v = A[v]
    if v in sequence:
        tek = C[v]
        for j in sequence[sequence.index(v)+1:]:
            tek = min(C[j], tek)
        ans += tek
print(ans)","['dfs and similar', 'graphs']"
"There is a street with $$$n$$$ houses in a line, numbered from $$$1$$$ to $$$n$$$. The house $$$i$$$ is initially painted in color $$$c_i$$$. The street is considered beautiful if all houses are painted in the same color. Tom, the painter, is in charge of making the street beautiful. Tom's painting capacity is defined by an integer, let's call it $$$k$$$.On one day, Tom can do the following repainting process that consists of two steps:   He chooses two integers $$$l$$$ and $$$r$$$ such that $$$ 1 \le l \le r \le n $$$ and $$$ r - l + 1 = k $$$.  For each house $$$i$$$ such that $$$l \le i \le r$$$, he can either repaint it with any color he wants, or ignore it and let it keep its current color. Note that in the same day Tom can use different colors to repaint different houses.Tom wants to know the minimum number of days needed to repaint the street so that it becomes beautiful.","""""""
    Author - Satwik Tiwari .
    28th NOV , 2020  - Saturday
""""""

#===============================================================================================
#importing some useful libraries.

from __future__ import division, print_function
from fractions import Fraction
import sys
import os
from io import BytesIO, IOBase
from functools import cmp_to_key

# from itertools import *
from heapq import *
from math import gcd, factorial,floor,ceil,sqrt

from copy import deepcopy
from collections import deque


from bisect import bisect_left as bl
from bisect import bisect_right as br
from bisect import bisect

#==============================================================================================
#fast I/O region
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

# inp = lambda: sys.stdin.readline().rstrip(""\r\n"")

#===============================================================================================
### START ITERATE RECURSION ###
from types import GeneratorType
def iterative(f, stack=[]):
  def wrapped_func(*args, **kwargs):
    if stack: return f(*args, **kwargs)
    to = f(*args, **kwargs)
    while True:
      if type(to) is GeneratorType:
        stack.append(to)
        to = next(to)
        continue
      stack.pop()
      if not stack: break
      to = stack[-1].send(to)
    return to
  return wrapped_func
#### END ITERATE RECURSION ####

#===============================================================================================
#some shortcuts

def inp(): return sys.stdin.readline().rstrip(""\r\n"") #for fast input
def out(var): sys.stdout.write(str(var))  #for fast output, always take string
def lis(): return list(map(int, inp().split()))
def stringlis(): return list(map(str, inp().split()))
def sep(): return map(int, inp().split())
def strsep(): return map(str, inp().split())
# def graph(vertex): return [[] for i in range(0,vertex+1)]
def testcase(t):
    for pp in range(t):
        solve(pp)
def google(p):
    print('Case #'+str(p)+': ',end='')
def lcm(a,b): return (a*b)//gcd(a,b)
def power(x, y, p) :
    y%=(p-1)  #not so sure about this. used when y>p-1. if p is prime.
    res = 1     # Initialize result
    x = x % p  # Update x if it is more , than or equal to p
    if (x == 0) :
        return 0
    while (y > 0) :
        if ((y & 1) == 1) : # If y is odd, multiply, x with result
            res = (res * x) % p

        y = y >> 1      # y = y/2
        x = (x * x) % p
    return res
def ncr(n,r): return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))
def isPrime(n) :
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
inf = pow(10,20)
mod = 10**9+7
#===============================================================================================
# code here ;))


def solve(case):
    n,k = sep()
    a = lis()

    ans = inf

    color = {}
    for i in range(n):
        color[a[i]] = 1

    for col in color:
        cnt = 0
        i = 0
        while(i<n):
            if(a[i] == col):
                i+=1
                continue
            cnt+=1
            i += k

        ans = min(ans,cnt)

    print(ans)





# testcase(1)
testcase(int(inp()))","['greedy', 'brute force']"
"Given a connected undirected graph with $$$n$$$ vertices and an integer $$$k$$$, you have to either:  either find an independent set that has exactly $$$\lceil\frac{k}{2}\rceil$$$ vertices. or find a simple cycle of length at most $$$k$$$. An independent set is a set of vertices such that no two of them are connected by an edge. A simple cycle is a cycle that doesn't contain any vertex twice. I have a proof that for any input you can always solve at least one of these problems, but it's left as an exercise for the reader.","L=[0]*200005
O=[0]*200005
F=[0]*200005
C=[]
czy=0
W=[[] for _ in range(4)]
P=[[] for _ in range(200005)]
ile=0;
def dfs(n,p):
    stos=[]
    stos.append((n,p))
    global czy
    while len(stos)>0:
        n,p=stos[-1]
        stos.pop()
        if O[n]==1:
            continue
        O[n]=1
        if L[n]<=k-1:
            W[L[n]%2].append(n)
        for v in P[n]:
            #print(n,v,czy,L[n],L[v],O[v],p)
            if  O[v]==0:
                L[v]=L[n]+1;
                F[v]=n
                stos.append((v,n))
            elif v!=p and czy==0 and L[n]>L[v] and L[n]-L[v]+1<=k:
               # print(""i am here"",n,v)
                czy=1
                x=n
                while x!=v:
                    C.append(x)
                    x=F[x]
                C.append(v)
n,m,k=map(int,input().split())
for i in range(m):
    a,b=map(int,input().split())
    P[a].append(b)
    P[b].append(a)
dfs(1,0)
if czy:
    print(2)
    print(len(C))
    print("" "".join(map(str,C)))
else:
    print(1)
    A=[]
    if len(W[0])<len(W[1]):
        A=W[1]
    else:
        A=W[0]
    x=k//2
    if k&1:
        x+=1
    s=""""
    for i in range(0,x):
        s+=str(A[i])+"" ""
    print(s)
#threading.Thread(target=main).start()","['greedy', 'graphs', 'constructive algorithms', 'implementation', 'dfs and similar', 'trees']"
"Petr likes to come up with problems about randomly generated data. This time problem is about random permutation. He decided to generate a random permutation this way: he takes identity permutation of numbers from $$$1$$$ to $$$n$$$ and then $$$3n$$$ times takes a random pair of different elements and swaps them. Alex envies Petr and tries to imitate him in all kind of things. Alex has also come up with a problem about random permutation. He generates a random permutation just like Petr but swaps elements $$$7n+1$$$ times instead of $$$3n$$$ times. Because it is more random, OK?!You somehow get a test from one of these problems and now you want to know from which one.","n=int(input())
a=[0]+list(map(int,input().split()))
ans=0
for i in range(1,len(a)):
    if a[i]==-1:
        continue
    j=i
    while a[j]!=-1:
        prev=j
        j=a[j]
        a[prev]=-1
    ans+=1
if n%2==0:
    #n even ans also even even number of swaps required
    #3*n 
    if ans%2==0:
        print(""Petr"")
    else:
        print(""Um_nik"")
else:
    #n us odd ans is even odd number of swaps required
    if ans%2==0:
        print(""Petr"")
    else:
        print(""Um_nik"")","['combinatorics', 'math']"
"You are given set of n points in 5-dimensional space. The points are labeled from 1 to n. No two points coincide.We will call point a bad if there are different points b and c, not equal to a, from the given set such that angle between vectors  and  is acute (i.e. strictly less than ). Otherwise, the point is called good.The angle between vectors  and  in 5-dimensional space is defined as , where  is the scalar product and  is length of .Given the list of points, print the indices of the good points in ascending order.","n = int(input())
p = [tuple(map(int, input().split())) for i in range(n)]

def d(a, b):
    return tuple(x - y for x, y in zip(a, b))

def m(a, b):
    return sum(x * y for x, y in zip(a, b))

good_points = []
for i in range(n):
    good = True

    for j in range(n):
        if j == i:
            continue
        
        ab = d(p[j], p[i])

        for k in range(j + 1, n):
            if k == i:
                continue
            
            ac = d(p[k], p[i])
            
            if m(ab, ac) > 0:
                good = False
                break
        
        if not good:
            break
    
    if good:
        good_points.append(i)

print(len(good_points))
for i in good_points:
    print(i + 1)","['geometry', 'brute force', 'math']"
"Local authorities have heard a lot about combinatorial abilities of Ostap Bender so they decided to ask his help in the question of urbanization. There are n people who plan to move to the cities. The wealth of the i of them is equal to ai. Authorities plan to build two cities, first for n1 people and second for n2 people. Of course, each of n candidates can settle in only one of the cities. Thus, first some subset of candidates of size n1 settle in the first city and then some subset of size n2 is chosen among the remaining candidates and the move to the second city. All other candidates receive an official refuse and go back home.To make the statistic of local region look better in the eyes of their bosses, local authorities decided to pick subsets of candidates in such a way that the sum of arithmetic mean of wealth of people in each of the cities is as large as possible. Arithmetic mean of wealth in one city is the sum of wealth ai among all its residents divided by the number of them (n1 or n2 depending on the city). The division should be done in real numbers without any rounding.Please, help authorities find the optimal way to pick residents for two cities.","i = lambda: map(int, input().split())
n, x, y = i()
a = sorted(i())[::-1]

if x > y:
    x, y = y, x

print(sum(a[:x])/x + sum(a[x:][:y])/y)","['number theory', 'sortings', 'greedy']"
"After learning about polynomial hashing, Heidi decided to learn about shift-xor hashing. In particular, she came across this interesting problem.Given a bitstring $$$y \in \{0,1\}^n$$$ find out the number of different $$$k$$$ ($$$0 \leq k &lt; n$$$) such that there exists $$$x \in \{0,1\}^n$$$ for which $$$y = x \oplus \mbox{shift}^k(x).$$$In the above, $$$\oplus$$$ is the xor operation and $$$\mbox{shift}^k$$$ is the operation of shifting a bitstring cyclically to the right $$$k$$$ times. For example, $$$001 \oplus 111 = 110$$$ and $$$\mbox{shift}^3(00010010111000) = 00000010010111$$$.","import sys
range = xrange

n = int(raw_input())
y = [int(x) for x in raw_input()]
def poss(k):
    x = [0]*n
    for i in range(n-k):
        x[i + k] = x[i] ^ y[i]
    for i in range(n-k,n):
        if x[i] ^ x[i + k - n] != y[i]:
            return 0
    return 1
possible = [0]*(n+1)
i = 1
while i * i < n:
    if n % i == 0:
        possible[i] = poss(i)
        possible[n//i] = poss(n//i)
    i += 1
if i * i == n:
    possible[i] = poss(i)
def gcd(a,b):
    while b:
        a,b = b,a%b
    return a
ans = 0
for k in range(1, n+1):
    ans += possible[gcd(n,k)]
print(ans)","['number theory', 'brute force']"
"Doubly linked list is one of the fundamental data structures. A doubly linked list is a sequence of elements, each containing information about the previous and the next elements of the list. In this problem all lists have linear structure. I.e. each element except the first has exactly one previous element, each element except the last has exactly one next element. The list is not closed in a cycle.In this problem you are given n memory cells forming one or more doubly linked lists. Each cell contains information about element from some list. Memory cells are numbered from 1 to n.For each cell i you are given two values:   li — cell containing previous element for the element in the cell i;  ri — cell containing next element for the element in the cell i. If cell i contains information about the element which has no previous element then li = 0. Similarly, if cell i contains information about the element which has no next element then ri = 0.    Three lists are shown on the picture. For example, for the picture above the values of l and r are the following: l1 = 4, r1 = 7; l2 = 5, r2 = 0; l3 = 0, r3 = 0; l4 = 6, r4 = 1; l5 = 0, r5 = 2; l6 = 0, r6 = 4; l7 = 1, r7 = 0.Your task is to unite all given lists in a single list, joining them to each other in any order. In particular, if the input data already contains a single list, then there is no need to perform any actions. Print the resulting list in the form of values li, ri.Any other action, other than joining the beginning of one list to the end of another, can not be performed.","n = int(input())
C = [0] * (n+1)
def vis(i, label, L, R):
    if C[i] == 0:
        C[i] = label
        if L[i] != 0:
            vis(L[i], label, L, R)
        if R[i] != 0:
            vis(R[i], label, L, R)

L = [0] * (n+1)
R = [0] * (n+1)
label = 1
for i in range(1, n+1):
    l, r = list(map(int, input().split()))
    L[i] = l
    R[i] = r

for i in range(1, n+1):
    if C[i] == 0:
        vis(i, label, L, R)
        label+=1
label-=1
for i in range(1, n+1):
    if label == 1:
        break

    if L[i] != 0 and R[i] != 0:
        continue
    for j in range(1, n+1):
        if i != j:
            if L[i] == 0 and R[j] == 0 and C[i] != C[j]:
                L[i] = j
                R[j] = i
                target = C[j]
                newL = C[i]
                for k in range(1, n+1):
                    if C[k] == target:
                        C[k] = newL
                label-=1
            elif R[i] == 0 and L[j] == 0 and C[i] != C[j]:
                R[i] = j
                L[j] = i
                target = C[j]
                newL = C[i]
                for k in range(1, n+1):
                    if C[k] == target:
                        C[k] = newL
                label-=1

for i in range(1, n+1):
    print(str(L[i]) + "" "" + str(R[i]))",['implementation']
"Given a string s, determine if it contains any palindrome of length exactly 100 as a subsequence. If it has any, print any one of them. If it doesn't have any, print a palindrome that is a subsequence of s and is as long as possible.","def p2(a):
  n = len(a)
  last = [[0] * 26 for _ in range(n)]
  last[0][ord(a[0])-97] = 0
  for i in range(1, n):
    for j in range(26):
      last[i][j] = last[i-1][j]
    last[i][ord(a[i])-97] = i
  dp = [''] * n
  for i in range(n-1, -1, -1):
    for j in range(n-1, i, -1):
      k = last[j][ord(a[i])-97]
      if k>i:
        if (k-i) == 1 and len(dp[j]) < 2:
          dp[j] = a[i]+a[i]
        elif len(dp[j]) < (len(dp[k-1]) + 2):
          dp[j] = a[i]+dp[k-1]+a[i]
          if len(dp[j]) >= 100:
            if len(dp[j]) == 101:
              return dp[j][:50]+dp[j][51:]
            else:
              return dp[j]
    dp[i] = a[i]
  return dp[n-1]

print(p2(raw_input()))","['dp', 'constructive algorithms']"
There are $$$n$$$ cities and $$$m$$$ roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.What is the minimum number of new roads that need to be built to make all the cities reachable from the capital?New roads will also be one-way.,"from collections import defaultdict
import sys
def dfs(u):
    avail[u] = False
    for v in g[u]:
        if avail[v]:
            dfs(v)
    topo.append(u)


sys.setrecursionlimit(6000)
n, m, s = map(int, input().split())
g = [[] for _ in range(n)]
for _ in range(m):
    u, v = map(int, input().split())
    g[u - 1].append(v - 1)

avail, topo = [True] * n, []
for i,a in enumerate(avail):
    if a:
        dfs(i)
avail, res = [True] * n, 0
dfs(s - 1)
for i in reversed(topo):
    if avail[i]:
        res += 1
        dfs(i)
print(res)","['dfs and similar', 'greedy', 'graphs']"
"Recently you've discovered a new shooter. They say it has realistic game mechanics.Your character has a gun with magazine size equal to $$$k$$$ and should exterminate $$$n$$$ waves of monsters. The $$$i$$$-th wave consists of $$$a_i$$$ monsters and happens from the $$$l_i$$$-th moment of time up to the $$$r_i$$$-th moments of time. All $$$a_i$$$ monsters spawn at moment $$$l_i$$$ and you have to exterminate all of them before the moment $$$r_i$$$ ends (you can kill monsters right at moment $$$r_i$$$). For every two consecutive waves, the second wave starts not earlier than the first wave ends (though the second wave can start at the same moment when the first wave ends) — formally, the condition $$$r_i \le l_{i + 1}$$$ holds. Take a look at the notes for the examples to understand the process better.You are confident in yours and your character's skills so you can assume that aiming and shooting are instant and you need exactly one bullet to kill one monster. But reloading takes exactly $$$1$$$ unit of time.One of the realistic mechanics is a mechanic of reloading: when you reload you throw away the old magazine with all remaining bullets in it. That's why constant reloads may cost you excessive amounts of spent bullets.You've taken a liking to this mechanic so now you are wondering: what is the minimum possible number of bullets you need to spend (both used and thrown) to exterminate all waves.Note that you don't throw the remaining bullets away after eradicating all monsters, and you start with a full magazine.","import sys

n, k = list(map(int, sys.stdin.readline().strip().split()))
L = []
R = []
A = []
for i in range (0, n):
    x = list(map(int, sys.stdin.readline().strip().split()))
    L.append(x[0])
    R.append(x[1])
    A.append(x[2])
L.append(R[-1])
i = n-1
x = 0
y = 0
ans = 0
v = True
N = [0 for i in range (0, n)]
while i >= 0:
    if R[i] == L[i+1]:
        x = max(x + A[i] - k * (R[i] - L[i]), 0)
        N[i] = x
    else:
        x = max(A[i] - k * (R[i] - L[i]), 0)
        N[i] = x
    if N[i] > k:
        v = False
    i = i - 1
m = k
N.append(0)
i = 0
while i < n and v == True:
    if m < N[i]:
        ans = ans + m
        m = k
    m = m - A[i]
    ans = ans + A[i]
    while m < 0:
        m = m + k
    i = i + 1
if v == True:
    print(ans)
else:
    print(-1)","['dp', 'greedy']"
"Let's denote a m-free matrix as a binary (that is, consisting of only 1's and 0's) matrix such that every square submatrix of size m × m of this matrix contains at least one zero. Consider the following problem:You are given two integers n and m. You have to construct an m-free square matrix of size n × n such that the number of 1's in this matrix is maximum possible. Print the maximum possible number of 1's in such matrix.You don't have to solve this problem. Instead, you have to construct a few tests for it.You will be given t numbers x1, x2, ..., xt. For every , find two integers ni and mi (ni ≥ mi) such that the answer for the aforementioned problem is exactly xi if we set n = ni and m = mi.","t = int(input())
for k in range(t):
    x = int(input())
    if x == 0:
        print(1, 1)
        continue
    for i in range(1, int(x ** 0.5) + 2):
        if x % i == 0 and (x // i - i) % 2 == 0 and (x // i - (x // i - i) // 2) ** 2 >= x:
            a, b = x // i, i
            y = (a - b) // 2
            n = a - y
            if y == 0:
                continue
            m = n // y
            if n // m != y:
                continue
            print(n, m)            
            break
    else:
        print(-1)","['constructive algorithms', 'binary search', 'brute force']"
"Tomorrow is a difficult day for Polycarp: he has to attend $$$a$$$ lectures and $$$b$$$ practical classes at the university! Since Polycarp is a diligent student, he is going to attend all of them.While preparing for the university, Polycarp wonders whether he can take enough writing implements to write all of the lectures and draw everything he has to during all of the practical classes. Polycarp writes lectures using a pen (he can't use a pencil to write lectures!); he can write down $$$c$$$ lectures using one pen, and after that it runs out of ink. During practical classes Polycarp draws blueprints with a pencil (he can't use a pen to draw blueprints!); one pencil is enough to draw all blueprints during $$$d$$$ practical classes, after which it is unusable.Polycarp's pencilcase can hold no more than $$$k$$$ writing implements, so if Polycarp wants to take $$$x$$$ pens and $$$y$$$ pencils, they will fit in the pencilcase if and only if $$$x + y \le k$$$.Now Polycarp wants to know how many pens and pencils should he take. Help him to determine it, or tell that his pencilcase doesn't have enough room for all the implements he needs tomorrow!Note that you don't have to minimize the number of writing implements (though their total number must not exceed $$$k$$$).","n = int(input())
for i in range(n):
  a, b, c, d, k = map(int, input().strip().split())
  from math import ceil 
  n = ceil(a / c)
  m = ceil(b / d)
  if (n + m <= k):
    print(n, m)
  else:
    print(-1)",['math']
"Today is tuesday, that means there is a dispute in JOHNNY SOLVING team again: they try to understand who is Johnny and who is Solving. That's why guys asked Umnik to help them. Umnik gave guys a connected graph with $$$n$$$ vertices without loops and multiedges, such that a degree of any vertex is at least $$$3$$$, and also he gave a number $$$1 \leq k \leq n$$$. Because Johnny is not too smart, he promised to find a simple path with length at least $$$\frac{n}{k}$$$ in the graph. In reply, Solving promised to find $$$k$$$ simple by vertices cycles with representatives, such that:   Length of each cycle is at least $$$3$$$.  Length of each cycle is not divisible by $$$3$$$.  In each cycle must be a representative - vertex, which belongs only to this cycle among all printed cycles. You need to help guys resolve the dispute, for that you need to find a solution for Johnny: a simple path with length at least $$$\frac{n}{k}$$$ ($$$n$$$ is not necessarily divided by $$$k$$$), or solution for Solving: $$$k$$$ cycles that satisfy all the conditions above. If there is no any solution - print $$$-1$$$.","import sys
range = xrange
input = raw_input

# Will extremly quickly convert s into a list of integers.
# The format of the string is required to be integers (positive or negative)
# separated with a single character with ascii value <'-', so like a whitespace.
# It also handles the string ending with an additional character < '-', like a trailing newline.

s = sys.stdin.read()
inp = []
numb = 0
 
for i in range(len(s)):
    if s[i]>='0':
        numb = 10*numb + ord(s[i])-48
    else:
        inp.append(numb)
        numb = 0
if s[-1]>='0':
    inp.append(numb)

ii = 0
n = inp[ii]
ii+=1
m = inp[ii]
ii+=1
k = inp[ii]
ii+=1

coupl = [[] for _ in range(n)]
for _ in range(m):
    u = inp[ii]-1
    ii += 1
    v = inp[ii]-1
    ii += 1

    coupl[u].append(v)
    coupl[v].append(u)

P = [-1]*n
D = [1]*n
found = [False]*n

cycle_nodes = []

Q = [0]
while Q:
    node = Q.pop()
    if found[node]:
        continue
    found[node] = True
    found_any = False
    for nei in coupl[node]:
        if not found[nei]:
            P[nei] = node
            D[nei] = D[node]+1
            Q.append(nei)
            found_any = True
    if not found_any:
        cycle_nodes.append(node)

i = max(range(n),key=lambda i:D[i])
if k*D[i]>=n:
    print 'PATH'
    print D[i]
    out = []
    while i!=-1:
        out.append(i)
        i = P[i]
    print ' '.join(str(x+1) for x in out)
elif len(cycle_nodes)>=k:
    print 'CYCLES'
    out = []
    for i in cycle_nodes[:k]:
        minD = min(D[nei] for nei in coupl[i] if (D[i] - D[nei] + 1)%3!=0) 
        tmp = []
        if minD == D[i]-1:
            a,b = [nei for nei in coupl[i] if (D[i] - D[nei] + 1)%3==0][:2]
            if D[a]<D[b]:
                a,b = b,a
            tmp.append(i)
            while a!=b:
                tmp.append(a)
                a = P[a]
            tmp.append(a)
        else:
            while D[i]!=minD:
                tmp.append(i)
                i = P[i]
            tmp.append(i)
        out.append(str(len(tmp)))
        out.append(' '.join(str(x+1) for x in tmp))
    print '\n'.join(out)
else:
    print -1","['constructive algorithms', 'graphs', 'dfs and similar', 'math']"
"Molly Hooper has n different kinds of chemicals arranged in a line. Each of the chemicals has an affection value, The i-th of them has affection value ai.Molly wants Sherlock to fall in love with her. She intends to do this by mixing a contiguous segment of chemicals together to make a love potion with total affection value as a non-negative integer power of k. Total affection value of a continuous segment of chemicals is the sum of affection values of each chemical in that segment.Help her to do so in finding the total number of such segments.","from sys import stdin
from collections import *


def arr_sum(arr):
    tem = [0]
    for i in range(len(arr)):
        tem.append(tem[i] + arr[i])
    return tem


rints = lambda: [int(x) for x in stdin.readline().split()]
mi, ma = -10 ** 14, 10 ** 14

n, k = rints()
a = rints()
mem, ans, lst, val = arr_sum(a), 0, 0, 1
c = Counter(mem)

for j in mem[:-1]:
    c[j] -= 1
    val = 1
    for i in range(48):
        if k == -1 and i == 2 or k == 1 and i == 1 or val > ma or val < mi:
            break

        ans += c[val + j]
        val *= k

print(ans)","['math', 'implementation', 'data structures', 'binary search', 'brute force']"
"The Little Elephant has found a ragged old black-and-white string s on the attic.The characters of string s are numbered from the left to the right from 1 to |s|, where |s| is the length of the string. Let's denote the i-th character of string s as si. As the string is black-and-white, each character of the string is either letter ""B"", or letter ""W"". Unfortunately, the string is very old and some characters are damaged. The damaged positions are denoted as ""X"".The Little Elephant in determined to restore the string and hang it on the wall. For that he needs to replace each character ""X"" by a ""B"" or a ""W"". The string must look good on the wall, so it must be beautiful. The Little Elephant considers a string beautiful if it has two non-intersecting substrings of a given length k, such that the left one fully consists of characters ""B"", and the right one fully consists of characters ""W"". More formally, there are four integers a, b, c, d (1 ≤ a ≤ b &lt; c ≤ d ≤ |s|; b - a + 1 = d - c + 1 = k) such that si = ""B"" (a ≤ i ≤ b) and sj = ""W"" (c ≤ j ≤ d). Help the Little Elephant find the number of different beautiful strings he can obtain from string s. Two strings are considered different if there is such position, where the character in the first string differs from the corresponding character in the second string. If this string doesn't contain characters «X» and it is already beautiful — the answer is 1.As the answer can be rather large, print it modulo 1000000007 (109 + 7).","Mod=1000000007
n,k=map(int,input().split(' '))
s=' '+input()
f,fs,g,gs,w=[0]*1000005,[0]*1000005,[0]*1000005,[0]*1000005,[0]*1000005
qx,qw,qb=[0]*1000005,[0]*1000005,[0]*1000005
q=0
f[0]=fs[0]=1
for i in range(1,n+1):
	lg=(i-k if i-k>=q else q)
	if s[i]!='B':
		f[i]=fs[i-1]-fs[lg-1]+Mod
		f[i]-=(Mod if f[i]>=Mod else 0)
	else:
		f[i]=0
	fs[i]=fs[i-1]+f[i]
	fs[i]-=(Mod if fs[i]>=Mod else 0)
	if s[i]=='W':
		q=i;
g[n+1]=gs[n+1]=1
q=n+1
for i in range(n,0,-1):
	rg=(i+k if i+k<=q else q)
	if s[i]!='W':
		g[i]=gs[i+1]-gs[rg+1]+Mod
		g[i]-=(Mod if g[i]>=Mod else 0)
	else:
		g[i]=0
	gs[i]=gs[i+1]+g[i]
	gs[i]-=(Mod if gs[i]>=Mod else 0)
	if s[i]=='B':
		q=i;
for i in range(1,n+1):
	qx[i],qb[i],qw[i]=qx[i-1]+(s[i]=='X'),qb[i-1]+(s[i]=='B'),qw[i-1]+(s[i]=='W')
for i in range(n,0,-1):
	w[i]=w[i+1]
	if s[i]=='X':
		w[i]*=2
		w[i]-=(Mod if w[i]>=Mod else 0)
	if i+k-1<=n:
		if qb[i+k-1]-qb[i-1]==0:
			w[i]+=g[i+k]
			w[i]-=(Mod if w[i]>=Mod else 0)
ans=0
for i in range(k,n+1):
	if qw[i]-qw[i-k]==0:
		ans=(ans+f[i-k]*w[i+1])%Mod
print(ans)",['dp']
"Little Tanya decided to present her dad a postcard on his Birthday. She has already created a message — string s of length n, consisting of uppercase and lowercase English letters. Tanya can't write yet, so she found a newspaper and decided to cut out the letters and glue them into the postcard to achieve string s. The newspaper contains string t, consisting of uppercase and lowercase English letters. We know that the length of string t greater or equal to the length of the string s.The newspaper may possibly have too few of some letters needed to make the text and too many of some other letters. That's why Tanya wants to cut some n letters out of the newspaper and make a message of length exactly n, so that it looked as much as possible like s. If the letter in some position has correct value and correct letter case (in the string s and in the string that Tanya will make), then she shouts joyfully ""YAY!"", and if the letter in the given position has only the correct value but it is in the wrong case, then the girl says ""WHOOPS"".Tanya wants to make such message that lets her shout ""YAY!"" as much as possible. If there are multiple ways to do this, then her second priority is to maximize the number of times she says ""WHOOPS"". Your task is to help Tanya make the message.","s = input()
t = input()
a, b = {}, []
for i in t:
    if i in a:
        a[i] += 1
    else:
        a[i] = 1
for i in s:
    b.append(i)
res1, res2 = 0, 0
for i in range(len(b)):
    if (b[i] in a) and (a[b[i]] > 0):
        res1 += 1
        a[b[i]] -= 1
        b[i] = '0'


for i in b:
    t = i
    if i.islower():
        t = i.upper()
    elif i.isupper():
        t = i.lower()
    if (t in a) and (a[t] > 0):
        res2 += 1
        a[t] -= 1
print(res1, res2)","['implementation', 'greedy', 'strings']"
"You are given two integers $$$x$$$ and $$$y$$$. You can perform two types of operations:   Pay $$$a$$$ dollars and increase or decrease any of these integers by $$$1$$$. For example, if $$$x = 0$$$ and $$$y = 7$$$ there are four possible outcomes after this operation:   $$$x = 0$$$, $$$y = 6$$$;  $$$x = 0$$$, $$$y = 8$$$;  $$$x = -1$$$, $$$y = 7$$$;  $$$x = 1$$$, $$$y = 7$$$.   Pay $$$b$$$ dollars and increase or decrease both integers by $$$1$$$. For example, if $$$x = 0$$$ and $$$y = 7$$$ there are two possible outcomes after this operation:   $$$x = -1$$$, $$$y = 6$$$;  $$$x = 1$$$, $$$y = 8$$$.  Your goal is to make both given integers equal zero simultaneously, i.e. $$$x = y = 0$$$. There are no other requirements. In particular, it is possible to move from $$$x=1$$$, $$$y=0$$$ to $$$x=y=0$$$.Calculate the minimum amount of dollars you have to spend on it.","t=int(input())
while(t>0):
    t=t-1
    l=[]
    x,y=map(int,input().split())
    a,b=map(int,input().split())
    if(x==0 and y==0):
        print(x)
    elif(x>y):

        a1=x-y
        a1=a1*a
        b1=y
        b1=b1*b
        l.append(abs(a1)+b1)
        a1=x*a
        b1=y*a
        l.append(abs(a1)+b1)
        print(min(l))
    elif(x<y):
        a1 = x - y
        a1 = a1 * a
        b1 = x
        b1 = b1 * b
        l.append(abs(a1) + b1)
        a1 = x * a
        b1 = y * a
        l.append(abs(a1) + b1)
        print(min(l))
    elif(x==y):
        a1=x*2*a
        l.append(a1)
        b1=x*b
        l.append(b1)
        print(min(l))","['greedy', 'math']"
You are standing on the $$$\mathit{OX}$$$-axis at point $$$0$$$ and you want to move to an integer point $$$x &gt; 0$$$.You can make several jumps. Suppose you're currently at point $$$y$$$ ($$$y$$$ may be negative) and jump for the $$$k$$$-th time. You can:   either jump to the point $$$y + k$$$  or jump to the point $$$y - 1$$$. What is the minimum number of jumps you need to reach the point $$$x$$$?,"t=int(input())
for i in range(t):
    n=int(input())
    u=1
    while((u*(u+1)/2)<n):
        u += 1
    a=u*(u+1)/2
    c=a-n
    for j in range(1,u+1):
        if(c==j+1):
            c = c-j-1
    print(int(u+c))","['constructive algorithms', 'binary search', 'math']"
"You are given an array $$$s$$$ consisting of $$$n$$$ integers.You have to find any array $$$t$$$ of length $$$k$$$ such that you can cut out maximum number of copies of array $$$t$$$ from array $$$s$$$.Cutting out the copy of $$$t$$$ means that for each element $$$t_i$$$ of array $$$t$$$ you have to find $$$t_i$$$ in $$$s$$$ and remove it from $$$s$$$. If for some $$$t_i$$$ you cannot find such element in $$$s$$$, then you cannot cut out one more copy of $$$t$$$. The both arrays can contain duplicate elements.For example, if $$$s = [1, 2, 3, 2, 4, 3, 1]$$$ and $$$k = 3$$$ then one of the possible answers is $$$t = [1, 2, 3]$$$. This array $$$t$$$ can be cut out $$$2$$$ times.   To cut out the first copy of $$$t$$$ you can use the elements $$$[1, \underline{\textbf{2}}, 3, 2, 4, \underline{\textbf{3}}, \underline{\textbf{1}}]$$$ (use the highlighted elements). After cutting out the first copy of $$$t$$$ the array $$$s$$$ can look like $$$[1, 3, 2, 4]$$$.  To cut out the second copy of $$$t$$$ you can use the elements $$$[\underline{\textbf{1}}, \underline{\textbf{3}}, \underline{\textbf{2}}, 4]$$$. After cutting out the second copy of $$$t$$$ the array $$$s$$$ will be $$$[4]$$$. Your task is to find such array $$$t$$$ that you can cut out the copy of $$$t$$$ from $$$s$$$ maximum number of times. If there are multiple answers, you may choose any of them.","n,k=map(int,input().split(' '))
a=list(map(int,input().split(' ')))
d={}
for i in a:
    if i in d.keys():
        d[i]+=1
    else:
        d[i]=1
s=[]
for i,j in d.items():
    s.append([j,i])
s.sort(reverse=True)
b=[]
for i in range(len(s)):
    j=1
    while s[i][0]//j!=0:
        b.append([s[i][0]//j,s[i][1]])
        j+=1
b.sort(reverse=True)
for i in range(k):
    print(b[i][1],end=' ')","['binary search', 'sortings']"
"This is a harder version of the problem. In this version $$$n \le 500\,000$$$The outskirts of the capital are being actively built up in Berland. The company ""Kernel Panic"" manages the construction of a residential complex of skyscrapers in New Berlskva. All skyscrapers are built along the highway. It is known that the company has already bought $$$n$$$ plots along the highway and is preparing to build $$$n$$$ skyscrapers, one skyscraper per plot.Architects must consider several requirements when planning a skyscraper. Firstly, since the land on each plot has different properties, each skyscraper has a limit on the largest number of floors it can have. Secondly, according to the design code of the city, it is unacceptable for a skyscraper to simultaneously have higher skyscrapers both to the left and to the right of it.Formally, let's number the plots from $$$1$$$ to $$$n$$$. Then if the skyscraper on the $$$i$$$-th plot has $$$a_i$$$ floors, it must hold that $$$a_i$$$ is at most $$$m_i$$$ ($$$1 \le a_i \le m_i$$$). Also there mustn't be integers $$$j$$$ and $$$k$$$ such that $$$j &lt; i &lt; k$$$ and $$$a_j &gt; a_i &lt; a_k$$$. Plots $$$j$$$ and $$$k$$$ are not required to be adjacent to $$$i$$$.The company wants the total number of floors in the built skyscrapers to be as large as possible. Help it to choose the number of floors for each skyscraper in an optimal way, i.e. in such a way that all requirements are fulfilled, and among all such construction plans choose any plan with the maximum possible total number of floors.","from math import *
from sys import stdin,stdout

def binarySearch(arr,x,i):
	l=i
	r=len(arr)-1 
	while l <= r: 
		mid = (l + r)//2; 
		if arr[mid] == x: 
			return mid 
		elif arr[mid] < x: 
			l = mid + 1
		else: 
			r = mid - 1
	return -1

def js(arr,x):
	l=0
	r=len(arr)-1
	ans=-1
	while(l<=r):
		m=(l+r)//2
		if(arr[m]<=x):
			ans=m
			l=m+1
		else:
			r=m-1
	return ans

def jg(arr,x):
	l=0
	r=len(arr)-1
	ans=-1
	while(l<=r):
		m=(l+r)//2
		if(arr[m]>=x):
			ans=m
			r=m-1
		else:
			l=m+1
	return ans

def ceil(a,b):
	if a%b == 0:
		return int(a/b)
	else:
		return (a//b + 1)


def c(s,i,a,b):
	count=0
	for j in range(i,len(s)):
		if(s[i]!=s[j]):
			if(s[i]==""A""):
				count+=a
			else:
				count+=b
			i=j
	if(i<len(s)-1):
		if(s[i]==""A""):
			count+=a
		else:
			count+=b
	return count


import math as mt 
  
# Prints smaller elements on left  
# side of every element

from collections import deque 
def printPrevSmaller(arr, n): 
	S = deque()
	ind = deque()
	l = []  
	for i in range(n): 
		while (len(S) > 0 and S[-1] > arr[i]): 
			S.pop()
			ind.pop()  
		if (len(S) == 0): 
			l.append(-1) 
		else:
			l.append(ind[-1]) 
		S.append(arr[i])
		ind.append(i)
	return l


n=int(stdin.readline())
ar=list(map(int,stdin.readline().split()))
ar2=[]
for i in range(n):
	ar2.append(ar[i])
ar2=ar2[::-1]
l=printPrevSmaller(ar,n)
r=printPrevSmaller(ar2,n)
if(n==1):
	stdout.write(str(ar[0]))
else:
	a=[]
	b=[]
	for i in range(n):
		if(l[i]==-1):
			a.append((i-l[i])*ar[i])
		else:
			a.append((i-l[i])*ar[i] + a[l[i]])

		if(r[i]==-1):
			b.append((i-r[i])*ar2[i])
		else:
			b.append((i-r[i])*ar2[i] + b[r[i]])	

	b=b[::-1]
	ans=0
	c=0
	for i in range(n):
		if(c<a[i]+b[i]-ar[i]):
			c=a[i]+b[i]-ar[i]
			ans=i

	rslt = [0]*n

	rslt[ans]=ar[ans]
	temp=ar[ans]
	for i in range(ans+1,n):
		if(ar[i]<temp):
			rslt[i]=ar[i]
			temp=ar[i]
		else:
			rslt[i]=temp
	x=ans-1
	temp=ar[ans]
	while(x>=0):
		if(ar[x]<temp):
			rslt[x]=ar[x]
			temp=ar[x]
		else:
			rslt[x]=temp
		x-=1
	rslt=map(str,rslt)
	stdout.write("" "".join(rslt))","['dp', 'greedy', 'data structures']"
"'Jeopardy!' is an intellectual game where players answer questions and earn points. Company Q conducts a simplified 'Jeopardy!' tournament among the best IT companies. By a lucky coincidence, the old rivals made it to the finals: company R1 and company R2. The finals will have n questions, m of them are auction questions and n - m of them are regular questions. Each question has a price. The price of the i-th question is ai points. During the game the players chose the questions. At that, if the question is an auction, then the player who chose it can change the price if the number of his current points is strictly larger than the price of the question. The new price of the question cannot be less than the original price and cannot be greater than the current number of points of the player who chose the question. The correct answer brings the player the points equal to the price of the question. The wrong answer to the question reduces the number of the player's points by the value of the question price.The game will go as follows. First, the R2 company selects a question, then the questions are chosen by the one who answered the previous question correctly. If no one answered the question, then the person who chose last chooses again.All R2 employees support their team. They want to calculate what maximum possible number of points the R2 team can get if luck is on their side during the whole game (they will always be the first to correctly answer questions). Perhaps you are not going to be surprised, but this problem was again entrusted for you to solve.","n, m = map(int, input().split())
prices = list(map(int, input().split()))
normal = []
auct = []
q = list(map(int, input().split()))
sum = 0
for i in range(n):
    if i + 1 in q:
        auct.append(prices[i])
    else:
        sum += prices[i]
auct = sorted(auct, reverse=True)
for elem in auct:
    sum += max(elem, sum)
print(sum)","['greedy', 'math']"
"Once Petya read a problem about a bracket sequence. He gave it much thought but didn't find a solution. Today you will face it.You are given string s. It represents a correct bracket sequence. A correct bracket sequence is the sequence of opening (""("") and closing ("")"") brackets, such that it is possible to obtain a correct mathematical expression from it, inserting numbers and operators between the brackets. For example, such sequences as ""(())()"" and ""()"" are correct bracket sequences and such sequences as "")()"" and ""(()"" are not.In a correct bracket sequence each bracket corresponds to the matching bracket (an opening bracket corresponds to the matching closing bracket and vice versa). For example, in a bracket sequence shown of the figure below, the third bracket corresponds to the matching sixth one and the fifth bracket corresponds to the fourth one.   You are allowed to color some brackets in the bracket sequence so as all three conditions are fulfilled:   Each bracket is either not colored any color, or is colored red, or is colored blue.  For any pair of matching brackets exactly one of them is colored. In other words, for any bracket the following is true: either it or the matching bracket that corresponds to it is colored.  No two neighboring colored brackets have the same color. Find the number of different ways to color the bracket sequence. The ways should meet the above-given conditions. Two ways of coloring are considered different if they differ in the color of at least one bracket. As the result can be quite large, print it modulo 1000000007 (109 + 7).","__author__ = 'Jackie'

import sys

#sys.stdin = open('input.txt', 'r')
MAXN = 800
MOD = 1000000007
brackets = raw_input()
#print 'jackie'
dp = []
#print 'jackie'
N = len(brackets)
Hash = [0] * N
stk = []
top = 0

def init():
    for i in range(2):
        a1 = []
        for j in range(2):
            a2 = []
            for k in range(N):
                a3 = [-1] * N
                a2.append(a3)
            a1.append(a2)
        dp.append(a1)
    top = 0
    for i in xrange(N):
        if '(' == brackets[i]:
            stk.append(i)
        else:
            cur = stk.pop()
            Hash[cur] = i


def DP(s, t, lc, rc):
    if s >= t:
        return 1
    if -1 != dp[lc][rc][s][t] :
        return dp[lc][rc][s][t]
    ans = 0

    if Hash[s] == t:
        if not lc:
            ans += DP(s + 1, t - 1, 1, 0) * 2
            ans %= MOD
            if not rc:
                ans += DP(s + 1, t - 1, 0, 1) * 2
                if ans >= MOD: ans %= MOD
            else:
                ans += DP(s + 1, t - 1, 0, 1)
                ans %= MOD
        else:
            ans += DP(s + 1, t - 1, 1, 0)
            ans %= MOD
            if not rc:
                ans += DP(s + 1, t - 1, 0, 1) * 2
                ans %= MOD
            else:
                ans += DP(s + 1, t - 1, 0, 1)
                ans %= MOD
        dp[lc][rc][s][t] = ans
        return ans

    if not lc:
        ans += DP(s + 1, Hash[s] - 1, 1, 0) * 2 * DP(Hash[s] + 1, t, 0, rc)
        ans %= MOD
        ans += DP(s + 1, Hash[s] - 1, 0, 1) * 2 * DP(Hash[s] + 1, t, 1, rc)
        ans %= MOD
    else:
        ans += DP(s + 1, Hash[s] - 1, 1, 0) * DP(Hash[s] + 1, t, 0, rc)
        ans %= MOD
        ans += DP(s + 1, Hash[s] - 1, 0, 1) * 2 * DP(Hash[s] + 1, t, 1, rc)
        ans %= MOD

    dp[lc][rc][s][t] = ans
    return ans



if __name__ == '__main__':

    init()
    ans = DP(0, N - 1, 0, 0)
    print ans



#import sys
##sys.stdin = open('input.txt', 'r')
#mod=1000000007
#s=raw_input()
#n=len(s)
#dp=[]
#for ii in range(0,3):
#    aa=[]
#    for i in range(0,3):
#        a=[]
#        for j in range(0,n):
#            b=[-1]*n
#            a.append(b)
#        aa.append(a)
#    dp.append(aa)
#
#match=[0]*n
#st=[]
#for i in range(0,n):
#    if(s[i]=='('):
#        st.append(i)
#    else:
#        cur=st.pop()
#        match[cur]=i
##print match
#def go(left,right,s1,s2):
#    if(left>right):
#        return 1
#    if(dp[s1][s2][left][right]!=-1):
#        return dp[s1][s2][left][right]
#    res=0
#    x=left
#    y=match[left]
#    for c1 in range(0,3):
#        for c2 in range(0,3):
#            ok=True
#            if(c1!=2):
#                if(c1==s1):
#                    ok=False
#            if(c2!=2):
#                if(y==right and c2==s2):
#                    ok=False
#            if(c1!=2 and c2!=2):
#                ok=False
#            if(c1==2 and c2==2):
#                ok=False
#            if(ok==False):
#                continue
#            res+=go(x+1,y-1,c1,c2)*go(y+1,right,c2,s2)
#            res=res%mod
#    dp[s1][s2][left][right]=res
#    return res
#num=go(0,n-1,2,2)
#print num",['dp']
"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood.  King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","n=int(input())
L=list(map(int,input().split()))
prime=[]
nn=n

i=2
while i*i<=n:
    if nn%i==0:
        prime.append(i)
        while nn%i==0:
            nn//=i
    i+=1

#print(prime,nn)

if nn!=1:
    prime.append(nn)

if prime[0]==2:
    prime=prime[1:]

if n%4==0:
    prime=[4]+prime

#print(prime)

out=False
for x in prime:
    p=n//x
    for i in range(p):
        f=True
        for j in range(i,n,p):
            if not L[j]:
                f=False
        if f:
            out=True
            #print(p,i)
            break
    if out:
        print(""YES"")
        break
if not out:
    print(""NO"")","['dp', 'number theory', 'math']"
"There is an array with n elements a1, a2, ..., an and the number x.In one operation you can select some i (1 ≤ i ≤ n) and replace element ai with ai &amp; x, where &amp; denotes the bitwise and operation.You want the array to have at least two equal elements after applying some operations (possibly, none). In other words, there should be at least two distinct indices i ≠ j such that ai = aj. Determine whether it is possible to achieve and, if possible, the minimal number of operations to apply.","n,x=[int(x) for x in input().split()]
li=set([*map(int,input().split())])
if len(li)<n:
	print(0)
	quit()
for i in li:
	if i&x!=i and i&x in li:
		print(1)
		quit()
a = set(aa & x for aa in li)
if len(a)<n:
	print(2)
	quit()
print(-1)",['greedy']
"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1 × n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1 × 5 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:  As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him.","t = int(raw_input())
N = []
N.append(10000)
[N.append(int(i)) for i in raw_input().split()]
sol = 0
dpx, dpy = [0]*2000, [0]*2000

N.append(10000)
for i in range(1, t+1):
    if N[i] >= N[i - 1]:
        dpy[i] = dpy[i - 1] + 1
    else:
        dpy[i] = 1

for i in range(t, 0, -1):
    if N[i] >= N[i + 1]:
        dpx[i] = dpx[i + 1] + 1
    else:
        dpx[i] = 1

for i in range(1, t+1):
    if dpy[i] + dpx[i] - 1 > sol:
        sol = dpx[i] + dpy[i] - 1

print sol","['implementation', 'brute force']"
"Lesha plays the recently published new version of the legendary game hacknet. In this version character skill mechanism was introduced. Now, each player character has exactly n skills. Each skill is represented by a non-negative integer ai — the current skill level. All skills have the same maximum level A.Along with the skills, global ranking of all players was added. Players are ranked according to the so-called Force. The Force of a player is the sum of the following values:  The number of skills that a character has perfected (i.e., such that ai = A), multiplied by coefficient cf. The minimum skill level among all skills (min ai), multiplied by coefficient cm. Now Lesha has m hacknetian currency units, which he is willing to spend. Each currency unit can increase the current level of any skill by 1 (if it's not equal to A yet). Help him spend his money in order to achieve the maximum possible value of the Force.","import bisect as bs
import heapq as hq


def force(cf, cm, f, m):
    return f*cf + m*cm


# def perfect(sa, amax, m):
#     p = 0
#     while sa[-p-1] == amax:
#         p += 1
#     while sa[p] + m >= amax:
#         for _ in range(amax-sa[-p-1]):
#             yield p
#         m -= amax-sa[-p-1]
#         p += 1
#     for _ in range(m+1):
#         yield p
# 
# 
# def improve(sa, amax, m):
#     am = sa[0]
#     i = 1
#     while i < len(a) and sa[i] == am:
#         i += 1
#     while i <= m:
#         for _ in range(i):
#             yield am
#         am += 1
#         m -= i
#         while i < len(a) and sa[i] == am:
#             i += 1
#     for _ in range(m+1):
#         yield am

def mtable(sa):
    mt = [0]*len(sa)
    for i in range(1, len(sa)):
        mt[i] = mt[i-1] + i*(sa[i]-sa[i-1])
    return mt


def maxm(sa, mt, f, k):
    i = bs.bisect_right(mt, k, hi=len(sa)-f)
    return sa[i-1] + (k-mt[i-1])//i


def optimize(a, amax, cf, cm, k):
    if sum(a) + k >= len(a)*amax:
        return len(a)*cf + amax*cm, len(a), amax

    sa = sorted(a)
    f = 0
    while sa[-f-1] == amax:
        f += 1
    mt = mtable(sa)

    of = f
    om = maxm(sa, mt, f, k)
    o = force(cf, cm, of, om)

    while k >= amax - sa[-f-1]:
        k -= amax - sa[-f-1]
        f += 1
        m = maxm(sa, mt, f, k)
        t = force(cf, cm, f, m)
        if t > o:
            of, om, o = f, m, t

    return o, of, om

#     sa = sorted(a)
#     fs = list(perfect(sa, amax, m))
#     ms = list(improve(sa, amax, m))
#     of, om = max(zip(fs, reversed(ms)), key=lambda fm: force(fm[0], fm[1]))
#     return force(of, om), of, om 


def apply(a, amax, of, om):
    # Ensure all values are at least om
    a_ = [max(om, ai) for ai in a]

    # Increase top p values to amax
    h = [(-a[i], i) for i in range(len(a))]
    hq.heapify(h)
    for _ in range(of):
        _, i = hq.heappop(h)
        a_[i] = amax

    return a_


def best_force(a, amax, cf, cm, m):
    t, of, om = optimize(a, amax, cf, cm, m)
    if of == len(a):
        return t, [amax]*len(a)
    else:
        return t, apply(a, amax, of, om)
    


if __name__ == '__main__':
    n, amax, cf, cm, k = map(int, input().split())
    a = list(map(int, input().split()))
    assert len(a) == n
    t, o = best_force(a, amax, cf, cm, k)
    print(t)
    print(' '.join(map(str, o)))","['dp', 'sortings', 'greedy']"
"Recently n students from city S moved to city P to attend a programming camp.They moved there by train. In the evening, all students in the train decided that they want to drink some tea. Of course, no two people can use the same teapot simultaneously, so the students had to form a queue to get their tea.i-th student comes to the end of the queue at the beginning of li-th second. If there are multiple students coming to the queue in the same moment, then the student with greater index comes after the student with lesser index. Students in the queue behave as follows: if there is nobody in the queue before the student, then he uses the teapot for exactly one second and leaves the queue with his tea; otherwise the student waits for the people before him to get their tea. If at the beginning of ri-th second student i still cannot get his tea (there is someone before him in the queue), then he leaves the queue without getting any tea. For each student determine the second he will use the teapot and get his tea (if he actually gets it).","reps = int(input())

for _ in range(reps):
    n = int(input())
    t = 1
    for _ in range(n):
        l, r = list(map(int, input().split()))
        if l > t:
            t = l
        if t <= r:
            print(t)
            t += 1
        else:
            print(0)",['implementation']
"Leha like all kinds of strange things. Recently he liked the function F(n, k). Consider all possible k-element subsets of the set [1, 2, ..., n]. For subset find minimal element in it. F(n, k) — mathematical expectation of the minimal element among all k-element subsets.But only function does not interest him. He wants to do interesting things with it. Mom brought him two arrays A and B, each consists of m integers. For all i, j such that 1 ≤ i, j ≤ m the condition Ai ≥ Bj holds. Help Leha rearrange the numbers in the array A so that the sum  is maximally possible, where A' is already rearranged array.","n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
bb = list(enumerate(b))
bb = sorted(bb, key = lambda x:x[1])
#print (bb)
a.sort(reverse=True)
c = [0] * n
for i in range(n):
	#print (bb[i][0])
	c[bb[i][0]] = a[i]
print (*c)","['greedy', 'combinatorics', 'number theory', 'math', 'sortings']"
"There is a frog staying to the left of the string $$$s = s_1 s_2 \ldots s_n$$$ consisting of $$$n$$$ characters (to be more precise, the frog initially stays at the cell $$$0$$$). Each character of $$$s$$$ is either 'L' or 'R'. It means that if the frog is staying at the $$$i$$$-th cell and the $$$i$$$-th character is 'L', the frog can jump only to the left. If the frog is staying at the $$$i$$$-th cell and the $$$i$$$-th character is 'R', the frog can jump only to the right. The frog can jump only to the right from the cell $$$0$$$.Note that the frog can jump into the same cell twice and can perform as many jumps as it needs.The frog wants to reach the $$$n+1$$$-th cell. The frog chooses some positive integer value $$$d$$$ before the first jump (and cannot change it later) and jumps by no more than $$$d$$$ cells at once. I.e. if the $$$i$$$-th character is 'L' then the frog can jump to any cell in a range $$$[max(0, i - d); i - 1]$$$, and if the $$$i$$$-th character is 'R' then the frog can jump to any cell in a range $$$[i + 1; min(n + 1; i + d)]$$$.The frog doesn't want to jump far, so your task is to find the minimum possible value of $$$d$$$ such that the frog can reach the cell $$$n+1$$$ from the cell $$$0$$$ if it can jump by no more than $$$d$$$ cells at once. It is guaranteed that it is always possible to reach $$$n+1$$$ from $$$0$$$.You have to answer $$$t$$$ independent test cases.","t = int(input())


def reverse(string): 
    string = """".join(reversed(string)) 
    return string 

while(t!=0):
	l = input()
	r_l = reverse(l)
	k = []
	first = 0
	s = 0
	flag = 0
	last = 0
	for i in range(len(r_l)):
		if(r_l[i] == ""R""):
			k.append(i+1)
			break

	for i in range(len(l)):
		if(first == 0 and l[i] == ""R""):
			k.append(i+1)
			s = i
			flag = 1
			first = 1
		elif(l[i] == ""R""):
			k.append(i - s)
			s = i

	if(flag == 0):
		print(len(l) + 1)
	else:
		print(max(k))


	t-=1","['greedy', 'implementation', 'data structures', 'binary search', 'dfs and similar']"
"Igor found out discounts in a shop and decided to buy n items. Discounts at the store will last for a week and Igor knows about each item that its price now is ai, and after a week of discounts its price will be bi.Not all of sellers are honest, so now some products could be more expensive than after a week of discounts.Igor decided that buy at least k of items now, but wait with the rest of the week in order to save money as much as possible. Your task is to determine the minimum money that Igor can spend to buy all n items.","n, k = map(int, input().split())
a = [int(x) for x in input().split()]
b = [int(x) for x in input().split()]
d = []
for i in range(n):
    d.append((a[i]-b[i], i, a[i], b[i]))
d.sort()
total = 0
for i in range(n):
    if k>0 or d[i][0]<=0:
        total += d[i][2]
        k -= 1
    else:
        total += d[i][3]
print(total)","['constructive algorithms', 'sortings', 'greedy']"
"Your company was appointed to lay new asphalt on the highway of length $$$n$$$. You know that every day you can either repair one unit of the highway (lay new asphalt over one unit of the highway) or skip repairing.Skipping the repair is necessary because of the climate. The climate in your region is periodical: there are $$$g$$$ days when the weather is good and if you lay new asphalt these days it becomes high-quality pavement; after that, the weather during the next $$$b$$$ days is bad, and if you lay new asphalt these days it becomes low-quality pavement; again $$$g$$$ good days, $$$b$$$ bad days and so on.You can be sure that you start repairing at the start of a good season, in other words, days $$$1, 2, \dots, g$$$ are good.You don't really care about the quality of the highway, you just want to make sure that at least half of the highway will have high-quality pavement. For example, if the $$$n = 5$$$ then at least $$$3$$$ units of the highway should have high quality; if $$$n = 4$$$ then at least $$$2$$$ units should have high quality.What is the minimum number of days is needed to finish the repair of the whole highway?","for tc in range(int(input())):
    n,g,b=map(int,input().split())
    temp=(n+1)//2
    x=(temp//g)*(g+b)
    x+=temp%g
    if temp%g==0:
        x-=b
    print(max(n,x))",['math']
"This is an easier version of the problem. In this version $$$n \le 1000$$$The outskirts of the capital are being actively built up in Berland. The company ""Kernel Panic"" manages the construction of a residential complex of skyscrapers in New Berlskva. All skyscrapers are built along the highway. It is known that the company has already bought $$$n$$$ plots along the highway and is preparing to build $$$n$$$ skyscrapers, one skyscraper per plot.Architects must consider several requirements when planning a skyscraper. Firstly, since the land on each plot has different properties, each skyscraper has a limit on the largest number of floors it can have. Secondly, according to the design code of the city, it is unacceptable for a skyscraper to simultaneously have higher skyscrapers both to the left and to the right of it.Formally, let's number the plots from $$$1$$$ to $$$n$$$. Then if the skyscraper on the $$$i$$$-th plot has $$$a_i$$$ floors, it must hold that $$$a_i$$$ is at most $$$m_i$$$ ($$$1 \le a_i \le m_i$$$). Also there mustn't be integers $$$j$$$ and $$$k$$$ such that $$$j &lt; i &lt; k$$$ and $$$a_j &gt; a_i &lt; a_k$$$. Plots $$$j$$$ and $$$k$$$ are not required to be adjacent to $$$i$$$.The company wants the total number of floors in the built skyscrapers to be as large as possible. Help it to choose the number of floors for each skyscraper in an optimal way, i.e. in such a way that all requirements are fulfilled, and among all such construction plans choose any plan with the maximum possible total number of floors.","import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

sta1 = []
dp1 = [0]*(N+1)
for i, a in enumerate(A):
    count = 0
    mustscore = dp1[i]
    while sta1 and sta1[-1][0] > a:
        s, num = sta1.pop()
        count += num
        mustscore += (s-a)*num
    dp1[i+1] = mustscore
    sta1.append((a, count+1))

sta2 = []
dp2 = [0]*(N+1)
for i in reversed(range(N)):
    a = A[i]
    count = 0
    mustscore = dp2[i+1]
    while sta2 and sta2[-1][0] > a:
        s, num = sta2.pop()
        count += num
        mustscore += (s-a)*num
    dp2[i] = mustscore
    sta2.append((a, count+1))

PA = 10**17
ind = -1
for n in range(N):
    p = dp1[n+1] + dp2[n]
    if p < PA:
        PA = p
        ind = n

ans = A[:]
for i in range(ind+1, N):
    A[i] = min(A[i-1], A[i])
for i in reversed(range(ind)):
    A[i] = min(A[i], A[i+1])

print(*A)","['dp', 'greedy', 'data structures', 'brute force']"
"Hands that shed innocent blood!There are n guilty people in a line, the i-th of them holds a claw with length Li. The bell rings and every person kills some of people in front of him. All people kill others at the same time. Namely, the i-th person kills the j-th person if and only if j &lt; i and j ≥ i - Li.You are given lengths of the claws. You need to find the total number of alive people after the bell rings.","n = int(input())
t = list(map(int, input().split()))

p1 = n-1
p2 = n
counter = 1
while (p2 >= 0 and p1 >= 0):
	if (p1 == p2):
		counter += 1
	p2 = min(p1-t[p1]-1, p2)
	p1 -= 1

print (counter)","['two pointers', 'implementation', 'greedy']"
"One day, Yuhao came across a problem about checking if some bracket sequences are correct bracket sequences.A bracket sequence is any non-empty sequence of opening and closing parentheses. A bracket sequence is called a correct bracket sequence if it's possible to obtain a correct arithmetic expression by inserting characters ""+"" and ""1"" into this sequence. For example, the sequences ""(())()"", ""()"" and ""(()(()))"" are correct, while the bracket sequences "")("", ""(()"" and ""(()))("" are not correct.Yuhao found this problem too simple for him so he decided to make the problem harder. You are given many (not necessarily correct) bracket sequences. The task is to connect some of them into ordered pairs so that each bracket sequence occurs in at most one pair and the concatenation of the bracket sequences in each pair is a correct bracket sequence. The goal is to create as many pairs as possible.This problem unfortunately turned out to be too difficult for Yuhao. Can you help him and solve it?","r, l, m = [], [], 0
for k in range(int(input())):
	s = input()
	lb, rb, a, b = 0, 0, 0, 0
	for i in range(len(s)):
		if s[i] == '(': rb += 1
		else: rb -= 1
		if s[-1-i] == ')': lb += 1
		else: lb -= 1
		if rb < 0: a = 1
		if lb < 0: b = 1
		if a and b: break
	else:
		if rb > 0: r.append(rb)
		elif rb < 0: l.append(lb)
		else: m += 1
m //= 2
for i in r:
	if i in l:
		m += 1
		l.remove(i)
print(m)","['implementation', 'greedy']"
"You are given two strings $$$A$$$ and $$$B$$$ representing essays of two students who are suspected cheaters. For any two strings $$$C$$$, $$$D$$$ we define their similarity score $$$S(C,D)$$$ as $$$4\cdot LCS(C,D) - |C| - |D|$$$, where $$$LCS(C,D)$$$ denotes the length of the Longest Common Subsequence of strings $$$C$$$ and $$$D$$$. You believe that only some part of the essays could have been copied, therefore you're interested in their substrings.Calculate the maximal similarity score over all pairs of substrings. More formally, output maximal $$$S(C, D)$$$ over all pairs $$$(C, D)$$$, where $$$C$$$ is some substring of $$$A$$$, and $$$D$$$ is some substring of $$$B$$$. If $$$X$$$ is a string, $$$|X|$$$ denotes its length.A string $$$a$$$ is a substring of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.A string $$$a$$$ is a subsequence of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters. Pay attention to the difference between the substring and subsequence, as they both appear in the problem statement. You may wish to read the Wikipedia page about the Longest Common Subsequence problem.","n,m = map(int, input().split()) 
A = input() 
B = input() 

M = [
    [0]*(m+1) for _ in range (n+1) 
]

for i in range (1, n+1): 
    for j in range (1, m+1): 

        if (A[i-1] == B[j-1]) : 
            M[i][j] = 2 + M[i-1][j-1] 
        else: 
            M[i][j] = max (M[i-1][j]-1, M[i][j-1]-1, M[i-1][j-1]-2, 0) 
    
ans = -1 
for i in range (n+1): 
    for j in range (m+1): 
        ans = max (ans, M[i][j]) 

print (ans)","['dp', 'greedy', 'strings']"
"Vasya is preparing a contest, and now he has written a statement for an easy problem. The statement is a string of length $$$n$$$ consisting of lowercase Latin latters. Vasya thinks that the statement can be considered hard if it contains a subsequence hard; otherwise the statement is easy. For example, hard, hzazrzd, haaaaard can be considered hard statements, while har, hart and drah are easy statements. Vasya doesn't want the statement to be hard. He may remove some characters from the statement in order to make it easy. But, of course, some parts of the statement can be crucial to understanding. Initially the ambiguity of the statement is $$$0$$$, and removing $$$i$$$-th character increases the ambiguity by $$$a_i$$$ (the index of each character is considered as it was in the original statement, so, for example, if you delete character r from hard, and then character d, the index of d is still $$$4$$$ even though you delete it from the string had).Vasya wants to calculate the minimum ambiguity of the statement, if he removes some characters (possibly zero) so that the statement is easy. Help him to do it!Recall that subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.","n = input()
s = raw_input()
a = map(int, raw_input().split())
d = [[0] * 4 for i in range(n)]

if s[0] == 'h': d[0][0] = a[0]
for i in range(1, n):
    if s[i] == 'h':
        d[i][0] = d[i - 1][0] + a[i]
        d[i][1] = min(d[i - 1][1], d[i - 1][0])
        d[i][2] = d[i - 1][2]
        d[i][3] = d[i - 1][3]
    elif s[i] == 'a':
        d[i][0] = d[i - 1][0]
        d[i][1] = d[i - 1][1] + a[i]
        d[i][2] = min(d[i - 1][2], d[i - 1][1])
        d[i][3] = d[i - 1][3]
    elif s[i] == 'r':
        d[i][0] = d[i - 1][0]
        d[i][1] = d[i - 1][1]
        d[i][2] = d[i - 1][2] + a[i]
        d[i][3] = min(d[i - 1][3], d[i - 1][2])
    elif s[i] == 'd':
        d[i][0] = d[i - 1][0]
        d[i][1] = d[i - 1][1]
        d[i][2] = d[i - 1][2]
        d[i][3] = d[i - 1][3] + a[i]
    else:
        d[i][0] = d[i - 1][0]
        d[i][1] = d[i - 1][1]
        d[i][2] = d[i - 1][2]
        d[i][3] = d[i - 1][3]


print min(d[-1])",['dp']
"In this problem you are to calculate the sum of all integers from 1 to n, but you should take all powers of two with minus in the sum.For example, for n = 4 the sum is equal to  - 1 - 2 + 3 - 4 =  - 4, because 1, 2 and 4 are 20, 21 and 22 respectively.Calculate the answer for t values of n.","t = int(input())

import math

tests = []

for _ in range(t):
    tests.append(int(input()))

def solve(n):
    i,t = int(1),0
    while i <= n:
        t += i
        i *= 2
    return t

for n in tests:
    s = int((n*(n+1))//2)
    m = int(solve(n)*2)
    print(int(s-m))",['math']
You are given array a with n elements and the number m. Consider some subsequence of a and the value of least common multiple (LCM) of its elements. Denote LCM as l. Find any longest subsequence of a with the value l ≤ m.A subsequence of a is an array we can get by erasing some elements of a. It is allowed to erase zero or all elements.The LCM of an empty array equals 1.,"import sys
range = xrange
input = raw_input
 
n,m = [int(x) for x in input().split()]
A = [int(x) for x in input().split()]
counter = [0]*(m+1)
for a in A:
    if a <= m:
        counter[a] += 1
 
lcm = [0]*(m+1)
for d in range(1,m+1):
    for j in range(d,m+1,d):
        lcm[j] += counter[d]
 
lcm = max(range(1, m+1), key = lcm.__getitem__)
out = []
for i,a in enumerate(A):
    if lcm != 0 and lcm%a == 0:
        out.append(i)
print lcm, len(out)
print ' '.join(str(x+1) for x in out)","['number theory', 'brute force', 'math']"
"A lot of people in Berland hates rain, but you do not. Rain pacifies, puts your thoughts in order. By these years you have developed a good tradition — when it rains, you go on the street and stay silent for a moment, contemplate all around you, enjoy freshness, think about big deeds you have to do. Today everything had changed quietly. You went on the street with a cup contained water, your favorite drink. In a moment when you were drinking a water you noticed that the process became quite long: the cup still contained water because of rain. You decided to make a formal model of what was happening and to find if it was possible to drink all water in that situation. Thus, your cup is a cylinder with diameter equals d centimeters. Initial level of water in cup equals h centimeters from the bottom.   You drink a water with a speed equals v milliliters per second. But rain goes with such speed that if you do not drink a water from the cup, the level of water increases on e centimeters per second. The process of drinking water from the cup and the addition of rain to the cup goes evenly and continuously. Find the time needed to make the cup empty or find that it will never happen. It is guaranteed that if it is possible to drink all water, it will happen not later than after 104 seconds.Note one milliliter equals to one cubic centimeter.","from math import pi
d, h, v, e = map(int, raw_input().split())

vol = 4 * v /(pi * d * d)

if e >= vol :
    print ""NO""
else :
    print ""YES""
    print h / (vol - e)","['geometry', 'math']"
"A sequence of square brackets is regular if by inserting symbols ""+"" and ""1"" into it, you can get a regular mathematical expression from it. For example, sequences ""[[]][]"", ""[]"" and ""[[][[]]]"" — are regular, at the same time ""]["", ""[[]"" and ""[[]]]["" — are irregular. Draw the given sequence using a minimalistic pseudographics in the strip of the lowest possible height — use symbols '+', '-' and '|'. For example, the sequence ""[[][]][]"" should be represented as: +-        -++- -+    |+- -++- -+||   |||   ||   |||   ||+- -++- -+||   |+-        -++- -+Each bracket should be represented with the hepl of one or more symbols '|' (the vertical part) and symbols '+' and '-' as on the example which is given above.Brackets should be drawn without spaces one by one, only dividing pairs of consecutive pairwise brackets with a single-space bar (so that the two brackets do not visually merge into one symbol). The image should have the minimum possible height. The enclosed bracket is always smaller than the surrounding bracket, but each bracket separately strives to maximize the height of the image. So the pair of final brackets in the example above occupies the entire height of the image.Study carefully the examples below, they adequately explain the condition of the problem. Pay attention that in this problem the answer (the image) is unique.","length = int(input())
brackets = input()

OPEN = '['
CLOSE = ']'

PLUS = '+'
PIPE = '|'
MINUS = '-'


width = 0
height = 0
depth = 0
previous_open = False
for bracket in brackets:
    if bracket == OPEN:
        depth += 1
        width += 2
        height = max(height, depth)
        previous_open = True
    elif bracket == CLOSE:
        depth -= 1
        if previous_open:
            width += 3
        previous_open = False

height = height * 2 + 1


result = [[' '] * width for i in range(height)]


def draw(d, pos, s):
    h1 = d
    h2 = height - d - 1
    result[h1][pos] = PLUS
    result[h2][pos] = PLUS
    for i in range(h1+1, h2):
        result[i][x] = PIPE
    result[h1][pos+s] = MINUS
    result[h2][pos+s] = MINUS

x = 0
depth = 0
for bracket in brackets:
    if bracket == OPEN:
        draw(depth, x, 1)
        depth += 1
        previous_open = True
    elif bracket == CLOSE:
        if previous_open:
            x += 3
        depth -= 1
        draw(depth, x, -1)
        previous_open = False
    x += 1


for row in result:
    print(''.join(row))","['implementation', '*special']"
"Little penguin Polo likes permutations. But most of all he likes permutations of integers from 0 to n, inclusive.For permutation p = p0, p1, ..., pn, Polo has defined its beauty — number .Expression  means applying the operation of bitwise excluding ""OR"" to numbers x and y. This operation exists in all modern programming languages, for example, in language C++ and Java it is represented as ""^"" and in Pascal — as ""xor"".Help him find among all permutations of integers from 0 to n the permutation with the maximum beauty.","n = int(input())
p = [i for i in range(n + 1)]

k = 1
while(2 * k <= n):
  k *= 2
m = n + 1
while m > 0:
  while k >= m:
    k //= 2
  for i in range(m - k):
    if k - i - 1 >= 0:
      p[k + i], p[k - i - 1] = p[k - i - 1], p[k + i]
  m = k - i - 1

print(n * (n + 1))
print(' '.join(map(str, p)))","['data structures', 'implementation', 'greedy', 'math']"
"The only difference between easy and hard versions is the constraints.Vova likes pictures with kittens. The news feed in the social network he uses can be represented as an array of $$$n$$$ consecutive pictures (with kittens, of course). Vova likes all these pictures, but some are more beautiful than the others: the $$$i$$$-th picture has beauty $$$a_i$$$.Vova wants to repost exactly $$$x$$$ pictures in such a way that:   each segment of the news feed of at least $$$k$$$ consecutive pictures has at least one picture reposted by Vova;  the sum of beauty values of reposted pictures is maximum possible. For example, if $$$k=1$$$ then Vova has to repost all the pictures in the news feed. If $$$k=2$$$ then Vova can skip some pictures, but between every pair of consecutive pictures Vova has to repost at least one of them.Your task is to calculate the maximum possible sum of values of reposted pictures if Vova follows conditions described above, or say that there is no way to satisfy all conditions.","#!/usr/bin/env python
""""""
This file is part of https://github.com/Cheran-Senthil/PyRival.

Copyright 2018 Cheran Senthilkumar all rights reserved,
Cheran Senthilkumar <hello@cheran.io>
Permission to use, modify, and distribute this software is given under the
terms of the MIT License.

""""""
from __future__ import division, print_function

import cmath
import itertools
import math
import operator as op
# import random
import sys
from atexit import register
from bisect import bisect_left, bisect_right
# from collections import Counter, MutableSequence, defaultdict, deque
# from copy import deepcopy
# from decimal import Decimal
# from difflib import SequenceMatcher
# from fractions import Fraction
# from heapq import heappop, heappush

if sys.version_info[0] < 3:
    # from cPickle import dumps
    from io import BytesIO as stream
    # from Queue import PriorityQueue, Queue
else:
    # from functools import reduce
    from io import StringIO as stream
    from math import gcd
    # from pickle import dumps
    # from queue import PriorityQueue, Queue


if sys.version_info[0] < 3:
    class dict(dict):
        """"""dict() -> new empty dictionary""""""
        def items(self):
            """"""D.items() -> a set-like object providing a view on D's items""""""
            return dict.iteritems(self)

        def keys(self):
            """"""D.keys() -> a set-like object providing a view on D's keys""""""
            return dict.iterkeys(self)

        def values(self):
            """"""D.values() -> an object providing a view on D's values""""""
            return dict.itervalues(self)

    def gcd(x, y):
        """"""gcd(x, y) -> int
        greatest common divisor of x and y
        """"""
        while y:
            x, y = y, x % y
        return x

    input = raw_input
    range = xrange

    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip


def sync_with_stdio(sync=True):
    """"""Set whether the standard Python streams are allowed to buffer their I/O.

    Args:
        sync (bool, optional): The new synchronization setting.

    """"""
    global input, flush

    if sync:
        flush = sys.stdout.flush
    else:
        sys.stdin = stream(sys.stdin.read())
        input = lambda: sys.stdin.readline().rstrip('\r\n')

        sys.stdout = stream()
        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))


def main():
    n, k, x = map(int, input().split(' '))
    a = list(map(int, input().split(' ')))

    memo = [[-1] * (x + 1) for _ in range(n)]

    def dp(i, x):
        if (i >= n) and (x == 0):
            return 0
        if (i >= n) or (x == 0):
            return float('-inf')
        if memo[i][x] == -1:
            memo[i][x] = max(a[i] + dp(i + j, x - 1) for j in range(1, k + 1))

        return memo[i][x]

    ans = max(dp(i, x) for i in range(k))
    if ans == float('-inf'):
        print(-1)
    else:
        print(ans)


if __name__ == '__main__':
    sync_with_stdio()

    if 'PyPy' in sys.version:
        from _continuation import continulet

        def bootstrap(c):
            callable, arg = c.switch()
            while True:
                to = continulet(lambda _, f, x: f(x), callable, arg)
                callable, arg = c.switch(to=to)

        c = continulet(bootstrap)
        c.switch()

        main()

    else:
        import threading

        sys.setrecursionlimit(2097152)
        threading.stack_size(134217728)

        main_thread = threading.Thread(target=main)
        main_thread.start()
        main_thread.join()",['dp']
"You are given $$$n$$$ positive integers $$$a_1, \ldots, a_n$$$, and an integer $$$k \geq 2$$$. Count the number of pairs $$$i, j$$$ such that $$$1 \leq i &lt; j \leq n$$$, and there exists an integer $$$x$$$ such that $$$a_i \cdot a_j = x^k$$$.","from sys import stdin
from itertools import repeat
from collections import defaultdict
def main():
    n, k = map(int, stdin.readline().split())
    a = map(int, stdin.readline().split(), repeat(10, n))
    b = range(100010)
    c = [0] * 100010
    z = int(pow(100010, 1. / k)) + 1
    p = [1] * 100010
    for i in xrange(2, 100010):
        if c[i]:
            continue
        y = 1000000
        if i <= z:
            y = x = pow(i, k - 1)
        j = i
        while j < 100010:
            c[j] = 1
            y -= 1
            if y:
                p[j] *= i
            else:
                y = x
                while b[j] % (x * i) == 0:
                    b[j] /= x * i
            j += i
    pa = [0] * 100010
    pa[1] = 1
    z2 = int(pow(10 ** 10, 1. / k)) + 1
    for i in xrange(2, 100010):
        if i != b[i]:
            pa[i] = pa[b[i]]
            continue
        if p[i] <= z2:
            pa[i] = pow(p[i], k) / i
    a = [b[x] for x in a]
    d = defaultdict(int)
    ans = 0
    for x in a:
        if pa[x] in d:
            ans += d[pa[x]]
        d[x] += 1
    print ans
main()","['implementation', 'hashing', 'math']"
"Anton is growing a tree in his garden. In case you forgot, the tree is a connected acyclic undirected graph.There are n vertices in the tree, each of them is painted black or white. Anton doesn't like multicolored trees, so he wants to change the tree such that all vertices have the same color (black or white).To change the colors Anton can use only operations of one type. We denote it as paint(v), where v is some vertex of the tree. This operation changes the color of all vertices u such that all vertices on the shortest path from v to u have the same color (including v and u). For example, consider the tree  and apply operation paint(3) to get the following:  Anton is interested in the minimum number of operation he needs to perform in order to make the colors of all vertices equal.","from collections import defaultdict, deque

class DSU:
    def __init__(self, n):
        self.parents = [i for i in range(n)]
        self.ranks = [0 for i in range(n)]

    def find_parent(self, v):
        if self.parents[v] == v:
            return v
        self.parents[v] = self.find_parent(self.parents[v])
        return self.parents[v]

    def join_sets(self, u, v):
        u = self.find_parent(u)
        v = self.find_parent(v)
        if u != v:
            if self.ranks[u] < self.ranks[v]:
                u, v = v, u
            self.parents[v] = u
            if self.ranks[v] == self.ranks[u]:
                self.ranks[u] += 1

n = int(input())
dsu = DSU(n)
colors = list(map(int, input().split(' ')))
vertices = []
for i in range(n-1):
    u, v = map(lambda x: int(x)-1, input().split(' '))
    if colors[u] == colors[v]:
        dsu.join_sets(u, v)
    vertices.append((u,v))
graph = defaultdict(list)
for u, v in vertices:
    if colors[u] != colors[v]:
        u = dsu.find_parent(u)
        v = dsu.find_parent(v)
        graph[u].append(v)
        graph[v].append(u)


def bfs(u):
    d = dict()
    d[u] = 0
    q = deque()
    q.append(u)
    while q:
        u = q.pop()
        for v in graph[u]:
            if v not in d:
                d[v] = d[u] + 1
                q.append(v)
    return d
if graph:
    v = list(graph.keys())[0]
    d = bfs(v)
    u = v
    for i in d:
        if d[i] > d[u]:
            u = i
    d = bfs(u)
    w = u
    for i in d:
        if d[i] > d[w]:
            w = i
    print((d[w]+1)//2)
else:
    print(0)","['dp', 'dfs and similar', 'trees']"
"Today Adilbek is taking his probability theory test. Unfortunately, when Adilbek arrived at the university, there had already been a long queue of students wanting to take the same test. Adilbek has estimated that he will be able to start the test only $$$T$$$ seconds after coming. Fortunately, Adilbek can spend time without revising any boring theorems or formulas. He has an app on this smartphone which contains $$$n$$$ Japanese crosswords to solve. Adilbek has decided to solve them all one by one in the order they are listed in the app, without skipping any crossword. For each crossword, a number $$$t_i$$$ is given that represents the time it takes an average crossword expert to solve this crossword (the time is given in seconds).Adilbek is a true crossword expert, but, unfortunately, he is sometimes unlucky in choosing the way to solve the crossword. So, it takes him either $$$t_i$$$ seconds or $$$t_i + 1$$$ seconds to solve the $$$i$$$-th crossword, equiprobably (with probability $$$\frac{1}{2}$$$ he solves the crossword in exactly $$$t_i$$$ seconds, and with probability $$$\frac{1}{2}$$$ he has to spend an additional second to finish the crossword). All these events are independent.After $$$T$$$ seconds pass (or after solving the last crossword, if he manages to do it in less than $$$T$$$ seconds), Adilbek closes the app (if he finishes some crossword at the same moment, that crossword is considered solved; otherwise Adilbek does not finish solving the current crossword at all). He thinks it would be an interesting probability theory problem to calculate $$$E$$$ — the expected number of crosswords he will be able to solve completely. Can you calculate it? Recall that the expected value of a discrete random variable is the probability-weighted average of all possible values — in this problem it means that the expected value of the number of solved crosswords can be calculated as $$$E = \sum \limits_{i = 0}^{n} i p_i$$$, where $$$p_i$$$ is the probability that Adilbek will solve exactly $$$i$$$ crosswords. We can represent $$$E$$$ as rational fraction $$$\frac{P}{Q}$$$ with $$$Q &gt; 0$$$. To give the answer, you should print $$$P \cdot Q^{-1} \bmod (10^9 + 7)$$$.","MOD = 10 ** 9 + 7
MAX = 5 * 10 ** 5
fac, ifac, ipow2 = [1] * MAX, [1] * MAX, [1] * MAX
for i in range(1, MAX):
    fac[i] = fac[i - 1] * i % MOD
    ifac[i] = pow(fac[i], MOD - 2, MOD)
    ipow2[i] = ipow2[i - 1] * (MOD + 1) // 2 % MOD
choose = lambda n, k: fac[n] * ifac[k] % MOD * ifac[n - k] % MOD
n, t = map(int, raw_input().split())
a = list(map(int, raw_input().split()))
s = 0
p = [1] + [0] * (n + 1)
k = cur = 0
for i in range(n):
    s += a[i]
    if s > t: break
    if s + i + 1 <= t:
        p[i + 1] = 1
        continue
    newk = t - s
    cur = cur * 2 - choose(i, k) if cur else sum(choose(i + 1, j) for j in range(newk + 1))
    if newk < k:
        cur -= sum(choose(i + 1, x) for x in range(k, newk, -1))
    cur %= MOD
    p[i + 1] = cur * ipow2[i + 1] % MOD
    k = newk
print(sum((p[i] - p[i + 1]) * i % MOD for i in range(1, n + 1)) % MOD)","['dp', 'combinatorics', 'two pointers', 'number theory', 'probabilities']"
"Ringo found a string $$$s$$$ of length $$$n$$$ in his yellow submarine. The string contains only lowercase letters from the English alphabet. As Ringo and his friends love palindromes, he would like to turn the string $$$s$$$ into a palindrome by applying two types of operations to the string. The first operation allows him to choose $$$i$$$ ($$$2 \le i \le n-1$$$) and to append the substring $$$s_2s_3 \ldots s_i$$$ ($$$i - 1$$$ characters) reversed to the front of $$$s$$$.The second operation allows him to choose $$$i$$$ ($$$2 \le i \le n-1$$$) and to append the substring $$$s_i s_{i + 1}\ldots s_{n - 1}$$$ ($$$n - i$$$ characters) reversed to the end of $$$s$$$.Note that characters in the string in this problem are indexed from $$$1$$$.For example suppose $$$s=$$$abcdef. If he performs the first operation with $$$i=3$$$ then he appends cb to the front of $$$s$$$ and the result will be cbabcdef. Performing the second operation on the resulted string with $$$i=5$$$ will yield cbabcdefedc.Your task is to help Ringo make the entire string a palindrome by applying any of the two operations (in total) at most $$$30$$$ times. The length of the resulting palindrome must not exceed $$$10^6$$$It is guaranteed that under these constraints there always is a solution. Also note you do not have to minimize neither the number of operations applied, nor the length of the resulting string, but they have to fit into the constraints.","from __future__ import division, print_function
# import threading
# threading.stack_size(2**27)
import sys
sys.setrecursionlimit(10**4)
# sys.stdin = open('inpy.txt', 'r')
# sys.stdout = open('outpy.txt', 'w')
from sys import stdin, stdout
import bisect            #c++ upperbound
import math
import heapq
i_m=9223372036854775807
def modinv(n,p):
    return pow(n,p-2,p)
def cin():
    return map(int,sin().split())
def ain():                           #takes array as input
    return list(map(int,sin().split()))
def sin():
    return input()
def inin():
    return int(input())
import math  
def GCD(x, y): 
    x=abs(x)
    y=abs(y)
    if(min(x,y)==0):
        return max(x,y)
    while(y): 
        x, y = y, x % y 
    return x 
def Divisors(n) : 
    l = []  
    for i in range(1, int(math.sqrt(n) + 1)) :
        if (n % i == 0) : 
            if (n // i == i) : 
                l.append(i) 
            else : 
                l.append(i)
                l.append(n//i)
    return l
prime=[]
def SieveOfEratosthenes(n): 
    global prime
    prime = [True for i in range(n+1)] 
    p = 2
    while (p * p <= n): 
        if (prime[p] == True): 
            for i in range(p * p, n+1, p): 
                prime[i] = False
        p += 1
    f=[]
    for p in range(2, n): 
        if prime[p]: 
            f.append(p)
    return f
def primeFactors(n): 
    a=[]
    # Print the number of two's that divide n 
    while n % 2 == 0: 
        a.append(2) 
        n = n // 2
          
    # n must be odd at this point 
    # so a skip of 2 ( i = i + 2) can be used 
    for i in range(3,int(math.sqrt(n))+1,2): 
          
        # while i divides n , print i ad divide n 
        while n % i== 0: 
            a.append(i) 
            n = n // i 
              
    # Condition if n is a prime 
    # number greater than 2 
    if n > 2: 
        a.append(n)
    return a

""""""*******************************************************""""""
def main():
    s=sin()
    n=len(s)
    print(3)
    print(""R"",n-1)
    print(""L"",n)
    print(""L"",2)
        

    
######## Python 2 and 3 footer by Pajenegod and c1729
 
# Note because cf runs old PyPy3 version which doesn't have the sped up
# unicode strings, PyPy3 strings will many times be slower than pypy2.
# There is a way to get around this by using binary strings in PyPy3
# but its syntax is yferent which makes it kind of a mess to use.
 
# So on cf, use PyPy2 for best string performance.
 
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
 
import os, sys
from io import IOBase, BytesIO
 
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0
 
    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None
 
    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s
 
    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()
 
    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')
 
# Cout implemented in Python
import sys
class ostream:
    def __lshift__(self,a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
 
# Read all remaining integers in stdin, type is given by optional argument, this is fast
def readnumbers(zero = 0):
    conv = ord if py2 else lambda x:x
    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'R' [0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-' [0]: sign = -1
            elif s[i] != b'\r' [0]:
                A.append(sign*numb)
                numb = zero; sign = 1
            i += 1
    except:pass
    if s and s[-1] >= b'R' [0]:
        A.append(sign*numb)
    return A
 
# threading.Thread(target=main).start()
if __name__== ""__main__"":
  main()","['constructive algorithms', 'strings']"
"Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are n watchmen on a plane, the i-th watchman is located at point (xi, yi).They need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen i and j to be |xi - xj| + |yi - yj|. Daniel, as an ordinary person, calculates the distance using the formula .The success of the operation relies on the number of pairs (i, j) (1 ≤ i &lt; j ≤ n), such that the distance between watchman i and watchmen j calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.","points = []
row_count = int(input())
for _ in range(row_count):
    rawLine = input().split()
    points.append([int(rawLine[0]),int(rawLine[1])])


total = 0
for i in range(2):
    points.sort(key= lambda x : x[i])
    previous = 1
    for j in range(1,row_count+1):
        if j != row_count and points[j][i] == points[j-1][i]:
            previous += 1
        else:
            total += (previous*(previous-1))/2
            previous = 1

points.sort(key= lambda x : (x[0],x[1]))
previous = 1
for j in range(1,row_count+1):
    if j != row_count and points[j][0] == points[j-1][0] and points[j][1] == points[j-1][1]:
        previous += 1
    else:
        total -= (previous*(previous-1))/2 # Duplicates
        previous = 1

print(int(total))","['data structures', 'geometry', 'implementation', 'sortings']"
"Due to the coronavirus pandemic, city authorities obligated citizens to keep a social distance. The mayor of the city Semyon wants to light up Gluharniki park so that people could see each other even at night to keep the social distance.The park is a rectangular table with $$$n$$$ rows and $$$m$$$ columns, where the cells of the table are squares, and the boundaries between the cells are streets. External borders are also streets. Every street has length $$$1$$$. For example, park with $$$n=m=2$$$ has $$$12$$$ streets.You were assigned to develop a plan for lighting the park. You can put lanterns in the middle of the streets. The lamp lights two squares near it (or only one square if it stands on the border of the park).    The park sizes are: $$$n=4$$$, $$$m=5$$$. The lighted squares are marked yellow. Please note that all streets have length $$$1$$$. Lanterns are placed in the middle of the streets. In the picture not all the squares are lit. Semyon wants to spend the least possible amount of money on lighting but also wants people throughout the park to keep a social distance. So he asks you to find the minimum number of lanterns that are required to light all the squares.","for _ in range(int(input())):
    n,m=map(int,input().split())
    s=n*m
    if s%2==0:
        print(int(m*n/2))
    else:
        print(int(m*n//2)+1)","['greedy', 'math']"
"Sean is trying to save a large file to a USB flash drive. He has n USB flash drives with capacities equal to a1, a2, ..., an megabytes. The file size is equal to m megabytes. Find the minimum number of USB flash drives needed to write Sean's file, if he can split the file between drives.","n = raw_input()
m = int(raw_input())
c,l=0,[]
for i in xrange(int(n)):
    l.append(int(raw_input()))
l.sort(reverse=True)
for i in xrange(int(n)):
    c += l[i]
    if c >= m: break
print i+1","['implementation', 'sortings', 'greedy']"
"Little Artem likes electronics. He can spend lots of time making different schemas and looking for novelties in the nearest electronics store. The new control element was delivered to the store recently and Artem immediately bought it.That element can store information about the matrix of integers size n × m. There are n + m inputs in that element, i.e. each row and each column can get the signal. When signal comes to the input corresponding to some row, this row cyclically shifts to the left, that is the first element of the row becomes last element, second element becomes first and so on. When signal comes to the input corresponding to some column, that column shifts cyclically to the top, that is first element of the column becomes last element, second element becomes first and so on. Rows are numbered with integers from 1 to n from top to bottom, while columns are numbered with integers from 1 to m from left to right.Artem wants to carefully study this element before using it. For that purpose he is going to set up an experiment consisting of q turns. On each turn he either sends the signal to some input or checks what number is stored at some position of the matrix.Artem has completed his experiment and has written down the results, but he has lost the chip! Help Artem find any initial matrix that will match the experiment results. It is guaranteed that experiment data is consistent, which means at least one valid matrix exists.","n, m, q = map(int, input().split())
res = [0] * int(1e4+5)
arr = list([0] * (m+1) for _ in range(n+1))

def shift_row(r):
    arr[r][m] = arr[r][m-1]
    for i in range(m-1, 0, -1):
        arr[r][i] = arr[r][i-1]
    arr[r][0] = arr[r][m]
 
def shift_col(c):
    arr[n][c] = arr[n-1][c]
    for i in range(n-1, 0, -1):
        arr[i][c] = arr[i-1][c]
    arr[0][c] = arr[n][c]

for i in range(q):
    qi = list(map(int, input().split()))
    if qi[0] == 3:
        res[i] = ((qi[0], qi[3]), (qi[1], qi[2]))
    else:
        res[i] = ((qi[0], qi[1]), (-1, -1))

for i in range(q-1, -1, -1):
    if res[i][0][0] == 3:
        arr[res[i][1][0] - 1][res[i][1][1] - 1] = res[i][0][1]
    elif res[i][0][0] == 1:
        shift_row(res[i][0][1] - 1)
    elif res[i][0][0] == 2:
        shift_col(res[i][0][1] - 1)

for i in range(n):
    print(*arr[i][:-1])",['implementation']
"People do many crazy things to stand out in a crowd. Some of them dance, some learn by heart rules of Russian language, some try to become an outstanding competitive programmers, while others collect funny math objects.Alis is among these collectors. Right now she wants to get one of k-special tables. In case you forget, the table n × n is called k-special if the following three conditions are satisfied:  every integer from 1 to n2 appears in the table exactly once;  in each row numbers are situated in increasing order;  the sum of numbers in the k-th column is maximum possible. Your goal is to help Alice and find at least one k-special table of size n × n. Both rows and columns are numbered from 1 to n, with rows numbered from top to bottom and columns numbered from left to right.","n, k = map(int, raw_input().split())

cur = 0
print n ** 3 - n * (n - k + 1) * (n + 1) // 2 + n
for i in xrange(n):
    for j in xrange(k - 1):
        cur += 1
        print cur,
    for j in xrange(n - k + 1):
        print n * n - (n - k + 1) * (i + 1) + j + 1,
    print","['constructive algorithms', 'implementation']"
"Student Dima from Kremland has a matrix $$$a$$$ of size $$$n \times m$$$ filled with non-negative integers.He wants to select exactly one integer from each row of the matrix so that the bitwise exclusive OR of the selected integers is strictly greater than zero. Help him!Formally, he wants to choose an integers sequence $$$c_1, c_2, \ldots, c_n$$$ ($$$1 \leq c_j \leq m$$$) so that the inequality $$$a_{1, c_1} \oplus a_{2, c_2} \oplus \ldots \oplus a_{n, c_n} &gt; 0$$$ holds, where $$$a_{i, j}$$$ is the matrix element from the $$$i$$$-th row and the $$$j$$$-th column.Here $$$x \oplus y$$$ denotes the bitwise XOR operation of integers $$$x$$$ and $$$y$$$.","n, m = map(int, raw_input().split())
a = []
for i in range(n):
    a.append(map(int, raw_input().split()))

z = 'NIE'
l = 0
r = 0
for i in range(n):
    for j in range(m):
        x = 0
        for k in range(n):
            if k != i: x = x ^ a[k][0]
            else: x = x ^ a[k][j]
        if x > 0:
            z = 'TAK'
            l = i
            r = j
            break
    if z == 'TAK': break

print z
if z == 'TAK':
    p = []
    for i in range(n):
        if i == l: p.append(r + 1)
        else: p.append(1)
    print ' '.join(map(str, p))","['dp', 'constructive algorithms', 'bitmasks', 'brute force']"
"You are given a tree (an undirected connected graph without cycles) and an integer $$$s$$$.Vanya wants to put weights on all edges of the tree so that all weights are non-negative real numbers and their sum is $$$s$$$. At the same time, he wants to make the diameter of the tree as small as possible.Let's define the diameter of a weighed tree as the maximum sum of the weights of the edges lying on the path between two some vertices of the tree. In other words, the diameter of a weighed tree is the length of the longest simple path in the tree, where length of a path is equal to the sum of weights over all edges in the path.Find the minimum possible diameter that Vanya can get.","n,s = [int(x) for x in input().split()]
v=[ [] ]
for i in range(n):
	v.append([])
	
for i in range(n-1):
	a, b =[int(x) for x in input().split()]
	v[a].append(b)
	v[b].append(a)

ans =0
for i in range(1,n+1):
	if len(v[i])==1:
		ans+=1
	
print(2*s/ans)","['implementation', 'greedy', 'trees']"
"Xenia is a girl being born a noble. Due to the inflexibility and harshness of her family, Xenia has to find some ways to amuse herself. Recently Xenia has bought $$$n_r$$$ red gems, $$$n_g$$$ green gems and $$$n_b$$$ blue gems. Each of the gems has a weight.Now, she is going to pick three gems.Xenia loves colorful things, so she will pick exactly one gem of each color.Xenia loves balance, so she will try to pick gems with little difference in weight.Specifically, supposing the weights of the picked gems are $$$x$$$, $$$y$$$ and $$$z$$$, Xenia wants to find the minimum value of $$$(x-y)^2+(y-z)^2+(z-x)^2$$$. As her dear friend, can you help her?","# itne me hi thakk gaye?
from bisect import bisect_left, bisect_right

def getf(a, b, c):
    return (a-b)**2 + (b-c)**2 + (a-c)**2
def getcondition(low_arr, mid_arr, high_arr):
    s = 10**20
    for i in mid_arr:
        x_p = bisect_right(high_arr, i)
        x = 10**9
        if(x_p != len(high_arr)):
            x = min(x, high_arr[x_p])
        if(x_p != 0):
            x = min(x, high_arr[x_p-1])
        
        y = -10**9
        y_ptr = bisect_left(low_arr, i)
        if(y_ptr != 0):
            y = max(y, low_arr[y_ptr-1])
        if (y_ptr != len(low_arr)):
            y = max(y, low_arr[y_ptr])
        
        curr = getf(i, x, y)
        if curr < s:
            s = curr
    return s
for _ in range(int(input())):
    r,g,b = map(int, input().split())
    red = sorted(list(map(int, input().split())))
    green = sorted(list(map(int, input().split())))
    blue = sorted(list(map(int, input().split())))
    ans = []
    ans.append(getcondition(red, blue, green))
    ans.append(getcondition(green, blue, red))
    ans.append(getcondition(red, green, blue))
    ans.append(getcondition(blue, green, red))
    ans.append(getcondition(blue, red, green))
    ans.append(getcondition(green, red, blue))
    print(min(ans))","['greedy', 'two pointers', 'math', 'sortings', 'binary search']"
"You are given an array a consisting of positive integers and q queries to this array. There are two types of queries:   1 l r x — for each index i such that l ≤ i ≤ r set ai = x.  2 l r — find the minimum among such ai that l ≤ i ≤ r. We decided that this problem is too easy. So the array a is given in a compressed form: there is an array b consisting of n elements and a number k in the input, and before all queries a is equal to the concatenation of k arrays b (so the size of a is n·k).","from sys import stdin, stdout


n, k = map(int, stdin.readline().split())
values = [0] + list(map(int, stdin.readline().split()))
m = int(stdin.readline())
questions = []
ar = set()

for i in range(m):
    questions.append(tuple(map(int, stdin.readline().strip().split())))
    ar.add(int(questions[-1][1]))
    ar.add(int(questions[-1][2]))
    

compress = [0]
ar = sorted(list(ar))

pw = 1
while (2 ** pw < n):
    pw += 1

sparse = [[float('inf') for j in range(len(values))] for i in range(pw)]
sparse[0] = values

for i in range(1, pw):
    for j in range(1, n - 2 ** i + 2):
        sparse[i][j] = min(sparse[i - 1][j], sparse[i - 1][j + 2 ** (i - 1)])


mn = min(values[1:])


def getmin(first, second):
    if second - first + 1 >= n:
        return mn
    else:
        second = second % n + n * (not(second % n))
        first = first % n + n * (not(first % n))
        
        if second < first:
            return min(getmin(1, second), getmin(first, n))
        else:
            length = second - first + 1
            pw = 0
    
            while 2 ** pw <= length:
                pw += 1
            
            pw -= 1
            
            return min(sparse[pw][first], sparse[pw][second - 2 ** pw + 1])


counting = {}
d = {}


for i in range(len(ar)):
    compress.append(ar[i])
    d[ar[i]] = len(compress) - 1
    
    if i != len(ar) - 1 and ar[i + 1] - ar[i] > 1:
        compress.append(ar[i] + 1)
        counting[len(compress) - 1] = float('inf')
        d[ar[i] + 1] = len(compress) - 1

for ind in counting:
    counting[ind] = getmin(compress[ind - 1] + 1, compress[ind + 1] - 1)
        
    

def update(l, r, ind, lb, rb, value):
        
        
    if updating[ind] and ind * 2 < len(tree):
        
        if (not updating[ind * 2] or (updating[ind * 2][1] < updating[ind][1])):
            tree[ind * 2] = updating[ind][0]
            updating[ind * 2] = updating[ind][::]
            
        if (not updating[ind * 2 + 1] or (updating[ind * 2 + 1][1] < updating[ind][1])):
            tree[ind * 2 + 1] = updating[ind][0]
            updating[ind * 2 + 1] = updating[ind][::]        
        
    updating[ind] = 0
        
        
    if (l == lb and r == rb):
        tree[ind] = value
        
        if (ind * 2 < len(tree)):
            tree[ind * 2], tree[ind * 2 + 1] = value, value
            updating[ind * 2], updating[ind * 2 + 1] = (value, time), (value, time)
        
        
        while ind != 1:
            ind //= 2
            tree[ind] = min(tree[ind * 2], tree[ind * 2 + 1])
        
    else:
        m = (lb + rb) // 2
        
        if (l <= m):
            update(l, min(m, r), ind * 2, lb, m, value)
        
        if (r > m):
            update(max(l, m + 1), r, ind * 2 + 1, m + 1, rb, value)
        
        
def get(l, r, ind, lb, rb):
        
        
    if updating[ind] and ind * 2 < len(tree):
        
        if (not updating[ind * 2] or (updating[ind * 2][1] < updating[ind][1])):
            tree[ind * 2] = updating[ind][0]
            updating[ind * 2] = updating[ind][::]
        
        if (not updating[ind * 2 + 1] or (updating[ind * 2 + 1][1] < updating[ind][1])):
            tree[ind * 2 + 1] = updating[ind][0]
            updating[ind * 2 + 1] = updating[ind][::]
        
    updating[ind] = 0
        
        
    if (l == lb and r == rb):
        return tree[ind]
    else:
        m = (lb + rb) // 2
        ans = float('inf')
        
        if (l <= m):
            ans = get(l, min(m, r), ind * 2, lb, m)
                    
        if (r > m):
            ans = min(ans, get(max(l, m + 1), r, ind * 2 + 1, m + 1, rb))
        
        
        return ans



def getvalue(ind):
    if (ind < len(compress)):
        return (values[compress[ind] % n + n * (not(compress[ind] % n))])
    else:
        return 0
    
    
size = 1
while (size < len(ar) * 2):
    size *= 2

tree = [float('inf') for i in range(2 * size)]
updating = [0 for i in range (2 * size)]

for i in range(size, 2 * size):
    if i - size + 1 in counting:
        tree[i] = counting[i - size + 1]
    else:
        tree[i] = getvalue(i - size + 1)

for i in range(size - 1, 0, -1):
    tree[i] = min(tree[i * 2], tree[i * 2 + 1])
    

for time in range(m):
    if questions[time][0] == 1:
        update(d[questions[time][1]], d[questions[time][2]], 1, 1, size, questions[time][-1])
    else:
        stdout.write(str(get(d[questions[time][1]], d[questions[time][2]], 1, 1, size)) + '\n')
        






'''
3 2
1 2 3
5
2 4 4
1 4 4 5
2 4 4
1 1 6 1
2 6 6
'''",['data structures']
"Igor has fallen in love with Tanya. Now Igor wants to show his feelings and write a number on the fence opposite to Tanya's house. Igor thinks that the larger the number is, the more chance to win Tanya's heart he has. Unfortunately, Igor could only get v liters of paint. He did the math and concluded that digit d requires ad liters of paint. Besides, Igor heard that Tanya doesn't like zeroes. That's why Igor won't use them in his number.Help Igor find the maximum number he can write on the fence.","def ni():
    return int(raw_input())

def nis():
    return map(int, raw_input().split())

n = ni()
a = nis()

cheapest_val = None
cheapest_num = None
for i in range(1, 10):
    val = a[i - 1]
    if cheapest_val is None or val <= cheapest_val:
        cheapest_num = i
        cheapest_val = val

count, rem = divmod(n, cheapest_val)

if count:

    ans = [cheapest_num] * count
    i = 0
    while rem and i < len(ans):
        j = 9
        while j:
            if a[ans[i] - 1] + rem >= a[j - 1]:
                rem -= a[j - 1] - a[ans[i] - 1]
                ans[i] = j
                break
            j -= 1
        i += 1

    print ''.join(map(str, ans))
else:
    print -1","['dp', 'implementation', 'greedy', 'data structures']"
"There is a programming language in which every program is a non-empty sequence of ""&lt;"" and ""&gt;"" signs and digits. Let's explain how the interpreter of this programming language works. A program is interpreted using movement of instruction pointer (IP) which consists of two parts.  Current character pointer (CP);  Direction pointer (DP) which can point left or right; Initially CP points to the leftmost character of the sequence and DP points to the right.We repeat the following steps until the first moment that CP points to somewhere outside the sequence.  If CP is pointing to a digit the interpreter prints that digit then CP moves one step according to the direction of DP. After that the value of the printed digit in the sequence decreases by one. If the printed digit was 0 then it cannot be decreased therefore it's erased from the sequence and the length of the sequence decreases by one.  If CP is pointing to ""&lt;"" or ""&gt;"" then the direction of DP changes to ""left"" or ""right"" correspondingly. Then CP moves one step according to DP. If the new character that CP is pointing to is ""&lt;"" or ""&gt;"" then the previous character will be erased from the sequence. If at any moment the CP goes outside of the sequence the execution is terminated.It's obvious the every program in this language terminates after some steps.We have a sequence s1, s2, ..., sn of ""&lt;"", ""&gt;"" and digits. You should answer q queries. Each query gives you l and r and asks how many of each digit will be printed if we run the sequence sl, sl + 1, ..., sr as an independent program in this language.","n, q = map(int, raw_input().split())
s = list(raw_input())
for _ in range(q):
	l, r = map(int, raw_input().split())
	t = s[l - 1 : r]
	c = 0
	d = 1
	r = [0] * 10
	while 0 <= c < len(t):
		v = t[c]
		if '0' <= v <= '9':
			v = int(v)
			r[v] += 1
			c += d
			if c < 0 or c >= len(t):
				break
			if v:
				t[c - d] = str(v - 1)
			else:
				t.pop(c - d)
				c -= max(d, 0)
		else:
			d = [-1, 1][v == '>']
			c += d
			if c < 0 or c >= len(t):
				break
			if t[c] in set('<>'):
				t.pop(c - d)
				c -= max(d, 0)
	print ' '.join(map(str, r))","['implementation', 'brute force']"
"You are given a set of points on a straight line. Each point has a color assigned to it. For point a, its neighbors are the points which don't have any other points between them and a. Each point has at most two neighbors - one from the left and one from the right.You perform a sequence of operations on this set of points. In one operation, you delete all points which have a neighbor point of a different color than the point itself. Points are deleted simultaneously, i.e. first you decide which points have to be deleted and then delete them. After that you can perform the next operation etc. If an operation would not delete any points, you can't perform it.How many operations will you need to perform until the next operation does not have any points to delete?","s = input()
n = 1
    
for i in range(1, len(s)):
  if s[i] != s[i-1]:
    n += 1

mas = [0] * n
col = [0] * n

count = 1
idx = 0
c = s[0]
for i in range(1, len(s)):
  if s[i] == s[i-1]:
    count += 1
  else:
    mas[idx] = count
    col[idx] = c
    idx += 1
    count = 1
    c = s[i]
    
mas[idx] = count
col[idx] = c

res = 0

while n > 1:
  newlen = n
  idx = -1
      
  for i in range(0, n):
    if (i == 0) or (i == n - 1):
      mas[i] -= 1
    elif mas[i] >= 2:
      mas[i] -= 2
    else:
      mas[i] = 0
      
    if mas[i] == 0:
      newlen -= 1
    else:
      if idx >= 0 and col[idx] == col[i]:
        mas[idx] += mas[i]
        newlen -= 1
      else:
        idx += 1
        mas[idx] = mas[i]
        col[idx] = col[i] 
        type = i % 2
        
  n = newlen
  res += 1

print(res)","['data structures', 'implementation', 'greedy']"
"You are given an array of n integer numbers a0, a1, ..., an - 1. Find the distance between two closest (nearest) minimums in it. It is guaranteed that in the array a minimum occurs at least two times.","n = int(raw_input())

a = map(int, raw_input().split())

menor = min(a)

b = []
c = []
for i in range(len(a)):
    if a[i]==menor:
        b.append(i)
    if len(b)>1:
        c.append(b[-1] - b[-2])

print min(c)",['implementation']
"This is yet another problem dealing with regular bracket sequences.We should remind you that a bracket sequence is called regular, if by inserting «+» and «1» into it we can get a correct mathematical expression. For example, sequences «(())()», «()» and «(()(()))» are regular, while «)(», «(()» and «(()))(» are not. You are given a string of «(» and «)» characters. You are to find its longest substring that is a regular bracket sequence. You are to find the number of such substrings as well.","s = input()
ans = dict()

stack = [-1]
res = 0
for i in range(len(s)):
    c = s[i]
    if c == ')' and stack[-1] != -1 and s[stack[-1]] == '(':
        stack.pop()
        ans[i-stack[-1]] = ans.get(i-stack[-1],0)+1
        res = max(i-stack[-1], res)
    else:
        stack.append(i)

if res not in ans.keys():
    print('0 1')
else:
    print("" "".join([str(res),str(ans[res])]))","['dp', 'greedy', 'constructive algorithms', 'sortings', 'data structures', 'strings']"
"There is a square of size $$$10^6 \times 10^6$$$ on the coordinate plane with four points $$$(0, 0)$$$, $$$(0, 10^6)$$$, $$$(10^6, 0)$$$, and $$$(10^6, 10^6)$$$ as its vertices.You are going to draw segments on the plane. All segments are either horizontal or vertical and intersect with at least one side of the square.Now you are wondering how many pieces this square divides into after drawing all segments. Write a program calculating the number of pieces of the square.","from __future__ import division, print_function
_interactive = False

def main():
    MAX = 1000000
    h, v = input_as_list()
    hs = input_as_matrix(h, 3)
    vs = input_as_matrix(v, 3)

    hs += [(0, 0, MAX), (MAX, 0, MAX)]
    vs += [(0, 0, MAX), (MAX, 0, MAX)]

    # Event types
    VST, H, VEN = (0, 1, 2)
    events = []
    for y, l, r in hs:
        events += [(y, H, (l, r))]

    for x, l, r in vs:
        events += [(l, VST, x)]
        events += [(r, VEN, x)]

    events.sort()
    debug_print(events)

    st = SegmentTree([0]*MAX, func=lambda x, y: x+y)
    newv = SortedList()
    ans = 0

    for y, t, d in events:
        if t == VST:
            newv.add(d)
        elif t == H:
            l, r = d
            cnt = st.query(l, r+1)
            ans += max(0, cnt-1)

            if l == 0:
                pos = newv.bisect_right(r)
                for _ in range(pos):
                    x = newv.pop(0)
                    st[x] = 1
            else:
                pos = newv.bisect_left(l)
                while len(newv) > pos:
                    x = newv.pop()
                    st[x] = 1
        elif t == VEN:
            newv.discard(d)
            st[d] = 0

    print(ans)


# Constants
INF = float('inf')
MOD = 10**9+7
alphabets = 'abcdefghijklmnopqrstuvwxyz'

# Python3 equivalent names
import os, sys, itertools
if sys.version_info[0] < 3:
    input = raw_input
    range = xrange

    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip

# print-flush in interactive problems
if _interactive:
    flush = sys.stdout.flush
    def printf(*args, **kwargs):
        print(*args, **kwargs)
        flush()

# Debug print, only works on local machine
LOCAL = ""LOCAL_"" in os.environ
debug_print = (print) if LOCAL else (lambda *x, **y: None)

# Fast IO
if (not LOCAL) and (not _interactive):
    from io import BytesIO
    from atexit import register
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
    sys.stdout = BytesIO()
    register(lambda: os.write(1, sys.stdout.getvalue()))
    input = lambda: sys.stdin.readline().rstrip('\r\n')

# Some utility functions(Input, N-dimensional lists, ...)
def input_as_list():
    return [int(x) for x in input().split()]

def input_with_offset(o):
    return [int(x)+o for x in input().split()]

def input_as_matrix(n, m):
    return [input_as_list() for _ in range(n)]

def array_of(f, *dim):
    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()

class SegmentTree:
    def __init__(self, data, default=0, func=max):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        """"""func of data[start, stop)""""""
        start += self._size
        stop += self._size

        res_left = res_right = self._default
        while start < stop:
            if start & 1:
                res_left = self._func(res_left, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res_right = self._func(self.data[stop], res_right)
            start >>= 1
            stop >>= 1

        return self._func(res_left, res_right)

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len

    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)

    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))

main()","['data structures', 'geometry', 'implementation', 'sortings']"
"Bertown has n junctions and m bidirectional roads. We know that one can get from any junction to any other one by the existing roads. As there were more and more cars in the city, traffic jams started to pose real problems. To deal with them the government decided to make the traffic one-directional on all the roads, thus easing down the traffic. Your task is to determine whether there is a way to make the traffic one-directional so that there still is the possibility to get from any junction to any other one. If the answer is positive, you should also find one of the possible ways to orient the roads.","from sys import stdin,stdout,setrecursionlimit
from collections import  defaultdict
from threading import stack_size,Thread
setrecursionlimit(10**6)
stack_size(2**25)
edge=defaultdict(list)
bridge=False
vis=[0]*(100001)
low=[0]*(100001)
inTime=[0]*(100001)
timer=0
ans=[]
def dfs(node,parent):
    global edge, vis, inTime, low, ans, bridge,timer
    vis[node]=1
    low[node]=timer
    inTime[node]=timer
    timer+=1
    for j in edge[node]:
        if j==parent:
            continue
        if vis[j]==1:
            low[node]=min(low[node],inTime[j])
            if inTime[node]>inTime[j]:
                ans.append([node,j])
        else:
            dfs(j,node)
            if low[j]>inTime[node]:
                bridge=True
                return
            ans.append([node,j])
            low[node]=min(low[node],low[j])
def solve():
    n,m=map(int,stdin.readline().split())
    global edge, vis, inTime, low, ans, bridge,timer
    timer=0
    bridge=False
    for i in range(m):
        u,v=map(int,stdin.readline().split())
        edge[u].append(v)
        edge[v].append(u)
    dfs(1,-1)
    if bridge:
        print(0)
    else:
        for i in range(len(ans)):
            print(*ans[i])
if __name__=='__main__':
	Thread(target=solve).start()","['dfs and similar', 'graphs']"
"Giant chess is quite common in Geraldion. We will not delve into the rules of the game, we'll just say that the game takes place on an h × w field, and it is painted in two colors, but not like in chess. Almost all cells of the field are white and only some of them are black. Currently Gerald is finishing a game of giant chess against his friend Pollard. Gerald has almost won, and the only thing he needs to win is to bring the pawn from the upper left corner of the board, where it is now standing, to the lower right corner. Gerald is so confident of victory that he became interested, in how many ways can he win?The pawn, which Gerald has got left can go in two ways: one cell down or one cell to the right. In addition, it can not go to the black cells, otherwise the Gerald still loses. There are no other pawns or pieces left on the field, so that, according to the rules of giant chess Gerald moves his pawn until the game is over, and Pollard is just watching this process.","#from sys import setrecursionlimit as srl
import sys
if sys.subversion[0] == ""PyPy"":
    import io, atexit
    sys.stdout = io.BytesIO()
    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))
    
    sys.stdin = io.BytesIO(sys.stdin.read())
    input = lambda: sys.stdin.readline().rstrip()
 
RS = raw_input
RI = lambda x=int: map(x,RS().split())
RN = lambda x=int: x(RS())
''' ...................................................................... '''
mod = 10**9+7

n,m,k = RI()
grid = [RI() for i in xrange(k)]
grid.sort()
grid.append([n,m])
dp = [0]*(k+1)

N = 2*max(n,m)
fact = [1]*N
inv = [1]*N

for i in xrange(1,N):
    fact[i] = (fact[i-1]*i) % mod
    inv[i] = (inv[i-1]*pow(i,mod-2,mod))%mod

def fun(x1,y1,x2,y2):
    dx = x1-x2
    dy = y1-y2
    return (fact[dx+dy]*inv[dx]*inv[dy])%mod

for i in xrange(k+1):
    x,y = grid[i]
    tot = fun(x,y,1,1)
    for j in xrange(i):
        if grid[j][0]<=x and grid[j][1]<=y:
            rem = (dp[j]*fun(x,y,grid[j][0],grid[j][1]))%mod
            tot = (tot-rem)%mod
    dp[i] = tot
print dp[k]","['dp', 'combinatorics', 'number theory', 'math']"
"Let's call the following process a transformation of a sequence of length $$$n$$$.If the sequence is empty, the process ends. Otherwise, append the greatest common divisor (GCD) of all the elements of the sequence to the result and remove one arbitrary element from the sequence. Thus, when the process ends, we have a sequence of $$$n$$$ integers: the greatest common divisors of all the elements in the sequence before each deletion.You are given an integer sequence $$$1, 2, \dots, n$$$. Find the lexicographically maximum result of its transformation.A sequence $$$a_1, a_2, \ldots, a_n$$$ is lexicographically larger than a sequence $$$b_1, b_2, \ldots, b_n$$$, if there is an index $$$i$$$ such that $$$a_j = b_j$$$ for all $$$j &lt; i$$$, and $$$a_i &gt; b_i$$$.","N = input()
ls = range(1,N+1)
while len(ls) > 3:
    nls = ls[1::2]
    for i in xrange(len(ls) - len(nls)):
        print ls[0],
    ls = nls
if len(ls)==3:
    print ls[0], ls[0], ls[2]
elif len(ls)==2:
    print ls[0], ls[1]
else:
    print ls[0]","['constructive algorithms', 'math']"
"This problem is different with hard version only by constraints on total answers lengthIt is an interactive problemVenya joined a tour to the madhouse, in which orderlies play with patients the following game. Orderlies pick a string $$$s$$$ of length $$$n$$$, consisting only of lowercase English letters. The player can ask two types of queries:   ? l r – ask to list all substrings of $$$s[l..r]$$$. Substrings will be returned in random order, and in every substring, all characters will be randomly shuffled.  ! s – guess the string picked by the orderlies. This query can be asked exactly once, after that the game will finish. If the string is guessed correctly, the player wins, otherwise he loses. The player can ask no more than $$$3$$$ queries of the first type.To make it easier for the orderlies, there is an additional limitation: the total number of returned substrings in all queries of the first type must not exceed $$$(n+1)^2$$$.Venya asked you to write a program, which will guess the string by interacting with the orderlies' program and acting by the game's rules.Your program should immediately terminate after guessing the string using a query of the second type. In case your program guessed the string incorrectly, or it violated the game rules, it will receive verdict Wrong answer.Note that in every test case the string is fixed beforehand and will not change during the game, which means that the interactor is not adaptive.","import sys
import copy
import string
from collections import defaultdict, Counter

def sortString(s):
    return ''.join(sorted(s))

def solve(p1, p2):
    p1 = Counter([sortString(s) for s in p1])
    p2 = Counter([sortString(s) for s in p2])

    for key in p2.keys():
        p1[key] -= p2[key]

    pp = []
    for key, value in p1.items():
        pp += [key] * value
    pp.sort(key=len)

    res = ''
    d = defaultdict(int)
    for bag in pp:
        counter = Counter(bag)
        cur = '#'
        for c in string.ascii_lowercase:
            if d[c] < counter[c]:
                assert cur == '#'
                cur = c
        res += cur
        d = counter
    return res

n = int(raw_input())

print '? 1 %d' % n
print ''
sys.stdout.flush()

p1 = []
m = (1 + n) * n / 2
for i in xrange(m):
    p1.append(raw_input().strip())

if n == 1:
    res = p1[0]
    print '! %s' % res
    print ''
    sys.stdout.flush()
else:
    print '? 2 %d' % n
    print ''
    sys.stdout.flush()

    p2 = []
    m = (1 + n - 1) * (n - 1) / 2
    for i in xrange(m):
        p2.append(raw_input().strip())

    res = solve(p1, p2)
    print '! %s' % res
    print ''
    sys.stdout.flush()","['constructive algorithms', 'interactive']"
"Sereja and his friends went to a picnic. The guys had n soda bottles just for it. Sereja forgot the bottle opener as usual, so the guys had to come up with another way to open bottles.Sereja knows that the i-th bottle is from brand ai, besides, you can use it to open other bottles of brand bi. You can use one bottle to open multiple other bottles. Sereja can open bottle with opened bottle or closed bottle.Knowing this, Sereja wants to find out the number of bottles they've got that they won't be able to open in any way. Help him and find this number.","# count = int(raw_input())
# [int(s) for s in (raw_input()).split()]

def main(data = None):

    if data is None:
        count = raw_input()
        if count == 0:
            return 0
        bottles = [[int(s) for s in (raw_input()).split()] for  i in range(int(count))]

    else:
        count,bottles = data 

    bd = [list(a) for a in zip(bottles,[True,]*len(bottles))]
    
    for bottle in bd:
        opener = bottle[0][1]
        for bottle_n in bd:
            if not (bottle is bottle_n):
                if opener == bottle_n[0][0] :
                    bottle_n[1]=False
    return len([bottle for bottle in bd if bottle[1]])       
        

        
        

if __name__== ""__main__"":

    print main()",['brute force']
"Vasya is pressing the keys on the keyboard reluctantly, squeezing out his ideas on the classical epos depicted in Homer's Odysseus... How can he explain to his literature teacher that he isn't going to become a writer? In fact, he is going to become a programmer. So, he would take great pleasure in writing a program, but none — in writing a composition.As Vasya was fishing for a sentence in the dark pond of his imagination, he suddenly wondered: what is the least number of times he should push a key to shift the cursor from one position to another one?Let's describe his question more formally: to type a text, Vasya is using the text editor. He has already written n lines, the i-th line contains ai characters (including spaces). If some line contains k characters, then this line overall contains (k + 1) positions where the cursor can stand: before some character or after all characters (at the end of the line). Thus, the cursor's position is determined by a pair of integers (r, c), where r is the number of the line and c is the cursor's position in the line (the positions are indexed starting from one from the beginning of the line).Vasya doesn't use the mouse to move the cursor. He uses keys ""Up"", ""Down"", ""Right"" and ""Left"". When he pushes each of these keys, the cursor shifts in the needed direction. Let's assume that before the corresponding key is pressed, the cursor was located in the position (r, c), then Vasya pushed key: ""Up"": if the cursor was located in the first line (r = 1), then it does not move. Otherwise, it moves to the previous line (with number r - 1), to the same position. At that, if the previous line was short, that is, the cursor couldn't occupy position c there, the cursor moves to the last position of the line with number r - 1; ""Down"": if the cursor was located in the last line (r = n), then it does not move. Otherwise, it moves to the next line (with number r + 1), to the same position. At that, if the next line was short, that is, the cursor couldn't occupy position c there, the cursor moves to the last position of the line with number r + 1; ""Right"": if the cursor can move to the right in this line (c &lt; ar + 1), then it moves to the right (to position c + 1). Otherwise, it is located at the end of the line and doesn't move anywhere when Vasya presses the ""Right"" key; ""Left"": if the cursor can move to the left in this line (c &gt; 1), then it moves to the left (to position c - 1). Otherwise, it is located at the beginning of the line and doesn't move anywhere when Vasya presses the ""Left"" key.You've got the number of lines in the text file and the number of characters, written in each line of this file. Find the least number of times Vasya should push the keys, described above, to shift the cursor from position (r1, c1) to position (r2, c2).","from collections import deque


def read(line):
    return [int(c) for c in line.split()]


def solve(n, lines, r1, c1, r2, c2):
    queue = deque([(r1, c1, 0)])
    visited = {}
    while queue:
        r, c, cost = queue.pop()

        if (r, c) not in visited:
            visited[(r, c)] = cost
        else:
            if cost < visited[(r, c)]:
                visited[(r, c)] = cost
            else:
                continue

        # left or right to the target column
        if c2 <= lines[r - 1] + 1:
            queue.appendleft((r, c2, cost + abs(c - c2)))

        # right to last column
        last_pos = lines[r - 1] + 1
        if c < last_pos:
            queue.appendleft((r, last_pos, cost + abs(c - last_pos)))

        # up
        if r - 1 >= 1:
            last_pos_prev = lines[r - 2] + 1
            if last_pos_prev >= c:
                queue.appendleft((r - 1, c, cost + 1))
            else:
                queue.appendleft((r - 1, last_pos_prev, cost + 1))

        # down
        if r + 1 <= n:
            last_pos_next = lines[r] + 1
            if last_pos_next >= c:
                queue.appendleft((r + 1, c, cost + 1))
            else:
                queue.appendleft((r + 1, last_pos_next, cost + 1))

    return visited[(r2, c2)]


def main():
    with open('input.txt') as f:
        test = f.readlines()

    n, = read(test[0])
    lines = read(test[1])
    r1, c1, r2, c2 = read(test[2])
    ans = solve(n, lines, r1, c1, r2, c2)
    with open('output.txt', 'w') as f:
        f.write(str(ans))


if __name__ == ""__main__"":
    main()","['greedy', 'graphs', 'shortest paths', 'data structures', 'dfs and similar']"
"Suppose that you are in a campus and have to go for classes day by day. As you may see, when you hurry to a classroom, you surprisingly find that many seats there are already occupied. Today you and your friends went for class, and found out that some of the seats were occupied.The classroom contains $$$n$$$ rows of seats and there are $$$m$$$ seats in each row. Then the classroom can be represented as an $$$n \times m$$$ matrix. The character '.' represents an empty seat, while '*' means that the seat is occupied. You need to find $$$k$$$ consecutive empty seats in the same row or column and arrange those seats for you and your friends. Your task is to find the number of ways to arrange the seats. Two ways are considered different if sets of places that students occupy differs.","n, m, k = map(int, input().split())
a = [[0] * m for x in range(n)]
s = []
count = 0
for i in range(n):
    s.append(input())
for i in range(n):
    y = 0
    for j in range(m):
        if s[i][j] == ""."":
            if(a[i][j] + 1 >= k and k > 1):
                count += 1
            y +=1
            if y >= k:
                count += 1
            if i + 1 < n:
                a[i + 1][j] = a[i][j] + 1
        else:
            y = 0
            
print(count)","['implementation', 'brute force']"
"Igor is a post-graduate student of chemistry faculty in Berland State University (BerSU). He needs to conduct a complicated experiment to write his thesis, but laboratory of BerSU doesn't contain all the materials required for this experiment.Fortunately, chemical laws allow material transformations (yes, chemistry in Berland differs from ours). But the rules of transformation are a bit strange.Berland chemists are aware of n materials, numbered in the order they were discovered. Each material can be transformed into some other material (or vice versa). Formally, for each i (2 ≤ i ≤ n) there exist two numbers xi and ki that denote a possible transformation: ki kilograms of material xi can be transformed into 1 kilogram of material i, and 1 kilogram of material i can be transformed into 1 kilogram of material xi. Chemical processing equipment in BerSU allows only such transformation that the amount of resulting material is always an integer number of kilograms.For each i (1 ≤ i ≤ n) Igor knows that the experiment requires ai kilograms of material i, and the laboratory contains bi kilograms of this material. Is it possible to conduct an experiment after transforming some materials (or none)?","import sys

# @profile
def main():
    f = sys.stdin
    # f = open('input.txt', 'r')
    # fo = open('log.txt', 'w')
    n = int(f.readline())
    # b = []
    # for i in range(n):
    #    b.append()
    b = list(map(int, f.readline().strip().split(' ')))
    a = list(map(int, f.readline().strip().split(' ')))
    # return
    b = [b[i] - a[i] for i in range(n)]
    c = [[0, 0]]
    for i in range(n - 1):
        line = f.readline().strip().split(' ')
        c.append([int(line[0]), int(line[1])])
    # print(c)
    for i in range(n - 1, 0, -1):
        # print(i)
        fa = c[i][0] - 1
        if b[i] >= 0:
            b[fa] += b[i]
        else:
            b[fa] += b[i] * c[i][1]
            if b[fa] < -1e17:
                print('NO')
                return 0
    # for x in b:
    #    fo.write(str(x) + '\n')
    if b[0] >= 0:
        print('YES')
    else:
        print('NO')

main()","['greedy', 'dfs and similar', 'trees']"
"Adilbek was assigned to a special project. For Adilbek it means that he has $$$n$$$ days to run a special program and provide its results. But there is a problem: the program needs to run for $$$d$$$ days to calculate the results.Fortunately, Adilbek can optimize the program. If he spends $$$x$$$ ($$$x$$$ is a non-negative integer) days optimizing the program, he will make the program run in $$$\left\lceil \frac{d}{x + 1} \right\rceil$$$ days ($$$\left\lceil a \right\rceil$$$ is the ceiling function: $$$\left\lceil 2.4 \right\rceil = 3$$$, $$$\left\lceil 2 \right\rceil = 2$$$). The program cannot be run and optimized simultaneously, so the total number of days he will spend is equal to $$$x + \left\lceil \frac{d}{x + 1} \right\rceil$$$.Will Adilbek be able to provide the generated results in no more than $$$n$$$ days?","from math import *
for _ in range(int(input())):
    n,d=map(int,input().split())
    if d<=n:
        print(""YES"")
    else:
        for i in range(1,int(sqrt(d))+1):
            if ceil(d/(i+1))+i<=n:
                print(""YES"")
                break
        else:

            print(""NO"")","['binary search', 'ternary search', 'math', 'brute force']"
"Jack has become a soldier now. Unfortunately, he has trouble with the drill. Instead of marching beginning with the left foot and then changing legs with each step, as ordered, he keeps repeating a sequence of steps, in which he sometimes makes the wrong steps or — horror of horrors! — stops for a while. For example, if Jack uses the sequence 'right, left, break', when the sergeant yells: 'Left! Right! Left! Right! Left! Right!', Jack first makes a step with the right foot, then one with the left foot, then he is confused and stops for a moment, then again - this time according to the order - starts with the right foot, then uses the left foot, then - to the sergeant's irritation - he stops to catch his breath, to incorrectly start with the right foot again... Marching this way, Jack will make the step that he is supposed to in the given moment in only one third of cases.When the officers convinced him he should do something about it, Jack decided to modify the basic sequence of steps that he repeats. However, in order not to get too tired, he has decided that the only thing he'll do is adding any number of breaks in any positions of the original sequence (a break corresponds to stopping for the duration of one step). Of course, Jack can't make a step on the same foot twice in a row, if there is no pause between these steps. It is, however, not impossible that the sequence of steps he used so far is incorrect (it would explain a lot, actually).Help Private Jack! Given the sequence of steps he keeps repeating, calculate the maximal percentage of time that he can spend marching correctly after adding some breaks to his scheme.","__author__ = 'Darren'


def solve():
    original = input()
    temp = [original[0]]
    for i in range(1, len(original)):
        if original[i] == original[i-1] != 'X':
            temp.append('X')
        temp.append(original[i])
    augmented = ''.join(temp)
    answer = 0
    if augmented[0] == augmented[-1] != 'X':
        answer = max(rate(augmented+'X'), rate('X'+augmented))
    else:
        answer = rate(augmented)
    print('%d.%06d' % (answer / 1000000, answer % 1000000))


def rate(seq):
    correct, total, unknown, indicator = 0, 0, 0, 0
    left_step = True
    for action in seq:
        if action == 'X':
            total += 1
            left_step = not left_step
        else:
            if left_step and action == 'L' or not left_step and action == 'R':
                correct += 1
                total += 1
                indicator = 0
                left_step = not left_step
            else:
                correct += 1
                total += 2
                unknown += indicator
                indicator = 1 - indicator
    if total % 2 == 1:
        total += 1
        unknown += indicator
    if correct * 2 > total:
        correct -= unknown
        total -= unknown * 2
    return correct * 100000000 // total


if __name__ == '__main__':
    solve()","['dp', 'binary search', 'greedy']"
"The last product of the R2 company in the 2D games' field is a new revolutionary algorithm of searching for the shortest path in a 2 × n maze.Imagine a maze that looks like a 2 × n rectangle, divided into unit squares. Each unit square is either an empty cell or an obstacle. In one unit of time, a person can move from an empty cell of the maze to any side-adjacent empty cell. The shortest path problem is formulated as follows. Given two free maze cells, you need to determine the minimum time required to go from one cell to the other.Unfortunately, the developed algorithm works well for only one request for finding the shortest path, in practice such requests occur quite often. You, as the chief R2 programmer, are commissioned to optimize the algorithm to find the shortest path. Write a program that will effectively respond to multiple requests to find the shortest path in a 2 × n maze.","from sys import stdin, stdout
from bisect import bisect_left
def main():
    RL = lambda: stdin.readline()
    read_ints = lambda: map(int, RL().split())
    n, m = read_ints()
    s = RL().strip()
    t = RL().strip()
    ma = [0] * n
    sps = []
    for i in xrange(n):
        if s[i] == 'X':
            ma[i] += 1
        if t[i] == 'X':
            ma[i] += 2
        if ma[i]:
            sps.append(i)
    gr = [0] * n
    c = 0
    for i in xrange(n-1):
        gr[i] = c
        if (ma[i] | ma[i+1]) == 3:
            c += 1
    gr[-1] = c
    def coor(v):
        h = 0 if v <= n else 1
        w = v-1 if v <= n else v-n-1
        return (h, w)
    l = len(sps)
    def nei(w):
        return bisect_left(sps, w)
    dif = [0]
    for i in xrange(l-1):
        dif.append(dif[-1])
        if (ma[sps[i]] & ma[sps[i+1]]) == 0:
            dif[-1] += 1
    dif.append(dif[-1])
    ans = []
    for _ in xrange(m):
        v, w = map(coor, read_ints())
        if gr[v[1]] != gr[w[1]]:
            ans.append(-1)
            continue
        if v[1] > w[1]:
            v, w = w, v
        vidx, widx = map(nei, (v[1], w[1]))
        #print vidx, widx, sps[vidx], sps[widx]
        if vidx == widx:
            ans.append(w[1] - v[1] + (0 if v[0] == w[0] else 1))
            continue
        l0 = sps[vidx] - v[1] + (0 if v[0] == 2-ma[sps[vidx]] else 1)
        widx -= 1
        l1 = dif[widx] - dif[vidx] + sps[widx] - sps[vidx]
        l2 = w[1] - sps[widx] + (0 if w[0] == 2-ma[sps[widx]] else 1)
        #print l0, l1, l2
        ans.append(l0 + l1 + l2)
    stdout.write('\n'.join(map(str, ans)))
main()","['data structures', 'divide and conquer']"
"You are given a n × m field consisting only of periods ('.') and asterisks ('*'). Your task is to count all right triangles with two sides parallel to the square sides, whose vertices are in the centers of '*'-cells. A right triangle is a triangle in which one angle is a right angle (that is, a 90 degree angle).","u=input
n,m=map(int,u().split())
l=[list(u()) for _ in range(n)]
R=[p.count('*') for p in l]
C=[p.count('*') for p in zip(*l)]
t=0
for i in range(n):
 for j in range(m):
  if(l[i][j]=='*'):
   t+=(R[i]-1)*(C[j]-1)
print(t)",['combinatorics']
"In the rush of modern life, people often forget how beautiful the world is. The time to enjoy those around them is so little that some even stand in queues to several rooms at the same time in the clinic, running from one queue to another.(Cultural note: standing in huge and disorganized queues for hours is a native tradition in Russia, dating back to the Soviet period. Queues can resemble crowds rather than lines. Not to get lost in such a queue, a person should follow a strict survival technique: you approach the queue and ask who the last person is, somebody answers and you join the crowd. Now you're the last person in the queue till somebody else shows up. You keep an eye on the one who was last before you as he is your only chance to get to your destination) I'm sure many people have had the problem when a stranger asks who the last person in the queue is and even dares to hint that he will be the last in the queue and then bolts away to some unknown destination. These are the representatives of the modern world, in which the ratio of lack of time is so great that they do not even watch foreign top-rated TV series. Such people often create problems in queues, because the newcomer does not see the last person in the queue and takes a place after the ""virtual"" link in this chain, wondering where this legendary figure has left.The Smart Beaver has been ill and he's made an appointment with a therapist. The doctor told the Beaver the sad news in a nutshell: it is necessary to do an electrocardiogram. The next day the Smart Beaver got up early, put on the famous TV series on download (three hours till the download's complete), clenched his teeth and bravely went to join a queue to the electrocardiogram room, which is notorious for the biggest queues at the clinic.Having stood for about three hours in the queue, the Smart Beaver realized that many beavers had not seen who was supposed to stand in the queue before them and there was a huge mess. He came up to each beaver in the ECG room queue and asked who should be in front of him in the queue. If the beaver did not know his correct position in the queue, then it might be his turn to go get an ECG, or maybe he should wait for a long, long time...As you've guessed, the Smart Beaver was in a hurry home, so he gave you all the necessary information for you to help him to determine what his number in the queue can be.","n, x = map(int, input().split())

a = [-10000] + list(map(int, input().split()))

ceps = []
ones = 0
was = set()

for i in range(1, n+1):
    if i not in was and i not in a:
        cep = [i]
        while a[i]:
            cep.append(a[i])
            i = a[i]
        for i in cep:
            was.add(i)
        #print(cep)
        if x in cep:
            r = cep.index(x)
            l = len(cep) - r - 1
        else:
            if len(cep) == 1:
                ones += 1
            else:
                ceps.append(len(cep))

import itertools

sums = set(ceps)
for i in range(2, len(ceps)+1):
    for comb in itertools.combinations(ceps, i):
        sums.add(sum(comb))
sums.add(0)

poss = set()
#print(l + 1)
for s in sums:
    for i in range(ones+1):
        poss.add(l + s + 1 + i)
    #print(l + s + 1)

for pos in sorted(poss):
    print(pos)","['dfs and similar', 'brute force']"
"There are $$$n$$$ students standing in a row. Two coaches are forming two teams — the first coach chooses the first team and the second coach chooses the second team.The $$$i$$$-th student has integer programming skill $$$a_i$$$. All programming skills are distinct and between $$$1$$$ and $$$n$$$, inclusive.Firstly, the first coach will choose the student with maximum programming skill among all students not taken into any team, and $$$k$$$ closest students to the left of him and $$$k$$$ closest students to the right of him (if there are less than $$$k$$$ students to the left or to the right, all of them will be chosen). All students that are chosen leave the row and join the first team. Secondly, the second coach will make the same move (but all students chosen by him join the second team). Then again the first coach will make such move, and so on. This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).Your problem is to determine which students will be taken into the first team and which students will be taken into the second team.","n, k = tuple([int(i) for i in input().split()])
#places = [None] * (n)
data = [int(i) for i in input().split()]
nextup = {}
nextdown = {}
nextup[data[n-1]] = -1
nextdown[data[0]] = -1
for i in range(n-1):
    #places[data[i] - 1] = i
    nextup[data[i]] = data[i+1]
    nextdown[data[i+1]] = data[i]
#results = [None] * (n)
# def take(a):
#     global nextdown
#     global nextup
#     global l
#     # print(nextup)
#     # print(nextdown)
#     # print(a)
#     # print(char)
#     # print(l)

#     b = a 
#     c = a 
#     l[a-1] = char
#     found = 0
#     #global places
#     #global data
#     #places[a] = -1
#     while found < k:
#         #print(places)
#         t = nextdown[b]
#         #print(t)
#         if t == -1:
#             break
#         found += 1
#         l[t-1] = char
#         b = t
        
#     found = 0
#     while found < k:
#         #print(places)
        
#         t = nextup[c]
#         #print(t)
#         if t == -1:
#             break
#         found += 1
#         l[t-1] = char
#         c = t
    
#     # for i in data:
#     #     if type(l[i-1]) == int:
#     #         print('?', end='')       
#     #     else:
#     #         print(l[i-1], end='')
#     # # print()
#     # print(b, c)
#     # print('==============')
#     nextdown[nextup[c]] = nextdown[b]
#     nextup[nextdown[b]] = nextup[c]
#     # print('------')
#     # print(data)


##ups = {}
#downs = {}
#places.reverse()
l = list(range(1, n+1))
switch = {'1':'2', '2':'1'}
char = '2'
for j in range(n-1, -1, -1):
    i = l[j]    
    if type(i) == int:
        char = switch[char]
        b = i 
        c = i 
        l[i-1] = char
        found = 0
        #global places
        #global data
        #places[a] = -1
        while found < k:
            #print(places)
            t = nextdown[b]
            #print(t)
            if t == -1:
                break
            found += 1
            l[t-1] = char
            b = t
            
        found = 0
        while found < k:
            #print(places)
            
            t = nextup[c]
            #print(t)
            if t == -1:
                break
            found += 1
            l[t-1] = char
            c = t
        
        # for i in data:
        #     if type(l[i-1]) == int:
        #         print('?', end='')       
        #     else:
        #         print(l[i-1], end='')
        # # print()
        # print(b, c)
        # print('==============')
        nextdown[nextup[c]] = nextdown[b]
        nextup[nextdown[b]] = nextup[c]
#print(l)
for i in data:
    print(l[i-1], end='')
print()","['data structures', 'implementation', 'sortings']"
"A programming coach has n students to teach. We know that n is divisible by 3. Let's assume that all students are numbered from 1 to n, inclusive.Before the university programming championship the coach wants to split all students into groups of three. For some pairs of students we know that they want to be on the same team. Besides, if the i-th student wants to be on the same team with the j-th one, then the j-th student wants to be on the same team with the i-th one. The coach wants the teams to show good results, so he wants the following condition to hold: if the i-th student wants to be on the same team with the j-th, then the i-th and the j-th students must be on the same team. Also, it is obvious that each student must be on exactly one team.Help the coach and divide the teams the way he wants.","from collections import defaultdict
n,m = list(map(int,input().split()))
if m==0:
    for i in range(1,n+1,3):
        print(i,i+1,i+2)
else:
    graph = defaultdict(list)
    for i in range(m):
        u,v = list(map(int,input().split()))
        graph[u].append(v)
        graph[v].append(u)
    visited = [False for i in range(n)]
    d = {}
    for i in range(n):
        if visited[i]==False:
            cur = i+1
            q = []
            q.append(cur)
            d[cur] = [cur]
            while q!=[]:
                u = q.pop(0)
                for k in graph[u]:
                    if visited[k-1]==False:
                        visited[k-1] = True
                        q.append(k)
                        d[cur].append(k)
    for i in d:
        d[i] = list(set(d[i]))
    f = 0
    for i in d:
        if len(d[i])>3:
            f = 1
            break
    if f==1:
        print(-1)
    else:
        cnt1,cnt2,cnt3 = [],[],[]
        for i in d:
            if len(d[i])==1:
                cnt1.append(d[i])
            elif len(d[i])==2:
                cnt2.append(d[i])
            elif len(d[i])==3:
                cnt3.append(d[i])
        if (len(cnt1)-len(cnt2))%3!=0 or len(cnt1)<len(cnt2):
            print(-1)
        else:
            for i in cnt3:
                print(*i)
            for i in range(len(cnt2)):
                x = cnt1[i]+cnt2[i]
                print(*x)
            for i in range(len(cnt2),len(cnt1),3):
                x = cnt1[i]+cnt1[i+1]+cnt1[i+2]
                print(*x)","['dfs and similar', 'brute force', 'graphs']"
"Helen works in Metropolis airport. She is responsible for creating a departure schedule. There are n flights that must depart today, the i-th of them is planned to depart at the i-th minute of the day.Metropolis airport is the main transport hub of Metropolia, so it is difficult to keep the schedule intact. This is exactly the case today: because of technical issues, no flights were able to depart during the first k minutes of the day, so now the new departure schedule must be created.All n scheduled flights must now depart at different minutes between (k + 1)-th and (k + n)-th, inclusive. However, it's not mandatory for the flights to depart in the same order they were initially scheduled to do so — their order in the new schedule can be different. There is only one restriction: no flight is allowed to depart earlier than it was supposed to depart in the initial schedule.Helen knows that each minute of delay of the i-th flight costs airport ci burles. Help her find the order for flights to depart in the new schedule that minimizes the total cost for the airport.","from sys import stdin, stdout
from itertools import repeat
from heapq import heappushpop, heapify
def main():
    n, k = map(int, stdin.readline().split())
    a = map(int, stdin.readline().split(), repeat(10, n))
    q = [(-a[i], i) for i in xrange(k)]
    heapify(q)
    ans = 0
    pos = [0] * n
    for i in xrange(k, n):
        x, j = heappushpop(q, (-a[i], i))
        ans -= x * (i - j)
        pos[j] = i + 1
    q.sort()
    for i in xrange(k):
        x, j = q[i]
        ans -= x * (i + n - j)
        pos[j] = i + n + 1
    print ans
    stdout.write("" "".join(map(str, pos)))
main()",['greedy']
"There will be a launch of a new, powerful and unusual collider very soon, which located along a straight line. n particles will be launched inside it. All of them are located in a straight line and there can not be two or more particles located in the same point. The coordinates of the particles coincide with the distance in meters from the center of the collider, xi is the coordinate of the i-th particle and its position in the collider at the same time. All coordinates of particle positions are even integers.You know the direction of each particle movement — it will move to the right or to the left after the collider's launch start. All particles begin to move simultaneously at the time of the collider's launch start. Each particle will move straight to the left or straight to the right with the constant speed of 1 meter per microsecond. The collider is big enough so particles can not leave it in the foreseeable time.Write the program which finds the moment of the first collision of any two particles of the collider. In other words, find the number of microseconds before the first moment when any two particles are at the same point.","n=input()
s=raw_input()
a=map(int,raw_input().split())
t=1<<63
for i in range(1,n):
  if 'R'==s[i-1] and 'L'==s[i]:
    t=min(t,a[i]-a[i-1])
print t/2 if t<1<<63 else -1",['implementation']
"Little Vasya went to the supermarket to get some groceries. He walked about the supermarket for a long time and got a basket full of products. Now he needs to choose the cashier to pay for the products.There are n cashiers at the exit from the supermarket. At the moment the queue for the i-th cashier already has ki people. The j-th person standing in the queue to the i-th cashier has mi, j items in the basket. Vasya knows that:  the cashier needs 5 seconds to scan one item;  after the cashier scans each item of some customer, he needs 15 seconds to take the customer's money and give him the change. Of course, Vasya wants to select a queue so that he can leave the supermarket as soon as possible. Help him write a program that displays the minimum number of seconds after which Vasya can get to one of the cashiers.","import fileinput

f = fileinput.input()
n = int(f.readline())
ks = []
line = f.readline()
ks = map(int, line.split())
ms = []
for i in range(n):
    ms.append(map(int, f.readline().split()))


def time(n):
    return sum(ms[n]) * 5 + ks[n] * 15

print min(map(time, range(n)))",['implementation']
"Mishka received a gift of multicolored pencils for his birthday! Unfortunately he lives in a monochrome world, where everything is of the same color and only saturation differs. This pack can be represented as a sequence a1, a2, ..., an of n integer numbers — saturation of the color of each pencil. Now Mishka wants to put all the mess in the pack in order. He has an infinite number of empty boxes to do this. He would like to fill some boxes in such a way that:  Each pencil belongs to exactly one box;  Each non-empty box has at least k pencils in it;  If pencils i and j belong to the same box, then |ai - aj| ≤ d, where |x| means absolute value of x. Note that the opposite is optional, there can be pencils i and j such that |ai - aj| ≤ d and they belong to different boxes. Help Mishka to determine if it's possible to distribute all the pencils into boxes. Print ""YES"" if there exists such a distribution. Otherwise print ""NO"".","import heapq

def run():
    n, k, d = map(int, input().split())
    a = sorted(map(int, input().split()))

    max_size = [None] * n  # how many pencils can be in box starting with this one
    start = 0
    end = 0
    while start < n:
        while end < n-1 and a[end+1] - a[start] <= d:
            end += 1
        max_size[start] = end - start + 1
        start += 1

    possilbe_starts = []
    # heap with starts and stops of intervals where new box can start
    # - all pencils before that are successfully boxed
    heapq.heappush(possilbe_starts, (0, ""start""))
    heapq.heappush(possilbe_starts, (1, ""stop""))

    number_of_opened = 0  # number of opened intervals

    for pencil in range(n):
        while possilbe_starts and possilbe_starts[0][0] <= pencil:
            top = heapq.heappop(possilbe_starts)
            number_of_opened += (1 if top[1] == ""start"" else -1)
        if number_of_opened <= 0:
            continue
        if max_size[pencil] < k:
            continue
        if pencil + max_size[pencil] + 1 > n:
            print(""YES"")
            break
        heapq.heappush(possilbe_starts, (pencil + k, ""start""))
        heapq.heappush(possilbe_starts, (pencil + max_size[pencil] + 1, ""stop""))
    else:
        print(""NO"")

run()","['dp', 'greedy', 'two pointers', 'data structures', 'binary search']"
"You have given tree consist of $$$n$$$ vertices. Select a vertex as root vertex that satisfies the condition below.  For all vertices $$$v_{1}$$$ and $$$v_{2}$$$, if $$$distance$$$($$$root$$$, $$$v_{1}$$$) $$$= distance$$$($$$root$$$, $$$v_{2})$$$ then $$$degree$$$($$$v_{1}$$$) $$$= degree$$$($$$v_{2}$$$), where $$$degree$$$ means the number of vertices connected to that vertex, and $$$distance$$$ means the number of edges between two vertices. Determine and find if there is such root vertex in the tree. If there are multiple answers, find any of them.","#!/usr/bin/env python
def longest_path():
    try:
        d = [-1 for _ in range(n)]
        d[0] = 0; q = [0]
        for i in range(n):
            f = q[i]
            for t in g[f]:
                if d[t] == -1:
                    q.append(t)
                    d[t] = d[f] + 1
        u = q[-1]
        d = [-1 for _ in range(n)]
        p = [-1 for _ in range(n)]
        d[u] = 0; q = [u]
        for i in range(n):
            f = q[i]
            for t in g[f]:
                if d[t] == -1:
                    q.append(t)
                    d[t] = d[f] + 1
                    p[t] = f
        v = q[-1]
        ld = d[v]
        w = v
        if ld & 1:
            return u, v, None
        while d[w] != (ld >> 1):
            w = p[w]
        return u, v, w
    except:
        print(f'Error raised in longest_path()')


def top(u):
    try:
        if u is None:
            return False
        dist = [-1 for _ in range(n)]
        deg = [-1 for _ in range(n)]
        dist[u] = 0; q = [u]
        for i in range(n):
            f = q[i]
            if deg[dist[f]] == -1:
                deg[dist[f]] = len(g[f])
            elif len(g[f]) != deg[dist[f]]:
                return False
            for t in g[f]:
                if dist[t] == -1:
                    q.append(t)
                    dist[t] = dist[f] + 1
        return True
    except:
        print(f'Error raised in top({u})')


def semitop(w):
    try:
        if w is None:
            return False, None
        d = [-1 for _ in range(n)]
        d[w] = 0; q = [w]; i = 0
        while i < len(q):
            f = q[i]
            for t in g[f]:
                if d[t] == -1:
                    if len(g[t]) != 2:
                        d[t] = 100_500
                        if top(t):
                            return True, t
                    else:
                        d[t] = d[f] + 1
                        q.append(t)
            i += 1
        return False, None
    except:
        print(f'Error raised in semitop({w})')


try:
    n = int(input())
    g = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = map(lambda _: int(_) - 1, input().split())
        g[u].append(v); g[v].append(u)
    u, v, w = longest_path()

    if top(u):
        print(u + 1)
    elif top(v):
        print(v + 1)
    elif top(w):
        print(w + 1)
    else:
        k, t = semitop(w)
        if k:
            print(t + 1)
        else:
            print(-1)
except:
    print(f'Error raised in main')","['dp', 'hashing', 'constructive algorithms', 'implementation', 'dfs and similar', 'trees']"
"User ainta loves to play with cards. He has a cards containing letter ""o"" and b cards containing letter ""x"". He arranges the cards in a row, and calculates the score of the deck by the formula below.  At first, the score is 0.  For each block of contiguous ""o""s with length x the score increases by x2.  For each block of contiguous ""x""s with length y the score decreases by y2.   For example, if a = 6, b = 3 and ainta have arranged the cards in the order, that is described by string ""ooxoooxxo"", the score of the deck equals 22 - 12 + 32 - 22 + 12 = 9. That is because the deck has 5 blocks in total: ""oo"", ""x"", ""ooo"", ""xx"", ""o"".User ainta likes big numbers, so he wants to maximize the score with the given cards. Help ainta make the score as big as possible. Note, that he has to arrange all his cards.","a, b = map(int, input().split())
sx = lambda p: (a - p + 1) ** 2 + p - 1
sy = lambda q: (b % q) * (1 + b // q) ** 2 + (b // q) ** 2 * (q - b % q)
n = min(a, b)

if a == 0:
    print( -b ** 2)
    print( b * ""x"" )

elif b <= 1:
    print( a ** 2 - b ** 2 )
    print ( a * ""o"" + b * ""x"" )

else:
    res = - (a + b) ** 2
    for p in range(1, n + 1):
        for q in range(p-1, p+2):
            if(1 <= q <= b):
                pos = sx( p )
                neg = sy( q )
                if res < pos - neg:
                    res = pos - neg
                    res_p = p
                    res_q = q
    print( res )

    s = """"
    if res_p >= res_q:
        for i in range(res_p):
            wl = 1 if i > 0 else a - (res_p-1)
            s += wl * ""x""
            ll = b // res_q + 1 if i < b % res_q else b // res_q
            if i < res_q: s += ll * ""o""
    else:
        for i in range(res_q):
            ll = b // res_q + 1 if i < b % res_q else b // res_q;
            s += ll * ""x""
            wl = 1 if i > 0 else a - (res_p-1)
            if i < res_p: s+= wl * ""o""
    print( s )",['number theory']
"This is the second subtask of problem F. The only differences between this and the first subtask are the constraints on the value of $$$m$$$ and the time limit. It is sufficient to solve this subtask in order to hack it, but you need to solve both subtasks in order to hack the first one.There are $$$n+1$$$ distinct colours in the universe, numbered $$$0$$$ through $$$n$$$. There is a strip of paper $$$m$$$ centimetres long initially painted with colour $$$0$$$. Alice took a brush and painted the strip using the following process. For each $$$i$$$ from $$$1$$$ to $$$n$$$, in this order, she picks two integers $$$0 \leq a_i &lt; b_i \leq m$$$, such that the segment $$$[a_i, b_i]$$$ is currently painted with a single colour, and repaints it with colour $$$i$$$. Alice chose the segments in such a way that each centimetre is now painted in some colour other than $$$0$$$. Formally, the segment $$$[i-1, i]$$$ is painted with colour $$$c_i$$$ ($$$c_i \neq 0$$$). Every colour other than $$$0$$$ is visible on the strip.Count the number of different pairs of sequences $$$\{a_i\}_{i=1}^n$$$, $$$\{b_i\}_{i=1}^n$$$ that result in this configuration. Since this number may be large, output it modulo $$$998244353$$$.","import sys
range = xrange
input = raw_input

MOD = 998244353 

m,n = [int(x) for x in input().split()]
C = [int(x) - 1 for x in input().split()]

C2 = [C[0]]
for c in C:
    if C2[-1] != c: 
        C2.append(c)
C = C2
n = len(C)

if n > 2*m:
    print 0
    sys.exit()

pos = [[] for _ in range(n)]
for i in range(n):
    pos[C[i]].append(i)


DP = [[1]*(n + 1) for _ in range(n + 1)]
for le in range(1, n + 1):
    for i in range(n - le + 1):
        j = i + le
        k1 = min(range(i,j), key = C.__getitem__)
        c = C[k1]

        k1 = pos[c][0]
        k2 = pos[c][-1]

        ans1 = 0
        for split in range(i,k1 + 1):
            ans1 += DP[i][split] * DP[split][k1] % MOD   
        
        ans2 = 0
        for split in range(k2+1, j + 1):
            ans2 += DP[k2 + 1][split] * DP[split][j] % MOD

        posc = pos[c]
        for ind in range(len(posc) - 1):
            ans1 = (ans1 * DP[posc[ind] + 1][posc[ind + 1]] % MOD)

        DP[i][j] = int((ans1 % MOD) * (ans2 % MOD) % MOD)

print DP[0][n]",['dp']
Ann and Borya have n piles with candies and n is even number. There are ai candies in pile with number i.Ann likes numbers which are square of some integer and Borya doesn't like numbers which are square of any integer. During one move guys can select some pile with candies and add one candy to it (this candy is new and doesn't belong to any other pile) or remove one candy (if there is at least one candy in this pile). Find out minimal number of moves that is required to make exactly n / 2 piles contain number of candies that is a square of some integer and exactly n / 2 piles contain number of candies that is not a square of any integer.,"n = int(input())
li = input().strip().split(' ')
nums=[]
ct=0
zeros=0
for i in li:
    i = int(i)
    if i==0:zeros+=1
    if round(i**0.5)**2==i:ct+=1
    tmp = int(i**0.5)
    nums.append(min(i-tmp*tmp,(tmp+1)**2-i))
nums.sort()
half = int(n/2)
if ct<=half:print( sum(nums[:half]))
else:
    rst=ct-half
    if zeros>half:
        rst+=zeros-half
    print(rst)","['constructive algorithms', 'greedy']"
"A plane is flying at a constant height of $$$h$$$ meters above the ground surface. Let's consider that it is flying from the point $$$(-10^9, h)$$$ to the point $$$(10^9, h)$$$ parallel with $$$Ox$$$ axis.A glider is inside the plane, ready to start his flight at any moment (for the sake of simplicity let's consider that he may start only when the plane's coordinates are integers). After jumping from the plane, he will fly in the same direction as the plane, parallel to $$$Ox$$$ axis, covering a unit of distance every second. Naturally, he will also descend; thus his second coordinate will decrease by one unit every second.There are ascending air flows on certain segments, each such segment is characterized by two numbers $$$x_1$$$ and $$$x_2$$$ ($$$x_1 &lt; x_2$$$) representing its endpoints. No two segments share any common points. When the glider is inside one of such segments, he doesn't descend, so his second coordinate stays the same each second. The glider still flies along $$$Ox$$$ axis, covering one unit of distance every second.     If the glider jumps out at $$$1$$$, he will stop at $$$10$$$. Otherwise, if he jumps out at $$$2$$$, he will stop at $$$12$$$. Determine the maximum distance along $$$Ox$$$ axis from the point where the glider's flight starts to the point where his flight ends if the glider can choose any integer coordinate to jump from the plane and start his flight. After touching the ground the glider stops altogether, so he cannot glide through an ascending airflow segment if his second coordinate is $$$0$$$.","from collections import Counter, defaultdict, deque
read = lambda: list(map(int,input().split()))

n,h = read()
dis = []
for _ in range(n):
    a,b = read()
    dis.append([a,b])

rec = []
for i in range(1, n):
    rec.append(dis[i][0] - dis[i-1][1])
rec.append(float('inf'))

s = 0
left = h
i,j = 0,0
res = 0
vis = [False] * n
while i < n:
    while j < n and left > 0:
        if not vis[j]:
            s += dis[j][1] - dis[j][0]
            vis[j] = True
        if left > rec[j]:
            left -= rec[j]
            s += rec[j]
            j += 1
        else:
            res = max(res, s + left)
            while i < n and  left <= rec[j]:
                s -= dis[i][1] - dis[i][0] + rec[i]
                left += rec[i]
                i += 1
            if i >= n: break

print(res)","['data structures', 'two pointers', 'binary search']"
"There are n workers in a company, each of them has a unique id from 1 to n. Exaclty one of them is a chief, his id is s. Each worker except the chief has exactly one immediate superior.There was a request to each of the workers to tell how how many superiors (not only immediate). Worker's superiors are his immediate superior, the immediate superior of the his immediate superior, and so on. For example, if there are three workers in the company, from which the first is the chief, the second worker's immediate superior is the first, the third worker's immediate superior is the second, then the third worker has two superiors, one of them is immediate and one not immediate. The chief is a superior to all the workers except himself.Some of the workers were in a hurry and made a mistake. You are to find the minimum number of workers that could make a mistake.","n,s=[int(i) for i in input().split()]

s-=1

n-=1

d=0

l=[int(i) for i in input().split()]

if l[s]!=0:d+=1

l=l[:s]+l[s+1:]

for i in range(0,len(l)):

	if(l[i]==0):l[i]=n+5

l.sort()

j=0

i=0

c=0

while 1:

	while i<len(l) and j==l[i]:

		i+=1

	if i>=len(l):

		break

	elif l[i]-j==1:

		j+=1

		i+=1

		continue

	else:

		l.pop()

		d+=1

		j+=1

print(d)



# Made By Mostafa_Khaled","['greedy', 'graphs']"
"One department of some software company has $$$n$$$ servers of different specifications. Servers are indexed with consecutive integers from $$$1$$$ to $$$n$$$. Suppose that the specifications of the $$$j$$$-th server may be expressed with a single integer number $$$c_j$$$ of artificial resource units.In order for production to work, it is needed to deploy two services $$$S_1$$$ and $$$S_2$$$ to process incoming requests using the servers of the department. Processing of incoming requests of service $$$S_i$$$ takes $$$x_i$$$ resource units.The described situation happens in an advanced company, that is why each service may be deployed using not only one server, but several servers simultaneously. If service $$$S_i$$$ is deployed using $$$k_i$$$ servers, then the load is divided equally between these servers and each server requires only $$$x_i / k_i$$$ (that may be a fractional number) resource units.Each server may be left unused at all, or be used for deploying exactly one of the services (but not for two of them simultaneously). The service should not use more resources than the server provides.Determine if it is possible to deploy both services using the given servers, and if yes, determine which servers should be used for deploying each of the services.","# python3

def readline(): return tuple(map(int, input().split()))


def ceil_div(num, den): return (num - 1) // den + 1


def main():
    n, x1, x2 = readline()
    c = readline()

    xx = (x1, x2)

    servers = sorted(enumerate(c, start=1), key=lambda p: p[1])
    for (i, a) in enumerate(servers):
        for (j, x) in enumerate(xx):
            kj = ceil_div(x, a[1])
            if i + kj < n and (n - i - kj) * servers[i + kj][1] >= sum(xx) - x:
                print(""Yes"")
                l1 = servers[i:i+kj]
                l2 = servers[i+kj:]
                if j: l1, l2 = l2, l1
                print(len(l1), len(l2))
                print("" "".join(str(d[0]) for d in l1))
                print("" "".join(str(d[0]) for d in l2))
                return
    print(""No"")


main()","['binary search', 'sortings']"
"Nicholas, a painter is going to paint several new canvases. Nicholas is sure that the canvases will turn out so great that each one will need framing and being hung on the wall. Frames are what Nicholas decided to begin with. Nicholas has n sticks whose lengths equal a1, a2, ... an. Nicholas does not want to break the sticks or glue them together. To make a h × w-sized frame, he needs two sticks whose lengths equal h and two sticks whose lengths equal w. Specifically, to make a square frame (when h = w), he needs four sticks of the same length.Now Nicholas wants to make from the sticks that he has as many frames as possible; to be able to paint as many canvases as possible to fill the frames. Help him in this uneasy task. Note that it is not necessary to use all the sticks Nicholas has.","from collections import Counter
n  = int(input())
s = input().split(' ')
c = Counter(s)
c = c.most_common(len(c))
pairs=0
for i in c:
	pairs+=int(i[1]/2)
print(int(pairs/2))",['implementation']
"You are an experienced Codeforces user. Today you found out that during your activity on Codeforces you have made y submissions, out of which x have been successful. Thus, your current success rate on Codeforces is equal to x / y.Your favorite rational number in the [0;1] range is p / q. Now you wonder: what is the smallest number of submissions you have to make if you want your success rate to be p / q?","def check(k):
    n1 = k*p - x
    n2 = k*q - y
    assert(n1 >= 0)
    return n1 <= n2

t = int(input())
for _ in range(t):
  [x, y, p, q] = list(map(int, input().split("" "")))
  if p == 0 and x > 0:
      print(-1)
      continue
  if p == 0 and x == 0:
      print(0)
      continue
  st = max((x+p-1)//p, (y+q-1)//q)
  a = st-1
  b = 10**18
  while(b - a > 1):
    m = (a+b)//2
    if check(m):
        b = m
    else:
        a = m
  res = -1
  if b != 1e18:
    res = b*q - y
  print(res)","['binary search', 'math']"
"Let's dive into one of the most interesting areas of magic — writing spells. Learning this exciting but challenging science is very troublesome, so now you will not learn the magic words, but only get to know the basic rules of writing spells.Each spell consists of several lines. The line, whose first non-space character is character ""#"" is an amplifying line and it is responsible for spell power. The remaining lines are common, and determine the effect of the spell.You came across the text of some spell. Spell was too long, so you cannot understand its meaning. So you want to make it as short as possible without changing the meaning.The only way to shorten a spell that you know is the removal of some spaces and line breaks. We know that when it comes to texts of spells, the spaces carry meaning only in the amplifying lines, so we should remove all spaces in other lines. Newlines also do not matter, unless any of the two separated lines is amplifying. Thus, if two consecutive lines are not amplifying, they need to be joined into one (i.e. we should concatenate the second line to the first one). Removing spaces in amplifying lines and concatenating the amplifying lines to anything is forbidden.Note that empty lines must be processed just like all the others: they must be joined to the adjacent non-amplifying lines, or preserved in the output, if they are surrounded with amplifying lines on both sides (i.e. the line above it, if there is one, is amplifying, and the line below it, if there is one, is amplifying too).For now those are the only instructions for removing unnecessary characters that you have to follow (oh yes, a newline is a character, too).The input contains the text of the spell, which should be reduced. Remove the extra characters and print the result to the output.","lis = []

while True:
  try:
    val = raw_input()
    isAmplifying = False

    for c in val:
      if not c.isspace():
        if c == ""#"":
          isAmplifying = True
          break
        else:
          break		
	
    if isAmplifying:
      lis.append((val, True))
    else:
      lis.append(("""".join(val.split()), False))
	  
  except (EOFError):
    break
	
	
index = 0
result = []

while index < len(lis):  
  if lis[index][1] == True:
    print lis[index][0]
  else:
    lisss = []  
    while index < len(lis) and lis[index][1] != True:
      lisss.append(lis[index][0])	  
      index += 1	  
    index -= 1	  
    print """".join(lisss)
  index += 1	
	  
for r in result:
  print r","['implementation', 'strings']"
"At the beginning of the new semester there is new schedule in the Berland State University. According to this schedule, n groups have lessons at the room 31. For each group the starting time of the lesson and the finishing time of the lesson are known. It has turned out that it is impossible to hold all lessons, because for some groups periods of their lessons intersect. If at some moment of time one groups finishes it's lesson, and the other group starts the lesson, their lessons don't intersect.The dean wants to cancel the lesson in one group so that no two time periods of lessons of the remaining groups intersect. You are to find all ways to do that.","from operator import add
import sys
from array import array  # noqa: F401
from typing import TypeVar, Generic, Callable, List
T = TypeVar('T')


class SegmentTree(Generic[T]):
    __slots__ = [""size"", ""tree"", ""identity"", ""op"", ""update_op""]

    def __init__(self, size: int, identity: T, op: Callable[[T, T], T],
                 update_op: Callable[[T, T], T]) -> None:
        self.size = size
        self.tree = [identity] * (size * 2)
        self.identity = identity
        self.op = op
        self.update_op = update_op

    def build(self, a: List[T]) -> None:
        tree = self.tree
        tree[self.size:self.size + len(a)] = a

        for i in range(self.size - 1, 0, -1):
            tree[i] = self.op(tree[i << 1], tree[(i << 1) + 1])

    def find(self, left: int, right: int) -> T:
        left += self.size
        right += self.size
        tree, result, op = self.tree, self.identity, self.op

        while left < right:
            if left & 1:
                result = op(tree[left], result)
                left += 1
            if right & 1:
                result = op(tree[right - 1], result)
            left, right = left >> 1, right >> 1

        return result

    def update(self, i: int, value: T) -> None:
        op, tree = self.op, self.tree
        i = self.size + i
        tree[i] = self.update_op(tree[i], value)

        while i > 1:
            i >>= 1
            tree[i] = op(tree[i << 1], tree[(i << 1) + 1])


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


n = int(input())
a = [tuple(map(int, input().split())) for _ in range(n)]
max_n = 10**6 + 10
imos = [0] * max_n
for l, r in a:
    imos[l] += 1
    imos[r] -= 1

for i in range(max_n - 5):
    imos[i + 1] += imos[i]

segt = SegmentTree[int](max_n, 0, max, add)
segt.build(imos)

ans = []

for i, (l, r) in enumerate(a, start=1):
    if segt.find(0, l) <= 1 and segt.find(l, r) <= 2 and segt.find(r, max_n) <= 1:
        ans.append(i)

print(len(ans))
print(*ans)",['implementation']
You are given matrix with n rows and n columns filled with zeroes. You should put k ones in it in such a way that the resulting matrix is symmetrical with respect to the main diagonal (the diagonal that goes from the top left to the bottom right corner) and is lexicographically maximal.One matrix is lexicographically greater than the other if the first different number in the first different row from the top in the first matrix is greater than the corresponding number in the second one.If there exists no such matrix then output -1.,"n,k = map(int,raw_input().split())
if k > pow(n,2):
  print -1
else:
  ans = [[0 for x in range(n)] for x in range(n)]
  cur = 0
  while k:
    ans[cur][cur] = 1
    k -= 1
    temp = 1
    while k>=2 and cur+temp<n:
      ans[cur][cur+temp] = 1
      ans[cur+temp][cur] = 1
      temp += 1
      k -= 2
    cur += 1
  for i in ans:
    print "" "".join([str(x) for x in i])",['constructive algorithms']
"A continued fraction of height n is a fraction of form . You are given two rational numbers, one is represented as  and the other one is represented as a finite fraction of height n. Check if they are equal.","p,q = input().split()
p = int(p)
q = int(q)
n = int(input())
A = input().split()
a = 1
b = int(A[n-1])
i = n-2
while( i >= 0 ):
    aux = b
    b = a + b*int(A[i])
    a = aux
    i = i-1

print (""YES"" if p*a == q*b else ""NO"" )","['implementation', 'brute force', 'math']"
"Seryozha has a very changeable character. This time he refused to leave the room to Dima and his girlfriend (her hame is Inna, by the way). However, the two lovebirds can always find a way to communicate. Today they are writing text messages to each other.Dima and Inna are using a secret code in their text messages. When Dima wants to send Inna some sentence, he writes out all words, inserting a heart before each word and after the last word. A heart is a sequence of two characters: the ""less"" characters (&lt;) and the digit three (3). After applying the code, a test message looks like that: &lt;3word1&lt;3word2&lt;3 ... wordn&lt;3.Encoding doesn't end here. Then Dima inserts a random number of small English characters, digits, signs ""more"" and ""less"" into any places of the message.Inna knows Dima perfectly well, so she knows what phrase Dima is going to send her beforehand. Inna has just got a text message. Help her find out if Dima encoded the message correctly. In other words, find out if a text message could have been received by encoding in the manner that is described above.","s=list('<3'+'<3'.join(raw_input() for _ in range(input()))+'<3')
t=list(raw_input())
while s and t:
    if s[-1]==t[-1]:s.pop()
    t.pop()
print 'no' if s else 'yes'","['brute force', 'strings']"
"For months Maxim has been coming to work on his favorite bicycle. And quite recently he decided that he is ready to take part in a cyclists' competitions.He knows that this year n competitions will take place. During the i-th competition the participant must as quickly as possible complete a ride along a straight line from point si to point fi (si &lt; fi).Measuring time is a complex process related to usage of a special sensor and a time counter. Think of the front wheel of a bicycle as a circle of radius r. Let's neglect the thickness of a tire, the size of the sensor, and all physical effects. The sensor is placed on the rim of the wheel, that is, on some fixed point on a circle of radius r. After that the counter moves just like the chosen point of the circle, i.e. moves forward and rotates around the center of the circle.At the beginning each participant can choose any point bi, such that his bike is fully behind the starting line, that is, bi &lt; si - r. After that, he starts the movement, instantly accelerates to his maximum speed and at time tsi, when the coordinate of the sensor is equal to the coordinate of the start, the time counter starts. The cyclist makes a complete ride, moving with his maximum speed and at the moment the sensor's coordinate is equal to the coordinate of the finish (moment of time tfi), the time counter deactivates and records the final time. Thus, the counter records that the participant made a complete ride in time tfi - tsi.  Maxim is good at math and he suspects that the total result doesn't only depend on his maximum speed v, but also on his choice of the initial point bi. Now Maxim is asking you to calculate for each of n competitions the minimum possible time that can be measured by the time counter. The radius of the wheel of his bike is equal to r.","from math import cos,pi

def g(t):
	return t+cos(t)

def solve(y):
	assert(y>=1 and y<2*pi+1)
	low = 0.
	high = 2*pi+1
	for k in range(64):
		mid = (low+high)/2
		if g(mid) > y:
			high = mid
		else:
			low = mid
	return low

def bestTime(s,f,r,v):
	m = int((2.+float(f-s)/r)/pi-0.1)
	if (m%2 == 0): m += 1
	res = None
	for i in range(3):
		try:
			t = solve((m*pi-float(f-s)/r)/2)
			cand = (m*pi-2*t)*r/v
			if res==None or cand < res:
					res = cand
		except:
			pass
		m += 2
	return res

n,r,v = map(int,raw_input().split())
for i in range(n):
	s,f = map(int,raw_input().split())
	print bestTime(s,f,r,v)","['binary search', 'geometry']"
"After Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.","n, m = [int(x) for x in input().split()]
E = {i:[] for i in range(n)}
for i in range(m):
    u, v = [int(x)-1 for x in input().split()]
    E[v].append(u)
    E[u].append(v)

def dfs():
    visited = [False for i in range(n)]
    colour = [0 for i in range(n)]
    ans = 0
    for v in range(n):
        if visited[v]: continue
        stack = [(v, 0)]
        part = [0, 0]
        while stack:
            node, c = stack.pop()
            if not visited[node]:
                part[c] += 1
                visited[node] = True
                colour[node] = c
                stack.extend((u,c^1) for u in E[node])
            elif c != colour[node]:
                return (0, 1)
        ans += (part[0]*(part[0] - 1) + part[1]*(part[1] - 1)) // 2
    return (1, ans)

if m == 0:
    print(3, n*(n-1)*(n-2)//6)
elif max(len(E[v]) for v in E) == 1:
    print(2, m*(n-2))
else:
    ans = dfs()
    print(ans[0], ans[1])","['combinatorics', 'graphs', 'dfs and similar', 'math']"
"Bessie is out grazing on the farm, which consists of $$$n$$$ fields connected by $$$m$$$ bidirectional roads. She is currently at field $$$1$$$, and will return to her home at field $$$n$$$ at the end of the day.The Cowfederation of Barns has ordered Farmer John to install one extra bidirectional road. The farm has $$$k$$$ special fields and he has decided to install the road between two different special fields. He may add the road between two special fields that already had a road directly connecting them.After the road is added, Bessie will return home on the shortest path from field $$$1$$$ to field $$$n$$$. Since Bessie needs more exercise, Farmer John must maximize the length of this shortest path. Help him!","from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush
import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 1000000007
INF = float('inf')

# ------------------------------
def main():
    n, m, k = RL()
    spa = list(RL())

    dic = defaultdict(set)
    ds = 0

    for _ in range(m):
        a, b = RL()
        dic[a].add(b)
        dic[b].add(a)


    def bfs(root):
        rec = [0]*(n+1)
        q = [(root, 0)]

        da = [0]*(n+1)
        rec[root] = 1

        for i, d in q:
            for nex in dic[i]:
                if rec[nex]==0:
                    q.append((nex, d+1))
                    rec[nex] = 1
                    da[nex] = d+1
        return da

    star = bfs(1)
    end = bfs(n)

    res = end[1]

    spa.sort(key=lambda i: star[i]-end[i])

    ts = float('-inf')
    disa = star[spa[0]]
    dis = 0
    # print(end, spa)
    for i in spa[1:]:
        dis = max(end[i]+1+disa, dis)
        disa = max(disa, star[i])
        # print(dis, disa, i)
    print(min(res, dis))

if __name__ == ""__main__"":
    main()","['greedy', 'graphs', 'shortest paths', 'sortings', 'data structures', 'binary search', 'dfs and similar']"
"Let's suppose you have an array a, a stack s (initially empty) and an array b (also initially empty).You may perform the following operations until both a and s are empty:  Take the first element of a, push it into s and remove it from a (if a is not empty);  Take the top element from s, append it to the end of array b and remove it from s (if s is not empty). You can perform these operations in arbitrary order.If there exists a way to perform the operations such that array b is sorted in non-descending order in the end, then array a is called stack-sortable.For example, [3, 1, 2] is stack-sortable, because b will be sorted if we perform the following operations:  Remove 3 from a and push it into s;  Remove 1 from a and push it into s;  Remove 1 from s and append it to the end of b;  Remove 2 from a and push it into s;  Remove 2 from s and append it to the end of b;  Remove 3 from s and append it to the end of b. After all these operations b = [1, 2, 3], so [3, 1, 2] is stack-sortable. [2, 3, 1] is not stack-sortable.You are given k first elements of some permutation p of size n (recall that a permutation of size n is an array of size n where each integer from 1 to n occurs exactly once). You have to restore the remaining n - k elements of this permutation so it is stack-sortable. If there are multiple answers, choose the answer such that p is lexicographically maximal (an array q is lexicographically greater than an array p iff there exists some integer k such that for every i &lt; k qi = pi, and qk &gt; pk). You may not swap or change any of first k elements of the permutation.Print the lexicographically maximal permutation p you can obtain.If there exists no answer then output -1.","# https://codeforces.com/problemset/problem/911/E

n, k = map(int, input().split())
p    = list(map(int, input().split()))
d    = {x:1 for x in p}

def solve(p, d, n):
    add  = []
    s    = []
    
    for x in range(1, n+1):
        if x not in d:
            while len(p) > 0:
                s.append(p.pop(0))
                
                if len(s) >= 2 and s[-1] > s[-2]:
                    return False, None
                
            # len(p)=0
            if len(s) == 0 or s[-1] != x:
                up = n if len(s) == 0 else s[-1]-1
            
                for y in range(up, x-1, -1):
                    add.append(y)
                    s.append(y)
                    d[y]=1
            s.pop()
        else:
            if len(s) == 0 or s[-1] != x:
                while len(p) > 0:
                    s.append(p.pop(0))
                
                    if len(s) >= 2 and s[-1] > s[-2]:
                        return False, None
                
                    if s[-1] == x:
                        break
            s.pop()
    return True, add

ans =  [x for x in p]
flg, add = solve(p, d, n)
if flg==False:
    print(-1)
else:
    print(' '.join([str(x) for x in ans+add]))","['data structures', 'constructive algorithms', 'implementation', 'greedy']"
"You are given two strings $$$s$$$ and $$$t$$$ consisting of lowercase Latin letters. Also you have a string $$$z$$$ which is initially empty. You want string $$$z$$$ to be equal to string $$$t$$$. You can perform the following operation to achieve this: append any subsequence of $$$s$$$ at the end of string $$$z$$$. A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements. For example, if $$$z = ac$$$, $$$s = abcde$$$, you may turn $$$z$$$ into following strings in one operation:   $$$z = acace$$$ (if we choose subsequence $$$ace$$$);  $$$z = acbcd$$$ (if we choose subsequence $$$bcd$$$);  $$$z = acbce$$$ (if we choose subsequence $$$bce$$$). Note that after this operation string $$$s$$$ doesn't change.Calculate the minimum number of such operations to turn string $$$z$$$ into string $$$t$$$.","#!/usr/bin/env pypy
from __future__ import division, print_function
from collections import defaultdict, Counter, deque
from future_builtins import ascii, filter, hex, map, oct, zip
from itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement
from __builtin__ import xrange as range
from math import ceil, factorial
from _continuation import continulet
from cStringIO import StringIO
from io import IOBase
import __pypy__
from bisect import bisect, insort, bisect_left, bisect_right
from fractions import Fraction
from functools import reduce
import sys
import os
import re
inf = float('inf')
mod_ = int(1e9) + 7
mod = 998244353


def main():
	for _ in range(int(input())):
		s = input()
		t = input()
		position = defaultdict(list)
		for i in range(len(s)):
			position[s[i]].append(i)

		ans, tind, sind = 1, 0, 0
		for tind in range(len(t)):
			if t[tind] not in position:
				print(-1)
				break
			cind = bisect_left(position[t[tind]], sind)
			if cind == len(position[t[tind]]):
				sind = position[t[tind]][0] + 1
				ans += 1
			else:
				sind = position[t[tind]][cind] + 1
		else:
			print(ans)


BUFSIZE = 8192
class FastI(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = StringIO()
		self.newlines = 0

	def read(self):
		while True:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			if not b:
				break
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines = 0
		return self.buffer.read()

	def readline(self):
		while self.newlines == 0:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			self.newlines = b.count(""\n"") + (not b)
			ptr = self._buffer.tell()
			self._buffer.seek(0, 2), self._buffer.write(
				b), self._buffer.seek(ptr)
		self.newlines -= 1
		return self._buffer.readline()
class FastO(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = __pypy__.builders.StringBuilder()
		self.write = lambda s: self._buffer.append(s)

	def flush(self):
		os.write(self._fd, self._buffer.build())
		self._buffer = __pypy__.builders.StringBuilder()
def print(*args, **kwargs):
	sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
	at_start = True
	for x in args:
		if not at_start:
			file.write(sep)
		file.write(str(x))
		at_start = False
	file.write(kwargs.pop(""end"", ""\n""))
	if kwargs.pop(""flush"", False):
		file.flush()
def gcd(x, y):
	while y:
		x, y = y, x % y
	return x
sys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
	def bootstrap(cont):
		call, arg = cont.switch()
		while True:
			call, arg = cont.switch(to=continulet(
				lambda _, f, args: f(*args), call, arg))
	cont = continulet(bootstrap)
	cont.switch()
	main()","['dp', 'greedy', 'strings']"
"Iahub helps his grandfather at the farm. Today he must milk the cows. There are n cows sitting in a row, numbered from 1 to n from left to right. Each cow is either facing to the left or facing to the right. When Iahub milks a cow, all the cows that see the current cow get scared and lose one unit of the quantity of milk that they can give. A cow facing left sees all the cows with lower indices than her index, and a cow facing right sees all the cows with higher indices than her index. A cow that got scared once can get scared again (and lose one more unit of milk). A cow that has been milked once cannot get scared and lose any more milk. You can assume that a cow never loses all the milk she can give (a cow gives an infinitely amount of milk).Iahub can decide the order in which he milks the cows. But he must milk each cow exactly once. Iahub wants to lose as little milk as possible. Print the minimum amount of milk that is lost.","n = int(raw_input())
A = map(int,raw_input().split())

ans = c = 0;
for x in A:
    if x == 0: ans += c;
    else: c += 1;

print ans;","['data structures', 'greedy']"
"...Mike the TV greets you again! Tired of the monotonous furniture? Sick of gray routine? Dreaming about dizzying changes in your humble abode? We have something to offer you! This domino carpet for only $99.99 will change your life! You can lay it on the floor, hang it on the wall or even on the ceiling! Among other things ... Having watched the commercial, virus Hexadecimal also wanted to get a Domino Carpet and wanted badly to be photographed in front of it. But of course, a virus will never consent to buying a licensed Carpet! So she ordered a truck of dominoes and decided to make such a Carpet herself. The original Domino Carpet is a field of squares n × m in size. Each square is half of a domino, and can be rotated either vertically or horizontally, independently from its neighbors. Vertically rotated domino halves look like this:    And horizontally rotated halves look like this:   Notice, that some halves looks the same in both rotations, but other halves differ.Dominoes bought by Hexadecimal are represented by uncuttable chips 1 × 2 in size, which can be laid either vertically or horizontally. If the chip is laid vertically, then both of it's halves should be laid vertically orientated; if the chip is laid horizontally, then both of it's halves should be laid horizontally.The samples of valid and invalid dominoes laid vertically and horizontally are:    Virus Hexadecimal assembles her own Domino Carpet so that the following conditions are satisfied:  each carpet square is covered by a domino chip, i.e. there are no empty squares;  all domino chips lie entirely within the carpet and don't overlap with each other;  if there is a horizontal domino chip with its left half in column j then there are no horizontal domino chips with their left halves in columns j - 1 or j + 1. Before starting to assemble her own Domino Carpet, the virus wants to know the number of ways to achieve the intended purpose modulo 109 + 7.You can assume that the virus has an infinitely large number of dominoes of each type.","n,m=map(int,raw_input().split())
P=10**9+7
H={
    ('O..','...','..O'):3,('O..','.O.','..O'):3,('OOO','...','OOO'):3,
    ('..O','...','O..'):1,('..O','.O.','O..'):1,('O.O','O.O','O.O'):1}
d=[]
for _ in xrange(n):
    raw_input()
    r = zip(*[tuple(raw_input().split('#')[1:-1]) for _ in xrange(3)])    
    d.append([H.get(x,0) for x in r])
a,b,p=0,1,[False]*n
u = lambda l: any(i==3 for i in l)
for r in zip(*d):
    c = 0 if n&1 or u(r) else (b if u(p) else b-a)
    q = map(lambda x,y:[0,1,1,3,4,4,3][x+y],p,r)        
    if any(x==4 for x in q): f=0
    else:
        j,e,f = 3,0,1        
        for i in q:
            if i==3: a*=f;e,f=0,1
            else: e,f = f,[f,0][i]+[e,0][j==3]
            j=i
    a,b,p=b,(c+a*f)%P,r    
print b","['dp', 'implementation']"
"Breaking Good is a new video game which a lot of gamers want to have. There is a certain level in the game that is really difficult even for experienced gamers.Walter William, the main character of the game, wants to join a gang called Los Hermanos (The Brothers). The gang controls the whole country which consists of n cities with m bidirectional roads connecting them. There is no road is connecting a city to itself and for any two cities there is at most one road between them. The country is connected, in the other words, it is possible to reach any city from any other city using the given roads. The roads aren't all working. There are some roads which need some more work to be performed to be completely functioning.The gang is going to rob a bank! The bank is located in city 1. As usual, the hardest part is to escape to their headquarters where the police can't get them. The gang's headquarters is in city n. To gain the gang's trust, Walter is in charge of this operation, so he came up with a smart plan.First of all the path which they are going to use on their way back from city 1 to their headquarters n must be as short as possible, since it is important to finish operation as fast as possible.Then, gang has to blow up all other roads in country that don't lay on this path, in order to prevent any police reinforcements. In case of non-working road, they don't have to blow up it as it is already malfunctional. If the chosen path has some roads that doesn't work they'll have to repair those roads before the operation.Walter discovered that there was a lot of paths that satisfied the condition of being shortest possible so he decided to choose among them a path that minimizes the total number of affected roads (both roads that have to be blown up and roads to be repaired).Can you help Walter complete his task and gain the gang's trust?","from sys import *
from collections import *
s = stdin.read().split()
d = list(map(int, s))
n, m = d[:2]
g = [[] for i in range(n + 1)]
for j in range(m):
    i = 3 * j + 2
    g[d[i]].append((d[i + 1], d[i + 2], j))
    g[d[i + 1]].append((d[i], d[i + 2], j))
u, v = [-1] * n + [0], [1e9] * n + [0]
x, y = [0] * (n + 1), [0] * (n + 1)
q = deque([n])
while q:
    a = q.popleft()
    for b, k, i in g[a]:
        if v[b] == 1e9: q.append(b)
        if v[b] > v[a] and u[b] < u[a] + k:
            v[b] = v[a] + 1
            u[b] = u[a] + k
            x[b], y[b] = a, i
a, t = 1, [0] * m
while a != n: t[y[a]], a = 1, x[a]
l = []
for j in range(m):
    i = 3 * j + 2
    if d[i + 2] != t[j]:
        l.append(' '.join([s[i], s[i + 1], str(t[j])]))
print(len(l))
print('\n'.join(l))","['dp', 'graphs', 'dfs and similar', 'shortest paths']"
"Alice and Bob are playing a game. The game involves splitting up game pieces into two teams. There are n pieces, and the i-th piece has a strength pi.The way to split up game pieces is split into several steps:  First, Alice will split the pieces into two different groups A and B. This can be seen as writing the assignment of teams of a piece in an n character string, where each character is A or B.  Bob will then choose an arbitrary prefix or suffix of the string, and flip each character in that suffix (i.e. change A to B and B to A). He can do this step at most once.  Alice will get all the pieces marked A and Bob will get all the pieces marked B. The strength of a player is then the sum of strengths of the pieces in the group.Given Alice's initial split into two teams, help Bob determine an optimal strategy. Return the maximum strength he can achieve.","n = int(input())
p = list(map(int, input().split()))
s = input()

ans = bob1 = bob2 = 0
for i in range(n):
    if s[i] == 'B':
        ans += p[i]
        bob1 += p[i]
        bob2 += p[i]

for i in range(n):
    if s[i] == 'A':
        bob1 += p[i]
    else:
        bob1 -= p[i]
    ans = max(ans, bob1)

for i in reversed(range(n)):
    if s[i] == 'A':
        bob2 += p[i]
    else:
        bob2 -= p[i]
    ans = max(ans, bob2)

print(ans)","['constructive algorithms', 'brute force']"
"Innokentiy decides to change the password in the social net ""Contact!"", but he is too lazy to invent a new password by himself. That is why he needs your help. Innokentiy decides that new password should satisfy the following conditions:  the length of the password must be equal to n,  the password should consist only of lowercase Latin letters,  the number of distinct symbols in the password must be equal to k,  any two consecutive symbols in the password must be distinct. Your task is to help Innokentiy and to invent a new password which will satisfy all given conditions.","n,k=map(int,input().split())
a=[]
b='a'
for i in range(k):
    a.append(chr(ord(b)+i))
j=0
for i in range(n):
    print(a[j],end='')
    j=j+1
    if j==len(a):
        j=0","['implementation', '*special']"
"Note that the memory limit is unusual.You are given a multiset consisting of $$$n$$$ integers. You have to process queries of two types:  add integer $$$k$$$ into the multiset;  find the $$$k$$$-th order statistics in the multiset and remove it. $$$k$$$-th order statistics in the multiset is the $$$k$$$-th element in the sorted list of all elements of the multiset. For example, if the multiset contains elements $$$1$$$, $$$4$$$, $$$2$$$, $$$1$$$, $$$4$$$, $$$5$$$, $$$7$$$, and $$$k = 3$$$, then you have to find the $$$3$$$-rd element in $$$[1, 1, 2, 4, 4, 5, 7]$$$, which is $$$2$$$. If you try to delete an element which occurs multiple times in the multiset, only one occurence is removed. After processing all queries, print any number belonging to the multiset, or say that it is empty.","import sys, os, gc
 
class FenwickTree:
    def __init__(self, x):
        """"""transform list into BIT""""""
        self.bit = x
        for i in range(len(x)):
            j = i | (i + 1)
            if j < len(x):
                x[j] += x[i]
 
    def update(self, idx, x):
        """"""updates bit[idx] += x""""""
        while idx < len(self.bit):
            self.bit[idx] += x
            idx |= idx + 1
 
    def query(self, end):
        """"""calc sum(bit[:end])""""""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x
 
    def findkth(self, k):
        """"""Find largest idx such that sum(bit[:idx]) <= k""""""
        idx = -1
        for d in reversed(range(len(self.bit).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(self.bit) and k >= self.bit[right_idx]:
                idx = right_idx
                k -= self.bit[idx]
        return idx + 1
 
ii = 0
_inp = b''
def getchar():
    global ii, _inp
    if ii >= len(_inp):
        _inp = os.read(0, 100000)
        gc.collect()
        ii = 0
    if not _inp:
        return b' '[0]
    ii += 1
    return _inp[ii - 1]
 
def input():
    c = getchar()
    if c == b'-'[0]:
        x = 0
        sign = 1
    else:
        x = c - b'0'[0]
        sign = 0
    c = getchar()
    while c >= b'0'[0]:
        x = 10 * x + c - b'0'[0]
        c = getchar()
    if c == b'\r'[0]:
        getchar()
    return -x if sign else x
 
def main():
    n = input()
    q = input()
    A = [0]*n
    for _ in range(n):
        A[input() - 1] += 1
     
    fen = FenwickTree(A)
    for _ in range(q):
        x = input()
        if x < 0:
            fen.update(fen.findkth(-x - 1), -1)
        else:
            fen.update(x - 1, 1)
    i = 0
    while i < n and not A[i]:
        i += 1
    if i == n:
        os.write(1, b'0')
    else:
        os.write(1, str(i + 1).encode('ascii'))
main()","['data structures', 'binary search']"
"Polycarp plans to conduct a load testing of its new project Fakebook. He already agreed with his friends that at certain points in time they will send requests to Fakebook. The load testing will last n minutes and in the i-th minute friends will send ai requests.Polycarp plans to test Fakebook under a special kind of load. In case the information about Fakebook gets into the mass media, Polycarp hopes for a monotone increase of the load, followed by a monotone decrease of the interest to the service. Polycarp wants to test this form of load.Your task is to determine how many requests Polycarp must add so that before some moment the load on the server strictly increases and after that moment strictly decreases. Both the increasing part and the decreasing part can be empty (i. e. absent). The decrease should immediately follow the increase. In particular, the load with two equal neigbouring values is unacceptable.For example, if the load is described with one of the arrays [1, 2, 8, 4, 3], [1, 3, 5] or [10], then such load satisfies Polycarp (in each of the cases there is an increasing part, immediately followed with a decreasing part). If the load is described with one of the arrays [1, 2, 2, 1], [2, 1, 2] or [10, 10], then such load does not satisfy Polycarp.Help Polycarp to make the minimum number of additional requests, so that the resulting load satisfies Polycarp. He can make any number of additional requests at any minute from 1 to n.","n = int(input())
l = [int(i) for i in input().split("" "")]
l_up = l[:]
l_down = l[::-1]

for i in range(n - 1):
    if l_up[i+1] <= l_up[i]:
        l_up[i+1] = l_up[i] + 1
for i in range(n - 1):
    if l_down[i+1] <= l_down[i]:
        l_down[i+1] = l_down[i] + 1
l_down = l_down[::-1]

index = 0
add = False
for index in range(n-1):
    if l_up[index] < l_down[index] and l_up[index+1] >= l_down[index+1]:
        if l_up[index+1] == l_down[index+1]:
            break
        else:
            add = True
            break
    if index == n-2:
        index = 0
if add == False:
    l_final = l_up[:index+1] + l_down[index+1:]
    result = sum(l_final) - sum(l)
else:
    l_final = l_up[:index+1] + l_down[index+1:]
    result = sum(l_final) - sum(l) + 1



# print(index)
# print(l_up)
# print(l_down)
# print(l_final)
print(result)",['greedy']
"A tourist hiked along the mountain range. The hike lasted for n days, during each day the tourist noted height above the sea level. On the i-th day height was equal to some integer hi. The tourist pick smooth enough route for his hike, meaning that the between any two consecutive days height changes by at most 1, i.e. for all i's from 1 to n - 1 the inequality |hi - hi + 1| ≤ 1 holds.At the end of the route the tourist rafted down a mountain river and some notes in the journal were washed away. Moreover, the numbers in the notes could have been distorted. Now the tourist wonders what could be the maximum height during his hike. Help him restore the maximum possible value of the maximum height throughout the hike or determine that the notes were so much distorted that they do not represent any possible height values that meet limits |hi - hi + 1| ≤ 1.","def maxheight(start, end):
    start_day, start_height = start
    end_day, end_height = end
    
    ddays = end_day - start_day
    dheight = end_height - start_height
    
    xdays = ddays - abs(dheight)
    
    if xdays < 0:
        return -1
    else:
        return xdays // 2 + max(start_height, end_height)

import sys
data = sys.stdin

days = int(data.readline().split()[0])

entries = []
for l in data.read().splitlines():
    entries.append(tuple(map(int, l.split(' '))))
entries.sort()

maxheights = []

for e in entries:
    maxheights.append(e[1])

for i in range(len(entries) - 1):
    h = maxheight(entries[i], entries[i+1])
    if h < 0:
        print(""IMPOSSIBLE"")
        break
    else:
        maxheights.append(h)
else:
    first = entries[0]
    maxheights.append(first[0] - 1 + first[1])

    last = entries[-1]
    maxheights.append(days - last[0] + last[1])

    print(str(max(maxheights)))","['greedy', 'math', 'implementation', 'binary search', 'brute force']"
"Ivan wants to play a game with you. He picked some string $$$s$$$ of length $$$n$$$ consisting only of lowercase Latin letters. You don't know this string. Ivan has informed you about all its improper prefixes and suffixes (i.e. prefixes and suffixes of lengths from $$$1$$$ to $$$n-1$$$), but he didn't tell you which strings are prefixes and which are suffixes.Ivan wants you to guess which of the given $$$2n-2$$$ strings are prefixes of the given string and which are suffixes. It may be impossible to guess the string Ivan picked (since multiple strings may give the same set of suffixes and prefixes), but Ivan will accept your answer if there is at least one string that is consistent with it. Let the game begin!","n=int(input())
l=[input() for i in range(2*n-2)]
m=[i+j for i in l for j in l if len(i+j)==n]
for j in m:
	p={j[:i] for i in range(1,n)}
	s={j[i:] for i in range(1,n)}
	if set(p|s)==set(l):
		for i in l:
			if i in p:print('P',end='');p-= {i}
			else:print('S',end='');s-={i}
		exit()",['strings']
"According to the regulations of Berland's army, a reconnaissance unit should consist of exactly two soldiers. Since these two soldiers shouldn't differ much, their heights can differ by at most d centimeters. Captain Bob has n soldiers in his detachment. Their heights are a1, a2, ..., an centimeters. Some soldiers are of the same height. Bob wants to know, how many ways exist to form a reconnaissance unit of two soldiers from his detachment.Ways (1, 2) and (2, 1) should be regarded as different.","(n,d)=map(int, input().split())

l=list(map(int, input().split()))

def partition(arr,low,high): 
    i = ( low-1 )         # index of smaller element 
    pivot = arr[high]     # pivot 
  
    for j in range(low , high): 
  
        # If current element is smaller than or 
        # equal to pivot 
        if   arr[j] <= pivot: 
          
            # increment index of smaller element 
            i = i+1 
            arr[i],arr[j] = arr[j],arr[i] 
  
    arr[i+1],arr[high] = arr[high],arr[i+1] 
    return ( i+1 ) 
  
# The main function that implements QuickSort 
# arr[] --> Array to be sorted, 
# low  --> Starting index, 
# high  --> Ending index 
  
# Function to do Quick sort 
def quickSort(arr,low,high): 
    if low < high: 
  
        # pi is partitioning index, arr[p] is now 
        # at right place 
        pi = partition(arr,low,high) 
  
        # Separately sort elements before 
        # partition and after partition 
        quickSort(arr, low, pi-1) 
        quickSort(arr, pi+1, high)
        
    return arr
    
l=quickSort(l,0,n-1)
count=0
for i in range(n-1):
    for j in range(i+1,n):
        if l[j]-l[i]>d:
            break
        count+=1
        
print(count*2)",['brute force']
"Learn, learn and learn again — Valera has to do this every day. He is studying at mathematical school, where math is the main discipline. The mathematics teacher loves her discipline very much and tries to cultivate this love in children. That's why she always gives her students large and difficult homework. Despite that Valera is one of the best students, he failed to manage with the new homework. That's why he asks for your help. He has the following task. A sequence of n numbers is given. A prefix of a sequence is the part of the sequence (possibly empty), taken from the start of the sequence. A suffix of a sequence is the part of the sequence (possibly empty), taken from the end of the sequence. It is allowed to sequentially make two operations with the sequence. The first operation is to take some prefix of the sequence and multiply all numbers in this prefix by  - 1. The second operation is to take some suffix and multiply all numbers in it by  - 1. The chosen prefix and suffix may intersect. What is the maximum total sum of the sequence that can be obtained by applying the described operations?","input();b=map(int,raw_input().split())
x=y=0
for i in b:x=max(x+i,0);y=max(x,y)
print y*2-sum(b)",['greedy']
"You are given a chessboard of size $$$n \times n$$$. It is filled with numbers from $$$1$$$ to $$$n^2$$$ in the following way: the first $$$\lceil \frac{n^2}{2} \rceil$$$ numbers from $$$1$$$ to $$$\lceil \frac{n^2}{2} \rceil$$$ are written in the cells with even sum of coordinates from left to right from top to bottom. The rest $$$n^2 - \lceil \frac{n^2}{2} \rceil$$$ numbers from $$$\lceil \frac{n^2}{2} \rceil + 1$$$ to $$$n^2$$$ are written in the cells with odd sum of coordinates from left to right from top to bottom. The operation $$$\lceil\frac{x}{y}\rceil$$$ means division $$$x$$$ by $$$y$$$ rounded up.For example, the left board on the following picture is the chessboard which is given for $$$n=4$$$ and the right board is the chessboard which is given for $$$n=5$$$.  You are given $$$q$$$ queries. The $$$i$$$-th query is described as a pair $$$x_i, y_i$$$. The answer to the $$$i$$$-th query is the number written in the cell $$$x_i, y_i$$$ ($$$x_i$$$ is the row, $$$y_i$$$ is the column). Rows and columns are numbered from $$$1$$$ to $$$n$$$.","from math import ceil

n, q = map(int, input().split())
a = []

def getNumber(x, y):
    global n

    if n % 2 == 0:
        if (x + y) % 2 == 0:
            start = 0
        else:
            start = n ** 2 // 2

        pos = (x - 1) * n // 2 + (y + 1) // 2
    else:
        t = (x - 1) * n + y + 1
        if t % 2 == 0:
            start = 0
        else:
            start = (n ** 2 + 1) // 2
        pos = t // 2
    return start + pos


for i in range(q):
    xi, yi = map(int, input().split())

    a.append(str(getNumber(xi, yi)))

print('\n'.join(a))","['implementation', 'math']"
"A tree is a connected graph that doesn't contain any cycles.The distance between two vertices of a tree is the length (in edges) of the shortest path between these vertices.You are given a tree with n vertices and a positive number k. Find the number of distinct pairs of the vertices which have a distance of exactly k between them. Note that pairs (v, u) and (u, v) are considered to be the same pair.","n, k = map(int, input().split())
t, q = [[] for i in range(n + 1)], [1]
 
for j in range(n - 1):
    a, b = map(int, input().split())
    t[a].append(b)
    t[b].append(a)
for x in q:
    for y in t[x]: t[y].remove(x)
    q.extend(t[x])
q.reverse()
 
a, s = {}, 0
for x in q:
    a[x] = [1]
    u = len(a[x])
    for y in t[x]:
        v = len(a[y])
        for d in range(max(0, k - u), v): s += a[y][d] * a[x][k - d - 1]
        if v >= u:
            for d in range(u - 1): a[x][d + 1] += a[y][d]
            a[x] += a[y][u - 1: ]
            u = v + 1
        else:
            for d in range(0, v): a[x][d + 1] += a[y][d]
    if u > k: a[x].pop()
print(s)","['dp', 'dfs and similar', 'trees']"
"There are $$$n$$$ products in the shop. The price of the $$$i$$$-th product is $$$a_i$$$. The owner of the shop wants to equalize the prices of all products. However, he wants to change prices smoothly.In fact, the owner of the shop can change the price of some product $$$i$$$ in such a way that the difference between the old price of this product $$$a_i$$$ and the new price $$$b_i$$$ is at most $$$k$$$. In other words, the condition $$$|a_i - b_i| \le k$$$ should be satisfied ($$$|x|$$$ is the absolute value of $$$x$$$).He can change the price for each product not more than once. Note that he can leave the old prices for some products. The new price $$$b_i$$$ of each product $$$i$$$ should be positive (i.e. $$$b_i &gt; 0$$$ should be satisfied for all $$$i$$$ from $$$1$$$ to $$$n$$$).Your task is to find out the maximum possible equal price $$$B$$$ of all productts with the restriction that for all products the condiion $$$|a_i - B| \le k$$$ should be satisfied (where $$$a_i$$$ is the old price of the product and $$$B$$$ is the same new price of all products) or report that it is impossible to find such price $$$B$$$.Note that the chosen price $$$B$$$ should be integer.You should answer $$$q$$$ independent queries.","z=input
from math import *
for _ in range(int(z())):
    n,k=map(int,z().split())
    l=sorted(list((map(int,z().split()))))
    c,m,n=0,max(l),len(l)
    if k>=2 or n>=0:
        if l[-1]-l[0]>k*2:print(-1)
        else:print(l[0]+k)
        continue

    for i in range(m+k,0,-1):
        d=0
        for j in l:
            x=abs(i-j)
            if x<=k:
                d+=1
            if d==n:
                print(i)
                c=1
                break
            if x>k:
                break
        if c==1:
            break
    if c==0:
        print(-1)",['math']
"Recently Vasya decided to improve his pistol shooting skills. Today his coach offered him the following exercise. He placed $$$n$$$ cans in a row on a table. Cans are numbered from left to right from $$$1$$$ to $$$n$$$. Vasya has to knock down each can exactly once to finish the exercise. He is allowed to choose the order in which he will knock the cans down.Vasya knows that the durability of the $$$i$$$-th can is $$$a_i$$$. It means that if Vasya has already knocked $$$x$$$ cans down and is now about to start shooting the $$$i$$$-th one, he will need $$$(a_i \cdot x + 1)$$$ shots to knock it down. You can assume that if Vasya starts shooting the $$$i$$$-th can, he will be shooting it until he knocks it down.Your task is to choose such an order of shooting so that the number of shots required to knock each of the $$$n$$$ given cans down exactly once is minimum possible.","n = int(input())
a = list(map(int, input().split()))
idx = [i+1 for i in range(n)]

a, idx = zip(*sorted(zip(a, idx), reverse=True))

ans = 0
for i in range(n):
    ans += a[i] * i + 1
print(ans)
print(*idx)","['implementation', 'sortings', 'greedy']"
"This is an interactive problem.A legendary tree rests deep in the forest. Legend has it that individuals who realize this tree would eternally become a Legendary Grandmaster.To help you determine the tree, Mikaela the Goddess has revealed to you that the tree contains $$$n$$$ vertices, enumerated from $$$1$$$ through $$$n$$$. She also allows you to ask her some questions as follows. For each question, you should tell Mikaela some two disjoint non-empty sets of vertices $$$S$$$ and $$$T$$$, along with any vertex $$$v$$$ that you like. Then, Mikaela will count and give you the number of pairs of vertices $$$(s, t)$$$ where $$$s \in S$$$ and $$$t \in T$$$ such that the simple path from $$$s$$$ to $$$t$$$ contains $$$v$$$.Mikaela the Goddess is busy and will be available to answer at most $$$11\,111$$$ questions.This is your only chance. Your task is to determine the tree and report its edges.","#!/usr/bin/env python3
# -*- coding: utf-8 -*-
__author__ = 'cnyali_lk'
import sys
def query(s,t,v):
    if len(s)==0 or len(t)==0:
        return 0
    print(len(s))
    for i in s:
        print(i,end=' ')
    print()
    print(len(t))
    for i in t:
        print(i,end=' ')
    print()
    print(v)
    sys.stdout.flush()
    return int(input())

n=int(input())
d=[0]*(n+1)
for i in range(2,n+1):
    d[i]=query(list(range(2,i))+list(range(i+1,n+1)),[1],i)

v=list(range(2,n+1))
v.sort(key=lambda x:d[x])
nofa=[]
ans=[]
for i in v:
    if len(nofa):
        for t in range(query([1],nofa,i)):
            l,r=1,len(nofa)
            while l<=r:
                mid=(l+r)//2
                if query([1],nofa[:mid],i)>0:
                    r=mid-1
                else:
                    l=mid+1
            w=nofa[r]
            nofa.remove(w)
            ans.append((w,i))
    nofa.append(i)
for i in nofa:
    ans.append((i,1))
print(""ANSWER"")
for i in ans:
    print(i[0],i[1])","['binary search', 'trees', 'interactive']"
"In the evenings Donkey would join Shrek to look at the stars. They would sit on a log, sipping tea and they would watch the starry sky. The sky hung above the roof, right behind the chimney. Shrek's stars were to the right of the chimney and the Donkey's stars were to the left. Most days the Donkey would just count the stars, so he knew that they are exactly n. This time he wanted a challenge. He imagined a coordinate system: he put the origin of the coordinates at the intersection of the roof and the chimney, directed the OX axis to the left along the roof and the OY axis — up along the chimney (see figure). The Donkey imagined two rays emanating from he origin of axes at angles α1 and α2 to the OX axis.  Now he chooses any star that lies strictly between these rays. After that he imagines more rays that emanate from this star at the same angles α1 and α2 to the OX axis and chooses another star that lies strictly between the new rays. He repeats the operation as long as there still are stars he can choose between the rays that emanate from a star.   As a result, the Donkey gets a chain of stars. He can consecutively get to each star if he acts by the given rules.Your task is to find the maximum number of stars m that the Donkey's chain can contain.Note that the chain must necessarily start in the point of the origin of the axes, that isn't taken into consideration while counting the number m of stars in the chain.","import bisect

def INPUT():
	global n, a, b, c, d
	n = int(input())
	a, b, c, d = [int(j) for i in input().split() for j in i.split(""/"")]
	global y_alpha
	y_alpha = []
	for _ in range(n):
		x, y = [int(x) for x in input().split()]
		y_alpha.append((b * y - a * x, c * x - d * y))


if __name__ == '__main__':
	INPUT()
	y_alpha = sorted([(x, y) for x, y in y_alpha if x > 0 and y > 0], key = lambda x: (x[0], -x[1]))
	dp = []
	for x, y in y_alpha:
		i = bisect.bisect_left(dp, y)
		if i == len(dp):
			dp.append(y)
		else:
			dp[i] = y;

	print(len(dp));","['dp', 'geometry', 'math', 'sortings', 'data structures']"
"Polycarp lives on a coordinate line at the point $$$x = 0$$$. He goes to his friend that lives at the point $$$x = a$$$. Polycarp can move only from left to right, he can pass one unit of length each second.Now it's raining, so some segments of his way are in the rain. Formally, it's raining on $$$n$$$ non-intersecting segments, the $$$i$$$-th segment which is in the rain is represented as $$$[l_i, r_i]$$$ ($$$0 \le l_i &lt; r_i \le a$$$).There are $$$m$$$ umbrellas lying on the line, the $$$i$$$-th umbrella is located at point $$$x_i$$$ ($$$0 \le x_i \le a$$$) and has weight $$$p_i$$$. When Polycarp begins his journey, he doesn't have any umbrellas.During his journey from $$$x = 0$$$ to $$$x = a$$$ Polycarp can pick up and throw away umbrellas. Polycarp picks up and throws down any umbrella instantly. He can carry any number of umbrellas at any moment of time. Because Polycarp doesn't want to get wet, he must carry at least one umbrella while he moves from $$$x$$$ to $$$x + 1$$$ if a segment $$$[x, x + 1]$$$ is in the rain (i.e. if there exists some $$$i$$$ such that $$$l_i \le x$$$ and $$$x + 1 \le r_i$$$).The condition above is the only requirement. For example, it is possible to go without any umbrellas to a point where some rain segment starts, pick up an umbrella at this point and move along with an umbrella. Polycarp can swap umbrellas while he is in the rain.Each unit of length passed increases Polycarp's fatigue by the sum of the weights of umbrellas he carries while moving.Can Polycarp make his way from point $$$x = 0$$$ to point $$$x = a$$$? If yes, find the minimum total fatigue after reaching $$$x = a$$$, if Polycarp picks up and throws away umbrellas optimally.","import sys

def input():
    return sys.stdin.readline().strip()

def input_l():
    return map(int, input().split())

def input_t():
    return tuple(input_l())
    
def main():
    a, s, d = input_l()
    q = []
    e = []
    z = [0] * (a + 1)
    
    for i in range(s):
        w = input_t()
        for k in range(w[0], w[1]):
            q.append(k + 1)

    for j in range(d):
        e.append(input_t())
    
    e = sorted(e, key = lambda x: x[0])
    
    if e[0][0] > q[0] - 1:
        print(-1)
        sys.exit(0)
    
    for i in range(1, len(z)):
        if i not in q:
            z[i] = z[i-1]
            continue
    
        for j in e:
            if i >= j[0]:
                c = (i - j[0]) * j[1] + z[j[0]]
                if z[i] > 0:
                    if c < z[i]:
                        z[i] = c            
                else:
                    z[i] = c
    
    print(z[-1])
    
main()",['dp']
"You are given an array $$$a$$$ of length $$$2n$$$. Consider a partition of array $$$a$$$ into two subsequences $$$p$$$ and $$$q$$$ of length $$$n$$$ each (each element of array $$$a$$$ should be in exactly one subsequence: either in $$$p$$$ or in $$$q$$$).Let's sort $$$p$$$ in non-decreasing order, and $$$q$$$ in non-increasing order, we can denote the sorted versions by $$$x$$$ and $$$y$$$, respectively. Then the cost of a partition is defined as $$$f(p, q) = \sum_{i = 1}^n |x_i - y_i|$$$.Find the sum of $$$f(p, q)$$$ over all correct partitions of array $$$a$$$. Since the answer might be too big, print its remainder modulo $$$998244353$$$.","'''Author- Akshit Monga'''
from sys import stdin,stdout
input=stdin.readline
m=998244353
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p
t =1
for _ in range(t):
    n=int(input())
    arr=[int(x) for x in input().split()]
    arr=sorted(arr)
    ans=((abs(sum(arr[0:n])-sum(arr[n:])))%m*ncr(2*n,n,m))%m
    print(ans)","['combinatorics', 'sortings', 'math']"
"Each year in the castle of Dwarven King there is a competition in growing mushrooms among the dwarves. The competition is one of the most prestigious ones, and the winner gets a wooden salad bowl. This year's event brought together the best mushroom growers from around the world, so we had to slightly change the rules so that the event gets more interesting to watch.Each mushroom grower has a mushroom that he will grow on the competition. Under the new rules, the competition consists of two parts. The first part lasts t1 seconds and the second part lasts t2 seconds. The first and the second part are separated by a little break.After the starting whistle the first part of the contest starts, and all mushroom growers start growing mushrooms at once, each at his individual speed of vi meters per second. After t1 seconds, the mushroom growers stop growing mushrooms and go to have a break. During the break, for unexplained reasons, the growth of all mushrooms is reduced by k percent. After the break the second part of the contest starts and all mushrooms growers at the same time continue to grow mushrooms, each at his individual speed of ui meters per second. After a t2 seconds after the end of the break, the competition ends. Note that the speeds before and after the break may vary.Before the match dwarf Pasha learned from all participants, what two speeds they have chosen. However, the participants did not want to disclose to him all their strategy and therefore, did not say in what order they will be using these speeds. That is, if a participant chose speeds ai and bi, then there are two strategies: he either uses speed ai before the break and speed bi after it, or vice versa.Dwarf Pasha really wants to win the totalizer. He knows that each participant chooses the strategy that maximizes the height of the mushroom. Help Dwarf Pasha make the final table of competition results.The participants are sorted in the result table by the mushroom height (the participants with higher mushrooms follow earlier in the table). In case of equal mushroom heights, the participants are sorted by their numbers (the participants with a smaller number follow earlier).","n, t1, t2, k = map(int, input().split())

board = []
for i in range(1,n+1):
	a, b = map(int, input().split())
	
	c1 = a*t2 + (1-k/100)*t1*b
	c2 = b*t2 + (1-k/100)*t1*a
	
	c = c1 if c1>c2 else c2
	board.append((i,c))


board = sorted(board, key = lambda x: x[1], reverse = True)


for p in board:
	print(""%d %.2f"" % (p[0],p[1]))","['sortings', 'greedy']"
"This is yet another problem on regular bracket sequences.A bracket sequence is called regular, if by inserting ""+"" and ""1"" into it we get a correct mathematical expression. For example, sequences ""(())()"", ""()"" and ""(()(()))"" are regular, while "")("", ""(()"" and ""(()))("" are not. You have a pattern of a bracket sequence that consists of characters ""("", "")"" and ""?"". You have to replace each character ""?"" with a bracket so, that you get a regular bracket sequence.For each character ""?"" the cost of its replacement with ""("" and "")"" is given. Among all the possible variants your should choose the cheapest.","# coding: utf-8

""""""
题解
判断一个括号序列是否合法常见的有两种方式，栈和前缀和。
使用前缀和时，初始化一个计数器为0，从左向右扫描序列，遇到左括号时计数器加一，右括号计数器减一。扫描过程中，计数器的值不能出现负数；扫描完成后，计数器的和为0，此时这个序列满足括号匹配规则。
这道题使用这种思路来做，就是一个贪心问题。
我们先将所有 ? 都当做右括号来处理。从左向右扫描序列，当计数器变为负数时，将左边的一个 ? 变为左括号，计数器加2 ，扫描完成后检查计数器是否为0。
考虑到这道题还要求替换成本最小，因此选择 ? 变为左括号时，要选择变完之后成本最小的那个。这里可以使用一个优先队列来存储 ? 替换为左右括号的成本，减少插入和获取的时间。
""""""

from heapq import heappush, heappop

def solution():
    line = raw_input() # 输入的原始序列
    result = []  # 替换后的结果
    cost = 0 # 替换后的总成本
    priority_queue = [] # 优先队列
    cnt = 0 # 计数器
    for index, char in enumerate(line):
        if char == '(':
            result.append(char)
            cnt += 1
        else:
            result.append(')')
            cnt -= 1
            # 读到问号，从标准输入获取替换成本，放入优先队列
            if char == '?':
                left_cost, right_cost = map(int, raw_input().split())
                heappush(priority_queue, (left_cost - right_cost, index))
                cost += right_cost  # 问号默认先按右括号处理

            if cnt < 0:
                if not priority_queue:  # 计数器出现负数，又没有 ? 可以替换为左括号
                    break

                # 挑选从右括号变为左括号后，成本减小最大的那个问号，贪心
                tmp_cost, tmp_index = heappop(priority_queue)
                cost += tmp_cost
                result[tmp_index] = '('
                cnt += 2

    if cnt != 0:
        print -1
    else:
        print cost
        print ''.join(result)


if __name__ == '__main__':
    solution()",['greedy']
"A function  is called Lipschitz continuous if there is a real constant K such that the inequality |f(x) - f(y)| ≤ K·|x - y| holds for all . We'll deal with a more... discrete version of this term.For an array , we define it's Lipschitz constant  as follows:  if n &lt; 2,   if n ≥ 2,  over all 1 ≤ i &lt; j ≤ n In other words,  is the smallest non-negative integer such that |h[i] - h[j]| ≤ L·|i - j| holds for all 1 ≤ i, j ≤ n.You are given an array  of size n and q queries of the form [l, r]. For each query, consider the subarray ; determine the sum of Lipschitz constants of all subarrays of .","f = lambda: map(int, input().split())
n, m = f()
t = list(f())
p = [1e9] + [abs(b - a) for a, b in zip(t, t[1:])] + [1e9]
L, R = [0] * n, [0] * n
for i in range(1, n):
    j = n - i
    x, y = i - 1, j + 1
    a, b = p[i], p[j]
    while a > p[x]: x = L[x]
    while b >= p[y]: y = R[y]
    L[i], R[j] = x, y
for k in range(m):
    l, r = f()
    print(sum((i - max(l - 1, L[i])) * (min(r, R[i]) - i) * p[i] for i in range(l, r)))","['data structures', 'math']"
"Ivan is playing a strange game.He has a matrix a with n rows and m columns. Each element of the matrix is equal to either 0 or 1. Rows and columns are 1-indexed. Ivan can replace any number of ones in this matrix with zeroes. After that, his score in the game will be calculated as follows:  Initially Ivan's score is 0;  In each column, Ivan will find the topmost 1 (that is, if the current column is j, then he will find minimum i such that ai, j = 1). If there are no 1's in the column, this column is skipped;  Ivan will look at the next min(k, n - i + 1) elements in this column (starting from the element he found) and count the number of 1's among these elements. This number will be added to his score. Of course, Ivan wants to maximize his score in this strange game. Also he doesn't want to change many elements, so he will replace the minimum possible number of ones with zeroes. Help him to determine the maximum possible score he can get and the minimum possible number of replacements required to achieve that score.","n,m,k = map(int,raw_input().split())
arr = []
for i in range(n):
  arr.append(list(map(int,raw_input().split())))
ans = 0
ans2 = 0
for i in range(m):
  cnt = 0
  res = 0
  res2 = 0
  for j in range(n):
    if arr[j][i]==1:
      cnt += 1
      temp = 0
      for l in range(j,min(j+k,n)):
        temp += arr[l][i]
      if temp > res:
        res = temp
        res2 = cnt-1
  ans += res
  ans2 += res2
print ans,ans2","['two pointers', 'greedy']"
"During her tantrums the princess usually smashes some collectable porcelain. Every furious shriek is accompanied with one item smashed.The collection of porcelain is arranged neatly on n shelves. Within each shelf the items are placed in one row, so that one can access only the outermost items — the leftmost or the rightmost item, not the ones in the middle of the shelf. Once an item is taken, the next item on that side of the shelf can be accessed (see example). Once an item is taken, it can't be returned to the shelves.You are given the values of all items. Your task is to find the maximal damage the princess' tantrum of m shrieks can inflict on the collection of porcelain.","#!/usr/bin/env python3
import os
import sys
from io import BytesIO, IOBase


class FastO:
    def __init__(self, fd=1):
        stream = BytesIO()
        self.flush = lambda: os.write(fd, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)
        self.write = lambda b: stream.write(b.encode())


class ostream:
    def __lshift__(self, a):
        sys.stdout.write(str(a))
        return self


sys.stdout, cout = FastO(), ostream()

numbers, num, sign = [], 0, True
for char in os.read(0, os.fstat(0).st_size):
    if char >= 48:
        num = num * 10 + char - 48
    elif char == 45:
        sign = False
    elif char != 13:
        numbers.append(num if sign else -num)
        num, sign = 0, True

if char >= 48:
    numbers.append(num if sign else -num)

getnum = iter(numbers).__next__


def main():
    n, m = getnum(), getnum()

    _dp = [[] for _ in range(n)]
    for i in range(n):
        ni = getnum()
        ai = [getnum() for _ in range(ni)]

        cumsum = [0] * (ni + 1)
        for j in range(ni):
            cumsum[j + 1] = cumsum[j] + ai[j]

        _dpi = [0] * (ni + 1)
        for j in range(ni + 1):
            for k in range(j, ni + 1):
                _dpi[ni + j - k] = max(_dpi[ni + j - k], cumsum[j] + cumsum[-1] - cumsum[k])
        _dp[i] = _dpi

    dp = [0] * (m + 1)
    for i in range(n):
        for j in reversed(range(m + 1)):
            for k in range(min(len(_dp[i]), j + 1)):
                dp[j] = max(dp[j], _dp[i][k] + dp[j - k])

    cout << dp[m]


if __name__ == '__main__':
    main()",['dp']
"Note that the only difference between String Transformation 1 and String Transformation 2 is in the move Koa does. In this version the letter $$$y$$$ Koa selects must be strictly greater alphabetically than $$$x$$$ (read statement for better understanding). You can make hacks in these problems independently.Koa the Koala has two strings $$$A$$$ and $$$B$$$ of the same length $$$n$$$ ($$$|A|=|B|=n$$$) consisting of the first $$$20$$$ lowercase English alphabet letters (ie. from a to t).In one move Koa:  selects some subset of positions $$$p_1, p_2, \ldots, p_k$$$ ($$$k \ge 1; 1 \le p_i \le n; p_i \neq p_j$$$ if $$$i \neq j$$$) of $$$A$$$ such that $$$A_{p_1} = A_{p_2} = \ldots = A_{p_k} = x$$$ (ie. all letters on this positions are equal to some letter $$$x$$$).  selects a letter $$$y$$$ (from the first $$$20$$$ lowercase letters in English alphabet) such that $$$y&gt;x$$$ (ie. letter $$$y$$$ is strictly greater alphabetically than $$$x$$$).  sets each letter in positions $$$p_1, p_2, \ldots, p_k$$$ to letter $$$y$$$. More formally: for each $$$i$$$ ($$$1 \le i \le k$$$) Koa sets $$$A_{p_i} = y$$$. Note that you can only modify letters in string $$$A$$$.Koa wants to know the smallest number of moves she has to do to make strings equal to each other ($$$A = B$$$) or to determine that there is no way to make them equal. Help her!","import sys
input = sys.stdin.readline
def print(val):
    sys.stdout.write(str(val) + '\n')
def prog():
    for _ in range(int(input())):
        n = int(input())
        a = list(input().strip())
        b = input().strip()
        fail = False
        for i in range(n):
            if b[i] < a[i]:
                fail = True
                break
        if fail:
            print(-1)
        else:
            exclude = [0]*n
            for i in range(n):
                if a[i] == b[i]:
                    exclude[i] = 1
                    
            largest = max(b)
            curr = largest
            for i in range(n):
                if not exclude[i]:
                    curr = min(curr, a[i])
            operations = 0
            while curr < largest:
                to_change = []
                for i in range(n):
                    if a[i] == curr and not exclude[i]:
                        to_change.append(i)
                smallest = largest
                for i in to_change:
                    smallest = min(smallest, b[i])
                for i in to_change:
                    if b[i] == smallest:
                        exclude[i] = 1
                    a[i] = smallest
                curr = largest
                for i in range(n):
                    if not exclude[i]:
                        curr = min(curr, a[i])
                operations += 1
            print(operations)
prog()","['greedy', 'graphs', 'dsu', 'sortings', 'dfs and similar', 'trees']"
"Vasya has an array of integers of length n.Vasya performs the following operations on the array: on each step he finds the longest segment of consecutive equal integers (the leftmost, if there are several such segments) and removes it. For example, if Vasya's array is [13, 13, 7, 7, 7, 2, 2, 2], then after one operation it becomes [13, 13, 2, 2, 2].Compute the number of operations Vasya should make until the array becomes empty, i.e. Vasya removes all elements from it.","import heapq

n = int(input())
a = list(map(int, input().split()))

# idx: l, r, length, val
d   = {}
pre, l = None, 0
seg    = []

for i, x in enumerate(a):
    if pre is None:
        pre = x
        l   = 1
    else:
        if x == pre:
            l+=1
        else:
            seg.append([l, pre])
            pre = x
            l   = 1
            
    if i==len(a)-1:
        seg.append([l, x])
        
Q = []
for i, s in enumerate(seg):
    l=None if i  ==0 else i-1
    r=None if i+1==len(seg) else i+1
    d[i] = [l, r, s[0], s[1]]
    
    heapq.heappush(Q, (-s[0], i))      
    
cnt=0
while len(Q) > 0:
    length, idx = heapq.heappop(Q)
    length = -length
    
    #print(d[idx])
    if d[idx][2] != length:
        continue
        
    l, r, length, val = d[idx]
    d[idx][0]=0
    cnt+=1
    
    if l is None and r is None:
        break
    elif l is None:
        d[r][0] = None
    elif r is None:
        d[l][1] = None
    else:
        if d[l][3] == d[r][3]:
            d[l][1]  = d[r][1]
            d[l][2] += d[r][2]
            d[r][2]  = 0
            
            if d[r][1] is not None:
                nnr       = d[r][1]
                d[nnr][0] = l 
                
            heapq.heappush(Q, (-d[l][2], l))
        else:
            d[l][1] = r
            d[r][0] = l
print(cnt)","['two pointers', 'flows', 'dsu', 'implementation', 'data structures']"
"Sereja loves number sequences very much. That's why he decided to make himself a new one following a certain algorithm.Sereja takes a blank piece of paper. Then he starts writing out the sequence in m stages. Each time he either adds a new number to the end of the sequence or takes l first elements of the current sequence and adds them c times to the end. More formally, if we represent the current sequence as a1, a2, ..., an, then after we apply the described operation, the sequence transforms into a1, a2, ..., an[, a1, a2, ..., al] (the block in the square brackets must be repeated c times). A day has passed and Sereja has completed the sequence. He wonders what are the values of some of its elements. Help Sereja.","from bisect import bisect_left
def fun(ind,alr,ll,sll):
    if ind in alr:
        return alr[ind]
    k = bisect_left(sll,ind)
    md = ll[k]
    return fun((ind-sll[k])%md,alr,ll,sll)
pos = {}
m = int(input())
l = 0
cp = []
cpl = []
for _ in range(0,m):
    q = [int(i) for i in input().split()]
    if q[0] == 1:
        pos[l] = q[1]
        l += 1
    else:
        cp.append(q[1])
        l += q[1]*q[2]
        cpl.append(l)
n = int(input())
qq = [int(i)-1 for i in input().split()]
ans = [fun(i,pos,cp,cpl) for i in qq]
print(*ans)","['binary search', 'brute force']"
"Berland starts to seize the initiative on the war with Flatland. To drive the enemy from their native land, the berlanders need to know exactly how many more flatland soldiers are left in the enemy's reserve. Fortunately, the scouts captured an enemy in the morning, who had a secret encrypted message with the information the berlanders needed so much.The captured enemy had an array of positive integers. Berland intelligence have long been aware of the flatland code: to convey the message, which contained a number m, the enemies use an array of integers a. The number of its subarrays, in which there are at least k equal numbers, equals m. The number k has long been known in the Berland army so General Touristov has once again asked Corporal Vasya to perform a simple task: to decipher the flatlanders' message.Help Vasya, given an array of integers a and number k, find the number of subarrays of the array of numbers a, which has at least k equal numbers.Subarray a[i... j] (1 ≤ i ≤ j ≤ n) of array a = (a1, a2, ..., an) is an array, made from its consecutive elements, starting from the i-th one and ending with the j-th one: a[i... j] = (ai, ai + 1, ..., aj).","import collections

n, k = map(int, raw_input().split())
a = map(int, raw_input().split())
out = 0
dic = collections.defaultdict(int)
right = -1
left = -1
for i in xrange(n):
    dic[a[i]] += 1
    if dic[a[i]] == k:
        if left != -1 : # count submassives
            out += (i - right) * (left + 1)
        right = i
        for j in xrange(left + 1, i + 1):
            if dic[a[j]] == k:
                left = j
                dic[a[j]] -= 1
                break
            dic[a[j]] -= 1
if left != -1:
    out +=  (n - right) * (left + 1)

print out",['two pointers']
"Polycarp has n dice d1, d2, ..., dn. The i-th dice shows numbers from 1 to di. Polycarp rolled all the dice and the sum of numbers they showed is A. Agrippina didn't see which dice showed what number, she knows only the sum A and the values d1, d2, ..., dn. However, she finds it enough to make a series of statements of the following type: dice i couldn't show number r. For example, if Polycarp had two six-faced dice and the total sum is A = 11, then Agrippina can state that each of the two dice couldn't show a value less than five (otherwise, the remaining dice must have a value of at least seven, which is impossible).For each dice find the number of values for which it can be guaranteed that the dice couldn't show these values if the sum of the shown values is A.","n, a = map(int, input().split())
d = list(map(int, input().split()))
s = sum(d)

def solve():
    for x in d:
        yield max(x - (a - n + 1), 0) + max(a - (s - x) - 1, 0)

print(' '.join(map(str, solve())))",['math']
"Recently Pashmak has been employed in a transportation company. The company has k buses and has a contract with a school which has n students. The school planned to take the students to d different places for d days (each day in one place). Each day the company provides all the buses for the trip. Pashmak has to arrange the students in the buses. He wants to arrange the students in a way that no two students become close friends. In his ridiculous idea, two students will become close friends if and only if they are in the same buses for all d days.Please help Pashmak with his weird idea. Assume that each bus has an unlimited capacity.","n,k,d=map(int,input().split())
if n>k**d:print(-1);exit()
K=1
for j in range(d):
    print("" "".join([str(i//K%k +1) for i in range(n)]))
    K*=k","['constructive algorithms', 'math', 'combinatorics']"
"We often have to copy large volumes of information. Such operation can take up many computer resources. Therefore, in this problem you are advised to come up with a way to copy some part of a number array into another one, quickly.More formally, you've got two arrays of integers a1, a2, ..., an and b1, b2, ..., bn of length n. Also, you've got m queries of two types:  Copy the subsegment of array a of length k, starting from position x, into array b, starting from position y, that is, execute by + q = ax + q for all integer q (0 ≤ q &lt; k). The given operation is correct — both subsegments do not touch unexistent elements.  Determine the value in position x of array b, that is, find value bx. For each query of the second type print the result — the value of the corresponding element of array b.","from sys import stdin
import math


def task_old():
    n, m = map(int, stdin.readline().split())
    a = map(int, stdin.readline().split())
    b = map(int, stdin.readline().split())
    values = [map(int, i) for i in map(str.split, stdin.readlines())]
    size = max(2, int(math.sqrt(len(values))))
    z = [-1] * int(math.ceil(float(n) / size))

    result = []
    for request in values:
        print 'z>%s' % z
        print 'a>%s' % ''.join([i.rjust(4) for i in map(str, a)])
        print 'b>%s' % ''.join([i.rjust(4) for i in map(str, b)])
        if request[0] == 1:
            # copy
            p_a, p_b, length = request[1:]
            p_a, p_b = p_a - 1, p_b - 1
            print 'set a(%s, %s) => b(%s, %s)' % (p_a, p_a + length - 1, p_b, p_b + length - 1)
            z1, i1 = divmod(p_b, size)
            z2, i2 = divmod((p_b + length - 1), size)
            l = min(size - i1, length)
            b[p_b:p_b + l] = a[p_a:p_a + l]
            if z2 > z1:
                b[p_b + length - i2 - 1: p_b + length] = a[p_a + length - i2 - 1: p_a + length]
            for zi in xrange(z2 - z1 - 1):
                z[z1 + zi + 1] = p_a - (size - i1) + zi * size
        else:
            # get
            i = request[1] - 1
            print 'get %s item' % i,
            zi, p_z = divmod(i, size)
            if z[zi] == -1:
                result.append(b[i])
                print '=> %s' % b[i]
            else:
                result.append(a[z[zi] + p_z])
                print ' => %s' % a[z[zi] + p_z]
        print

    print '\n'.join(map(str, result))


MED_L = 1 << 17
MAX_L = MED_L << 1

def task():
    n, m = map(int, stdin.readline().split())
    a = map(int, stdin.readline().split())
    b = map(int, stdin.readline().split())
    values = [map(int, i) for i in map(str.split, stdin.readlines())]

    x = [0]*m
    y = [0]*m
    z = [0]*m
    t = [-1]*MAX_L

    def mark(q, lo, hi):
        lo += MED_L
        hi += MED_L
        while lo <= hi:
            if lo & 1:
                t[lo] = q
                lo += 1
            if not (hi & 1):
                t[hi] = q
                hi -= 1
            lo >>= 1
            hi >>= 1

    def value(p):
        res = b[p]
        q = -1
        s = p + MED_L
        while s > 0:
            q = max(q, t[s])
            s >>= 1
        if q != -1:
            res = a[x[q] + p - y[q]]
        return res

    result = []
    for j in xrange(m):
        if values[j][0] == 1:
            x[j], y[j], z[j] = values[j][1:]
            x[j] -= 1
            y[j] -= 1
            mark(j, y[j], y[j] + z[j] - 1)
        else:
            p = values[j][1] - 1
            result.append(value(p))

    print '\n'.join(map(str, result))


task()",['data structures']
"On vacations n pupils decided to go on excursion and gather all together. They need to overcome the path with the length l meters. Each of the pupils will go with the speed equal to v1. To get to the excursion quickly, it was decided to rent a bus, which has seats for k people (it means that it can't fit more than k people at the same time) and the speed equal to v2. In order to avoid seasick, each of the pupils want to get into the bus no more than once.Determine the minimum time required for all n pupils to reach the place of excursion. Consider that the embarkation and disembarkation of passengers, as well as the reversal of the bus, take place immediately and this time can be neglected.","#!/usr/bin/python3

import sys
sys.setrecursionlimit(10 ** 9)

def bscheck(n, l, v1, v2, k, t):
    while True:
        if k > n:
            k = n
        if n == 0:
            return True
        if l / v2 > t:
            return False
    #    v2 * tx + v1 * (t - tx) = l
    #    (v2 - v1) * tx = l - v1 * t
        tx = (l - v1 * t) / (v2 - v1)
        ty = (tx * v2 - tx * v1) / (v1 + v2)

        _n = n - k
        _l = l - tx * v1 - ty * v1
        _t = t - tx - ty

        n = _n
        l = _l
        t = _t


n, l, v1, v2, k = map(int, input().split())

lt, rt = 0, 1791791791
for i in range(100):
    mid = (lt + rt) / 2
    if bscheck(n, l, v1, v2, k, mid):
        rt = mid
    else:
        lt = mid

print(rt)","['binary search', 'math']"
The circle line of the Berland subway has n stations. We know the distances between all pairs of neighboring stations: d1 is the distance between the 1-st and the 2-nd station; d2 is the distance between the 2-nd and the 3-rd station;... dn - 1 is the distance between the n - 1-th and the n-th station; dn is the distance between the n-th and the 1-st station.The trains go along the circle line in both directions. Find the shortest distance between stations with numbers s and t.,"n = input()
d = list(map(int, raw_input().split()))
s, t = map(int, raw_input().split())
a = sum(d)

if s == t:
        print 0
else:
        s, t = min(s, t), max(s, t)
        b = sum(d[s-1: t-1])
        print min(b, a-b)",['implementation']
"Vasya has several phone books, in which he recorded the telephone numbers of his friends. Each of his friends can have one or several phone numbers.Vasya decided to organize information about the phone numbers of friends. You will be given n strings — all entries from Vasya's phone books. Each entry starts with a friend's name. Then follows the number of phone numbers in the current entry, and then the phone numbers themselves. It is possible that several identical phones are recorded in the same record.Vasya also believes that if the phone number a is a suffix of the phone number b (that is, the number b ends up with a), and both numbers are written by Vasya as the phone numbers of the same person, then a is recorded without the city code and it should not be taken into account.The task is to print organized information about the phone numbers of Vasya's friends. It is possible that two different people have the same number. If one person has two numbers x and y, and x is a suffix of y (that is, y ends in x), then you shouldn't print number x. If the number of a friend in the Vasya's phone books is recorded several times in the same format, it is necessary to take it into account exactly once.Read the examples to understand statement and format of the output better.","def cleaner(l):
    l = list(set(l))
    l.sort()
    ans=[]
    for i in range(len(l)):
        for j in range(0,len(l)):
            if l[j].endswith(l[i]) and i!=j:
                break
        else:
            ans+=[l[i]]
    return ans
d = dict()
for t in range(int(input())):
    l = [x for x in input().split("" "")]
    name,x = l[0],[1]
    l = l[2:]
    if name in d:
        d[name]+=l
    else:
        d[name]=l
keys = d.keys()
print(len(keys))
for k in keys:
    l = cleaner(d[k])
    print(k,len(l),*l)","['implementation', 'strings']"
"There are two bus stops denoted A and B, and there $$$n$$$ buses that go from A to B every day. The shortest path from A to B takes $$$t$$$ units of time but some buses might take longer paths. Moreover, buses are allowed to overtake each other during the route.At each station one can find a sorted list of moments of time when a bus is at this station. We denote this list as $$$a_1 &lt; a_2 &lt; \ldots &lt; a_n$$$ for stop A and as $$$b_1 &lt; b_2 &lt; \ldots &lt; b_n$$$ for stop B. The buses always depart from A and arrive to B according to the timetable, but the order in which the buses arrive may differ. Let's call an order of arrivals valid if each bus arrives at least $$$t$$$ units of time later than departs.It is known that for an order to be valid the latest possible arrival for the bus that departs at $$$a_i$$$ is $$$b_{x_i}$$$, i.e. $$$x_i$$$-th in the timetable. In other words, for each $$$i$$$ there exists such a valid order of arrivals that the bus departed $$$i$$$-th arrives $$$x_i$$$-th (and all other buses can arrive arbitrary), but there is no valid order of arrivals in which the $$$i$$$-th departed bus arrives $$$(x_i + 1)$$$-th.Formally, let's call a permutation $$$p_1, p_2, \ldots, p_n$$$ valid, if $$$b_{p_i} \ge a_i + t$$$ for all $$$i$$$. Then $$$x_i$$$ is the maximum value of $$$p_i$$$ among all valid permutations.You are given the sequences $$$a_1, a_2, \ldots, a_n$$$ and $$$x_1, x_2, \ldots, x_n$$$, but not the arrival timetable. Find out any suitable timetable for stop B $$$b_1, b_2, \ldots, b_n$$$ or determine that there is no such timetable.","n, t = map(int, input().split())
a = list(map(int, input().split()))
x = list(map(int, input().split()))
if n == 200000 and t == 10000 or n == 5000 and t == 100:
	print('No')
	exit(0)
for i in range(len(x)):
	if x[i] < i + 1 or (i > 0 and x[i] < x[i - 1]):
		print('No')
		exit(0)
b = [ 3 * 10 ** 18 ]
for i in range(len(x) - 1):
	ind = len(x) - i - 2
	lower, upper = a[ind] + t, b[-1] - 1
	if x[ind + 1] != x[ind]:
		upper = min(upper, a[ind + 1] + t - 1)
	else:
		lower = max(lower, a[ind + 1] + t)
	if upper < lower:
		print('No')
		exit(0)
	b.append(upper)
print('Yes\n' + ' '.join(list(map(str, b[::-1]))))","['constructive algorithms', 'math']"
"Vasya tries to break in a safe. He knows that a code consists of n numbers, and every number is a 0 or a 1. Vasya has made m attempts to enter the code. After each attempt the system told him in how many position stand the right numbers. It is not said in which positions the wrong numbers stand. Vasya has been so unlucky that he hasn’t entered the code where would be more than 5 correct numbers. Now Vasya is completely bewildered: he thinks there’s a mistake in the system and it is self-contradictory. Help Vasya — calculate how many possible code variants are left that do not contradict the previous system responses.","from itertools import combinations

def calculate(s, dif):
	x = int(s, 2)
	for j in combinations(range(len(s)), dif):
		y = x
		for k in j:
			y ^= (2**k)
		yield y

def calculate2(s, dif, arr):
	y = int(s, 2)
	for x in arr:
	    if(bin(y ^ x).count('1') == dif):
	        yield x


n, m = map(int, input().split())
result = []
(st, dif) = input().split()
total = calculate(st, int(dif))
for i in range(1, m):
	st, dif = input().split()
	total = calculate2(st, int(dif), total)

print(len(list(total)))",['brute force']
"A string is binary, if it consists only of characters ""0"" and ""1"".String v is a substring of string w if it has a non-zero length and can be read starting from some position in string w. For example, string ""010"" has six substrings: ""0"", ""1"", ""0"", ""01"", ""10"", ""010"". Two substrings are considered different if their positions of occurrence are different. So, if some string occurs multiple times, we should consider it the number of times it occurs.You are given a binary string s. Your task is to find the number of its substrings, containing exactly k characters ""1"".","k=int(input())
l=input()
if k==0:
    c=0
    ans=0
    for i in range(len(l)):
        if l[i]==""0"":
            c+=1
        else:
            temp=((c*(c+1))//2)
            ans+=temp
            c=0
    ans+=(c*(c+1))//2
    print(ans)
else:
    ans=0
    ar=[]
    a=-1
    for i in range(len(l)):
        if l[i]==""1"":
            ar.append(i-a-1)
            a=i
    ar.append(len(l)-a-1)
    p=len(ar)-1
    for i in range(len(ar)):
        if i+k>p:
            break
        ans+=ar[i]*ar[i+k]+ar[i]+ar[i+k]+1
    print(ans)","['dp', 'two pointers', 'math', 'binary search', 'brute force', 'strings']"
"Reading books is one of Sasha's passions. Once while he was reading one book, he became acquainted with an unusual character. The character told about himself like that: ""Many are my names in many countries. Mithrandir among the Elves, Tharkûn to the Dwarves, Olórin I was in my youth in the West that is forgotten, in the South Incánus, in the North Gandalf; to the East I go not.""And at that moment Sasha thought, how would that character be called in the East? In the East all names are palindromes. A string is a palindrome if it reads the same backward as forward. For example, such strings as ""kazak"", ""oo"" and ""r"" are palindromes, but strings ""abb"" and ""ij"" are not. Sasha believed that the hero would be named after one of the gods of the East. As long as there couldn't be two equal names, so in the East people did the following: they wrote the original name as a string on a piece of paper, then cut the paper minimum number of times $$$k$$$, so they got $$$k+1$$$ pieces of paper with substrings of the initial string, and then unite those pieces together to get a new string. Pieces couldn't be turned over, they could be shuffled.In this way, it's possible to achive a string abcdefg from the string f|de|abc|g using $$$3$$$ cuts (by swapping papers with substrings f and abc). The string cbadefg can't be received using the same cuts.More formally, Sasha wants for the given palindrome $$$s$$$ find such minimum $$$k$$$, that you can cut this string into $$$k + 1$$$ parts, and then unite them in such a way that the final string will be a palindrome and it won't be equal to the initial string $$$s$$$. It there is no answer, then print ""Impossible"" (without quotes).","s = input()

l = len(s)

c = s[0]
diff = False
for i in range(0,int(l/2)):
    if s[i] != c:
        diff = True

if not diff:
    print('Impossible')
    exit()

s_2 = s + s

for i in range(1,l):
    is_palendrome = True

    for j in range(int(l/2)):
        if s_2[j + i] != s_2[i + l - j-1]:
            is_palendrome = False
    if is_palendrome and s_2[i:i+l] != s:
        print(1)
        exit()

print(2)","['constructive algorithms', 'brute force', 'strings']"
"You are given an undirected unweighted graph consisting of $$$n$$$ vertices and $$$m$$$ edges (which represents the map of Bertown) and the array of prices $$$p$$$ of length $$$m$$$. It is guaranteed that there is a path between each pair of vertices (districts).Mike has planned a trip from the vertex (district) $$$a$$$ to the vertex (district) $$$b$$$ and then from the vertex (district) $$$b$$$ to the vertex (district) $$$c$$$. He can visit the same district twice or more. But there is one issue: authorities of the city want to set a price for using the road so if someone goes along the road then he should pay the price corresponding to this road (he pays each time he goes along the road). The list of prices that will be used $$$p$$$ is ready and they just want to distribute it between all roads in the town in such a way that each price from the array corresponds to exactly one road.You are a good friend of Mike (and suddenly a mayor of Bertown) and want to help him to make his trip as cheap as possible. So, your task is to distribute prices between roads in such a way that if Mike chooses the optimal path then the price of the trip is the minimum possible. Note that you cannot rearrange prices after the start of the trip.You have to answer $$$t$$$ independent test cases.","import sys
import io, os
import math
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
import collections
from collections import defaultdict
def bfs1(root):
    queue = collections.deque([root])
    dist=[math.inf]*(n+1)
    dist[root]=0
    while queue:
        vertex = queue.popleft()
        for neighbour in graph1[vertex]:
            if  dist[neighbour]!=math.inf:
                continue
            dist[neighbour]=min(dist[neighbour],dist[vertex]+1)
            queue.append(neighbour)
            #print(prev)
    
    return(dist)
def restore(par, s,src):
    res = []
    while s != src:
        
        res.append(par[s][1])
        s = par[s][0]
    return(res)
t=int(input())
for count in range(t):
    n,m,a,b,c=map(int,input().split())
    p=[int(i) for i in input().split() if i!='\n']
    p.sort()
    p.insert(0,0)
    for i in range(1,len(p)):
        p[i]=p[i-1]+p[i]
    
    graph1=defaultdict(list)
    for j in range(m):
        x,y=map(int,input().split())
        graph1[x].append(y)
        graph1[y].append(x)
    one=bfs1(a)
    two=bfs1(b)
    three=bfs1(c)
    ans=math.inf
    for i in range(1,len(three)):
        try:
            ans=min(ans,p[one[i]+two[i]+three[i]]+p[two[i]])
        except:
            pass
    sys.stdout.write(str(ans)+'\n')","['greedy', 'graphs', 'shortest paths', 'sortings', 'brute force']"
"Professor GukiZ likes programming contests. He especially likes to rate his students on the contests he prepares. Now, he has decided to prepare a new contest. In total, n students will attend, and before the start, every one of them has some positive integer rating. Students are indexed from 1 to n. Let's denote the rating of i-th student as ai. After the contest ends, every student will end up with some positive integer position. GukiZ expects that his students will take places according to their ratings. He thinks that each student will take place equal to . In particular, if student A has rating strictly lower then student B, A will get the strictly better position than B, and if two students have equal ratings, they will share the same position. GukiZ would like you to reconstruct the results by following his expectations. Help him and determine the position after the end of the contest for each of his students if everything goes as expected.","# problem 1

n = raw_input()
ratings = raw_input().split()

# calculate positions, e.g. sort descending order

newlst = [0]*len(ratings)

# need to create another array to modify ranks
for i in xrange(len(ratings)) :
	newlst[i] = int(ratings[i])

# sort array in reverse order of rank (high-->low)
newlst.sort(reverse=True)

# dictionary that holds ('key', 'val') as ('rating', 'position amongst peers')
results = {}

for i in xrange(len(ratings)) :
	if not(newlst[i] in results):
		results[newlst[i]] = i + 1

# in order of input, print out the position of each rating
for i in xrange(len(ratings)) :
	print (results[int(ratings[i])]),","['implementation', 'sortings', 'brute force']"
"The Happy Farm 5 creators decided to invent the mechanism of cow grazing. The cows in the game are very slow and they move very slowly, it can even be considered that they stand still. However, carnivores should always be chased off them. For that a young player Vasya decided to make the shepherd run round the cows along one and the same closed path. It is very important that the cows stayed strictly inside the area limited by the path, as otherwise some cows will sooner or later be eaten. To be absolutely sure in the cows' safety, Vasya wants the path completion time to be minimum.The new game is launched for different devices, including mobile phones. That's why the developers decided to quit using the arithmetics with the floating decimal point and use only the arithmetics of integers. The cows and the shepherd in the game are represented as points on the plane with integer coordinates. The playing time is modeled by the turns. During every turn the shepherd can either stay where he stands or step in one of eight directions: horizontally, vertically, or diagonally. As the coordinates should always remain integer, then the length of a horizontal and vertical step is equal to 1, and the length of a diagonal step is equal to . The cows do not move. You have to minimize the number of moves the shepherd needs to run round the whole herd.","import math

n = int(input())

l = []
for i in range(n):
    l.append(tuple(list(map(int, input().split("" "")))))
l = list(set(l))
n = len(l)

pmin = 0
for i in range(1, n):
    if(l[i][1] < l[pmin][1] or (l[i][1] == l[pmin][1] and l[i][0] < l[pmin][0])):
        pmin = i

l[pmin], l[0] = l[0], l[pmin]

def orientation(p0, p1, p2):
    x = (p1[1] - p0[1]) * (p2[0] - p1[0]) - (p1[0] - p0[0]) * (p2[1] - p1[1])
    if(x < 0):
        return -1
    if(x > 0):
        return 1
    return 0

l = [(p[0] - l[0][0], p[1] - l[0][1]) for p in l[1:]]
l.sort(key = lambda p: (-p[0]/p[1] if(p[1] != 0) else -10e14, p[0] ** 2 + p[1] ** 2))
l = [(0, 0)] + l

t = [l[0]]
i = 1
n = len(l)
while(1):
    while(i < n - 1 and orientation(l[0], l[i], l[i + 1]) == 0):
        i += 1
    if(i >= n - 1):
        break
    t.append(l[i])
    i += 1
    
t.append(l[-1])

if(len(t) == 1):
    print(4)
elif(len(t) == 2):
    print(max(abs(t[1][1] - t[0][1]), abs(t[1][0] - t[0][0])) * 2 + 4)
else:
    stack = [t[0], t[1], t[2]]
    for i in range(3, len(t)):
        while(orientation(stack[-2], stack[-1], t[i]) == 1):
            stack.pop()
        stack.append(t[i])
    
    n = len(stack)
    s = 4
    for i in range(n - 1):
        s += max(abs(stack[i + 1][1] - stack[i][1]), abs(stack[i + 1][0] - stack[i][0]))
    s += max(abs(stack[0][1] - stack[n - 1][1]), abs(stack[0][0] - stack[n - 1][0]))
    print(s)",['geometry']
"There is a polyline going through points (0, 0) – (x, x) – (2x, 0) – (3x, x) – (4x, 0) – ... - (2kx, 0) – (2kx + x, x) – .... We know that the polyline passes through the point (a, b). Find minimum positive value x such that it is true or determine that there is no such x.","from math import floor
def main():
    a, b = map(int, input().split())
    if (b > a):
        print(-1)
        return 
    y = (a + b) / 2
    k = y // b    
    print(y / k)

main()","['binary search', 'math']"
"The map of Berland is a rectangle of the size n × m, which consists of cells of size 1 × 1. Each cell is either land or water. The map is surrounded by the ocean. Lakes are the maximal regions of water cells, connected by sides, which are not connected with the ocean. Formally, lake is a set of water cells, such that it's possible to get from any cell of the set to any other without leaving the set and moving only to cells adjacent by the side, none of them is located on the border of the rectangle, and it's impossible to add one more water cell to the set such that it will be connected with any other cell.You task is to fill up with the earth the minimum number of water cells so that there will be exactly k lakes in Berland. Note that the initial number of lakes on the map is not less than k.","n,m,k = (int(x) for x in input().split())
Map = []
lakesizes = [0]
lakemembers = [0]
for i in range(n):
    Map.append([x for x in input()])




stack = [(x,y,None) for x in range(1,m-1) for y in range(1,n-1)] + [(0,y,None) for y in range(n)] + [(m-1,y,None) for y in range(n)] + [(x,0,None) for x in range(1,m-1)] + [(x,n-1,None) for x in range(1,m-1)]
lakenumber = [ [None]*m for y in range(n) ]
for y in range(n):
    for x in range(m):
        if Map[y][x] == '.':
            lakenumber[y][x] = -1

while(stack):
    x,y,current = stack.pop()
    if lakenumber[y][x] is not None and lakenumber[y][x] < 0:

        if current is None:
            if x in [0,m-1] or y in [0,n-1]:
                current = 0
            else:
                current = len(lakesizes)
                lakesizes.append(0)
                lakemembers.append([])

        lakenumber[y][x] = current
        lakesizes[current] += 1
        if current > 0:
            lakemembers[current].append( (x,y) )

        for xo,yo in [(x,y+1),(x,y-1),(x+1,y),(x-1,y)]:
            if 0 <= yo < n and 0 <= xo < m:
                stack.append( (xo,yo,current) )

ordlakes = [(lakesizes[i],i) for i in range(1,len(lakesizes))]
ordlakes.sort()
totalsize = 0
for i in range(len(ordlakes)-k):
    size,ind = ordlakes[i]
    totalsize += size
    for x,y in lakemembers[ind]:
        Map[y][x] = '*'

print(totalsize)
for i in range(n):
    print(''.join(Map[i]))","['greedy', 'graphs', 'dsu', 'implementation', 'dfs and similar']"
"There are $$$n$$$ students in the first grade of Nlogonia high school. The principal wishes to split the students into two classrooms (each student must be in exactly one of the classrooms). Two distinct students whose name starts with the same letter will be chatty if they are put in the same classroom (because they must have a lot in common). Let $$$x$$$ be the number of such pairs of students in a split. Pairs $$$(a, b)$$$ and $$$(b, a)$$$ are the same and counted only once.For example, if there are $$$6$$$ students: ""olivia"", ""jacob"", ""tanya"", ""jack"", ""oliver"" and ""jessica"", then:  splitting into two classrooms (""jack"", ""jacob"", ""jessica"", ""tanya"") and (""olivia"", ""oliver"") will give $$$x=4$$$ ($$$3$$$ chatting pairs in the first classroom, $$$1$$$ chatting pair in the second classroom),  splitting into two classrooms (""jack"", ""tanya"", ""olivia"") and (""jessica"", ""oliver"", ""jacob"") will give $$$x=1$$$ ($$$0$$$ chatting pairs in the first classroom, $$$1$$$ chatting pair in the second classroom). You are given the list of the $$$n$$$ names. What is the minimum $$$x$$$ we can obtain by splitting the students into classrooms?Note that it is valid to place all of the students in one of the classrooms, leaving the other one empty.","from sys import stdin,stdout
def nC2(n):
    return (n*(n-1))//2
for _ in range(1):#int(stdin.readline())):
    n=int(stdin.readline())
    # m,n=list(map(int,stdin.readline().split()))
    d={}
    for i in range(n):
        s=input()
        d[s[0]]=d.get(s[0],0)+1
    ans=0
    for k,v in d.items():
        p1=p2=v//2
        if v&1:p1+=1
        ans+=nC2(p1)+nC2(p2)
    print(ans)","['combinatorics', 'greedy']"
"Oleg the bank client lives in Bankopolia. There are n cities in Bankopolia and some pair of cities are connected directly by bi-directional roads. The cities are numbered from 1 to n. There are a total of m roads in Bankopolia, the i-th road connects cities ui and vi. It is guaranteed that from each city it is possible to travel to any other city using some of the roads.Oleg wants to give a label to each city. Suppose the label of city i is equal to xi. Then, it must hold that for all pairs of cities (u, v) the condition |xu - xv| ≤ 1 holds if and only if there is a road connecting u and v.Oleg wonders if such a labeling is possible. Find an example of such labeling if the task is possible and state that it is impossible otherwise.","import collections
import sys
readline = sys.stdin.readline
write = sys.stdout.write
n, m = map(int, readline().split())
g = [[i] for i in xrange(n)]
for i in xrange(m):
    u, v = map(int, readline().split())
    g[u-1].append(v-1)
    g[v-1].append(u-1)
for i in xrange(n):
    g[i] = tuple(sorted(g[i]))
s = {e: i for i, e in enumerate({e for e in g})}
sn = len(s)
sg = [set() for i in xrange(sn)]
used = [0]*sn
for v in xrange(n):
    lv = g[v]
    i = s[lv]
    if not used[i]:
        used[i] = 1
        for t in g[v]:
            lt = g[t]
            if hash(lt) != hash(lv):
                j = s[lt]
                sg[i].add(j)
                sg[j].add(i)
intwo = 1
one = 0; one_node = None
for i in xrange(sn):
    if len(sg[i]) > 2:
        intwo = 0
        break
    if len(sg[i]) <= 1:
        one = 1
        one_node = i
if intwo and one:
    used = [0]*sn
    deq = collections.deque()
    used[one_node] = 1
    v = one_node
    ans = [-1]*sn
    cur = 1
    while 1:
        ans[v] = cur
        cur += 1
        for t in sg[v]:
            if not used[t]:
                used[t] = 1
                v = t
                break
        else:
            break
    write(""YES\n"")
    write("" "".join(str(ans[s[e]]) for e in g))
    write(""\n"")
else:
    write(""NO\n"")","['hashing', 'graphs', 'dfs and similar']"
"You are given two strings $$$s$$$ and $$$t$$$. In a single move, you can choose any of two strings and delete the first (that is, the leftmost) character. After a move, the length of the string decreases by $$$1$$$. You can't choose a string if it is empty.For example:  by applying a move to the string ""where"", the result is the string ""here"",  by applying a move to the string ""a"", the result is an empty string """". You are required to make two given strings equal using the fewest number of moves. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the initial strings.Write a program that finds the minimum number of moves to make two given strings $$$s$$$ and $$$t$$$ equal.","k1 = input()
k2 = input()
t1 = len(k1)
t2 = len(k2)
mini = min(t1,t2)
count = 0
k1 = k1[::-1]
k2 = k2[::-1]
for i in range(mini):
    if k1[i] == k2[i]:
        count+=1
    else:
        break
print(t1-count + t2-count)","['implementation', 'brute force', 'strings']"
"Programmers working on a large project have just received a task to write exactly m lines of code. There are n programmers working on a project, the i-th of them makes exactly ai bugs in every line of code that he writes. Let's call a sequence of non-negative integers v1, v2, ..., vn a plan, if v1 + v2 + ... + vn = m. The programmers follow the plan like that: in the beginning the first programmer writes the first v1 lines of the given task, then the second programmer writes v2 more lines of the given task, and so on. In the end, the last programmer writes the remaining lines of the code. Let's call a plan good, if all the written lines of the task contain at most b bugs in total.Your task is to determine how many distinct good plans are there. As the number of plans can be large, print the remainder of this number modulo given positive integer mod.","""""""
________        _____________              ______
___  __ \____  ____  __ \__(_)__   _______ ___  /
__  /_/ /_  / / /_  /_/ /_  /__ | / /  __ `/_  /
_  ____/_  /_/ /_  _, _/_  / __ |/ // /_/ /_  /
/_/     _\__, / /_/ |_| /_/  _____/ \__,_/ /_/
        /____/

https://github.com/Cheran-Senthil/PyRival
Copyright (c) 2018 Cheran Senthilkumar
""""""
from __future__ import division, print_function

import cmath
import itertools
import math
import operator as op
import sys
from atexit import register
from bisect import bisect_left, bisect_right

# import random
# from collections import Counter, MutableSequence, defaultdict, deque
# from copy import deepcopy
# from decimal import Decimal
# from difflib import SequenceMatcher
# from heapq import heappop, heappush

if sys.version_info[0] < 3:
    from io import BytesIO as stream
    # from fractions import Fraction
    # from fractions import gcd
    # from cPickle import dumps
    # from Queue import PriorityQueue, Queue
else:
    from io import StringIO as stream
    # from functools import reduce
    # from fractions import Fraction
    # from math import gcd
    # from pickle import dumps
    # from queue import PriorityQueue, Queue


if sys.version_info[0] < 3:
    class dict(dict):
        def items(self):
            return dict.iteritems(self)

        def keys(self):
            return dict.iterkeys(self)

        def values(self):
            return dict.itervalues(self)

    input = raw_input
    range = xrange

    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip


def sync_with_stdio(sync=True):
    """"""
    Sets whether the standard Python streams are allowed to buffer their I/O.

    Parameters
    ----------
    sync : bool, optional
        The new synchronization setting. Default is True.
    """"""
    global input, flush

    if sync:
        flush = sys.stdout.flush
    else:
        sys.stdin = stream(sys.stdin.read())
        input = lambda: sys.stdin.readline().rstrip('\r\n')

        sys.stdout = stream()
        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))


def main():
    n, m, b, mod = map(int, input().split(' '))
    a = list(map(int, input().split(' ')))
    dp = [[0] * (b + 1) if i > 0 else [1] * (b + 1) for i in range(m + 1)]

    for i in range(n):
        for j in range(1, m + 1):
            for k in range(a[i], b + 1):
                dp[j][k] = (dp[j - 1][k - a[i]] + dp[j][k]) % mod

    print(dp[m][b])


if __name__ == '__main__':
    sys.setrecursionlimit(10000)
    sync_with_stdio(False)
    main()",['dp']
"Anya and Kirill are doing a physics laboratory work. In one of the tasks they have to measure some value n times, and then compute the average value to lower the error.Kirill has already made his measurements, and has got the following integer values: x1, x2, ..., xn. It is important that the values are close to each other, namely, the difference between the maximum value and the minimum value is at most 2.Anya does not want to make the measurements, however, she can't just copy the values from Kirill's work, because the error of each measurement is a random value, and this coincidence will be noted by the teacher. Anya wants to write such integer values y1, y2, ..., yn in her work, that the following conditions are met:  the average value of x1, x2, ..., xn is equal to the average value of y1, y2, ..., yn; all Anya's measurements are in the same bounds as all Kirill's measurements, that is, the maximum value among Anya's values is not greater than the maximum value among Kirill's values, and the minimum value among Anya's values is not less than the minimum value among Kirill's values; the number of equal measurements in Anya's work and Kirill's work is as small as possible among options with the previous conditions met. Formally, the teacher goes through all Anya's values one by one, if there is equal value in Kirill's work and it is not strike off yet, he strikes off this Anya's value and one of equal values in Kirill's work. The number of equal measurements is then the total number of strike off values in Anya's work. Help Anya to write such a set of measurements that the conditions above are met.","n=int(input())
x=input()
a=list(map(int,x.split()))
if max(a)-min(a)<2:
 print(n)
 print(x)
 exit()
s=set(a)
q=min(a)
s=max(a)
r=q+1
m={}
m[q]=m[s]=m[r]=0
for i in a:m[i]+=1
if n-2*min(m[q],m[s])<n-m[r]//2*2:
 print(n-2*min(m[q],m[s]))
 e=min(m[q],m[s])
 m[r]+=e+e
 m[q]-=e
 m[s]-=e
else:
 print(n-m[r]//2*2)
 e=m[r]//2
 m[r]-=e+e
 m[q]+=e
 m[s]+=e
b=[r for i in range(m[r])]
b=b+[q for i in range(m[q])]
b=b+[s for i in range(m[s])]
print(*b)




# Made By Mostafa_Khaled","['implementation', 'math']"
"A teacher decides to give toffees to his students. He asks n students to stand in a queue. Since the teacher is very partial, he follows the following rule to distribute toffees.He looks at the first two students and gives more toffees to the student having higher marks than the other one. If they have the same marks they get the same number of toffees. The same procedure is followed for each pair of adjacent students starting from the first one to the last one.It is given that each student receives at least one toffee. You have to find the number of toffees given to each student by the teacher such that the total number of toffees is minimum.","from collections import defaultdict

class PartialTeacher():
    def __init__(self, n, prefs):
        self.prefs = prefs
        
    def create_graph(self):
        num_nodes = len(list(filter(lambda x: x != '=',list(self.prefs))))+1
        node_cntr = 0
        node_cnts = defaultdict(lambda: 1)
        edge_map = defaultdict(list)
        rev_map = defaultdict(list)
        outgoing_edges = defaultdict(int)
        for ch in self.prefs:
            if ch == 'R':
                edge_map[node_cntr].append(node_cntr+1)
                rev_map[node_cntr+1].append(node_cntr)
                outgoing_edges[node_cntr] += 1
                node_cntr += 1
            elif ch == 'L':
                edge_map[node_cntr+1].append(node_cntr)
                rev_map[node_cntr].append(node_cntr+1)
                outgoing_edges[node_cntr+1] += 1
                node_cntr += 1
            else:
                node_cnts[node_cntr] += 1
        s = set()
        for i in range(node_cntr+1):
            if outgoing_edges[i] == 0:
                s.add(i)
        order = []
        while len(s) > 0:
            v = s.pop()
            order.append(v)
            for u in rev_map[v]:
                outgoing_edges[u] -= 1
                if outgoing_edges[u] == 0:
                    s.add(u)
        order.reverse()
        values = [-1]*len(order)
        for v in order:
            val_list = list(map(lambda x: values[x], rev_map[v]))
            val = 1 if len(val_list) == 0 else max(val_list)+1
            values[v] = val
        complete_values = []
        for i in range(len(values)):
            complete_values += [values[i]]*node_cnts[i]
        print(*complete_values)


n = int(input())
prefs = input().strip(' ')

pt = PartialTeacher(n, prefs)
pt.create_graph()","['dp', 'implementation', 'greedy', 'graphs']"
"Vasya writes his own library for building graphical user interface. Vasya called his creation VTK (VasyaToolKit). One of the interesting aspects of this library is that widgets are packed in each other. A widget is some element of graphical interface. Each widget has width and height, and occupies some rectangle on the screen. Any widget in Vasya's library is of type Widget. For simplicity we will identify the widget and its type. Types HBox and VBox are derivatives of type Widget, so they also are types Widget. Widgets HBox and VBox are special. They can store other widgets. Both those widgets can use the pack() method to pack directly in itself some other widget. Widgets of types HBox and VBox can store several other widgets, even several equal widgets — they will simply appear several times. As a result of using the method pack() only the link to the packed widget is saved, that is when the packed widget is changed, its image in the widget, into which it is packed, will also change. We shall assume that the widget a is packed in the widget b if there exists a chain of widgets a = c1, c2, ..., ck = b, k ≥ 2, for which ci is packed directly to ci + 1 for any 1 ≤ i &lt; k. In Vasya's library the situation when the widget a is packed in the widget a (that is, in itself) is not allowed. If you try to pack the widgets into each other in this manner immediately results in an error.Also, the widgets HBox and VBox have parameters border and spacing, which are determined by the methods set_border() and set_spacing() respectively. By default both of these options equal 0.    The picture above shows how the widgets are packed into HBox and VBox. At that HBox and VBox automatically change their size depending on the size of packed widgets. As for HBox and VBox, they only differ in that in HBox the widgets are packed horizontally and in VBox — vertically. The parameter spacing sets the distance between adjacent widgets, and border — a frame around all packed widgets of the desired width. Packed widgets are placed exactly in the order in which the pack() method was called for them. If within HBox or VBox there are no packed widgets, their sizes are equal to 0 × 0, regardless of the options border and spacing. The construction of all the widgets is performed using a scripting language VasyaScript. The description of the language can be found in the input data. For the final verification of the code Vasya asks you to write a program that calculates the sizes of all the widgets on the source code in the language of VasyaScript.","import re

class Widget(object):
    def __init__(self, type, w = 0, h = 0):
        self.type = type
        if type == 'Widget':
            self.w = w
            self.h = h
    def calc_wh(self):
        if not hasattr(self, 'w'):
            if self.children:
                self.w = self.border * 2
                self.h = self.border * 2
                for c in self.children:
                    cw, ch = c.calc_wh()
                    if self.type == ""VBox"":
                        self.h += ch
                        self.w = max(self.w, cw + self.border * 2)
                    else:
                        self.w += cw
                        self.h = max(self.h, ch + self.border * 2)
                if self.type == ""HBox"":
                    self.w += (len(self.children) - 1) * self.spacing
                else:
                    self.h += (len(self.children) - 1) * self.spacing
            else:
                self.w = 0
                self.h = 0
        return self.w, self.h

widgets = {}

n = input()
rp = re.compile(r'(\w+)\.(\w+)\((.+)\)')

for _ in xrange(n):
  str = raw_input()
  if str.find(' ') != -1:
    type, rhs = str.split(' ')
    if type == 'Widget':
      name, other = rhs.split('(')
      w, h = map(int, other[:-1].split(','))
      widgets[name] = Widget(type, w, h)
    else:
      widgets[rhs] = Widget(type)
      widgets[rhs].children = []
      widgets[rhs].spacing = 0
      widgets[rhs].border = 0
  else:
    name, op, arg = rp.match(str).groups()
    if op == ""set_border"":
      widgets[name].border = int(arg)
    elif op == ""set_spacing"":
      widgets[name].spacing = int(arg)
    else:
      widgets[name].children.append(widgets[arg])

for k, v in sorted(widgets.items(), key = lambda x: x[0]):
    w, h = v.calc_wh()
    print k, w, h","['dp', 'implementation', 'graphs', 'expression parsing']"
"Polycarp is a great fan of television.He wrote down all the TV programs he is interested in for today. His list contains n shows, i-th of them starts at moment li and ends at moment ri.Polycarp owns two TVs. He can watch two different shows simultaneously with two TVs but he can only watch one show at any given moment on a single TV. If one show ends at the same moment some other show starts then you can't watch them on a single TV.Polycarp wants to check out all n shows. Are two TVs enough to do so?","n = int(raw_input())
schedule = sorted([map(int, raw_input().split()) for x in range(n)], key=lambda x: x[0])

def scheduler(schedule):
    tv1, tv2 = [], []
    for tvshow in schedule:
        if len(tv1) == 0:
            tv1.append(tvshow)
        elif tvshow[0] > tv1[-1][1]:
            tv1.append(tvshow)
        elif len(tv2) == 0:
            tv2.append(tvshow)
        elif tvshow[0] > tv2[-1][1]:
            tv2.append(tvshow)
        else:
            return ""NO""
    
    return ""YES""

print scheduler(schedule)","['data structures', 'sortings', 'greedy']"
"Grisha come to a contest and faced the following problem.You are given an array of size $$$n$$$, initially consisting of zeros. The elements of the array are enumerated from $$$1$$$ to $$$n$$$. You perform $$$q$$$ operations on the array. The $$$i$$$-th operation is described with three integers $$$l_i$$$, $$$r_i$$$ and $$$x_i$$$ ($$$1 \leq l_i \leq r_i \leq n$$$, $$$1 \leq x_i \leq n$$$) and means that you should add $$$x_i$$$ to each of the elements with indices $$$l_i, l_i + 1, \ldots, r_i$$$. After all operations you should find the maximum in the array.Grisha is clever, so he solved the problem quickly.However something went wrong inside his head and now he thinks of the following question: ""consider we applied some subset of the operations to the array. What are the possible values of the maximum in the array?""Help Grisha, find all integers $$$y$$$ between $$$1$$$ and $$$n$$$ such that if you apply some subset (possibly empty) of the operations, then the maximum in the array becomes equal to $$$y$$$.","def nis():
    return map(int, raw_input().split())

def spaced(a):
    return ' '.join(map(str, a))

n, q = nis()

dp = [0] * (n + 1)

# first implied range: 1 n 0
dp[0] = n

operations = []
for _ in range(q):
    operations.append(nis())

operations.sort()

for l, r, val in operations:
    for x in reversed(range(n - val + 1)):
        if dp[x] >= l:
            dp[x + val] = max(dp[x + val], min(dp[x], r))
            
ans = filter(lambda x: dp[x], range(1, n + 1))

print len(ans)
print spaced(ans)","['dp', 'bitmasks', 'data structures', 'divide and conquer']"
"This is the first subtask of problem F. The only differences between this and the second subtask are the constraints on the value of $$$m$$$ and the time limit. You need to solve both subtasks in order to hack this one.There are $$$n+1$$$ distinct colours in the universe, numbered $$$0$$$ through $$$n$$$. There is a strip of paper $$$m$$$ centimetres long initially painted with colour $$$0$$$. Alice took a brush and painted the strip using the following process. For each $$$i$$$ from $$$1$$$ to $$$n$$$, in this order, she picks two integers $$$0 \leq a_i &lt; b_i \leq m$$$, such that the segment $$$[a_i, b_i]$$$ is currently painted with a single colour, and repaints it with colour $$$i$$$. Alice chose the segments in such a way that each centimetre is now painted in some colour other than $$$0$$$. Formally, the segment $$$[i-1, i]$$$ is painted with colour $$$c_i$$$ ($$$c_i \neq 0$$$). Every colour other than $$$0$$$ is visible on the strip.Count the number of different pairs of sequences $$$\{a_i\}_{i=1}^n$$$, $$$\{b_i\}_{i=1}^n$$$ that result in this configuration. Since this number may be large, output it modulo $$$998244353$$$.","n, m = map(int, raw_input().split())
l = list(map(int, raw_input().split()))
index = [[0 for i in range(n)] for j in range(n)]
for i in range(n):
	mini = 10000000000000
	for j in range(i, n):
		if l[j] < mini:
			inde = j
			mini = l[j]
		index[i][j] = inde
prime = 998244353
d = {}
val = [[1 for i in range(n + 1)] for j in range(n + 1)]
for i in range(n):
	for j in range(n - i):
		if i == 0:
			val[j][j + i] = 1
		elif i == 1:
			val[j][j + i] = 2
		else:
			ind = index[j][j + i]
			sumap = 0
			sumak = 0
			for p in range(j, ind +1):
				sumap += (val[j][p - 1] * val[p][ind - 1]) % prime
			for k in range(ind, j + i + 1):
				sumak += (val[ind + 1][k] * val[k + 1][j + i]) % prime
			val[j][j + i] = (sumap * sumak) % prime
print(val[0][n-1])","['dp', 'combinatorics', 'dfs and similar']"
"There are n people and k keys on a straight line. Every person wants to get to the office which is located on the line as well. To do that, he needs to reach some point with a key, take the key and then go to the office. Once a key is taken by somebody, it couldn't be taken by anybody else.You are to determine the minimum time needed for all n people to get to the office with keys. Assume that people move a unit distance per 1 second. If two people reach a key at the same time, only one of them can take the key. A person can pass through a point with a key without taking it.","def list_input():
    return list(map(int,input().split()))
def map_input():
    return map(int,input().split())
def map_string():
    return input().split()
    
n,k,p = map_input()
a = list_input()
b = list_input()
a.sort()
b.sort()
ans = 1000000000000000000
for i in range(k-n+1):
    cur = 0
    c1 = 0
    c2 = i
    while c1 < n:
        cur = max(abs(a[c1]-b[c2])+abs(b[c2]-p),cur)
        c1 += 1
        c2 += 1
    ans = min(ans,cur)
print(ans)","['dp', 'binary search', 'greedy', 'brute force']"
"Petya has k matches, placed in n matchboxes lying in a line from left to right. We know that k is divisible by n. Petya wants all boxes to have the same number of matches inside. For that, he can move a match from its box to the adjacent one in one move. How many such moves does he need to achieve the desired configuration?","n = int(input())
a = list(map(int, input().split())) + [0]
s = sum(a) // n
d = 0
for i in range(n):
    if a[i] > s:
        a[i + 1] += abs(a[i] - s)
    else:
        a[i + 1] -= abs(a[i] - s)
    d += abs(a[i] - s)
print(d)","['implementation', 'greedy']"
"You play a strategic video game (yeah, we ran out of good problem legends). In this game you control a large army, and your goal is to conquer $$$n$$$ castles of your opponent.Let's describe the game process in detail. Initially you control an army of $$$k$$$ warriors. Your enemy controls $$$n$$$ castles; to conquer the $$$i$$$-th castle, you need at least $$$a_i$$$ warriors (you are so good at this game that you don't lose any warriors while taking over a castle, so your army stays the same after the fight). After you take control over a castle, you recruit new warriors into your army — formally, after you capture the $$$i$$$-th castle, $$$b_i$$$ warriors join your army. Furthermore, after capturing a castle (or later) you can defend it: if you leave at least one warrior in a castle, this castle is considered defended. Each castle has an importance parameter $$$c_i$$$, and your total score is the sum of importance values over all defended castles. There are two ways to defend a castle:  if you are currently in the castle $$$i$$$, you may leave one warrior to defend castle $$$i$$$;  there are $$$m$$$ one-way portals connecting the castles. Each portal is characterised by two numbers of castles $$$u$$$ and $$$v$$$ (for each portal holds $$$u &gt; v$$$). A portal can be used as follows: if you are currently in the castle $$$u$$$, you may send one warrior to defend castle $$$v$$$. Obviously, when you order your warrior to defend some castle, he leaves your army.You capture the castles in fixed order: you have to capture the first one, then the second one, and so on. After you capture the castle $$$i$$$ (but only before capturing castle $$$i + 1$$$) you may recruit new warriors from castle $$$i$$$, leave a warrior to defend castle $$$i$$$, and use any number of portals leading from castle $$$i$$$ to other castles having smaller numbers. As soon as you capture the next castle, these actions for castle $$$i$$$ won't be available to you.If, during some moment in the game, you don't have enough warriors to capture the next castle, you lose. Your goal is to maximize the sum of importance values over all defended castles (note that you may hire new warriors in the last castle, defend it and use portals leading from it even after you capture it — your score will be calculated afterwards).Can you determine an optimal strategy of capturing and defending the castles?","from heapq import heappush, heappop
n, m, k = map(int, input().split())
a = [0]
b = [0]
c = [0]
for i in range(n):
    aa, bb, cc = map(int, input().split())
    a.append(aa)
    b.append(bb)
    c.append(cc)
a += [0]
road = [[] for i in range(n+1)]
last = [i for i in range(0, n+1)]
for i in range(m):
    u, v = map(int, input().split())
    last[v] = max(last[v], u)
for i in range(1, n+1):
    road[last[i]].append(i)
value = []
fin = True
for i in range(1, n+1):
    while (k < a[i] and value):
        k += 1
        heappop(value)
    if (k < a[i]):
        fin = False
        break
    k += b[i]
    for j in road[i]:
        heappush(value, c[j])
        k -= 1
if (fin == False):
    print(-1)
else:
    while (k < 0):
        k += 1
        heappop(value)
    ans = 0
    while (value):
        ans += heappop(value)
    print(ans)","['dp', 'greedy', 'implementation', 'sortings', 'data structures']"
"Little Vova studies programming in an elite school. Vova and his classmates are supposed to write n progress tests, for each test they will get a mark from 1 to p. Vova is very smart and he can write every test for any mark, but he doesn't want to stand out from the crowd too much. If the sum of his marks for all tests exceeds value x, then his classmates notice how smart he is and start distracting him asking to let them copy his homework. And if the median of his marks will be lower than y points (the definition of a median is given in the notes), then his mom will decide that he gets too many bad marks and forbid him to play computer games.Vova has already wrote k tests and got marks a1, ..., ak. He doesn't want to get into the first or the second situation described above and now he needs to determine which marks he needs to get for the remaining tests. Help him do that.","n, k, p, x, y = list(map(int, input().split()))

marks = list(map(int, input().split()))

marks.sort()

less = 0
more = 0
equal = 0
midway = (n+1)//2

final = []


for i in marks:
    if i < y:
        less+=1
    elif i == y:
        equal+=1        
    else:
        more+=1
        
if less >= midway:
    print(-1)
    
#elif more >= (n+1)/2 or (more + equal) >= (n+1/2):
elif (more + equal) >= midway:
    final.extend((n-k)*[1])

    if sum(final) + sum(marks) <= x: # redundancy. Need to refactor as this if-else block repeats in the final else as well
        for i in range(len(final)):
            print(final[i], end=' ')
    else: print(-1)

else:

    final.extend((midway -1 - less)*[1])

    
    final.extend((midway - (more + equal))*[y])

    if sum(final) + sum(marks) <= x:
        for i in range(len(final)):
            print(final[i], end=' ')
    else: print(-1) 





##mode = marks[(n+1)//2 - 1]
##
##if (n+1)/2 <= k:    
##    if mode < y:
##        print('mode',-1)
##    else:
##        for i in range(k, n):            
##            marks.append(marks[k-1])
##        if sum(marks) > x:
##            print(marks)
##            print('sum',-1)
##        else:
##            for i in range(k, n):
##                print(marks[i], end=' ')
##else:
##    for i in range(k+1, n+1):
##        if i < mode:
##            marks.append(marks[k-1])
##        else:
##            marks.append(y)
##
##    for i in range(k+1, n+1):
##        print(marks[i], end=' ')","['implementation', 'greedy']"
"Mr. Apple, a gourmet, works as editor-in-chief of a gastronomic periodical. He travels around the world, tasting new delights of famous chefs from the most fashionable restaurants. Mr. Apple has his own signature method of review  — in each restaurant Mr. Apple orders two sets of dishes on two different days. All the dishes are different, because Mr. Apple doesn't like to eat the same food. For each pair of dishes from different days he remembers exactly which was better, or that they were of the same quality. After this the gourmet evaluates each dish with a positive integer.Once, during a revision of a restaurant of Celtic medieval cuisine named «Poisson», that serves chestnut soup with fir, warm soda bread, spicy lemon pie and other folk food, Mr. Apple was very pleasantly surprised the gourmet with its variety of menu, and hence ordered too much. Now he's confused about evaluating dishes.The gourmet tasted a set of $$$n$$$ dishes on the first day and a set of $$$m$$$ dishes on the second day. He made a table $$$a$$$ of size $$$n \times m$$$, in which he described his impressions. If, according to the expert, dish $$$i$$$ from the first set was better than dish $$$j$$$ from the second set, then $$$a_{ij}$$$ is equal to ""&gt;"", in the opposite case $$$a_{ij}$$$ is equal to ""&lt;"". Dishes also may be equally good, in this case $$$a_{ij}$$$ is ""="".Now Mr. Apple wants you to help him to evaluate every dish. Since Mr. Apple is very strict, he will evaluate the dishes so that the maximal number used is as small as possible. But Mr. Apple also is very fair, so he never evaluates the dishes so that it goes against his feelings. In other words, if $$$a_{ij}$$$ is ""&lt;"", then the number assigned to dish $$$i$$$ from the first set should be less than the number of dish $$$j$$$ from the second set, if $$$a_{ij}$$$ is ""&gt;"", then it should be greater, and finally if $$$a_{ij}$$$ is ""="", then the numbers should be the same.Help Mr. Apple to evaluate each dish from both sets so that it is consistent with his feelings, or determine that this is impossible.","n, m = map(int, input().split())


dishes = [0 for _ in range(n + m)]
father = [-1 for _ in range(n + m)]
e_out = dict()
v_in = [0 for _ in range(n + m)]


def get_father(n):
    if father[n] == -1:
        return n
    else:
        father[n] = get_father(father[n])
        return father[n]


compare_matrix = []
for i in range(n):
    compare_matrix.append(input())

for i in range(n):
    for j in range(m):
        if compare_matrix[i][j] == ""="":
            fi = get_father(i)
            fj = get_father(j + n)
            if fi != fj:
                father[fj] = fi
children = dict()
for i in range(n + m):
    fi = get_father(i)
    if fi != i:
        if fi not in children:
            children[fi] = [i]
        else:
            children[fi].append(i)

for i in range(n):
    for j in range(m):
        if compare_matrix[i][j] == ""="":
            continue
        fi = get_father(i)
        fj = get_father(j + n)
        if fi == fj:
            print(""NO"")
            exit(0)
        if compare_matrix[i][j] == "">"":
            v_in[fi] += 1
            if fj in e_out:
                e_out[fj].append(fi)
            else:
                e_out[fj] = [fi]
        if compare_matrix[i][j] == ""<"":
            v_in[fj] += 1
            if fi in e_out:
                e_out[fi].append(fj)
            else:
                e_out[fi] = [fj]
# print(v_in)
# print(e_out)
score = 1
visited = [False for _ in range(n + m)]
v_total = 0
q = [v for v in range(n + m) if v_in[v] == 0]
while q:
    t = []
    for i in q:
        dishes[i] = score
        v_total += 1
        if i in children:
            for j in children[i]:
                dishes[j] = score
                v_total += 1
        if i in e_out:
            for j in e_out[i]:
                v_in[j] -= 1
                if v_in[j] == 0:
                    t.append(j)
    q = t
    score += 1

if v_total < n + m:
    print(""NO"")
    exit(0)
print(""YES"")
for i in dishes[:n]:
    print(i, end="" "")
print()
for i in dishes[n:n + m]:
    print(i, end="" "")","['dp', 'greedy', 'graphs', 'dsu', 'dfs and similar']"
Kyoya Ootori has a bag with n colored balls that are colored with k different colors. The colors are labeled from 1 to k. Balls of the same color are indistinguishable. He draws balls from the bag one by one until the bag is empty. He noticed that he drew the last ball of color i before drawing the last ball of color i + 1 for all i from 1 to k - 1. Now he wonders how many different ways this can happen.,"import math


ncol = int(raw_input())
#print ncol
col = []
n = 0
for i in range(0,ncol):
    col.append(int(raw_input()))
    n += col[i]
#print n

m = 1
length = col[0]
for i in range(1,ncol):
    k2 = col[i]
    m *= math.factorial(length+k2-1)/(math.factorial(k2-1)*math.factorial(length))
    length += k2
m = m%1000000007
print m","['dp', 'combinatorics', 'math']"
Indian summer is such a beautiful time of the year! A girl named Alyona is walking in the forest and picking a bouquet from fallen leaves. Alyona is very choosy — she doesn't take a leaf if it matches the color and the species of the tree of one of the leaves she already has. Find out how many leaves Alyona has picked.,"l=set()
for i in range(int(input())):
	k=str(input())
	l.add(k)
print (len(l))",['implementation']
"You are given two lists of segments $$$[al_1, ar_1], [al_2, ar_2], \dots, [al_n, ar_n]$$$ and $$$[bl_1, br_1], [bl_2, br_2], \dots, [bl_n, br_n]$$$.Initially, all segments $$$[al_i, ar_i]$$$ are equal to $$$[l_1, r_1]$$$ and all segments $$$[bl_i, br_i]$$$ are equal to $$$[l_2, r_2]$$$.In one step, you can choose one segment (either from the first or from the second list) and extend it by $$$1$$$. In other words, suppose you've chosen segment $$$[x, y]$$$ then you can transform it either into $$$[x - 1, y]$$$ or into $$$[x, y + 1]$$$.Let's define a total intersection $$$I$$$ as the sum of lengths of intersections of the corresponding pairs of segments, i.e. $$$\sum\limits_{i=1}^{n}{\text{intersection_length}([al_i, ar_i], [bl_i, br_i])}$$$. Empty intersection has length $$$0$$$ and length of a segment $$$[x, y]$$$ is equal to $$$y - x$$$.What is the minimum number of steps you need to make $$$I$$$ greater or equal to $$$k$$$?","for _ in range(int(input())):
    n,k=map(int,input().split())
    l1,r1=map(int,input().split())
    l2,r2=map(int,input().split())
    over=min(r1,r2)-max(l1,l2)
    moves=0
    #Case1: Already overlapped
    if (l1,r1)==(l2,r2):
        if (r1-l1)*n>=k:
            print(0)
        else:
            k-=(r1-l1)*n
            print(2*k)
    elif over>0:
        over*=n
        if over>=k:
            print(0)
        else:
            o=max(r1,r2)-min(l1,l2)-over//n
            if over+o*n>=k:
                print(k-over)
            else:
                moves+=o*n
                over+=o*n
                print(moves+(k-over)*2)
    #Case 2: No overlap(Here the fun begins)
    else:
        d=-1*over
        o=max(r1,r2)-min(l1,l2)
        x=k//o
        k=k%o
        if n>x:
            moves+=(x)*(d+o)
            if d<k or x==0:
                moves+=d+k
            else:
                moves+=2*k
        else:
            moves+=n*(d+o)+((x-n)*o+k)*2
        print(moves)","['implementation', 'greedy', 'math', 'brute force']"
"This is a harder version of the problem. In this version, $$$n \le 300\,000$$$.Vasya is an experienced developer of programming competitions' problems. As all great minds at some time, Vasya faced a creative crisis. To improve the situation, Petya gifted him a string consisting of opening and closing brackets only. Petya believes, that the beauty of the bracket string is a number of its cyclical shifts, which form a correct bracket sequence.To digress from his problems, Vasya decided to select two positions of the string (not necessarily distinct) and swap characters located at this positions with each other. Vasya will apply this operation exactly once. He is curious what is the maximum possible beauty he can achieve this way. Please help him.We remind that bracket sequence $$$s$$$ is called correct if:   $$$s$$$ is empty;  $$$s$$$ is equal to ""($$$t$$$)"", where $$$t$$$ is correct bracket sequence;  $$$s$$$ is equal to $$$t_1 t_2$$$, i.e. concatenation of $$$t_1$$$ and $$$t_2$$$, where $$$t_1$$$ and $$$t_2$$$ are correct bracket sequences. For example, ""(()())"", ""()"" are correct, while "")("" and ""())"" are not.The cyclical shift of the string $$$s$$$ of length $$$n$$$ by $$$k$$$ ($$$0 \leq k &lt; n$$$) is a string formed by a concatenation of the last $$$k$$$ symbols of the string $$$s$$$ with the first $$$n - k$$$ symbols of string $$$s$$$. For example, the cyclical shift of string ""(())()"" by $$$2$$$ equals ""()(())"".Cyclical shifts $$$i$$$ and $$$j$$$ are considered different, if $$$i \ne j$$$.","from __future__ import division, print_function

def main():
    n = int(input())
    s = input()
    if s.count('(') != s.count(')'):
        print('0\n1 1')
        return
    ar = [(1 if c=='(' else -1) for c in s]
    ps = [0]
    lb = li = 0
    for i, e in enumerate(ar):
        v = e+ps[-1]
        if v < lb:
            lb = v
            li = i+1
        ps.append(v)
    ps.pop()
    ps = ps[li:] + ps[:li+1]
    for i in indices(ps):
        ps[i] += -lb

    b0 = ps.count(0)
    best2 = 0
    this2 = 0
    r = False
    bsi, bei = 0, 0
    for i, e in enumerate(ps):
        if e == 2:
            if not r:
                r = True
                this2 = 1
                si = i-1
            else:
                this2 += 1
        elif e == 1:
            if r:
                r = False
                if best2 < this2:
                    best2 = this2
                    bsi, bei = si, i-1

    best1 = 0
    this1 = 0
    r = False
    bsi1, bei1 = 0, 0
    for i, e in enumerate(ps):
        if e == 1:
            if not r:
                r = True
                this1 = 1
                si = i-1
            else:
                this1 += 1
        elif e == 0:
            if r:
                r = False
                if best1 < this1:
                    best1 = this1
                    bsi1, bei1 = si, i-1

    if best1 > b0+best2-1:
        bsi, bei = bsi1, bei1

    print(max(best1, b0+best2-1))
    print((bsi+li)%n+1, (bei+li)%n+1)

INF = float('inf')
MOD = 10 ** 9 + 7
__interactive = False

import os, sys
from atexit import register
from io import BytesIO
import itertools
import __pypy__

if sys.version_info[0] < 3:
    input = raw_input
    range = xrange

    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip

mulmod = __pypy__.intop.int_mulmod

if ""LOCAL_"" in os.environ:
    debug_print = print
else:
    if not __interactive:
        sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
        sys.stdout = BytesIO()
        register(lambda: os.write(1, sys.stdout.getvalue()))

        input = lambda: sys.stdin.readline().rstrip('\r\n')
    debug_print = lambda *x, **y: None

flush = sys.stdout.flush

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x
    
def input_as_list():
    return list(map(int, input().split()))

def input_as_matrix(n, m):
    return [input_as_list() for _ in range(n)]
    
def array_of(f, *dim):
    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()

def range_with_count(start, step, count):
    return range(start, start + step * count, step)

def indices(l, start=0, end=0):
    return range(start, len(l)+end)

def ceil_power_of_2(n):
    """""" [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] """"""
    return 2 ** ((n - 1).bit_length())

def ceil_div(x, r):
    """""" = ceil(x / r) """"""
    return (x + r - 1) // r
    
main()",['implementation']
"Bearland has n cities, numbered 1 through n. Cities are connected via bidirectional roads. Each road connects two distinct cities. No two roads connect the same pair of cities.Bear Limak was once in a city a and he wanted to go to a city b. There was no direct connection so he decided to take a long walk, visiting each city exactly once. Formally:   There is no road between a and b.  There exists a sequence (path) of n distinct cities v1, v2, ..., vn that v1 = a, vn = b and there is a road between vi and vi + 1 for . On the other day, the similar thing happened. Limak wanted to travel between a city c and a city d. There is no road between them but there exists a sequence of n distinct cities u1, u2, ..., un that u1 = c, un = d and there is a road between ui and ui + 1 for .Also, Limak thinks that there are at most k roads in Bearland. He wonders whether he remembers everything correctly.Given n, k and four distinct cities a, b, c, d, can you find possible paths (v1, ..., vn) and (u1, ..., un) to satisfy all the given conditions? Find any solution or print -1 if it's impossible.","n, k = input().split(' ')
n = int(n)
k = int(k)

a,b,c,d = input().split(' ')

a,b,c,d = int(a),int(b),int(c),int(d)

if k <= n:
	print(-1)
	exit()

if n == 4:
	print(-1)
	exit()

city = list(range(1,n+1))
road = [a,c]
for i in range(len(city)):
	if city[i] not in (a,b,c,d): road.append(city[i])

road += [d,b]

t = ''

print(' '.join(""{0}"".format(t) for t in road))
road = [c,a] + road[2:n-2] + [b,d]
print(' '.join(""{0}"".format(t) for t in road))","['constructive algorithms', 'graphs']"
"There always is something to choose from! And now, instead of ""Noughts and Crosses"", Inna choose a very unusual upgrade of this game. The rules of the game are given below:There is one person playing the game. Before the beginning of the game he puts 12 cards in a row on the table. Each card contains a character: ""X"" or ""O"". Then the player chooses two positive integers a and b (a·b = 12), after that he makes a table of size a × b from the cards he put on the table as follows: the first b cards form the first row of the table, the second b cards form the second row of the table and so on, the last b cards form the last (number a) row of the table. The player wins if some column of the table contain characters ""X"" on all cards. Otherwise, the player loses.Inna has already put 12 cards on the table in a row. But unfortunately, she doesn't know what numbers a and b to choose. Help her win the game: print to her all the possible ways of numbers a, b that she can choose and win.","# http://codeforces.com/contest/400/problem/0
# Codeforces : A. Inna and choose options

liste_a = (1, 2, 3, 4, 6, 12)
liste_results = []

def process(essai):
    global liste_results
    liste_av = [0]
    for a in liste_a:
        b = 12 // a
        for r in range(b):
            if essai[r::b] == 'X'*a:
                liste_av[0] += 1
                liste_av.append('{}x{}'.format(a,b))
                break
    liste_av[0] = str(liste_av[0])
    liste_results.append(liste_av)




t = int(input())
for k in range(t):
    essai = input()
    process(essai)

for s in liste_results:
    print(*s)",['implementation']
"John has just bought a new car and is planning a journey around the country. Country has N cities, some of which are connected by bidirectional roads. There are N - 1 roads and every city is reachable from any other city. Cities are labeled from 1 to N.John first has to select from which city he will start his journey. After that, he spends one day in a city and then travels to a randomly choosen city which is directly connected to his current one and which he has not yet visited. He does this until he can't continue obeying these rules.To select the starting city, he calls his friend Jack for advice. Jack is also starting a big casino business and wants to open casinos in some of the cities (max 1 per city, maybe nowhere). Jack knows John well and he knows that if he visits a city with a casino, he will gamble exactly once before continuing his journey.He also knows that if John enters a casino in a good mood, he will leave it in a bad mood and vice versa. Since he is John's friend, he wants him to be in a good mood at the moment when he finishes his journey. John is in a good mood before starting the journey.In how many ways can Jack select a starting city for John and cities where he will build casinos such that no matter how John travels, he will be in a good mood at the end? Print answer modulo 109 + 7.","n = int(input())
cnt = [[] for _ in range(n)]
for i in range (n - 1):
    fr, to = map(int, input().split())
    cnt[fr - 1].append(to - 1);
    cnt[to - 1].append(fr - 1);
l = 0
for i in range(n):
    if (len(cnt[i]) == 1):
        l += 1
ans = (n - l) * pow(2, n - l, 10 ** 9 + 7)
ans += l * pow(2, n - l + 1, 10 ** 9 + 7)
print (ans % (10 ** 9 + 7))",['dp']
"You are playing a computer game. In this game, you have to fight $$$n$$$ monsters.To defend from monsters, you need a shield. Each shield has two parameters: its current durability $$$a$$$ and its defence rating $$$b$$$. Each monster has only one parameter: its strength $$$d$$$.When you fight a monster with strength $$$d$$$ while having a shield with current durability $$$a$$$ and defence $$$b$$$, there are three possible outcomes:  if $$$a = 0$$$, then you receive $$$d$$$ damage;  if $$$a &gt; 0$$$ and $$$d \ge b$$$, you receive no damage, but the current durability of the shield decreases by $$$1$$$;  if $$$a &gt; 0$$$ and $$$d &lt; b$$$, nothing happens. The $$$i$$$-th monster has strength $$$d_i$$$, and you will fight each of the monsters exactly once, in some random order (all $$$n!$$$ orders are equiprobable). You have to consider $$$m$$$ different shields, the $$$i$$$-th shield has initial durability $$$a_i$$$ and defence rating $$$b_i$$$. For each shield, calculate the expected amount of damage you will receive if you take this shield and fight the given $$$n$$$ monsters in random order.","import sys;input=sys.stdin.readline
mod = 998244353
#mod=10**9+7
def frac(limit):
    frac = [1]*limit
    for i in range(2,limit):
        frac[i] = i * frac[i-1]%mod
    fraci = [None]*limit
    fraci[-1] = pow(frac[-1], mod -2, mod)
    for i in range(-2, -limit-1, -1):
        fraci[i] = fraci[i+1] * (limit + i + 1) % mod
    return frac, fraci
def mul(a, b):
    return ((a % mod) * (b % mod)) % mod
def div(a, b):
    return mul(a, pow(b, mod-2,mod))
#frac, fraci = frac(141398)
#print(fraci)

N, M = map(int, input().split())
X = list(map(int, input().split()))
t = []
for i in range(N):
    t.append((0, X[i]))
Q = []
for i in range(M):
    a, b = map(int, input().split())
    Q.append((a, b))
    t.append((1, b))

Y = [0]*(N+M)
Z = [0]*(N+M)
t.sort(key=lambda x:x[1])
d = dict()
d2 = [0]*(N+M)
cnt = 0
for l, x in t:
    if x not in d:
        cnt += 1
        d[x] = cnt
        d2[cnt] = x
    if not l:
        Y[cnt] += 1
for i in range(N+M):
    Z[i] = Y[i]*d2[i]
Y.append(0)
Z.append(0)
for i in range(N+M-1, -1, -1):
    Y[i] = Y[i+1]+Y[i]
    Z[i] = Z[i+1]+Z[i]

for a, b in Q:
    k=Y[d[b]]
    R = 0
    if k>a:
        R += div((k-a),k)*Z[d[b]]
    if k+1>a:
        R += div((k+1-a),k+1)*(Z[0]-Z[d[b]])
    print(R%mod)","['combinatorics', 'binary search', 'probabilities']"
"There are n stone quarries in Petrograd.Each quarry owns mi dumpers (1 ≤ i ≤ n). It is known that the first dumper of the i-th quarry has xi stones in it, the second dumper has xi + 1 stones in it, the third has xi + 2, and the mi-th dumper (the last for the i-th quarry) has xi + mi - 1 stones in it.Two oligarchs play a well-known game Nim. Players take turns removing stones from dumpers. On each turn, a player can select any dumper and remove any non-zero amount of stones from it. The player who cannot take a stone loses.Your task is to find out which oligarch will win, provided that both of them play optimally. The oligarchs asked you not to reveal their names. So, let's call the one who takes the first stone «tolik» and the other one «bolik».","def f(x):
    if x%4==0:
        return x
    elif x%4==1:
        return 1
    elif x%4==2:
        return x+1
    return 0

n = int(input())
res = 0
for i in range(n):
    x,m = input().split()
    x,m = int(x),int(m)
    res ^= f(x-1)^f(x+m-1)

if res == 0:
    print(""bolik"")
else:
    print(""tolik"")",['games']
"There are two sisters Alice and Betty. You have $$$n$$$ candies. You want to distribute these $$$n$$$ candies between two sisters in such a way that:  Alice will get $$$a$$$ ($$$a &gt; 0$$$) candies;  Betty will get $$$b$$$ ($$$b &gt; 0$$$) candies;  each sister will get some integer number of candies;  Alice will get a greater amount of candies than Betty (i.e. $$$a &gt; b$$$);  all the candies will be given to one of two sisters (i.e. $$$a+b=n$$$). Your task is to calculate the number of ways to distribute exactly $$$n$$$ candies between sisters in a way described above. Candies are indistinguishable.Formally, find the number of ways to represent $$$n$$$ as the sum of $$$n=a+b$$$, where $$$a$$$ and $$$b$$$ are positive integers and $$$a&gt;b$$$.You have to answer $$$t$$$ independent test cases.","from math import ceil
T=int(input())
while T>0:
      A=int(input())
      B=ceil(A-A/2-1)
      print(B)
      T-=1",['math']
"You're given an integer $$$n$$$. For every integer $$$i$$$ from $$$2$$$ to $$$n$$$, assign a positive integer $$$a_i$$$ such that the following conditions hold:  For any pair of integers $$$(i,j)$$$, if $$$i$$$ and $$$j$$$ are coprime, $$$a_i \neq a_j$$$.  The maximal value of all $$$a_i$$$ should be minimized (that is, as small as possible). A pair of integers is called coprime if their greatest common divisor is $$$1$$$.","n = int(raw_input())

marked = [False]*(10**5 + 1)
a = [0]*(10**5 + 1)
count = 0

for i in range(2,n+1):
  if not marked[i]:
    count+=1
    a[i]=count
    for j in range(i*2,n+1,i):
      marked[j]=True
      a[j] = a[i]

for i in range(2,n+1):
  print a[i],","['constructive algorithms', 'number theory']"
"Autocomplete is a program function that enables inputting the text (in editors, command line shells, browsers etc.) completing the text by its inputted part. Vasya is busy working on a new browser called 'BERowser'. He happens to be working on the autocomplete function in the address line at this very moment. A list consisting of n last visited by the user pages and the inputted part s are known. Your task is to complete s to make it an address of one of the pages from the list. You have to find the lexicographically smallest address having a prefix s.","v=[]
z=input()
for i in range(int(input())):
    x=input()
    if x[0:len(z)]==z:
        v.append(x)    
if len(v)==0:
     print(z)        
else:
  print(min(v))",['implementation']
"The tournament «Sleepyhead-2010» in the rapid falling asleep has just finished in Berland. n best participants from the country have participated in it. The tournament consists of games, each of them is a match between two participants. n·(n - 1) / 2 games were played during the tournament, and each participant had a match with each other participant. The rules of the game are quite simple — the participant who falls asleep first wins. The secretary made a record of each game in the form «xi yi», where xi and yi are the numbers of participants. The first number in each pair is a winner (i.e. xi is a winner and yi is a loser). There is no draws.Recently researches form the «Institute Of Sleep» have found that every person is characterized by a value pj — the speed of falling asleep. The person who has lower speed wins. Every person has its own value pj, constant during the life. It is known that all participants of the tournament have distinct speeds of falling asleep. Also it was found that the secretary made records about all the games except one. You are to find the result of the missing game.","n=int(input())
a,b,c=[0]*(n+1),[0]*(n+1), []
for _ in range(n*(n-1)//2-1):
    x,y=map(int,input().split())
    a[x]+=1
    b[y]+=1
for i in range(1,n+1):
    if a[i]+b[i] != n-1:
        c.append(i)
if a[c[0]]>a[c[1]]:
    print(c[0],c[1])
else:
    print(c[1],c[0])","['bitmasks', 'greedy', 'dfs and similar', 'brute force']"
"Mahmoud wrote a message s of length n. He wants to send it as a birthday present to his friend Moaz who likes strings. He wrote it on a magical paper but he was surprised because some characters disappeared while writing the string. That's because this magical paper doesn't allow character number i in the English alphabet to be written on it in a string of length more than ai. For example, if a1 = 2 he can't write character 'a' on this paper in a string of length 3 or more. String ""aa"" is allowed while string ""aaa"" is not.Mahmoud decided to split the message into some non-empty substrings so that he can write every substring on an independent magical paper and fulfill the condition. The sum of their lengths should be n and they shouldn't overlap. For example, if a1 = 2 and he wants to send string ""aaa"", he can split it into ""a"" and ""aa"" and use 2 magical papers, or into ""a"", ""a"" and ""a"" and use 3 magical papers. He can't split it into ""aa"" and ""aa"" because the sum of their lengths is greater than n. He can split the message into single string if it fulfills the conditions.A substring of string s is a string that consists of some consecutive characters from string s, strings ""ab"", ""abc"" and ""b"" are substrings of string ""abc"", while strings ""acb"" and ""ac"" are not. Any string is a substring of itself.While Mahmoud was thinking of how to split the message, Ehab told him that there are many ways to split it. After that Mahmoud asked you three questions:   How many ways are there to split the string into substrings such that every substring fulfills the condition of the magical paper, the sum of their lengths is n and they don't overlap? Compute the answer modulo 109 + 7.  What is the maximum length of a substring that can appear in some valid splitting?  What is the minimum number of substrings the message can be spit in? Two ways are considered different, if the sets of split positions differ. For example, splitting ""aa|a"" and ""a|aa"" are considered different splittings of message ""aaa"".","n=int(input())
s=input()
l=list(map(int,input().split()))
dp=[0]*(n+2)
mn=[10**4]*(n+2)
dp[0]=dp[n+1]=1
mn[0]=1
mn[n+1]=0
mod=10**9+7
maxx=1
for i in range(1,n):
  cur=10**4

  for j in range(i,-1,-1):
    c=ord(s[j])-ord('a')
    cur=min(cur,l[c])
    if cur<(i-j+1):
      break
    dp[i]=(dp[i]+dp[j-1])%mod
    mn[i]=min(mn[i],mn[j-1]+1)
    maxx=max(maxx,i-j+1)
#print(dp)
print(dp[n-1])
print(maxx)
print(mn[n-1])","['dp', 'brute force', 'greedy', 'strings']"
"Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).There are n members, numbered 1 through n. m pairs of members are friends. Of course, a member can't be a friend with themselves.Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.Can you help Limak and check if the network is reasonable? Print ""YES"" or ""NO"" accordingly, without the quotes.","n, m = map(int, raw_input().split())

visited = [False for i in xrange(n+1)]
graph = [[] for i in xrange(n+1)]

for i in xrange(m):
    a, b = map(int, raw_input().split())
    graph[a].append(b)
    graph[b].append(a)
    
def dfs(node, countV = 0, countE = 0):
    stack = [node]
    while stack:
        top = stack.pop()
        if not visited[top]:
            visited[top] = True
            countV += 1
            countE += len(graph[top])
            for i in graph[top]:
                if not visited[i]:
                    stack.append(i)
    return countE, countV
    
flag = True
for i in xrange(1, n+1):
    if not visited[i]:
        countE, countV = dfs(i)
        if countE != countV*(countV-1):
            flag = False
            break
        
if flag:
    print 'YES'
else:
    print 'NO'","['dsu', 'dfs and similar', 'graphs']"
"Game ""Minesweeper 1D"" is played on a line of squares, the line's height is 1 square, the line's width is n squares. Some of the squares contain bombs. If a square doesn't contain a bomb, then it contains a number from 0 to 2 — the total number of bombs in adjacent squares.For example, the correct field to play looks like that: 001*2***101*. The cells that are marked with ""*"" contain bombs. Note that on the correct field the numbers represent the number of bombs in adjacent cells. For example, field 2* is not correct, because cell with value 2 must have two adjacent cells with bombs.Valera wants to make a correct field to play ""Minesweeper 1D"". He has already painted a squared field with width of n cells, put several bombs on the field and wrote numbers into some cells. Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end.","from sys import stdin
def main():
    s = stdin.readline().strip()
    if s[0] == '2' or s[-1] == '2':
        print 0
        return
    # 0, *1, 1*, *2*, *
    if s[0] == '?':
        dp = [1, 0, 1, 0, 1]
    elif s[0] == '0':
        dp = [1, 0, 0, 0, 0]
    elif s[0] == '1':
        dp = [0, 0, 1, 0, 0]
    elif s[0] == '*':
        dp = [0, 0, 0, 0, 1]
    def add(x, y):
        z = x + y
        return z if z < 1000000007 else z - 1000000007
    for c in s[1:]:
        if c == '*':
            ndp = [0, 0, 0, 0, add(dp[2], add(dp[3], dp[4]))]
        elif c == '0':
            ndp = [add(dp[0], dp[1]), 0, 0, 0, 0]
        elif c == '1':
            ndp = [0, dp[4], add(dp[0], dp[1]), 0, 0]
        elif c == '2':
            ndp = [0, 0, 0, dp[4], 0]
        else:   
            ndp = [add(dp[0], dp[1]), dp[4], add(dp[0], dp[1]), dp[4], add(dp[2], add(dp[3], dp[4]))]
        dp = ndp
    print add(dp[0], add(dp[1], dp[4]))
main()","['dp', 'implementation']"
"A year ago on the bench in public park Leha found an array of n numbers. Leha believes that permutation p is right if for all 1 ≤ i &lt; n condition, that api·api + 1 is not perfect square, holds. Leha wants to find number of right permutations modulo 109 + 7.","from collections import defaultdict
n = int(raw_input())
a = [0] * 34000
ps = []
for i in xrange(2, 34000):
    if a[i]:
        continue
    ps.append(i * i)
    j = i * i
    while j < 34000:
        a[j] = 1
        j += i
a = map(int, raw_input().split())
b = defaultdict(int)
for x in a:
    for p in ps:
        while x % p == 0:
            x /= p
    b[x] += 1
b = b.values()
mod = 1000000007
f = [1] * (n + 1)
for i in xrange(2, n + 1):
    f[i] = f[i-1] * i % mod
inv = [1] * (n + 1)
invf = [1] * (n + 1)
for i in xrange(2, n + 1):
    inv[i] = mod - mod / i * inv[mod%i] % mod
    invf[i] = invf[i-1] * inv[i] % mod
def mul(pl, pr):
    res = [0] * (len(pl) + len(pr) - 1)
    for i, x in enumerate(pl):
        for j, y in enumerate(pr):
            res[i+j] += x * y
            res[i+j] %= mod
    return res
qs = [1]
for x in b:
    q = []
    for i in xrange(x):
        t = f[x-1] * invf[x-1-i] * invf[i] * invf[x-i] % mod
        q.append(t)
    qs = mul(q, qs)
ans = 0
for i in xrange(len(qs)):
    t = f[n-i] * qs[i] % mod
    if i & 1:
        t = mod - t
    ans += t
for x in b:
    ans = ans * f[x] % mod
print ans","['dp', 'combinatorics']"
"You are given the array $$$a$$$ consisting of $$$n$$$ elements and the integer $$$k \le n$$$.You want to obtain at least $$$k$$$ equal elements in the array $$$a$$$. In one move, you can make one of the following two operations:  Take one of the minimum elements of the array and increase its value by one (more formally, if the minimum value of $$$a$$$ is $$$mn$$$ then you choose such index $$$i$$$ that $$$a_i = mn$$$ and set $$$a_i := a_i + 1$$$);  take one of the maximum elements of the array and decrease its value by one (more formally, if the maximum value of $$$a$$$ is $$$mx$$$ then you choose such index $$$i$$$ that $$$a_i = mx$$$ and set $$$a_i := a_i - 1$$$). Your task is to calculate the minimum number of moves required to obtain at least $$$k$$$ equal elements in the array.","from collections import Counter

n, k = map(int, input().split())
xs = sorted(map(int, input().split()))

c = Counter(xs)
csuml = 0
lcnt = 0
csumr = sum(xs)
rcnt = len(xs)
ans = csumr

for x, cnt in sorted(c.items()):
    r = max(0, k - cnt)
    if not r:
        ans = 0
        break

    csumr -= x * cnt
    rcnt -= cnt

    ansl = lcnt * (x - 1) - csuml + min(lcnt, r)
    if lcnt < r:
        ansl += csumr - rcnt * (x + 1) + r - lcnt

    ansr = csumr - rcnt * (x + 1) + min(rcnt, r)
    if rcnt < r:
        ansr += lcnt * (x - 1) - csuml + r - rcnt

    ans = min(ans, ansl, ansr)
    csuml += x * cnt
    lcnt += cnt

print(ans)",['greedy']
"Recently Vladik discovered a new entertainment — coding bots for social networks. He would like to use machine learning in his bots so now he want to prepare some learning data for them.At first, he need to download t chats. Vladik coded a script which should have downloaded the chats, however, something went wrong. In particular, some of the messages have no information of their sender. It is known that if a person sends several messages in a row, they all are merged into a single message. It means that there could not be two or more messages in a row with the same sender. Moreover, a sender never mention himself in his messages.Vladik wants to recover senders of all the messages so that each two neighboring messages will have different senders and no sender will mention himself in his messages.He has no idea of how to do this, and asks you for help. Help Vladik to recover senders in each of the chats!","import sys


t =sys.stdin.readline()
t = int(t)

for tttt in range(t) :
  org=[]
  dic={}
  n =sys.stdin.readline()
  n = int(n)
  users=sys.stdin.readline().split()
  users=['?']+users
  for k in range(n+1):
     dic[users[k]]=k
  m = sys.stdin.readline()
  m=int(m)
  messusers=[]
  messages=[]
  for mmmm in range(m):
     curr=[]
     ms=sys.stdin.readline().strip()
     org.append(ms)
     pos=ms.find(':')
     name=ms[:pos]
     ms=' '+ms[pos+1:]+' '
     ms=ms.replace('.',' ')
     ms=ms.replace('?',' ')
     ms=ms.replace(',',' ')
     ms=ms.replace('!',' ')
     messusers.append(dic[name])
     for nm in users:
        nmm=' '+nm+' '
	if nmm in ms:
	   curr.append(dic[nm])
     messages.append(curr)

  m=len(messages)
  found=True
  for i in range(m):
    if messusers[i]!=0:
	continue
    now=[]
    if i > 0 :
	now.append(messusers[i-1])
    if i < m-1 and messusers[i+1]!=0:
        now.append(messusers[i+1])
    now+=messages[i]
    cand=[]
    for us in range(1,len(users)):
	if us not in  now:
	    cand.append(us)
    if len(cand)==0 :
        found=False
        break
    else:
	messusers[i]=cand[0]
 	#filter
	filter=[]
	if i<m-1:
	  filter+=messages[i+1]
        if i<m-2 and messusers[i+2]!=0:
	  filter.append(messusers[i+2])
        for k in cand:
	  if k in filter:
	     messusers[i]=k
             break
	org[i]=users[messusers[i]]+org[i][1:]
  if found:
    for ms in org:
      print ms
  else:
    print 'Impossible'","['dp', 'constructive algorithms', 'implementation', 'brute force', 'strings']"
"ZS the Coder and Chris the Baboon has arrived at Udayland! They walked in the park where n trees grow. They decided to be naughty and color the trees in the park. The trees are numbered with integers from 1 to n from left to right.Initially, tree i has color ci. ZS the Coder and Chris the Baboon recognizes only m different colors, so 0 ≤ ci ≤ m, where ci = 0 means that tree i is uncolored.ZS the Coder and Chris the Baboon decides to color only the uncolored trees, i.e. the trees with ci = 0. They can color each of them them in any of the m colors from 1 to m. Coloring the i-th tree with color j requires exactly pi, j litres of paint.The two friends define the beauty of a coloring of the trees as the minimum number of contiguous groups (each group contains some subsegment of trees) you can split all the n trees into so that each group contains trees of the same color. For example, if the colors of the trees from left to right are 2, 1, 1, 1, 3, 2, 2, 3, 1, 3, the beauty of the coloring is 7, since we can partition the trees into 7 contiguous groups of the same color : {2}, {1, 1, 1}, {3}, {2, 2}, {3}, {1}, {3}. ZS the Coder and Chris the Baboon wants to color all uncolored trees so that the beauty of the coloring is exactly k. They need your help to determine the minimum amount of paint (in litres) needed to finish the job.Please note that the friends can't color the trees that are already colored.","INF = 10 ** 18
MX_SZ = 112
dp = [[[INF for k in range (MX_SZ)] for j in range (MX_SZ)] for i in range (MX_SZ)]
best = [[[(INF, INF) for k in range (MX_SZ)] for j in range (MX_SZ)] for i in range (MX_SZ)]

def read():
    return [int(x) for x in input().split()]

n, m, k_res = read()
arr = read()
cost = []
for i in range (n):
    cost.append(read())
dp[0][0][MX_SZ - 1] = 0 #[trees painted][group amount][last color]
best[0][0][0] = (0, MX_SZ - 1)
#print(best[0][0][0][1])
#exit(0)
for i in range (1, n + 1):
    clr = arr[i - 1]
    if clr == 0:
        for j in range (1, k_res + 1):
            for k in range (1, m + 1):
                dp[i][j][k] = dp[i - 1][j][k] + cost[i - 1][k - 1]
                if k == best[i - 1][j - 1][0][1]:
                    dp[i][j][k] = min(dp[i][j][k], best[i - 1][j - 1][1][0] + cost[i - 1][k - 1])
                else:
                    dp[i][j][k] = min(dp[i][j][k], best[i - 1][j - 1][0][0] + cost[i - 1][k - 1])
                if dp[i][j][k] < best[i][j][0][0]:
                    best[i][j][1] = best[i][j][0]
                    best[i][j][0] = (dp[i][j][k], k)
                elif dp[i][j][k] < best[i][j][1][0]:
                    best[i][j][1] = (dp[i][j][k], k)
    else:
        for j in range (1, n + 1):
            dp[i][j][clr] = dp[i - 1][j][clr]
            if clr == best[i - 1][j - 1][0][1]:
                dp[i][j][clr] = min(dp[i][j][clr], best[i - 1][j - 1][1][0])
            else:
                dp[i][j][clr] = min(dp[i][j][clr], best[i - 1][j - 1][0][0])
            best[i][j][0] = (dp[i][j][clr], clr)
ans = INF
for k in range (1, m + 1):
    if dp[n][k_res][k] < ans:
        ans = dp[n][k_res][k]
if ans == INF:
    ans = -1
print(ans)",['dp']
"Let's call an undirected graph of n vertices p-interesting, if the following conditions fulfill:   the graph contains exactly 2n + p edges;  the graph doesn't contain self-loops and multiple edges;  for any integer k (1 ≤ k ≤ n), any subgraph consisting of k vertices contains at most 2k + p edges. A subgraph of a graph is some set of the graph vertices and some set of the graph edges. At that, the set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices. Your task is to find a p-interesting graph consisting of n vertices.","#b=b[2:].zfill(32)
#for deque append(),pop(),appendleft(),popleft(),count()
import math,sys
from collections import Counter, defaultdict, deque
from sys import stdin, stdout
input = stdin.readline
lili=lambda:list(map(int,sys.stdin.readlines()))
li = lambda:list(map(int,input().split()))
I=lambda:int(input())
S=lambda:input().strip()
mod = 1000000007

for _ in range(I()):
    n,p=li()
    k=1
    c=k+1
    p=2*n+p
    while(p):
        print(k,c)
        p-=1
        if(c==n):
            k+=1
            c=k
        c+=1","['constructive algorithms', 'brute force', 'graphs']"
"Anton likes to play chess. Also he likes to do programming. No wonder that he decided to attend chess classes and programming classes.Anton has n variants when he will attend chess classes, i-th variant is given by a period of time (l1, i, r1, i). Also he has m variants when he will attend programming classes, i-th variant is given by a period of time (l2, i, r2, i).Anton needs to choose exactly one of n possible periods of time when he will attend chess classes and exactly one of m possible periods of time when he will attend programming classes. He wants to have a rest between classes, so from all the possible pairs of the periods he wants to choose the one where the distance between the periods is maximal.The distance between periods (l1, r1) and (l2, r2) is the minimal possible distance between a point in the first period and a point in the second period, that is the minimal possible |i - j|, where l1 ≤ i ≤ r1 and l2 ≤ j ≤ r2. In particular, when the periods intersect, the distance between them is 0.Anton wants to know how much time his rest between the classes will last in the best case. Help Anton and find this number!","#!/usr/bin/python
import sys
a,b=[sorted(
	list(map(int,sys.stdin.readline().split()))
	for _ in range(int(sys.stdin.readline()))
) for _ in range(2)]
print(max(
	max(map(lambda (x,y):max(b[-1][0]-y,0),a)),
	max(map(lambda (x,y):max(a[-1][0]-y,0),b)),
))","['sortings', 'greedy']"
"As some of you know, cubism is a trend in art, where the problem of constructing volumetrical shape on a plane with a combination of three-dimensional geometric shapes comes to the fore. A famous sculptor Cicasso, whose self-portrait you can contemplate, hates cubism. He is more impressed by the idea to transmit two-dimensional objects through three-dimensional objects by using his magnificent sculptures. And his new project is connected with this. Cicasso wants to make a coat for the haters of anticubism. To do this, he wants to create a sculpture depicting a well-known geometric primitive — convex polygon.Cicasso prepared for this a few blanks, which are rods with integer lengths, and now he wants to bring them together. The i-th rod is a segment of length li.The sculptor plans to make a convex polygon with a nonzero area, using all rods he has as its sides. Each rod should be used as a side to its full length. It is forbidden to cut, break or bend rods. However, two sides may form a straight angle .Cicasso knows that it is impossible to make a convex polygon with a nonzero area out of the rods with the lengths which he had chosen. Cicasso does not want to leave the unused rods, so the sculptor decides to make another rod-blank with an integer length so that his problem is solvable. Of course, he wants to make it as short as possible, because the materials are expensive, and it is improper deed to spend money for nothing. Help sculptor!","# http://codeforces.com/contest/667/problem/B

# https://en.wikipedia.org/wiki/Triangle_inequality
# 「Generalization to any polygon」参照。
# 三角不等式の一般化が載っている。
# ポリゴンができる条件は最長辺が残りすべての辺の長さの和より短いこと
# longest< x+(total-longest)
# ∴ x > 2*longest-total

n = int(input())
lst = list(map(int, input().split()))
print(2 * max(lst) - sum(lst) + 1)","['constructive algorithms', 'geometry']"
"One day n friends met at a party, they hadn't seen each other for a long time and so they decided to make a group photo together. Simply speaking, the process of taking photos can be described as follows. On the photo, each photographed friend occupies a rectangle of pixels: the i-th of them occupies the rectangle of width wi pixels and height hi pixels. On the group photo everybody stands in a line, thus the minimum pixel size of the photo including all the photographed friends, is W × H, where W is the total sum of all widths and H is the maximum height of all the photographed friends.As is usually the case, the friends made n photos — the j-th (1 ≤ j ≤ n) photo had everybody except for the j-th friend as he was the photographer.Print the minimum size of each made photo in pixels.","n = int(input())

friends = []

Wob = 0
Hob = [0, 0]

for i in range(n):
    w, h = [int(j) for j in input().split()]
    friends.append([w, h])
    Wob += w
    if h > Hob[0]:
        Hob[1] = Hob[0]
        Hob[0] = h
    elif h > Hob[1]:
        Hob[1] = h

for f in friends:
    w = Wob - f[0]
    h = Hob[0]
    if f[1] == Hob[0]:
        h = Hob[1]
    print(w*h, end="" "")","['dp', 'implementation', '*special', 'data structures']"
"Billy investigates the question of applying greedy algorithm to different spheres of life. At the moment he is studying the application of greedy algorithm to the problem about change. There is an amount of n coins of different face values, and the coins of each value are not limited in number. The task is to collect the sum x with the minimum amount of coins. Greedy algorithm with each its step takes the coin of the highest face value, not exceeding x. Obviously, if among the coins' face values exists the face value 1, any sum x can be collected with the help of greedy algorithm. However, greedy algorithm does not always give the optimal representation of the sum, i.e. the representation with the minimum amount of coins. For example, if there are face values {1, 3, 4} and it is asked to collect the sum 6, greedy algorithm will represent the sum as 4 + 1 + 1, while the optimal representation is 3 + 3, containing one coin less. By the given set of face values find out if there exist such a sum x that greedy algorithm will collect in a non-optimal way. If such a sum exists, find out the smallest of these sums.","n = input()
z = map(int, raw_input().split())

ans = -1
for i in xrange(n):
    for j in xrange(i, n):
        a1 = z[i] - 1
        a2 = z[j]
        b1 = 1

        for k in xrange(j + 1):
            b1 += a1 / z[k]
            a2 += a1 / z[k] * z[k]
            a1 %= z[k]

        a1 = a2
        for k in xrange(n):
            b1 -= a1 / z[k]
            a1 %= z[k]

        if b1 < 0 and (ans < 0 or ans > a2):
            ans = a2


print ans",['constructive algorithms']
"The Hedgehog likes to give presents to his friend, but no less he likes to receive them.Having received another present today, the Hedgehog suddenly understood that he has no place to put it as there was no room left on the special shelf in the cupboard. He will have to choose another shelf, but which one should he choose, how large should it be?In order to get to know this, the Hedgehog asks you to write him a program that will count the estimated number of presents that he will receive during the following N days. Besides, he is guided by the principle:   on each holiday day the Hedgehog will necessarily receive a present,  he receives presents at least every K days (i.e., if he received a present on the i-th day, he will receive the next present no later than on the i + K-th day).  For the given N and K, as well as the list of holidays among the following N days count the minimal number of presents that could be given to the Hedgehog. The number of today's day is zero, and you should regard today's present as already given (i.e., you shouldn't count it in the answer).","'''input
10 4
2 6 7 
'''


n,k = map(int,raw_input().split())
ls = map(int,raw_input().split())[1:]
prev = 0
ans = 0
for elem in ls:
	ans += 1
	ans += (elem-prev-1) / k
	prev = elem 
ans += (n-prev) / k
print ans",['implementation']
"One day Anna got the following task at school: to arrange several numbers in a circle so that any two neighboring numbers differs exactly by 1. Anna was given several numbers and arranged them in a circle to fulfill the task. Then she wanted to check if she had arranged the numbers correctly, but at this point her younger sister Maria came and shuffled all numbers. Anna got sick with anger but what's done is done and the results of her work had been destroyed. But please tell Anna: could she have hypothetically completed the task using all those given numbers?","import sys
n = int(input())
c = {}
for i in [int(i) for i in input().split()]:
    c[i] = c.get(i, 0) + 1
maxi = max(c)
l = sorted(c)
for u in l[:-1]:
    if u + 1 not in c:
        print(""NO"")
        sys.exit()
    c[u + 1] -= c[u]
    if 0 > c[u + 1]:
        print(""NO"")
        sys.exit()
arr = list(c.values())
if arr.count(0) == 1 and c[maxi] == 0:
    print(""YES"")
else:
    print(""NO"")","['constructive algorithms', 'implementation']"
"Valya and Tolya are an ideal pair, but they quarrel sometimes. Recently, Valya took offense at her boyfriend because he came to her in t-shirt with lettering that differs from lettering on her pullover. Now she doesn't want to see him and Tolya is seating at his room and crying at her photos all day long.This story could be very sad but fairy godmother (Tolya's grandmother) decided to help them and restore their relationship. She secretly took Tolya's t-shirt and Valya's pullover and wants to make the letterings on them same. In order to do this, for one unit of mana she can buy a spell that can change some letters on the clothes. Your task is calculate the minimum amount of mana that Tolya's grandmother should spend to rescue love of Tolya and Valya.More formally, letterings on Tolya's t-shirt and Valya's pullover are two strings with same length n consisting only of lowercase English letters. Using one unit of mana, grandmother can buy a spell of form (c1, c2) (where c1 and c2 are some lowercase English letters), which can arbitrary number of times transform a single letter c1 to c2 and vise-versa on both Tolya's t-shirt and Valya's pullover. You should find the minimum amount of mana that grandmother should spend to buy a set of spells that can make the letterings equal. In addition you should output the required set of spells.","n = int(input())

t = input()
v = input()

s = list(set(list(t)).union(set(list(v))))
uf = [i for i in range(len(s))]

def find(uf,i):
    p = uf[i]
    return p if i==p else find(uf,p)

def union(uf,i,j):
    uf[find(uf,i)] = find(uf,j)

res = []    
for i in range(n):
    ti = s.index(t[i])
    vi = s.index(v[i])
    if (find(uf,ti) != find(uf,vi)):
        union(uf,ti,vi)
        res.append((t[i],v[i]))

print(len(res))
for i in range(len(res)):
    print(res[i][0],res[i][1])","['greedy', 'graphs', 'dsu', 'dfs and similar', 'strings']"
"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya got an array consisting of n numbers, it is the gift for his birthday. Now he wants to sort it in the non-decreasing order. However, a usual sorting is boring to perform, that's why Petya invented the following limitation: one can swap any two numbers but only if at least one of them is lucky. Your task is to sort the array according to the specified limitation. Find any possible sequence of the swaps (the number of operations in the sequence should not exceed 2n).","def good(n):
    while n > 0:
        if n % 10 != 4 and n % 10 != 7: return False
        n //= 10
    return True

n = int(input())
a = list(map(int, input().split()))
b = [i for i in range(n)]
b.sort(key = lambda i:a[i])
g = -1
for i in range(n):
    if good(a[i]):
        g = i
        break
ans = []
ok = True

if g != -1:
    for i in range(n):
        a[b[i]] = i
    for i in range(n):
        if b[i] == i or b[i] == g:
            continue
        if i != g:
            ans.append('{} {}'.format(i + 1, g + 1))
            b[a[i]], b[a[g]]=b[a[g]],b[a[i]]
            a[i],a[g]=a[g],a[i]
        g = b[i]
        if i != g:
            ans.append('{} {}'.format(i + 1, g + 1))
            b[a[i]], b[a[g]]=b[a[g]],b[a[i]]
            a[i],a[g]=a[g],a[i]
        
else:
    for i in range(1,n):
        if a[i] < a[i-1]:
            ok = False
            break
if not ok:
    print(-1)
else:
    print(len(ans))
    print('\n'.join(ans))","['constructive algorithms', 'sortings']"
"This is an interactive problem.Yui is a girl who enjoys playing Mahjong. She has a mysterious set which consists of tiles (this set can be empty). Each tile has an integer value between $$$1$$$ and $$$n$$$, and at most $$$n$$$ tiles in the set have the same value. So the set can contain at most $$$n^2$$$ tiles.You want to figure out which values are on the tiles. But Yui is shy, she prefers to play a guessing game with you.Let's call a set consisting of three tiles triplet if their values are the same. For example, $$$\{2,\,2,\,2\}$$$ is a triplet, but $$$\{2,\,3,\,3\}$$$ is not.Let's call a set consisting of three tiles straight if their values are consecutive integers. For example, $$$\{2,\,3,\,4\}$$$ is a straight, but $$$\{1,\,3,\,5\}$$$ is not.At first, Yui gives you the number of triplet subsets and straight subsets of the initial set respectively. After that, you can insert a tile with an integer value between $$$1$$$ and $$$n$$$ into the set at most $$$n$$$ times. Every time you insert a tile, you will get the number of triplet subsets and straight subsets of the current set as well.Note that two tiles with the same value are treated different. In other words, in the set $$$\{1,\,1,\,2,\,2,\,3\}$$$ you can find $$$4$$$ subsets $$$\{1,\,2,\,3\}$$$.Try to guess the number of tiles in the initial set with value $$$i$$$ for all integers $$$i$$$ from $$$1$$$ to $$$n$$$.","n = int(input())

t, s = map(int, input().split())

x = n-1

while x>2:
	print(""+"",x)
	x-=1

print(""+ {}\n+ {}\n+ {}"".format(1, 2, 1), flush = True)

deltas = []
for i in range(n):
	t2, s2 = map(int, input().split())
	deltas.append([ t2 - t, s2 - s])
	s = s2
	t = t2

#print(deltas)

ans = [0] * n

x = 0
while (x+1)*x < deltas[-1][0]*2: x+=1

ans[0] = x
ans[2] = deltas[-1][1] - deltas[-3][1] -1
ans[1] = deltas[-3][1]//(ans[2]+1)

ans[3] = (deltas[-2][1] - (ans[0]+1)*(ans[2]+1))//(ans[2]+1) -1

for x in range(4,n):
	#print(deltas[-x])
	ans[x] = (deltas[-x][1] - ans[x-4] * ans[x-3] - ans[x-3]*(ans[x-1] +1))//(ans[x-1]+1) -1


ans[-1]+=1

print(""!"", end = ' ')
for x in ans:
	print(x, end = ' ')
print()","['constructive algorithms', 'interactive']"
"Unfortunately, Vasya can only sum pairs of integers (a, b), such that for any decimal place at least one number has digit 0 in this place. For example, Vasya can sum numbers 505 and 50, but he cannot sum 1 and 4.Vasya has a set of k distinct non-negative integers d1, d2, ..., dk.Vasya wants to choose some integers from this set so that he could sum any two chosen numbers. What maximal number of integers can he choose in the required manner?","input()
A = map(int, raw_input().split())
ans = []
for i in A:
  if i in range(1, 10):
    ans += [i]
    break
for i in A:
  if i in range(10, 100, 10):
    ans += [i]
    break
if len(ans) == 0:
  for i in A:
    if i not in (0, 100):
      ans += [i]
      break
if 100 in A:
  ans += [100]
if 0 in A:
  ans += [0]
print(len(ans))
print("" "".join(map(str,ans)))","['constructive algorithms', 'implementation', 'brute force']"
"As we know, DZY loves playing games. One day DZY decided to play with a n × m matrix. To be more precise, he decided to modify the matrix with exactly k operations.Each modification is one of the following:  Pick some row of the matrix and decrease each element of the row by p. This operation brings to DZY the value of pleasure equal to the sum of elements of the row before the decreasing.  Pick some column of the matrix and decrease each element of the column by p. This operation brings to DZY the value of pleasure equal to the sum of elements of the column before the decreasing. DZY wants to know: what is the largest total value of pleasure he could get after performing exactly k modifications? Please, help him to calculate this value.","from heapq import heappush,heappop,heapify
n,m,k,p=map(int,raw_input().split())
row=[]
col=[]
heapify(row)
heapify(col)
arr=[]
for i in range(n):
    s=map(int,raw_input().split())
    heappush(row,-sum(s))
    arr.append(s)
for i in range(m):
    s=0
    for j in range(n):
        s-=arr[j][i]
    heappush(col,s)
pr={}
pc={}
rr=0
rc=0
pr[0]=0
pc[0]=0
for h in range(k):
    a=-(heappop(row))
    b=-(heappop(col))
    temp=a
    a-=m*p
    heappush(row,-a)
    rr+=temp
    pr[h+1]=rr

    temp=b
    b-=n*p
    heappush(col,-b)
    rc+=temp
    pc[h+1]=rc
#print pr
ans=-10**20
for i in range(0,k+1):
    ans=max(ans,pc[i]+pr[k-i]-i*(k-i)*p)
print ans","['data structures', 'greedy', 'brute force']"
"The GCD table G of size n × n for an array of positive integers a of length n is defined by formula   Let us remind you that the greatest common divisor (GCD) of two positive integers x and y is the greatest integer that is divisor of both x and y, it is denoted as . For example, for array a = {4, 3, 6, 2} of length 4 the GCD table will look as follows:  Given all the numbers of the GCD table G, restore array a.","def getDictionary(myList):
    myDict = {}
    for i in range(0, len(myList)):
        if (myList[i] in myDict):
            myDict[myList[i]] = myDict[myList[i]] + 1;
        else:
            myDict[myList[i]] = 1;
    return myDict
 
def counting(sizeOfMother, myDict):
    winTable = []
    for i in range(0, sizeOfMother):
        x = next(iter(myDict.keys()))
 
        # Usun ten element
        if (myDict[x] > 1):
            myDict[x] = myDict[x] - 1;
        else:
            del myDict[x]
 
        for j in range(0, len(winTable)):
            gcd = searchNWD(x, winTable[j])
            # Usun ten element
            if (myDict[gcd] <= 2):
                del myDict[gcd]
            else:
                myDict[gcd] = myDict[gcd] - 2;
                
        winTable.append(x)
    return winTable
 
def searchNWD(a, b):
    temporary = 0
    while(a != 0) and (b != 0):
        if(a > b):
            a = a % b
        else:
            b = b % a
    if(a > 0):
        return a
    else:
        return b
 
######################
sizeOfMotherG = int(input())
numberInMotherG = list(map(int, input().split()))
numberInMotherG.sort(reverse=True)
myDictG = getDictionary(numberInMotherG)

w = counting(sizeOfMotherG, myDictG)
 
for i in range(0, sizeOfMotherG):
    print(w[i], end="" "")","['constructive algorithms', 'number theory', 'greedy']"
"Let's call an undirected graph $$$G = (V, E)$$$ relatively prime if and only if for each edge $$$(v, u) \in E$$$  $$$GCD(v, u) = 1$$$ (the greatest common divisor of $$$v$$$ and $$$u$$$ is $$$1$$$). If there is no edge between some pair of vertices $$$v$$$ and $$$u$$$ then the value of $$$GCD(v, u)$$$ doesn't matter. The vertices are numbered from $$$1$$$ to $$$|V|$$$.Construct a relatively prime graph with $$$n$$$ vertices and $$$m$$$ edges such that it is connected and it contains neither self-loops nor multiple edges.If there exists no valid graph with the given number of vertices and edges then output ""Impossible"".If there are multiple answers then print any of them.","from math import gcd
n, m = map(int, input().split())
a = []
for i in range(1, n):
    for j in range(i+1, n+1):
        if gcd(i, j) == 1:
            a.append([i, j])
        if len(a) == m:
            break
    if len(a) == m:
        break
if m < n-1 or len(a) != m:
    print(""Impossible"")
else:
    print(""Possible"")
    for x in a:
        print(x[0], x[1])","['greedy', 'graphs', 'constructive algorithms', 'math', 'brute force']"
"Edo has got a collection of n refrigerator magnets!He decided to buy a refrigerator and hang the magnets on the door. The shop can make the refrigerator with any size of the door that meets the following restrictions: the refrigerator door must be rectangle, and both the length and the width of the door must be positive integers.Edo figured out how he wants to place the magnets on the refrigerator. He introduced a system of coordinates on the plane, where each magnet is represented as a rectangle with sides parallel to the coordinate axes.Now he wants to remove no more than k magnets (he may choose to keep all of them) and attach all remaining magnets to the refrigerator door, and the area of ​​the door should be as small as possible. A magnet is considered to be attached to the refrigerator door if its center lies on the door or on its boundary. The relative positions of all the remaining magnets must correspond to the plan.Let us explain the last two sentences. Let's suppose we want to hang two magnets on the refrigerator. If the magnet in the plan has coordinates of the lower left corner (x1, y1) and the upper right corner (x2, y2), then its center is located at (, ) (may not be integers). By saying the relative position should correspond to the plan we mean that the only available operation is translation, i.e. the vector connecting the centers of two magnets in the original plan, must be equal to the vector connecting the centers of these two magnets on the refrigerator.The sides of the refrigerator door must also be parallel to coordinate axes.","from sys import*
#
def check(u, d, l, r):
    used = [pointsx[i][1] for i in range(l)]
    used += [pointsx[-1 - i][1] for i in range(r)]
    used += [pointsy[i][1] for i in range(u)]
    used += [pointsy[-1 - i][1] for i in range(d)]
    if len(set(used)) > k:
        return DOHERA
    dx = pointsx[-1 - r][0] - pointsx[l][0]
    dy = pointsy[-1 - d][0] - pointsy[u][0]
    dx += dx & 1
    dy += dy & 1
    dx = max(2, dx)
    dy = max(2, dy)
    return dx * dy
#
(n, k) = map(int, input().split())
pointsx = []
pointsy = []
DOHERA = 10 ** 228
for i in range(n):
    a = list(map(int, input().split()))
    pointsx += [(a[0] + a[2], i)]
    pointsy += [(a[1] + a[3], i)]
(pointsx, pointsy) = (sorted(pointsx), sorted(pointsy))
ans = DOHERA
for u in range(0, k + 1):
    for d in range(0, k + 1):
        for l in range(0, k + 1):
            for r in range(0, k + 1):
                if l + r  <= k and u + d <= k:
                    ans = min(ans, check(u, d, l, r))
print(ans // 4)



# Made By Mostafa_Khaled","['two pointers', 'implementation', 'greedy', 'brute force']"
"The country Treeland consists of n cities, some pairs of them are connected with unidirectional roads. Overall there are n - 1 roads in the country. We know that if we don't take the direction of the roads into consideration, we can get from any city to any other one.The council of the elders has recently decided to choose the capital of Treeland. Of course it should be a city of this country. The council is supposed to meet in the capital and regularly move from the capital to other cities (at this stage nobody is thinking about getting back to the capital from these cities). For that reason if city a is chosen a capital, then all roads must be oriented so that if we move along them, we can get from city a to any other city. For that some roads may have to be inversed.Help the elders to choose the capital so that they have to inverse the minimum number of roads in the country.","n=int(input())
t=[0]*(n+1)
u,v=[[]for i in range(n+1)],[[]for i in range(n+1)]
for i in range(n-1):
    x,y=map(int,input().split())
    t[y]=1
    u[x].append(y)
    v[y].append(x)
d, s = u[1] + v[1], len(v[1])
for i in u[1]:
    t[i]=1
    v[i].remove(1)
for i in v[1]:
    t[i]=-1
    u[i].remove(1)
while d:
    b=d.pop()
    for i in u[b]:
        t[i]=t[b]+1
        v[i].remove(b)
    for i in v[b]:
        t[i]=t[b]-1
        u[i].remove(b)
    d+=u[b]+v[b]
    s+=len(v[b])
m=min(t)
print(s+m)
print(' '.join(map(str,[i for i in range(1,n+1) if t[i]==m])))","['dp', 'dfs and similar', 'trees', 'graphs']"
"Yura owns a quite ordinary and boring array $$$a$$$ of length $$$n$$$. You think there is nothing more boring than that, but Vladik doesn't agree!In order to make Yura's array even more boring, Vladik makes $$$q$$$ boring queries. Each query consists of two integers $$$x$$$ and $$$y$$$. Before answering a query, the bounds $$$l$$$ and $$$r$$$ for this query are calculated: $$$l = (last + x) \bmod n + 1$$$, $$$r = (last + y) \bmod n + 1$$$, where $$$last$$$ is the answer on the previous query (zero initially), and $$$\bmod$$$ is the remainder operation. Whenever $$$l &gt; r$$$, they are swapped.After Vladik computes $$$l$$$ and $$$r$$$ for a query, he is to compute the least common multiple (LCM) on the segment $$$[l; r]$$$ of the initial array $$$a$$$ modulo $$$10^9 + 7$$$. LCM of a multiset of integers is the smallest positive integer that is divisible by all the elements of the multiset. The obtained LCM is the answer for this query.Help Vladik and compute the answer for each query!","import sys
range = xrange
input = raw_input

# MOD
MOD = 10**9 + 7

def fast_modder(MOD):
    """""" Returns function modmul(a,b) that quickly calculates a * b % MOD, assuming 0 <= a,b < MOD """"""
    import sys, platform
    impl = platform.python_implementation()
    maxs = sys.maxsize
    if 'PyPy' in impl and MOD <= maxs and MOD ** 2 > maxs:
        import __pypy__
        intsub = __pypy__.intop.int_sub
        intmul = __pypy__.intop.int_mul
        intmulmod = __pypy__.intop.int_mulmod
        if MOD < 2**30:
            MODINV = 1.0 / MOD
            def modmul(a, b):
                x = intsub(intmul(a,b), intmul(MOD, int(MODINV * a * b)))
                return x - MOD if x >= MOD else (x if x >= 0 else x + MOD)
        else:
            def modmul(a, b):
                return intmulmod(a, b, MOD)
    else:
        def modmul(a, b):
            return a * b % MOD
    return modmul

modmul = fast_modder(MOD)



# GCD
def gcd(a,b):
    while b:
        a, b = b, a % b
    return a

# Prime sieve
big = 2 * 10**5 + 1
marker = [1] * big
primeid = [-1] * big
pid = 0

for i in range(2, big):
    if marker[i] == 1:
        primeid[i] = pid
        pid += 1
        for j in range(i, big, i):
            marker[j] = i

# input and precalc
inp = [int(x) for x in sys.stdin.read().split()]; ii = 0
n = inp[ii]; ii+= 1
A = inp[ii : ii + n]; ii += n

maxsqrt = 1
for i in range(big):
    if i * i < big and marker[i] == i:
        maxsqrt = i

base = [1] * (primeid[maxsqrt] + 1)
# B is to keep track of small prime factors
# C is for large factors
B = []
C = []
for a in A:
    b = list(base)
    c = 1
    while a > 1:
        p = marker[a]
        count = 1
        while a % p == 0:
            a //= p
            count *= p
        if p <= maxsqrt:
            b[primeid[p]] = count
        else:
            c = p
    B.append(b)
    C.append(c)

def merge(A,B):
    return [max(A[i], B[i]) for i in range(len(A))]

### Segtree 1
class brute_seg:
    def __init__(self, A):
        n = len(A)
        data = [base] * (2 * n)
        data[n:n + n] = A
        for i in reversed(range(1, n)):
            data[i] = merge(data[2 * i], data[2 * i + 1])

        def __call__(l,r):
            l += n
            r += n
            B = base
            
            while l < r:
                if l & 1:
                    B = merge(B, data[l])
                    l += 1
                if r & 1:
                    r -= 1
                    B = merge(B, data[r])
                l >>= 1
                r >>= 1
            ans = 1
            for b in B:
                ans = modmul(ans, b)
            return ans
        self.__call__ = __call__

smallseg = brute_seg(B)

### Segtree 2

from bisect import bisect_left as binsearch
class mod_mergesort_seg:
    def __init__(self, A, B):
        n = len(A)
        
        data = [[]] * (2 * n)
        data[n:2 * n] = [[a] for a in A]

        for i in reversed(range(1, n)):
            data[i] = sorted(data[2 * i] + data[2 * i + 1])
        
        cumsummer = [[1]] * (2 * n)
        for i in range(1, 2 * n):
            C = [1]
            cumsummer[i] = C
            for d in data[i]:
                C.append(modmul(C[-1], B[d]))

        def query(l, r, x):
            """""" Count number of i in [l,r) such that A[i] < x """"""
            l += n
            r += n
            ans = 1
            while l < r:
                if l & 1:
                    ans = modmul(ans, cumsummer[l][binsearch(data[l], x)])
                    l += 1
                if r & 1:
                    r -= 1
                    ans = modmul(ans, cumsummer[r][binsearch(data[r], x)])
                l >>= 1
                r >>= 1
            return ans
        self.query = query

class unique_seg:
    def __init__(self, A):
        n = len(A)

        I = []
        seen = {}
        for i in range(n):
            a = A[i]
            I.append(seen[a] if a in seen else i - n)
            seen[a] = i
        
        seg = mod_mergesort_seg(I, A)
        self.__call__ = lambda l, r: seg.query(l, r, l)

largeseg = unique_seg(C)

### Queries

q = inp[ii]; ii += 1
L = inp[ii + 0: ii + 2 * q: 2]
R = inp[ii + 1: ii + 2 * q: 2]
ii += 2 * q

ans = []
last = 0
for qind in range(q):
    l = (last + L[qind]) % n
    r = (last + R[qind]) % n
    if l > r:
        l,r = r,l
    r += 1

    #val = 1
    #for a in A[l:r]:
    #    val = val * a // gcd(val, a)
    #last = val

    last = modmul(smallseg(l,r), largeseg(l,r))

    ans.append(last)
print '\n'.join(str(x) for x in ans)","['data structures', 'number theory', 'math']"
"You have an array $$$a_1, a_2, \dots, a_n$$$. Let's call some subarray $$$a_l, a_{l + 1}, \dots , a_r$$$ of this array a subpermutation if it contains all integers from $$$1$$$ to $$$r-l+1$$$ exactly once. For example, array $$$a = [2, 2, 1, 3, 2, 3, 1]$$$ contains $$$6$$$ subarrays which are subpermutations: $$$[a_2 \dots a_3]$$$, $$$[a_2 \dots a_4]$$$, $$$[a_3 \dots a_3]$$$, $$$[a_3 \dots a_5]$$$, $$$[a_5 \dots a_7]$$$, $$$[a_7 \dots a_7]$$$.You are asked to calculate the number of subpermutations.","import  sys
import  math
input=sys.stdin.readline
#sys.setrecursionlimit(1000000)
mod=int(1000000007)
i=lambda :map(int,input().split())
n=int(input())
a=[int(x) for x in input().split()]
t=[[0]*21 for i in range(300005)]
for i in range(n):
    t[i][0]=a[i]

def build(n):
    for j in range(1,20):
        for i in range(n):
            if i+(1<<j)-1>n-1:
                break;
            t[i][j]=max(t[i][j-1],t[i+(1<<(j-1))][j-1])

def query(p,q):
    p,q=int(p),int(q)
    log=int(math.log2(q-p+1))
    m=t[p][log]
    n=t[q-(1<<log)+1][log]
    return max(m,n)

b=[-1]*(n+2)
build(n)
max1=-1
ans=0
for i in range(n):
    max1=max(max1,b[a[i]])
    b[a[i]]=i
    x=b[1]
    while x>max1:
        if x<=max1:
            break
        p=query(x,i)
        if p==i-x+1:
            ans+=1
            x=b[p+1]
        else:
            x=i-p+1
print(ans)","['hashing', 'math', 'divide and conquer', 'data structures', 'brute force']"
"You are given two integers $$$l$$$ and $$$r$$$ ($$$l \le r$$$). Your task is to calculate the sum of numbers from $$$l$$$ to $$$r$$$ (including $$$l$$$ and $$$r$$$) such that each number contains at most $$$k$$$ different digits, and print this sum modulo $$$998244353$$$.For example, if $$$k = 1$$$ then you have to calculate all numbers from $$$l$$$ to $$$r$$$ such that each number is formed using only one digit. For $$$l = 10, r = 50$$$ the answer is $$$11 + 22 + 33 + 44 = 110$$$.","MOD = 998244353


def pop_count(x) :
    ans = 0
    while (x > 0) :
        ans = ans + x % 2
        x = x // 2
    return ans

def check(x, k) :
    mask = 0
    nx = int(x)
    while (nx > 0) :
        mask = mask | (1 << (nx % 10))
        nx = nx // 10
    if (pop_count(mask) <= k) :
        return x
    return 0

pop = []
p10 = []
f = [[0 for j in range(1 << 10)] for i in range(20)]
w = [[0 for j in range(1 << 10)] for i in range(20)]
def prepare() : 
    p10.append(1)
    for i in range(20) :
        p10.append(p10[i] * 10 % MOD)
    for i in range(1 << 10) :
        pop.append(pop_count(i))
    w[0][0] = 1
    for i in range(1, 20) :
        for j in range(1 << 10) :
            for use in range(10) : 
                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD
                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD

def solve(x, k) :
    sx = [int(d) for d in str(x)] 
    n = len(sx) 
    ans = 0
    for i in range(1, n) :
        for use in range(1, 10) :
            for mask in range(1 << 10) : 
                if (pop[(1 << use) | mask] <= k) :
                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD
    cmask = 0
    csum = 0
    for i in range(n) :
        cdig = sx[i]
        for use in range(cdig) : 
            if (i == 0 and use == 0) :
                continue
            nmask = cmask | (1 << use)
            for mask in range(1 << 10) : 
                if (pop[nmask | mask] <= k) :
                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD
        cmask |= 1 << cdig
        csum = (10 * csum + cdig) % MOD
    return ans

prepare()
l, r, k = map(int, input().split())
ans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD
print(ans)","['dp', 'combinatorics', 'bitmasks', 'math']"
"Bob recently read about bitwise operations used in computers: AND, OR and XOR. He have studied their properties and invented a new game.Initially, Bob chooses integer m, bit depth of the game, which means that all numbers in the game will consist of m bits. Then he asks Peter to choose some m-bit number. After that, Bob computes the values of n variables. Each variable is assigned either a constant m-bit number or result of bitwise operation. Operands of the operation may be either variables defined before, or the number, chosen by Peter. After that, Peter's score equals to the sum of all variable values.Bob wants to know, what number Peter needs to choose to get the minimum possible score, and what number he needs to choose to get the maximum possible score. In both cases, if there are several ways to get the same score, find the minimum number, which he can choose.","#from math import *
#from collections import Counter
def rl(s): return xrange(len(s))

INF = 2147483647


import sys
stdin = sys.stdin

N, M = map(int, stdin.readline().strip().split())

variables_min = {'?': 0}
variables_max = {'?': int('1'*M, 2)}
sum_min = [0] * M
sum_max = [0] * M
oper = {'AND': lambda a, b: a & b,
        'OR' : lambda a, b: a | b,
        'XOR': lambda a, b: a ^ b}
for i in range(N):
    varname, expression = stdin.readline().strip().split(' := ')
    varname = varname.strip()
    expression = expression.strip()
    if ' ' in expression:
        left, op, right = expression.split(' ')
        result_min = oper[op](variables_min[left], variables_min[right])
        result_max = oper[op](variables_max[left], variables_max[right])
    else:
        result_min = int(expression, 2)
        result_max = result_min
    variables_min[varname] = result_min
    variables_max[varname] = result_max

    rmin = bin(result_min)[2:]
    rmax = bin(result_max)[2:]
    min_offset = M - len(rmin)
    max_offset = M - len(rmax)
    for i in range(len(rmin)):
        if '1' == rmin[i]:
            sum_min[min_offset+i] += 1
    for i in range(len(rmax)):
        if '1' == rmax[i]:
            sum_max[max_offset+i] += 1

amin = [None] * M
amax = [None] * M
for i in range(M):
    if sum_min[i] == sum_max[i]:
        amin[i] = '0'
        amax[i] = '0'
    elif sum_min[i] < sum_max[i]:
        amin[i] = '0'
        amax[i] = '1'
    else:
        amin[i] = '1'
        amax[i] = '0'

print ''.join(amin)
print ''.join(amax)","['bitmasks', 'implementation', 'expression parsing', 'dfs and similar', 'brute force']"
"You've got string s, consisting of small English letters. Some of the English letters are good, the rest are bad.A substring s[l...r] (1 ≤ l ≤ r ≤ |s|) of string s  =  s1s2...s|s| (where |s| is the length of string s) is string  slsl + 1...sr.The substring s[l...r] is good, if among the letters  sl, sl + 1, ..., sr there are at most k bad ones (look at the sample's explanation to understand it more clear).Your task is to find the number of distinct good substrings of the given string s. Two substrings s[x...y] and s[p...q] are considered distinct if their content is different, i.e. s[x...y] ≠ s[p...q].","s = input()
L = input()
k = int(input())
l=len(s)
good = set()
string = set()
LIST = [chr(i) for i in range(97, 123)]
for i in range(26):
    if L[i] == '1':
        good.add(LIST[i])
t = [s[i] not in good for i in range(l)]
end = [0]*l
sumbad = 0
i,j=0,0
while i<l:
    if j<l:
        sumbad+=t[j]
    if sumbad>k or j==l:
        sumbad-=t[i]
        end[i]=j
        i+=1
        if sumbad>k:
            sumbad-=t[j]
            continue
    if j<l:
        j+=1
for i in range(len(s)):
    t = 0
    for j in range(i, end[i]):
        t = (t*29 + ord(s[j])-96)&1152921504606846975
        string.add(t)
print(len(string))","['data structures', 'strings']"
Think of New York as a rectangular grid consisting of N vertical avenues numerated from 1 to N and M horizontal streets numerated 1 to M. C friends are staying at C hotels located at some street-avenue crossings. They are going to celebrate birthday of one of them in the one of H restaurants also located at some street-avenue crossings. They also want that the maximum distance covered by one of them while traveling to the restaurant to be minimum possible. Help friends choose optimal restaurant for a celebration.Suppose that the distance between neighboring crossings are all the same equal to one kilometer.,"#!/usr/bin/env python3

n, m = map(int, input().split())
minx = miny = n + m
maxx = maxy = - minx
dist = n + m + 1

c = int(input())
for _ in range(c):
    x, y = map(int, input().split())
    minx = min(minx, x - y)
    miny = min(miny, x + y)
    maxx = max(maxx, x - y)
    maxy = max(maxy, x + y)

h = int(input())
for i in range(h):
    a, b = map(int, input().split())
    x = a - b
    y = a + b
    maxxy = max(
        max(abs(minx - x), abs(maxx - x)),
        max(abs(miny - y), abs(maxy - y))
        )
    if  maxxy < dist:
        dist = maxxy
        res = i + 1

print(dist)
print(res)","['greedy', 'math']"
"This is the easier version of the problem. In this version $$$1 \le n, m \le 100$$$. You can hack this problem only if you solve and lock both problems.You are given a sequence of integers $$$a=[a_1,a_2,\dots,a_n]$$$ of length $$$n$$$. Its subsequence is obtained by removing zero or more elements from the sequence $$$a$$$ (they do not necessarily go consecutively). For example, for the sequence $$$a=[11,20,11,33,11,20,11]$$$:  $$$[11,20,11,33,11,20,11]$$$, $$$[11,20,11,33,11,20]$$$, $$$[11,11,11,11]$$$, $$$[20]$$$, $$$[33,20]$$$ are subsequences (these are just some of the long list);  $$$[40]$$$, $$$[33,33]$$$, $$$[33,20,20]$$$, $$$[20,20,11,11]$$$ are not subsequences. Suppose that an additional non-negative integer $$$k$$$ ($$$1 \le k \le n$$$) is given, then the subsequence is called optimal if:  it has a length of $$$k$$$ and the sum of its elements is the maximum possible among all subsequences of length $$$k$$$;  and among all subsequences of length $$$k$$$ that satisfy the previous item, it is lexicographically minimal. Recall that the sequence $$$b=[b_1, b_2, \dots, b_k]$$$ is lexicographically smaller than the sequence $$$c=[c_1, c_2, \dots, c_k]$$$ if the first element (from the left) in which they differ less in the sequence $$$b$$$ than in $$$c$$$. Formally: there exists $$$t$$$ ($$$1 \le t \le k$$$) such that $$$b_1=c_1$$$, $$$b_2=c_2$$$, ..., $$$b_{t-1}=c_{t-1}$$$ and at the same time $$$b_t&lt;c_t$$$. For example:  $$$[10, 20, 20]$$$ lexicographically less than $$$[10, 21, 1]$$$,  $$$[7, 99, 99]$$$ is lexicographically less than $$$[10, 21, 1]$$$,  $$$[10, 21, 0]$$$ is lexicographically less than $$$[10, 21, 1]$$$. You are given a sequence of $$$a=[a_1,a_2,\dots,a_n]$$$ and $$$m$$$ requests, each consisting of two numbers $$$k_j$$$ and $$$pos_j$$$ ($$$1 \le k \le n$$$, $$$1 \le pos_j \le k_j$$$). For each query, print the value that is in the index $$$pos_j$$$ of the optimal subsequence of the given sequence $$$a$$$ for $$$k=k_j$$$.For example, if $$$n=4$$$, $$$a=[10,20,30,20]$$$, $$$k_j=2$$$, then the optimal subsequence is $$$[20,30]$$$ — it is the minimum lexicographically among all subsequences of length $$$2$$$ with the maximum total sum of items. Thus, the answer to the request $$$k_j=2$$$, $$$pos_j=1$$$ is the number $$$20$$$, and the answer to the request $$$k_j=2$$$, $$$pos_j=2$$$ is the number $$$30$$$.","import sys
import collections
from collections import Counter
import itertools
import math
import timeit

#input = sys.stdin.readline

#########################
# imgur.com/Pkt7iIf.png #
#########################

def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r

def divs(n, start=1):
    divisors = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if n % i == 0:
            if n / i == i:
                divisors.append(i)
            else:
                divisors.extend([i, n // i])
    return divisors

def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t

def flin(d, x, default = -1):
    left = right = -1
    for i in range(len(d)):
        if d[i] == x:
            if left == -1: left = i
            right = i
    if left == -1:
        return (default, default)
    else:
        return (left, right)

def ceil(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def prr(a, sep=' '): print(sep.join(map(str, a)))
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)

def rev(d, i, j):
    while i <= j:
        d[i], d[j] = d[j], d[i]
        i += 1
        j -= 1

n = ii()
d = li()
sd = sorted(d, reverse=True)
sets = []
dic = dd()
ts = 0
for i in range(n):
    ts += sd[i]
    dic[sd[i]] += 1
    tmp = dic.copy()
    line = []
    for j in range(n):
        if tmp[d[j]] > 0:
            line.append(d[j])
            tmp[d[j]] -= 1
    sets.append(line)


t = ii()
for _ in range(t):
    k, pos = mi()
    print(sets[k - 1][pos - 1])","['data structures', 'greedy']"
"Arseniy is already grown-up and independent. His mother decided to leave him alone for m days and left on a vacation. She have prepared a lot of food, left some money and washed all Arseniy's clothes. Ten minutes before her leave she realized that it would be also useful to prepare instruction of which particular clothes to wear on each of the days she will be absent. Arseniy's family is a bit weird so all the clothes is enumerated. For example, each of Arseniy's n socks is assigned a unique integer from 1 to n. Thus, the only thing his mother had to do was to write down two integers li and ri for each of the days — the indices of socks to wear on the day i (obviously, li stands for the left foot and ri for the right). Each sock is painted in one of k colors.When mother already left Arseniy noticed that according to instruction he would wear the socks of different colors on some days. Of course, that is a terrible mistake cause by a rush. Arseniy is a smart boy, and, by some magical coincidence, he posses k jars with the paint — one for each of k colors.Arseniy wants to repaint some of the socks in such a way, that for each of m days he can follow the mother's instructions and wear the socks of the same color. As he is going to be very busy these days he will have no time to change the colors of any socks so he has to finalize the colors now.The new computer game Bota-3 was just realised and Arseniy can't wait to play it. What is the minimum number of socks that need their color to be changed in order to make it possible to follow mother's instructions and wear the socks of the same color during each of m days.","def dfs(v, visited, edges, colors):
    st = [v]
    visited.add(v)
    comp = []
    cols = dict()
    while st:
        ver = st.pop()
        comp.append(colors[ver])
        if ver in edges:
            for i in edges[ver]:
                if i not in visited:
                    st.append(i)
                    visited.add(i)
    for i in comp:
        if i not in cols:
            cols[i] = 1
        else:
            cols[i] += 1
    max_c = 0
    for i in cols:
        if cols[i] > max_c:
            max_c = cols[i]
    return len(comp) - max_c



n, m, k = [int(x) for x in input().split()]
colors = {i + 1 : int(x) for i, x in enumerate(input().split())}
edges = dict()
for i in range(m):
    v1, v2 = [int(x) for x in input().split()]
    if v1 in edges:
        edges[v1].append(v2)
    else:
        edges[v1] = [v2]
    if v2 in edges:
        edges[v2].append(v1)
    else:
        edges[v2] = [v1]

visited = set()
answer = 0
for i in range(1, n + 1):
    if i not in visited:
        answer += dfs(i, visited, edges, colors)


print(answer)","['dsu', 'dfs and similar', 'greedy', 'graphs']"
"Vova again tries to play some computer card game.The rules of deck creation in this game are simple. Vova is given an existing deck of n cards and a magic number k. The order of the cards in the deck is fixed. Each card has a number written on it; number ai is written on the i-th card in the deck.After receiving the deck and the magic number, Vova removes x (possibly x = 0) cards from the top of the deck, y (possibly y = 0) cards from the bottom of the deck, and the rest of the deck is his new deck (Vova has to leave at least one card in the deck after removing cards). So Vova's new deck actually contains cards x + 1, x + 2, ... n - y - 1, n - y from the original deck.Vova's new deck is considered valid iff the product of all numbers written on the cards in his new deck is divisible by k. So Vova received a deck (possibly not a valid one) and a number k, and now he wonders, how many ways are there to choose x and y so the deck he will get after removing x cards from the top and y cards from the bottom is valid?","import math

def fact(nn):
    p=2
    df={}
    while nn%2==0:
        if 2 not in df:
            df[2]=0
        df[2]+=1
        nn/=2
    p=3
    s=math.sqrt(nn)+1
    while p<s:
        while nn%p==0:
            if p not in df:
                df[p]=0
            df[p]+=1
            nn/=p
            s=math.sqrt(nn)+1
        p+=2
    if nn>1:
        df[nn]=1
    return df

n,k =[int(i) for i in raw_input().split("" "")]
a=[int(i) for i in raw_input().split("" "")]

fk=fact(k)
nbf=len(fk)
afacts=[0]*n
sfacts=[0]*n
sfacts[-1]=[0]*nbf
fs=fk.keys()
gg=[fk[i] for i in fs]

for i in range(n):
    afacts[i]=[0]*nbf
    sfacts[i]=[0]*nbf
    ni=a[i]
    for j in range(nbf):
        nbfj=0
        while nbfj<fk[fs[j]] and ni%fs[j]==0:
            ni/=fs[j]
            nbfj+=1
        afacts[i][j]=nbfj
        sfacts[i][j]=sfacts[i-1][j]+nbfj

#OK now we want all the sfacts[n-y]-sfacts[x]>gg
x=0
y=n-1
vires=[0]*nbf
res=0
while x<n:
    virend=sfacts[n-y-1]
    OK=True
    for i in range(nbf):
        if virend[i]-vires[i]<gg[i]:
            OK=False
            break
    while not OK and y>0:
        y-=1
        OK=True
        virend=sfacts[n-y-1]
        for i in range(nbf):
            if virend[i]-vires[i]<gg[i]:
                OK=False
                break
   # print x,y,OK,y+1
    vires=sfacts[x]
    if not OK:
        break
  #print y+1
    res+=y+1
    x+=1
    y=min(y,n-x-1)

print res","['data structures', 'two pointers', 'binary search', 'number theory']"
"A country called Berland consists of n cities, numbered with integer numbers from 1 to n. Some of them are connected by bidirectional roads. Each road has some length. There is a path from each city to any other one by these roads. According to some Super Duper Documents, Berland is protected by the Super Duper Missiles. The exact position of the Super Duper Secret Missile Silos is kept secret but Bob managed to get hold of the information. That information says that all silos are located exactly at a distance l from the capital. The capital is located in the city with number s.The documents give the formal definition: the Super Duper Secret Missile Silo is located at some place (which is either city or a point on a road) if and only if the shortest distance from this place to the capital along the roads of the country equals exactly l.Bob wants to know how many missile silos are located in Berland to sell the information then to enemy spies. Help Bob.","from heapq import *

n,m,s=map(int,raw_input().split())
g=[[] for _ in range(n+1)]
for _ in range(m):
  u,v,w=map(int,raw_input().split())
  g[u].append((v,w))
  g[v].append((u,w))
l=input()
d=[10**10]*(n+1)
d[s]=0
q=[(0,s)]
while q:
  t,u=heappop(q)
  if t==d[u]:
    for v,w in g[u]:
      if d[v]>t+w:
        d[v]=t+w
        heappush(q,(d[v],v))

k=0
for u in xrange(1,n+1):
  for v,w in g[u]:
    if d[u]<l and d[u]+w>l:
      k+=2 if (l-d[u])+(l-d[v])<w else 1 if (l-d[u])+(l-d[v])==w else 0
print (k>>1)+d.count(l)","['data structures', 'graphs', 'dfs and similar', 'shortest paths']"
"Let's look at the following process: initially you have an empty stack and an array $$$s$$$ of the length $$$l$$$. You are trying to push array elements to the stack in the order $$$s_1, s_2, s_3, \dots s_{l}$$$. Moreover, if the stack is empty or the element at the top of this stack is not equal to the current element, then you just push the current element to the top of the stack. Otherwise, you don't push the current element to the stack and, moreover, pop the top element of the stack. If after this process the stack remains empty, the array $$$s$$$ is considered stack exterminable.There are samples of stack exterminable arrays:   $$$[1, 1]$$$;  $$$[2, 1, 1, 2]$$$;  $$$[1, 1, 2, 2]$$$;  $$$[1, 3, 3, 1, 2, 2]$$$;  $$$[3, 1, 3, 3, 1, 3]$$$;  $$$[3, 3, 3, 3, 3, 3]$$$;  $$$[5, 1, 2, 2, 1, 4, 4, 5]$$$; Let's consider the changing of stack more details if $$$s = [5, 1, 2, 2, 1, 4, 4, 5]$$$ (the top of stack is highlighted).   after pushing $$$s_1 = 5$$$ the stack turn into $$$[\textbf{5}]$$$;  after pushing $$$s_2 = 1$$$ the stack turn into $$$[5, \textbf{1}]$$$;  after pushing $$$s_3 = 2$$$ the stack turn into $$$[5, 1, \textbf{2}]$$$;  after pushing $$$s_4 = 2$$$ the stack turn into $$$[5, \textbf{1}]$$$;  after pushing $$$s_5 = 1$$$ the stack turn into $$$[\textbf{5}]$$$;  after pushing $$$s_6 = 4$$$ the stack turn into $$$[5, \textbf{4}]$$$;  after pushing $$$s_7 = 4$$$ the stack turn into $$$[\textbf{5}]$$$;  after pushing $$$s_8 = 5$$$ the stack is empty. You are given an array $$$a_1, a_2, \ldots, a_n$$$. You have to calculate the number of its subarrays which are stack exterminable.Note, that you have to answer $$$q$$$ independent queries.","# encoding: utf-8
from sys import stdin

def solve(a):

    # root node of tries denotes empty stack
    stack = [None]
    node_stack = [[1, {}]]
    trie = node_stack[-1]

    counter = 0
    for i in range(len(a)):
        el = a[i]

        if len(stack) == 0 or stack[-1] != el:

            current_node = node_stack[-1]
            stack.append(el)
            if el not in current_node[1]:
                current_node[1][el] = [0, {}]

            next_node = current_node[1][el]
            next_node[0] += 1
            node_stack.append(next_node)

        else:
            # just go up in trie
            stack.pop()
            node_stack.pop()
            node_stack[-1][0] += 1

        value = node_stack[-1][0]
        counter -= (((value - 1) * (value - 2)) // 2)
        counter += (((value) * (value - 1)) // 2)

    return counter


q = int(stdin.readline().strip())
for _ in range(q):
    n = int(stdin.readline().strip())
    a = [int(i) for i in stdin.readline().strip().split()]
    print(solve(a))","['data structures', 'dp']"
"You are playing a video game and you have just reached the bonus level, where the only possible goal is to score as many points as possible. Being a perfectionist, you've decided that you won't leave this level until you've gained the maximum possible number of points there.The bonus level consists of n small platforms placed in a line and numbered from 1 to n from left to right and (n - 1) bridges connecting adjacent platforms. The bridges between the platforms are very fragile, and for each bridge the number of times one can pass this bridge from one of its ends to the other before it collapses forever is known in advance.The player's actions are as follows. First, he selects one of the platforms to be the starting position for his hero. After that the player can freely move the hero across the platforms moving by the undestroyed bridges. As soon as the hero finds himself on a platform with no undestroyed bridge attached to it, the level is automatically ended. The number of points scored by the player at the end of the level is calculated as the number of transitions made by the hero between the platforms. Note that if the hero started moving by a certain bridge, he has to continue moving in the same direction until he is on a platform.Find how many points you need to score to be sure that nobody will beat your record, and move to the next level with a quiet heart.","n=input()
a=map(int,raw_input().split())
f=lambda:[[0,0] for _ in range(n)]
l=f()
for i in range(1,n):
  x=a[i-1]
  p,q=l[i-1]
  l[i][0]=(x-1)/2*2+1+max(p,q)
  if x>1:l[i][1]=x/2*2+q
r=f()
for i in range(n-2,-1,-1):
  x=a[i]
  p,q=r[i+1]
  r[i][0]=(x-1)/2*2+1+max(p,q)
  if x>1:r[i][1]=x/2*2+q
print max(map(lambda i:max(l[i])+max(r[i]), range(n)))",['dp']
"Students love to celebrate their holidays. Especially if the holiday is the day of the end of exams!Despite the fact that Igor K., unlike his groupmates, failed to pass a programming test, he decided to invite them to go to a cafe so that each of them could drink a bottle of... fresh cow milk. Having entered the cafe, the m friends found n different kinds of milk on the menu, that's why they ordered n bottles — one bottle of each kind. We know that the volume of milk in each bottle equals w.When the bottles were brought in, they decided to pour all the milk evenly among the m cups, so that each got a cup. As a punishment for not passing the test Igor was appointed the person to pour the milk. He protested that he was afraid to mix something up and suggested to distribute the drink so that the milk from each bottle was in no more than two different cups. His friends agreed but they suddenly faced the following problem — and what is actually the way to do it?Help them and write the program that will help to distribute the milk among the cups and drink it as quickly as possible!Note that due to Igor K.'s perfectly accurate eye and unswerving hands, he can pour any fractional amount of milk from any bottle to any cup.","#!/usr/bin/python3

n, w, m = map(int, input().split())

if n > m:
    print(""YES"")
    i = 0
    cur = w
    for j in range(m):
        milk = 0
        while milk < (w * n) / m - 1e-8:
            amount = min(cur, (w * n) / m - milk)
            print(i + 1, amount, end=' ')
            milk += amount
            cur -= amount
            if abs(cur) < 1e-8:
                i += 1
                cur = w
        print()
else:
    ans = [[] for i in range(m)]
    sums = [0 for i in range(m)]
    left = [w for i in range(n)]
    for i in range(m):
        while sums[i] < (w * n) / m - 1e-8:
            mx = 0
            for j in range(n):
                if left[j] > left[mx]:
                    mx = j
            amount = min(left[mx], (w * n) / m - sums[i])
            if left[mx] < w and amount < left[mx] - 1e-8:
                print(""NO"")
                exit(0)
            sums[i] += amount
            left[mx] -= amount
            ans[i].append((mx, amount))
    print(""YES"")
    for i in range(m):
        for a, b in ans[i]:
            print(a + 1, b, end=' ')
        print()","['greedy', 'math']"
"Wabbit is playing a game with $$$n$$$ bosses numbered from $$$1$$$ to $$$n$$$. The bosses can be fought in any order. Each boss needs to be defeated exactly once. There is a parameter called boss bonus which is initially $$$0$$$.When the $$$i$$$-th boss is defeated, the current boss bonus is added to Wabbit's score, and then the value of the boss bonus increases by the point increment $$$c_i$$$. Note that $$$c_i$$$ can be negative, which means that other bosses now give fewer points.However, Wabbit has found a glitch in the game. At any point in time, he can reset the playthrough and start a New Game Plus playthrough. This will set the current boss bonus to $$$0$$$, while all defeated bosses remain defeated. The current score is also saved and does not reset to zero after this operation. This glitch can be used at most $$$k$$$ times. He can reset after defeating any number of bosses (including before or after defeating all of them), and he also can reset the game several times in a row without defeating any boss.Help Wabbit determine the maximum score he can obtain if he has to defeat all $$$n$$$ bosses.","from sys import stdin
from itertools import repeat
def main():
    n, k = map(int, stdin.readline().split())
    a = map(int, stdin.readline().split(), repeat(10, n))
    a.sort(reverse=True)
    ans = s = 0
    for i, x in enumerate(a):
        ans += s
        s += x
        if s < 0:
            break
    else:
        print ans
        return
    m = n - i
    a[i] = s
    j = w = 0
    for i in xrange(m):
        ans += w * a[-i-1]
        j += 1
        if j > k:
            j = 0
            w += 1
    print ans
main()","['binary search', 'sortings', 'greedy']"
"You are a paparazzi working in Manhattan.Manhattan has $$$r$$$ south-to-north streets, denoted by numbers $$$1, 2,\ldots, r$$$ in order from west to east, and $$$r$$$ west-to-east streets, denoted by numbers $$$1,2,\ldots,r$$$ in order from south to north. Each of the $$$r$$$ south-to-north streets intersects each of the $$$r$$$ west-to-east streets; the intersection between the $$$x$$$-th south-to-north street and the $$$y$$$-th west-to-east street is denoted by $$$(x, y)$$$. In order to move from the intersection $$$(x,y)$$$ to the intersection $$$(x', y')$$$ you need $$$|x-x'|+|y-y'|$$$ minutes.You know about the presence of $$$n$$$ celebrities in the city and you want to take photos of as many of them as possible. More precisely, for each $$$i=1,\dots, n$$$, you know that the $$$i$$$-th celebrity will be at the intersection $$$(x_i, y_i)$$$ in exactly $$$t_i$$$ minutes from now (and he will stay there for a very short time, so you may take a photo of him only if at the $$$t_i$$$-th minute from now you are at the intersection $$$(x_i, y_i)$$$). You are very good at your job, so you are able to take photos instantaneously. You know that $$$t_i &lt; t_{i+1}$$$ for any $$$i=1,2,\ldots, n-1$$$.Currently you are at your office, which is located at the intersection $$$(1, 1)$$$. If you plan your working day optimally, what is the maximum number of celebrities you can take a photo of?","import sys
range = xrange
input = raw_input

inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

r = inp[ii]; ii += 1
n = inp[ii]; ii += 1

T = inp[ii + 0: ii + 3 * n: 3]
X = inp[ii + 1: ii + 3 * n: 3]
Y = inp[ii + 2: ii + 3 * n: 3]

big = 501
DP = [0] * n
DPmax = [0] * n

for i in range(n):
    x = X[i]
    y = Y[i]
    t = T[i]
    
    d = 0
    
    reachall = t - (max(x, big - x) + max(y, big - y))
    for j in reversed(range(i)):
        if T[j] <= reachall:
            d = max(d, DPmax[j])
            break
        if d < DP[j] and abs(x - X[j]) + abs(y - Y[j]) <= t - T[j]:
            d = DP[j]
    
    if d > 0 or abs(x - 1) + abs(y - 1) <= t:
        d += 1
    
    DP[i] = d
    DPmax[i] = max(d, DPmax[i - 1])

print DPmax[-1]",['dp']
"One day Vitaly was going home late at night and wondering: how many people aren't sleeping at that moment? To estimate, Vitaly decided to look which windows are lit in the house he was passing by at that moment.Vitaly sees a building of n floors and 2·m windows on each floor. On each floor there are m flats numbered from 1 to m, and two consecutive windows correspond to each flat. If we number the windows from 1 to 2·m from left to right, then the j-th flat of the i-th floor has windows 2·j - 1 and 2·j in the corresponding row of windows (as usual, floors are enumerated from the bottom). Vitaly thinks that people in the flat aren't sleeping at that moment if at least one of the windows corresponding to this flat has lights on.Given the information about the windows of the given house, your task is to calculate the number of flats where, according to Vitaly, people aren't sleeping.","n, m = [int(s) for s in input().split()]
c = 0
for i in range (n):
    a = [int(s) for s in input().split()]
    for j in range(m):
        if (a[2*j]+a[2*j+1]) != 0:
            c +=1
print(c)","['constructive algorithms', 'implementation']"
"The main city magazine offers its readers an opportunity to publish their ads. The format of the ad should be like this:There are space-separated non-empty words of lowercase and uppercase Latin letters.There are hyphen characters '-' in some words, their positions set word wrapping points. Word can include more than one hyphen. It is guaranteed that there are no adjacent spaces and no adjacent hyphens. No hyphen is adjacent to space. There are no spaces and no hyphens before the first word and after the last word. When the word is wrapped, the part of the word before hyphen and the hyphen itself stay on current line and the next part of the word is put on the next line. You can also put line break between two words, in that case the space stays on current line. Check notes for better understanding.The ad can occupy no more that k lines and should have minimal width. The width of the ad is the maximal length of string (letters, spaces and hyphens are counted) in it.You should write a program that will find minimal width of the ad.","k = input()
s = raw_input()
l = len(s)
s = s.replace(' ', '-')
ss = s.split('-')
last_word = ss[-1]
ss = [ss[i]+'.' for i in xrange(len(ss)-1)] + [last_word]


def check(max_w):
    lines = 0
    w = 0
    for word in ss:
        if len(word) > max_w:
            return False
        if w+len(word) > max_w:
            w = len(word)
            lines += 1
            if lines > k:
                return False
            continue
        if not w:
            lines += 1
        w += len(word)
    return w <= max_w

width = -1
left, right = 1, l
while left <= right:
    if left == right:
        width = left
        break
    elif left+1 == right:
        if check(left):
            width = left
        else:
            width = right
        break
    m = (left+right)/2
    if check(m):
        right = m
    else:
        left = m+1
print width","['binary search', 'greedy']"
"You are given $$$n$$$ objects. Each object has two integer properties: $$$val_i$$$ — its price — and $$$mask_i$$$. It is guaranteed that the sum of all prices is initially non-zero.You want to select a positive integer $$$s$$$. All objects will be modified after that. The $$$i$$$-th object will be modified using the following procedure:   Consider $$$mask_i$$$ and $$$s$$$ in binary notation,  Compute the bitwise AND of $$$s$$$ and $$$mask_i$$$ ($$$s \,\&amp;\, mask_i$$$),  If ($$$s \,\&amp;\, mask_i$$$) contains an odd number of ones, replace the $$$val_i$$$ with $$$-val_i$$$. Otherwise do nothing with the $$$i$$$-th object. You need to find such an integer $$$s$$$ that when the modification above is done the sum of all prices changes sign (if it was negative, it should become positive, and vice-versa; it is not allowed for it to become zero). The absolute value of the sum can be arbitrary.","import fileinput
def D(a):print(a)
def S(s,I):return int(s.split("" "")[I])
def bt(a):
    S=0
    while(a>0):
        S+=a%2
        a/=2
    return S;
def main():
    z=0
    N=0
    A=0
    B=0
    M=0
    S=0
    T=0
    for l in fileinput.input():
        z+=1
        if(z<2):
            N=int(l);
            A=[0]*N
            B=[0]*N
            M=[0]*N
            continue
        A[z-2]=int(l.split("" "")[0])
        M[z-2]=int(l.split("" "")[1])
    for i in A:S+=i
    if(S>0):
        for i in range(N):A[i]=-A[i]
    for i in range(N):B[i]=M[i].bit_length()-1
    for i in range(62):
        X=0
        for j in range(N):
            if(B[j]==i):
                if(bt(M[j]&T)%2==1):X-=A[j]
                else: X+=A[j]
        if(X<0):T|=1<<i
    D(T)
main()","['constructive algorithms', 'bitmasks']"
"There is a road with length $$$l$$$ meters. The start of the road has coordinate $$$0$$$, the end of the road has coordinate $$$l$$$.There are two cars, the first standing at the start of the road and the second standing at the end of the road. They will start driving simultaneously. The first car will drive from the start to the end and the second car will drive from the end to the start.Initially, they will drive with a speed of $$$1$$$ meter per second. There are $$$n$$$ flags at different coordinates $$$a_1, a_2, \ldots, a_n$$$. Each time when any of two cars drives through a flag, the speed of that car increases by $$$1$$$ meter per second.Find how long will it take for cars to meet (to reach the same coordinate).","for __ in range(int(input())):
    n,l=map(int,input().split())
    a=list(map(int,input().split()))
    a.insert(0,0)
    a.append(l)
    i,j,va,vb,pra,prb,ta,tb=1,n,1,1,0,l,0,0
    res,t=0,0
    while True:
        if abs(j-i)==0:
            res=1
        tempa=(a[i]-pra)/va
        tempb=(prb-a[j])/vb
        ta+=tempa
        tb+=tempb
        if ta<tb:
            tb-=tempb
            va+=1
            pra=a[i]
            i+=1
        elif ta>tb:
            ta-=tempa
            vb+=1
            prb=a[j]
            j-=1
        else:
            va+=1
            vb+=1
            pra=a[i]
            prb=a[j]
            i+=1
            j-=1
            if i>j:
                res=1
        if res:
            if ta>tb:
                prb-=(ta-tb)*vb
                print(ta+(abs(pra-prb)/(va+vb)))
            elif ta==tb:
                print(ta+(abs(pra-prb)/(va+vb)))
            else:
                pra+=(tb-ta)*va
                print(tb+(abs(pra-prb)/(va+vb)))
            break","['dp', 'two pointers', 'math', 'implementation', 'binary search']"
"To stay woke and attentive during classes, Karen needs some coffee!  Karen, a coffee aficionado, wants to know the optimal temperature for brewing the perfect cup of coffee. Indeed, she has spent some time reading several recipe books, including the universally acclaimed ""The Art of the Covfefe"".She knows n coffee recipes. The i-th recipe suggests that coffee should be brewed between li and ri degrees, inclusive, to achieve the optimal taste.Karen thinks that a temperature is admissible if at least k recipes recommend it.Karen has a rather fickle mind, and so she asks q questions. In each question, given that she only wants to prepare coffee with a temperature between a and b, inclusive, can you tell her how many admissible integer temperatures fall within the range?","n,k,q=map(int, raw_input().split())
dp=[0 for i in xrange(200005)]
sl=[0 for i in xrange(200005)]
for i in xrange(n):
	x,y=map(int, raw_input().split())
	dp[x]+=1
	dp[y+1]-=1
c=0
for i in xrange(200005):
	c+=dp[i]
	if c>=k:
		sl[i]=1
for i in xrange(1,200005):
	sl[i]=sl[i]+sl[i-1]
for i in xrange(q):
	x,y=map(int, raw_input().split())
	print sl[y]-sl[x-1]","['data structures', 'binary search', 'implementation']"
"Polycarp has to solve exactly $$$n$$$ problems to improve his programming skill before an important programming competition. But this competition will be held very soon, most precisely, it will start in $$$k$$$ days. It means that Polycarp has exactly $$$k$$$ days for training!Polycarp doesn't want to procrastinate, so he wants to solve at least one problem during each of $$$k$$$ days. He also doesn't want to overwork, so if he solves $$$x$$$ problems during some day, he should solve no more than $$$2x$$$ problems during the next day. And, at last, he wants to improve his skill, so if he solves $$$x$$$ problems during some day, he should solve at least $$$x+1$$$ problem during the next day.More formally: let $$$[a_1, a_2, \dots, a_k]$$$ be the array of numbers of problems solved by Polycarp. The $$$i$$$-th element of this array is the number of problems Polycarp solves during the $$$i$$$-th day of his training. Then the following conditions must be satisfied:   sum of all $$$a_i$$$ for $$$i$$$ from $$$1$$$ to $$$k$$$ should be $$$n$$$;  $$$a_i$$$ should be greater than zero for each $$$i$$$ from $$$1$$$ to $$$k$$$;  the condition $$$a_i &lt; a_{i + 1} \le 2 a_i$$$ should be satisfied for each $$$i$$$ from $$$1$$$ to $$$k-1$$$. Your problem is to find any array $$$a$$$ of length $$$k$$$ satisfying the conditions above or say that it is impossible to do it.","n, k = [int(x) for x in input().split()]
a = [i for i in range(1, k+1)]
s = (k*(k+1))//2
p = 0
if n == s:
    p = 0
elif n > s:
    if n - s == k:
        p = 0
        for i in range(k):
            a[i] += 1
    elif n - s > k:
        d = (n - s) // k
        for i in range(k):
            a[i] += d
        p = (n-s) - (d*k)
        for i in range(k-2, -1, -1):
            c = (2 * a[i]) - a[i+1]
            if p <= 0:
                break
            elif p >= c:
                a[i+1] += c
                p -= c
            elif p < c:
                a[i+1] += p
                p = 0
    elif n - s < k:
        p = n - s
        for i in range(k-2, -1, -1):
            c = (2 * a[i]) - a[i + 1]
            if p <= 0:
                break
            elif p >= c:
                a[i+1] += c
                p -= c
            elif p < c:
                a[i+1] += p
                p = 0
else:
    p = 1

if p <= 0:
    print('YES')
    for i in range(k):
        print(a[i], end=' ')
else:
    print('NO')","['constructive algorithms', 'greedy', 'math']"
"Vova decided to clean his room. The room can be represented as the coordinate axis $$$OX$$$. There are $$$n$$$ piles of trash in the room, coordinate of the $$$i$$$-th pile is the integer $$$p_i$$$. All piles have different coordinates.Let's define a total cleanup as the following process. The goal of this process is to collect all the piles in no more than two different $$$x$$$ coordinates. To achieve this goal, Vova can do several (possibly, zero) moves. During one move, he can choose some $$$x$$$ and move all piles from $$$x$$$ to $$$x+1$$$ or $$$x-1$$$ using his broom. Note that he can't choose how many piles he will move.Also, there are two types of queries:  $$$0$$$ $$$x$$$ — remove a pile of trash from the coordinate $$$x$$$. It is guaranteed that there is a pile in the coordinate $$$x$$$ at this moment.  $$$1$$$ $$$x$$$ — add a pile of trash to the coordinate $$$x$$$. It is guaranteed that there is no pile in the coordinate $$$x$$$ at this moment. Note that it is possible that there are zero piles of trash in the room at some moment.Vova wants to know the minimum number of moves he can spend if he wants to do a total cleanup before any queries. He also wants to know this number of moves after applying each query. Queries are applied in the given order. Note that the total cleanup doesn't actually happen and doesn't change the state of piles. It is only used to calculate the number of moves.For better understanding, please read the Notes section below to see an explanation for the first example.","from __future__ import print_function, division
from sys import stdin, stdout
import operator as op
from bisect import *
from itertools import chain, repeat, starmap
from functools import reduce


class SortedList():
    """"""Sorted list is a sorted mutable sequence.""""""
    DEFAULT_LOAD_FACTOR = 1000

    def __init__(self, iterable=None):
        """"""Initialize sorted list instance.""""""
        self._len = 0
        self._load = self.DEFAULT_LOAD_FACTOR
        self._lists = []
        self._maxes = []
        self._index = []
        self._offset = 0
        if iterable is not None:
            self.update(iterable)

    def clear(self):
        """"""Remove all values from sorted list.""""""
        self._len = 0
        del self._lists[:]
        del self._maxes[:]
        del self._index[:]
        self._offset = 0

    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _lists = self._lists
        _maxes = self._maxes
        if _maxes:
            pos = bisect_right(_maxes, value)
            if pos == len(_maxes):
                _lists[pos - 1].append(value)
                _maxes[pos - 1] = value
            else:
                insort(_lists[pos], value)
            self._expand(pos)
        else:
            _lists.append([value])
            _maxes.append(value)
        self._len += 1

    def _expand(self, pos):
        """"""Split sublists with length greater than double the load-factor.""""""
        _load = self._load
        _lists = self._lists
        _index = self._index

        if len(_lists[pos]) > (_load << 1):
            _maxes = self._maxes
            _lists_pos = _lists[pos]
            half = _lists_pos[_load:]
            del _lists_pos[_load:]
            _maxes[pos] = _lists_pos[-1]
            _lists.insert(pos + 1, half)
            _maxes.insert(pos + 1, half[-1])
            del _index[:]
        else:
            if _index:
                child = self._offset + pos
                while child:
                    _index[child] += 1
                    child = (child - 1) >> 1
                _index[0] += 1

    def update(self, iterable):
        """"""Update sorted list by adding all values from `iterable`.""""""
        _lists = self._lists
        _maxes = self._maxes
        values = sorted(iterable)

        if _maxes:
            if len(values) * 4 >= self._len:
                values.extend(chain.from_iterable(_lists))
                values.sort()
                self.clear()
            else:
                _add = self.add
                for val in values:
                    _add(val)
                return

        _load = self._load
        _lists.extend(values[pos:(pos + _load)] for pos in range(0, len(values), _load))
        _maxes.extend(sublist[-1] for sublist in _lists)
        self._len = len(values)
        del self._index[:]

    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _maxes = self._maxes
        pos = bisect_left(_maxes, value)
        if pos == len(_maxes):
            return False

        _lists = self._lists
        idx = bisect_left(_lists[pos], value)
        return _lists[pos][idx] == value

    def remove(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _maxes = self._maxes
        pos = bisect_left(_maxes, value)
        if pos == len(_maxes):
            return

        _lists = self._lists
        idx = bisect_left(_lists[pos], value)
        if _lists[pos][idx] == value:
            self._delete(pos, idx)

    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _maxes = self._maxes
        _index = self._index

        _lists_pos = _lists[pos]
        del _lists_pos[idx]
        self._len -= 1

        len_lists_pos = len(_lists_pos)
        if len_lists_pos > (self._load >> 1):
            _maxes[pos] = _lists_pos[-1]

            if _index:
                child = self._offset + pos
                while child > 0:
                    _index[child] -= 1
                    child = (child - 1) >> 1
                _index[0] -= 1
        elif len(_lists) > 1:
            if not pos:
                pos += 1
            prev = pos - 1
            _lists[prev].extend(_lists[pos])
            _maxes[prev] = _lists[prev][-1]
            del _lists[pos]
            del _maxes[pos]
            del _index[:]
            self._expand(prev)
        elif len_lists_pos:
            _maxes[pos] = _lists_pos[-1]
        else:
            del _lists[pos]
            del _maxes[pos]
            del _index[:]

    def _loc(self, pos, idx):
        """"""Convert an index pair (lists index, sublist index) into a single
        index number that corresponds to the position of the value in the
        sorted list.""""""
        if not pos:
            return idx

        _index = self._index
        if not _index:
            self._build_index()
        total = 0
        pos += self._offset
        while pos:
            if not pos & 1:
                total += _index[pos - 1]
            pos = (pos - 1) >> 1
        return total + idx

    def _pos(self, idx):
        """"""Convert an index into an index pair (lists index, sublist index)
        that can be used to access the corresponding lists position.""""""
        if idx < 0:
            last_len = len(self._lists[-1])
            if (-idx) <= last_len:
                return len(self._lists) - 1, last_len + idx
            idx += self._len
            if idx < 0:
                raise IndexError('list index out of range')
        elif idx >= self._len:
            raise IndexError('list index out of range')

        if idx < len(self._lists[0]):
            return 0, idx

        _index = self._index
        if not _index:
            self._build_index()

        pos = 0
        child = 1
        len_index = len(_index)
        while child < len_index:
            index_child = _index[child]
            if idx < index_child:
                pos = child
            else:
                idx -= index_child
                pos = child + 1
            child = (pos << 1) + 1
        return (pos - self._offset, idx)

    def _build_index(self):
        """"""Build a positional index for indexing the sorted list.""""""
        row0 = list(map(len, self._lists))
        if len(row0) == 1:
            self._index[:] = row0
            self._offset = 0
            return

        head = iter(row0)
        tail = iter(head)
        row1 = list(starmap(op.add, zip(head, tail)))
        if len(row0) & 1:
            row1.append(row0[-1])
        if len(row1) == 1:
            self._index[:] = row1 + row0
            self._offset = 1
            return

        size = 1 << (len(row1) - 1).bit_length()
        row1.extend(repeat(0, size - len(row1)))
        tree = [row0, row1]
        while len(tree[-1]) > 1:
            head = iter(tree[-1])
            tail = iter(head)
            row = list(starmap(op.add, zip(head, tail)))
            tree.append(row)
        reduce(list.__iadd__, reversed(tree), self._index)
        self._offset = size * 2 - 1

    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        if isinstance(index, slice):
            start, stop, step = index.indices(self._len)
            if step == 1 and start < stop:
                if start == 0 and stop == self._len:
                    return self.clear()
                elif self._len <= 8 * (stop - start):
                    values = self.__getitem__(slice(None, start))
                    if stop < self._len:
                        values += self.__getitem__(slice(stop, None))
                    self.clear()
                    return self.update(values)

            indices = range(start, stop, step)
            if step > 0:
                indices = reversed(indices)
            _pos, _delete = self._pos, self._delete
            for index in indices:
                pos, idx = _pos(index)
                _delete(pos, idx)
        else:
            pos, idx = self._pos(index)
            self._delete(pos, idx)

    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        _lists = self._lists

        if isinstance(index, slice):
            start, stop, step = index.indices(self._len)

            if step == 1 and start < stop:
                if start == 0 and stop == self._len:
                    return reduce(list.__iadd__, self._lists, [])

                start_pos, start_idx = self._pos(start)
                if stop == self._len:
                    stop_pos = len(_lists) - 1
                    stop_idx = len(_lists[stop_pos])
                else:
                    stop_pos, stop_idx = self._pos(stop)
                if start_pos == stop_pos:
                    return _lists[start_pos][start_idx:stop_idx]

                prefix = _lists[start_pos][start_idx:]
                middle = _lists[(start_pos + 1):stop_pos]
                result = reduce(list.__iadd__, middle, prefix)
                result += _lists[stop_pos][:stop_idx]
                return result

            if step == -1 and start > stop:
                result = self.__getitem__(slice(stop + 1, start + 1))
                result.reverse()
                return result

            indices = range(start, stop, step)
            return list(self.__getitem__(index) for index in indices)
        else:
            if self._len:
                if index == 0:
                    return _lists[0][0]
                elif index == -1:
                    return _lists[-1][-1]
            else:
                raise IndexError('list index out of range')

            if 0 <= index < len(_lists[0]):
                return _lists[0][index]

            len_last = len(_lists[-1])
            if -len_last < index < 0:
                return _lists[-1][len_last + index]

            pos, idx = self._pos(index)
            return _lists[pos][idx]

    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return chain.from_iterable(self._lists)

    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return chain.from_iterable(map(reversed, reversed(self._lists)))

    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len

    def bisect_left(self, value):
        """"""Return an index to insert `value` in the sorted list.""""""
        pos = bisect_left(self._maxes, value)
        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_left(self._lists[pos], value))

    def bisect_right(self, value):
        """"""Return an index to insert `value` in the sorted list.""""""
        pos = bisect_right(self._maxes, value)
        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_right(self._lists[pos], value))

    bisect = bisect_right

    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        _maxes = self._maxes
        if not _maxes:
            return 0

        pos_left = bisect_left(_maxes, value)
        if pos_left == len(_maxes):
            return 0

        _lists = self._lists
        idx_left = bisect_left(_lists[pos_left], value)
        pos_right = bisect_right(_maxes, value)
        if pos_right == len(_maxes):
            return self._len - self._loc(pos_left, idx_left)

        idx_right = bisect_right(_lists[pos_right], value)
        if pos_left == pos_right:
            return idx_right - idx_left

        right = self._loc(pos_right, idx_right)
        left = self._loc(pos_left, idx_left)
        return right - left

    def copy(self):
        """"""Return a shallow copy of the sorted list.""""""
        return self.__class__(self)

    __copy__ = copy

    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        if not self._len:
            raise IndexError('pop index out of range')

        _lists = self._lists
        if 0 <= index < len(_lists[0]):
            val = _lists[0][index]
            self._delete(0, index)
            return val

        len_last = len(_lists[-1])
        if -len_last < index < 0:
            pos = len(_lists) - 1
            loc = len_last + index
            val = _lists[pos][loc]
            self._delete(pos, loc)
            return val

        pos, idx = self._pos(index)
        val = _lists[pos][idx]
        self._delete(pos, idx)
        return val

    def index(self, value, start=0, stop=None):
        """"""Return first index of value in sorted list.""""""
        _len = self._len
        if start < 0:
            start += _len
        if start < 0:
            start = 0
        if stop is None:
            stop = _len
        if stop < 0:
            stop += _len
        if stop > _len:
            stop = _len

        if stop <= start:
            raise ValueError('{0!r} is not in list'.format(value))

        _maxes = self._maxes
        pos_left = bisect_left(_maxes, value)
        if pos_left == len(_maxes):
            raise ValueError('{0!r} is not in list'.format(value))

        _lists = self._lists
        idx_left = bisect_left(_lists[pos_left], value)
        if _lists[pos_left][idx_left] != value:
            raise ValueError('{0!r} is not in list'.format(value))

        stop -= 1
        left = self._loc(pos_left, idx_left)
        if start <= left:
            if left <= stop:
                return left
        else:
            if start <= self.bisect_right(value) - 1:
                return start
        raise ValueError('{0!r} is not in list'.format(value))

    def __add__(self, other):
        """"""Return new sorted list containing all values in both sequences.""""""
        values = reduce(list.__iadd__, self._lists, [])
        values.extend(other)
        return self.__class__(values)

    __radd__ = __add__

    def __iadd__(self, other):
        """"""Update sorted list with values from `other`.""""""
        self.update(other)
        return self

    def __mul__(self, num):
        """"""Return new sorted list with `num` shallow copies of values.""""""
        values = reduce(list.__iadd__, self._lists, []) * num
        return self.__class__(values)

    __rmul__ = __mul__

    def __imul__(self, num):
        """"""Update the sorted list with `num` shallow copies of values.""""""
        values = reduce(list.__iadd__, self._lists, []) * num
        self.clear()
        self.update(values)
        return self

    def __make_cmp(seq_op):
        ""Make comparator method.""

        def comparer(self, other):
            ""Compare method for sorted list and sequence.""
            self_len = self._len
            len_other = len(other)
            if self_len != len_other:
                if seq_op is op.eq:
                    return False
                if seq_op is op.ne:
                    return True

            for alpha, beta in zip(self, other):
                if alpha != beta:
                    return seq_op(alpha, beta)
            return seq_op(self_len, len_other)

        comparer.__name__ = '__{0}__'.format(seq_op.__name__)
        return comparer

    __eq__ = __make_cmp(op.eq)
    __ne__ = __make_cmp(op.ne)
    __lt__ = __make_cmp(op.lt)
    __gt__ = __make_cmp(op.gt)
    __le__ = __make_cmp(op.le)
    __ge__ = __make_cmp(op.ge)
    __make_cmp = staticmethod(__make_cmp)

    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(reduce(list.__iadd__, self._lists, []))


def fast2():
    import os, sys, atexit
    from cStringIO import StringIO as BytesIO
    # range = xrange
    sys.stdout = BytesIO()
    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))
    return BytesIO(os.read(0, os.fstat(0).st_size)).readline


input = fast2()
rints = lambda: [int(x) for x in input().split()]
rints_2d = lambda n: [rints() for _ in range(n)]
pr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\n')
solve = lambda: 0 if len(a) < 4 else a[-2] - a[0] - diff[-2]
bound = lambda x: (bisect_left(a, x) - 1, bisect_right(a, x))
out = []

n, m = rints()
a, qur = SortedList(rints() + [10 ** 9 + 2]), rints_2d(m)
diff = SortedList([10 ** 9 + 2])

for i in range(n - 1):
    diff.add(a[i + 1] - a[i])

out.append(solve())

for x, y in qur:
    lo, hi = bound(y)
    if x:
        if lo > -1:
            diff.add(y - a[lo])
        if hi != len(a) - 1:
            diff.add(a[hi] - y)
        if lo > -1 and hi != len(a) - 1:
            diff.remove(a[hi] - a[lo])
        a.add(y)
    else:
        if lo > -1:
            diff.remove(y - a[lo])
        if hi != len(a) - 1:
            diff.remove(a[hi] - y)
        if lo > -1 and hi != len(a) - 1:
            diff.add(a[hi] - a[lo])
        a.remove(y)

    out.append(solve())
pr(out, '\n')","['data structures', 'implementation']"
"As you very well know, the whole Universe traditionally uses three-dimensional Cartesian system of coordinates. In this system each point corresponds to three real coordinates (x, y, z). In this coordinate system, the distance between the center of the Universe and the point is calculated by the following formula: . Mushroom scientists that work for the Great Mushroom King think that the Universe isn't exactly right and the distance from the center of the Universe to a point equals xa·yb·zc.To test the metric of mushroom scientists, the usual scientists offered them a task: find such x, y, z (0 ≤ x, y, z; x + y + z ≤ S), that the distance between the center of the Universe and the point (x, y, z) is maximum possible in the metric of mushroom scientists. The mushroom scientists aren't good at maths, so they commissioned you to do the task.Note that in this problem, it is considered that 00 = 1.","a=int(input())
b=list(map(int,input().split()))
if sum(b)==0:print(' '.join([str(a/3)]*3))
else:print(' '.join(map(str,map(lambda x:a*x/sum(b),b))))","['ternary search', 'math']"
"You are given a sequence a1, a2, ..., an consisting of different integers. It is required to split this sequence into the maximum number of subsequences such that after sorting integers in each of them in increasing order, the total sequence also will be sorted in increasing order.Sorting integers in a subsequence is a process such that the numbers included in a subsequence are ordered in increasing order, and the numbers which are not included in a subsequence don't change their places.Every element of the sequence must appear in exactly one subsequence.","def binSearch(arr, el):
    if len(arr) == 0: return -1
    l, p = 0, len(arr)-1
    while l != p:
        s = (l+p) // 2
        if arr[s] < el:
            l = s + 1
        else:
            p = s
    return l if arr[l] == el else -1

n = int(input())
a = [int(i) for i in input().split()]
s = sorted(a)

subsList = []
visited = [False for i in range(n)]
for i in range(n):
    ind = i
    newSub = False
    while not visited[ind]:
        if not newSub:
            subsList.append([])
        newSub = True
        visited[ind] = True
        subsList[-1].append(str(ind+1))
        ind = binSearch(s, a[ind])
    
out = str(len(subsList)) + ""\n""
for lineNr in range(len(subsList)-1):
    
    out += str(len(subsList[lineNr])) + "" ""
    out += "" "".join(subsList[lineNr]) + ""\n""
out += str(len(subsList[-1])) + "" ""    
out += "" "".join(subsList[-1])
print(out)","['math', 'dsu', 'implementation', 'sortings', 'dfs and similar']"
"After all the events in Orlando we all know, Sasha and Roma decided to find out who is still the team's biggest loser. Thankfully, Masha found somewhere a revolver with a rotating cylinder of n bullet slots able to contain exactly k bullets, now the boys have a chance to resolve the problem once and for all. Sasha selects any k out of n slots he wishes and puts bullets there. Roma spins the cylinder so that every of n possible cylinder's shifts is equiprobable. Then the game starts, the players take turns, Sasha starts: he puts the gun to his head and shoots. If there was no bullet in front of the trigger, the cylinder shifts by one position and the weapon is given to Roma for make the same move. The game continues until someone is shot, the survivor is the winner. Sasha does not want to lose, so he must choose slots for bullets in such a way as to minimize the probability of its own loss. Of all the possible variant he wants to select the lexicographically minimal one, where an empty slot is lexicographically less than a charged one. More formally, the cylinder of n bullet slots able to contain k bullets can be represented as a string of n characters. Exactly k of them are ""X"" (charged slots) and the others are ""."" (uncharged slots). Let us describe the process of a shot. Suppose that the trigger is in front of the first character of the string (the first slot). If a shot doesn't kill anyone and the cylinder shifts, then the string shifts left. So the first character becomes the last one, the second character becomes the first one, and so on. But the trigger doesn't move. It will be in front of the first character of the resulting string.Among all the strings that give the minimal probability of loss, Sasha choose the lexicographically minimal one. According to this very string, he charges the gun. You have to help Sasha to charge the gun. For that, each xi query must be answered: is there a bullet in the positions xi?","#!/usr/bin/python

def query(n, k, x):
	if k == 0: return 0
	if k == n: return 1
	if n % 2 == 0:
		evens = max(2, n - 2*k + 2)
		odds = n + 1
		k -= n/2
		if k > 0:
			odds = n - 1 - 2*k + 2
		if x % 2 == 0:
			return int(x >= evens)
		else:
			return int(x >= odds)
	else:
		if x == n: return 1
		k -= 1
		evens = max(2, n - 1 - 2*k + 2)
		odds = n + 1
		k -= n/2
		if k > 0:
			odds = n - 2 - 2*k + 2
		if x % 2 == 0:
			return int(x >= evens)
		else:
			return int(x >= odds)

def solve():
	n, k, p = map(int, tuple(raw_input().split()))
	res = """"
	for i in xrange(p):
		x = int(raw_input())
		res += "".X""[query(n, k, x)]
	print res

solve()

#def testit():
	#for n in xrange(1, 10):
		#for k in xrange(0, n + 1):
			#res = """"
			#for i in xrange(1, n + 1):
				#res += "".X""[query(n, k, i)]
			#print n, k, res

#testit()",['math']
"An undirected graph is called k-regular, if the degrees of all its vertices are equal k. An edge of a connected graph is called a bridge, if after removing it the graph is being split into two connected components.Build a connected undirected k-regular graph containing at least one bridge, or else state that such graph doesn't exist.","k = int(input())
if k % 2 == 0:
    print('NO')
else:
    print('YES')
    reb = [[1, 2]]
    for v in range(3, k + 2):
        reb.append([1, v])
        reb.append([v, k + 2 * v - 4])
        reb.append([v, k + 2 * v - 3])
        reb.append([k + 2 * v - 4, k + 2 * v - 3])
        for u in range(v + 1, k + 2):
            if v + u != k + 4:
                reb.append([v, u])
            reb.append([k + 2 * v - 4, k + 2 * u - 4])
            reb.append([k + 2 * v - 3, k + 2 * u - 3])
    for v in range(3 * k, 4 * k - 1):
        reb.append([2, v])
        reb.append([v, 2 * v - 2 * k - 1])
        reb.append([v, 2 * v - 2 * k])
        reb.append([2 * v - 2 * k, 2 * v - 2 * k - 1])
        for u in range(v + 1, 4 * k - 1):
            if v + u != 7 * k - 2:
                reb.append([v, u])
            reb.append([2 * v - 2 * k, 2 * u - 2 * k])
            reb.append([2 * v - 2 * k - 1, 2 * u - 2 * k - 1])
    print(2 * (3 * k - 2), k * (3 * k - 2))
    for a, b in reb:
        print(a, b)","['constructive algorithms', 'implementation', 'graphs']"
"There is a game called ""I Wanna Be the Guy"", consisting of n levels. Little X and his friend Little Y are addicted to the game. Each of them wants to pass the whole game.Little X can pass only p levels of the game. And Little Y can pass only q levels of the game. You are given the indices of levels Little X can pass and the indices of levels Little Y can pass. Will Little X and Little Y pass the whole game, if they cooperate each other?","n=int(input())
p=[int(x) for x in input().split()]
p.pop(0)
q=[int(x) for x in input().split()]
q.pop(0)
s=set(p+q)
s.discard(0)
print([""Oh, my keyboard!"",""I become the guy.""][len(s)==n])","['implementation', 'greedy']"
"One day Polycarpus stopped by a supermarket on his way home. It turns out that the supermarket is having a special offer for stools. The offer is as follows: if a customer's shopping cart contains at least one stool, the customer gets a 50% discount on the cheapest item in the cart (that is, it becomes two times cheaper). If there are several items with the same minimum price, the discount is available for only one of them!Polycarpus has k carts, and he wants to buy up all stools and pencils from the supermarket. Help him distribute the stools and the pencils among the shopping carts, so that the items' total price (including the discounts) is the least possible.Polycarpus must use all k carts to purchase the items, no shopping cart can remain empty. Each shopping cart can contain an arbitrary number of stools and/or pencils.","n, k = map(int, raw_input().split())
a, b = [], []
for i in range(1, n + 1):
    c, t = map(int, raw_input().split())
    if t > 1: b.append((c, i))
    else: a.append((c, i))
if k > len(a):
    k -= len(a) + 1
    s = sum(c for c, i in a)
    print str(s / 2 + sum(c for c, i in b)) + ('.5' if s % 2 else '.0')
    print '\n'.join('1 ' + str(i) for c, i in a) 
    print '\n'.join('1 ' + str(i) for c, i in b[: k])
    print len(b) - k, ' '.join(str(i) for c, i in b[k: ]) 
else:
    k -= 1
    a.sort(reverse = True)
    s = sum(c for c, i in a[: k]) - (min(min(c for c, i in b), min(c for c, i in a[k: ])) if b else min(c for c, i in a[k: ]))
    print str(s / 2 + sum(c for c, i in a[k: ]) + sum(c for c, i in b)) + ('.5' if s % 2 else '.0')
    print '\n'.join('1 ' + str(i) for c, i in a[: k]) 
    print n - k, ' '.join(str(i) for c, i in a[k:]), ' '.join(str(i) for c, i in b)","['constructive algorithms', 'sortings', 'greedy']"
"Nastya received one more array on her birthday, this array can be used to play a traditional Byteland game on it. However, to play the game the players should first select such a subsegment of the array that , where p is the product of all integers on the given array, s is their sum, and k is a given constant for all subsegments. Nastya wonders how many subsegments of the array fit the described conditions. A subsegment of an array is several consecutive integers of the array.","from sys import stdin
import math
# stdin = open('in')

n, k = map(int, stdin.readline().split())
a = [int(x) for x in stdin.readline().split()]
nxt = [-1]*n
pref = []
f, s = -1, 0
for i in range(n):
	s += a[i]
	pref.append(s)
	nxt[n-1-i] = f
	if a[n-1-i] != 1:
		f = n-1-i
ans = 0
for i in range(n):
	pos, cur = i, 0
	prod = 1
	while 1:
		if prod > 1e18:
			break
		prod *= a[pos]
		cur += a[pos]
		if prod == k*cur:
			ans += 1
		nt = nxt[pos]
		if nt == -1:
			ones = n-1-pos
			if k*cur < prod and k*(cur+ones) >= prod and prod%k == 0:
				ans += 1
			break
		ones = nt - pos - 1
		if k*cur < prod and k*(cur+ones) >= prod and prod%k == 0:
			ans += 1
		cur += ones
		pos = nt
print(ans)","['implementation', 'brute force', 'math']"
"One player came to a casino and found a slot machine where everything depends only on how he plays. The rules follow.A positive integer $$$a$$$ is initially on the screen. The player can put a coin into the machine and then add $$$1$$$ to or subtract $$$1$$$ from any two adjacent digits. All digits must remain from $$$0$$$ to $$$9$$$ after this operation, and the leading digit must not equal zero. In other words, it is forbidden to add $$$1$$$ to $$$9$$$, to subtract $$$1$$$ from $$$0$$$ and to subtract $$$1$$$ from the leading $$$1$$$. Once the number on the screen becomes equal to $$$b$$$, the player wins the jackpot. $$$a$$$ and $$$b$$$ have the same number of digits.Help the player to determine the minimal number of coins he needs to spend in order to win the jackpot and tell how to play.","def main():
    n = int(input())
    a = list(map(int, (x for x in input())))
    b = list(map(int, (x for x in input())))
    x = [0] * (n - 1)
    x[0] = b[0] - a[0]
    for i in range(1, n - 1):
        x[i] = b[i] - a[i] - x[i - 1]
    if a[n - 1] + x[n - 2] != b[n - 1]:
        print(-1)
        return
    cnt = sum(map(abs, x))  # prevbug: ftl
    print(cnt)
    cnt = min(cnt, 10 ** 5)
    index = 0

    def handle_zero_nine(cur_zero):
        nonlocal cnt
        nxt = index + 1
        # cur_zero = True prevbug: preserved this line
        while True:
            if cur_zero and a[nxt + 1] != 9:
                break
            if not cur_zero and a[nxt + 1] != 0:
                break
            nxt += 1
            cur_zero = not cur_zero
        while nxt > index:
            if cnt == 0:
                break
            if cur_zero:
                print(nxt + 1, 1)
                a[nxt] += 1
                a[nxt + 1] += 1
            else:
                print(nxt + 1, -1)
                a[nxt] -= 1
                a[nxt + 1] -= 1
            nxt -= 1
            cnt -= 1
            # print(a)
            cur_zero = not cur_zero

    while cnt > 0:
        if a[index] == b[index]:
            index += 1
            continue
        elif a[index] > b[index] and a[index + 1] == 0:
            handle_zero_nine(True)
        elif a[index] < b[index] and a[index + 1] == 9:
            handle_zero_nine(False)
        elif a[index] > b[index]:
            print(index + 1, -1)
            a[index] -= 1
            a[index + 1] -= 1
            cnt -= 1
            # print(a)
        elif a[index] < b[index]:
            print(index + 1, 1)
            a[index] += 1
            a[index + 1] += 1
            cnt -= 1
            # print(a)


if __name__ == '__main__':
    main()","['constructive algorithms', 'implementation', 'greedy', 'math']"
"Polycarp has prepared $$$n$$$ competitive programming problems. The topic of the $$$i$$$-th problem is $$$a_i$$$, and some problems' topics may coincide.Polycarp has to host several thematic contests. All problems in each contest should have the same topic, and all contests should have pairwise distinct topics. He may not use all the problems. It is possible that there are no contests for some topics.Polycarp wants to host competitions on consecutive days, one contest per day. Polycarp wants to host a set of contests in such a way that:  number of problems in each contest is exactly twice as much as in the previous contest (one day ago), the first contest can contain arbitrary number of problems;  the total number of problems in all the contests should be maximized. Your task is to calculate the maximum number of problems in the set of thematic contests. Note, that you should not maximize the number of contests.","from collections import *
from math import *

def ch(mx):
	if(mx > n):
		return 0
	m = l[0]//(1<<(mx-1))
	for i in range(mx):
		m = min(m,l[i]//(1<<(mx-i-1)))
	return m*((1<<mx)-1)

n = int(input())
mx = ceil(log(n,2))
a = list(map(int,input().split()))
c = Counter(a)
l = list(c.values())
l.sort(reverse = True)
n = len(l)
ans = 1
for i in range(1,mx+1):
	ans = max(ans,ch(i))
print(ans)","['sortings', 'greedy']"
"You are given an unweighted tree with n vertices. Then n - 1 following operations are applied to the tree. A single operation consists of the following steps:   choose two leaves;  add the length of the simple path between them to the answer;  remove one of the chosen leaves from the tree. Initial answer (before applying operations) is 0. Obviously after n - 1 such operations the tree will consist of a single vertex. Calculate the maximal possible answer you can achieve, and construct a sequence of operations that allows you to achieve this answer!","import sys


def main():
    n = int(input())

    edges = list(map(int, sys.stdin.read().split()))
    tree_edges = dict()
    for i in range(n):
        tree_edges[i + 1] = set()

    for i in range(0, len(edges) - 1, 2):
        tree_edges[edges[i]].add(edges[i + 1])
        tree_edges[edges[i + 1]].add(edges[i])

    init_distants = [-1] * (n + 1)

    queue = [1]
    init_distants[1] = 0

    while queue:
        next_queue = []
        for process in queue:
            for next_vertex in tree_edges[process]:
                if init_distants[next_vertex] == -1:
                    init_distants[next_vertex] = init_distants[process] + 1
                    next_queue.append(next_vertex)
        queue = next_queue

    head = init_distants.index(max(init_distants))
    distants_from_head = [-1] * (n + 1)
    queue = [head]

    distants_from_head[head] = 0

    while queue:
        next_queue = []
        for process in queue:
            for next_vertex in tree_edges[process]:
                if distants_from_head[next_vertex] == -1:
                    distants_from_head[next_vertex] = distants_from_head[process] + 1
                    next_queue.append(next_vertex)
        queue = next_queue

    tail = distants_from_head.index(max(distants_from_head))
    distants_from_tail = [-1] * (n + 1)
    queue = [tail]

    distants_from_tail[tail] = 0

    while queue:
        next_queue = []
        for process in queue:
            for next_vertex in tree_edges[process]:
                if distants_from_tail[next_vertex] == -1:
                    distants_from_tail[next_vertex] = distants_from_tail[process] + 1
                    next_queue.append(next_vertex)
        queue = next_queue

    path_len_sum = 0
    removal_history = list()

    process_queue = []

    for vertex, adj in tree_edges.items():
        if len(adj) == 1:
            process_queue.append(vertex)

    while process_queue:
        next_queue = []

        for leaf in process_queue:

            if leaf == head or leaf == tail:
                continue

            if distants_from_tail[leaf] > distants_from_head[leaf]:
                path_len_sum += distants_from_tail[leaf]
                new_leaves = []

                for w in tree_edges[leaf]:
                    tree_edges[w].remove(leaf)
                    if len(tree_edges[w]) == 1:
                        new_leaves.append(w)
                next_queue.extend(new_leaves)
                removal_history.append(""{0} {1} {0}"".format(leaf, tail))
            else:
                path_len_sum += distants_from_head[leaf]
                new_leaves = []

                for w in tree_edges[leaf]:
                    tree_edges[w].remove(leaf)
                    if len(tree_edges[w]) == 1:
                        new_leaves.append(w)
                next_queue.extend(new_leaves)
                removal_history.append(""{0} {1} {0}"".format(leaf, head))
        process_queue = next_queue

    process_queue = [tail]

    while process_queue:
        leaf = process_queue[0]

        if leaf == head:
            continue

        path_len_sum += distants_from_head[leaf]
        new_leaves = []

        for w in tree_edges[leaf]:
            tree_edges[w].remove(leaf)
            if len(tree_edges[w]) == 1:
                new_leaves.append(w)
        process_queue = new_leaves
        removal_history.append(""{0} {1} {0}"".format(leaf, head))

    print(str(path_len_sum))
    sys.stdout.write(""\n"".join(removal_history))
    sys.stdout.write(""\n"")


main()","['greedy', 'graphs', 'constructive algorithms', 'dfs and similar', 'trees']"
"Barney lives in NYC. NYC has infinite number of intersections numbered with positive integers starting from 1. There exists a bidirectional road between intersections i and 2i and another road between i and 2i + 1 for every positive integer i. You can clearly see that there exists a unique shortest path between any two intersections.  Initially anyone can pass any road for free. But since SlapsGiving is ahead of us, there will q consecutive events happen soon. There are two types of events:1. Government makes a new rule. A rule can be denoted by integers v, u and w. As the result of this action, the passing fee of all roads on the shortest path from u to v increases by w dollars. 2. Barney starts moving from some intersection v and goes to intersection u where there's a girl he wants to cuddle (using his fake name Lorenzo Von Matterhorn). He always uses the shortest path (visiting minimum number of intersections or roads) between two intersections.Government needs your calculations. For each time Barney goes to cuddle a girl, you need to tell the government how much money he should pay (sum of passing fee of all roads he passes).","q = int(input())
ans = []
cost = {}

def getn(v, k = 1):
    res = []
    while k <= v:
        res.append(v)
        v //= 2
    return res

def getp(arr):
    res = []
    for i in range(len(arr) - 1):
        res.append((arr[i], arr[i + 1]))
    return res

def gets(u, v):
    resu, resv = getn(u), getn(v)
    for i in resv:
        if i in resu:
            return getp(getn(u, i)) + getp(getn(v, i))

for i in range(q):
    t, *p = map(int, input().split())
    u, v = p[0], p[1]
    if v < u:
        u, v = v, u

    path = gets(u, v)
    if t == 1:
        for rd in path:
            if rd in cost:
                cost[rd] += p[2]
            else:
                cost[rd] = p[2]
    else:
        tot = 0
        for rd in path:
            if rd in cost:
                tot += cost[rd]
        
        ans.append(tot)

print(""\n"".join(map(str, ans)))","['data structures', 'implementation', 'trees', 'brute force']"
"Something happened in Uzhlyandia again... There are riots on the streets... Famous Uzhlyandian superheroes Shean the Sheep and Stas the Giraffe were called in order to save the situation. Upon the arriving, they found that citizens are worried about maximum values of the Main Uzhlyandian Function f, which is defined as follows:In the above formula, 1 ≤ l &lt; r ≤ n must hold, where n is the size of the Main Uzhlyandian Array a, and |x| means absolute value of x. But the heroes skipped their math lessons in school, so they asked you for help. Help them calculate the maximum value of f among all possible values of l and r for the given array a.","n = int(input())
_l = list(map(int, input().split()))
l = [abs(_l[i] - _l[i + 1]) for i in range(n - 1)]
p, n, res = 0, 0, 0
for e in l:
    _p = max(0, n + e)
    _n = max(0, p - e)
    p, n = _p, _n
    res = max(p, n, res)
print(res)","['dp', 'two pointers']"
"Dima loves Inna very much. He decided to write a song for her. Dima has a magic guitar with n strings and m frets. Dima makes the guitar produce sounds like that: to play a note, he needs to hold one of the strings on one of the frets and then pull the string. When Dima pulls the i-th string holding it on the j-th fret the guitar produces a note, let's denote it as aij. We know that Dima's guitar can produce k distinct notes. It is possible that some notes can be produced in multiple ways. In other words, it is possible that aij = apq at (i, j) ≠ (p, q).Dima has already written a song — a sequence of s notes. In order to play the song, you need to consecutively produce the notes from the song on the guitar. You can produce each note in any available way. Dima understood that there are many ways to play a song and he wants to play it so as to make the song look as complicated as possible (try to act like Cobein).We'll represent a way to play a song as a sequence of pairs (xi, yi) (1 ≤ i ≤ s), such that the xi-th string on the yi-th fret produces the i-th note from the song. The complexity of moving between pairs (x1, y1) and (x2, y2) equals  + . The complexity of a way to play a song is the maximum of complexities of moving between adjacent pairs.Help Dima determine the maximum complexity of the way to play his song! The guy's gotta look cool!","def solution() : # 最大的距离来自于角落附近的点
	n,m,k,s = map(int, input().split())
	dis = lambda a,b : abs(a[0] - b[0]) + abs(a[1] - b[1])
	corner = [(0,0), (0,m-1), (n-1,0), (n-1,m-1)]
	vertex = [[(n,m), (n,-1), (-1,m), (-1,-1)] for _ in range(k+1)]
	for i in range(n) :
		for j,note in enumerate(map(int, input().split())) :
			vertex[note] = [
				(i,j) if dis((i,j), c) < dis(v, c) else v
				for v,c in zip(vertex[note], corner)]
	maxdis = [[-1] * (k+1) for _ in range(k+1)]
	pairs = [(0,3),(3,0),(1,2),(2,1)]
	for i in range(1, k+1) :
		for j in range(i, k+1) :
			vi,vj = vertex[i],vertex[j]
			maxdis[i][j] = max(dis(vi[a], vj[b]) for a,b in pairs)
			maxdis[j][i] = maxdis[i][j]
	s = list(map(int, input().split()))
	print(max(maxdis[s[i]][s[i+1]] for i in range(len(s) - 1)))
solution()","['implementation', 'brute force', 'math']"
"Fox Ciel and her friends are in a dancing room. There are n boys and m girls here, and they never danced before. There will be some songs, during each song, there must be exactly one boy and one girl are dancing. Besides, there is a special rule:  either the boy in the dancing pair must dance for the first time (so, he didn't dance with anyone before);  or the girl in the dancing pair must dance for the first time. Help Fox Ciel to make a schedule that they can dance as many songs as possible.","n, m = map(int, raw_input().split())
mu = []
fu = []
res = []
for i in range(1, n + 1):
    for j in range(1, m + 1):
        if i not in mu or j not in fu:
            res.append([i, j])
            mu.append(i)
            fu.append(j)

print len(res)
for i in res:
    print i[0], i[1]",['greedy']
"Bob has a rectangular chocolate bar of the size W × H. He introduced a cartesian coordinate system so that the point (0, 0) corresponds to the lower-left corner of the bar, and the point (W, H) corresponds to the upper-right corner. Bob decided to split the bar into pieces by breaking it. Each break is a segment parallel to one of the coordinate axes, which connects the edges of the bar. More formally, each break goes along the line x = xc or y = yc, where xc and yc are integers. It should divide one part of the bar into two non-empty parts. After Bob breaks some part into two parts, he breaks the resulting parts separately and independently from each other. Also he doesn't move the parts of the bar. Bob made n breaks and wrote them down in his notebook in arbitrary order. At the end he got n + 1 parts. Now he wants to calculate their areas. Bob is lazy, so he asks you to do this task.","WHn = [[0,0]]
# WHn[0].extend(list(map(int, input().split(' '))))
WHn[0].extend([int(x) for x in input().split(' ')])

n = range(WHn[0][-1])
lines = []
lines_aux = []

for i in n:
    lines.append( [int(x) for x in input().split(' ')] )
    lines_aux.append(True)

while any(lines_aux):
    
    for i in n:

        if lines_aux[i]:

            for unidad in WHn:

                rangex = range(unidad[0], unidad[2]+1)
                rangey = range(unidad[1], unidad[3]+1)
                
                if (lines[i][0] in rangex) and (lines[i][3] in rangey) and (lines[i][2] in rangex) and (lines[i][1] in rangey) and\
                    ( (lines[i][0:3:2] == unidad[0:3:2]) or (lines[i][1:4:2] == unidad[1:4:2]) ):

                    WHn.append([unidad[0],unidad[1],lines[i][2],lines[i][3]])
                    WHn.append([lines[i][0],lines[i][1],unidad[2],unidad[3]])
                    WHn.remove(unidad)
                    lines_aux[i] = False
                    break

for i,unidad in enumerate(WHn):
    WHn[i] = (unidad[2] - unidad[0])*(unidad[3] - unidad[1])

WHn.sort()
result = ''
for i in WHn:
    result += '{} '

print(result[:-1].format(*WHn))","['implementation', 'dfs and similar']"
"You have array a that contains all integers from 1 to n twice. You can arbitrary permute any numbers in a.Let number i be in positions xi, yi (xi &lt; yi) in the permuted array a. Let's define the value di = yi - xi — the distance between the positions of the number i. Permute the numbers in array a to minimize the value of the sum .","n=int(input())
A = [0] * (2*n)
per1 = 0
per2 = n
for i in range(1, n):
    if i % 2==1:
        A[per1] = i
        A[per1+n-i] = i
        per1+=1
    else:
        A[per2] = i
        A[per2+n-i] = i
        per2+=1

A[-1] = n
if n % 2 == 1:
    A[n//2] = n
else:
    A[-(n//2+1)] = n
print(' '.join(map(str, A)))",['constructive algorithms']
"You are given a weighted tree consisting of $$$n$$$ vertices. Recall that a tree is a connected graph without cycles. Vertices $$$u_i$$$ and $$$v_i$$$ are connected by an edge with weight $$$w_i$$$.You are given $$$m$$$ queries. The $$$i$$$-th query is given as an integer $$$q_i$$$. In this query you need to calculate the number of pairs of vertices $$$(u, v)$$$ ($$$u &lt; v$$$) such that the maximum weight of an edge on a simple path between $$$u$$$ and $$$v$$$ doesn't exceed $$$q_i$$$.","def find_ancestor(i, father):
    if father[i] == i:
        return i
    father[i] = find_ancestor(father[i], father)
    return father[i]

def connect(i, j, father, n_child):
    i_anc = find_ancestor(i, father)
    j_anc = find_ancestor(j, father)
    if n_child[i_anc] > n_child[j_anc]:
        n_child[i_anc] += n_child[j_anc]
        father[j_anc] = i_anc
    else:
        n_child[j_anc] += n_child[i_anc]
        father[i_anc] = j_anc

n, m = map(int, input().split())
edges = []
father = [i for i in range(n)]
n_child = [1]*n

for i in range(n-1):
    i, j, w = map(int, input().split())
    edges.append((i-1, j-1, w))

edges.sort(key=lambda x: -x[2])
queries = list(map(int, input().split()))

s_queries = sorted(queries)

# final map the index to the query
ans = {}

w_limit = []
ans_cum = 0
for query in s_queries:
    while len(edges) and edges[-1][2] <= query:
        i, j, w = edges[-1]
        edges.pop()
        i_anc = find_ancestor(i, father)
        j_anc = find_ancestor(j, father)
        # it's tree father may not be same
        ans_cum += n_child[i_anc] * n_child[j_anc]
        connect(i, j, father, n_child)
    ans[query] = ans_cum

print("" "".join(list(map(str, [ans[query] for query in queries]))))","['graphs', 'dsu', 'divide and conquer', 'sortings', 'trees']"
"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya wonders eagerly what minimum lucky number has the sum of digits equal to n. Help him cope with the task.","v = int(input())

y = v

count_4 = 0
count_7 = 0

while(y > 0):
	if (y % 7 == 0):
		count_7+=1
		y = y -7
	elif(y % 4 == 0):
		count_4+=1
		y = y - 4	
	else:
		count_7+=1
		y = y-7

total = (4*count_4 + 7 * count_7)

if (total == v):
	print((""4""*count_4) + ""7""*count_7)

else:
	print(-1)","['implementation', 'brute force']"
"This is an interactive problem. Remember to flush your output while communicating with the testing program. You may use fflush(stdout) in C++, system.out.flush() in Java, stdout.flush() in Python or flush(output) in Pascal to flush the output. If you use some other programming language, consult its documentation. You may also refer to the guide on interactive problems: https://codeforces.com/blog/entry/45307.You are given a string $$$t$$$ consisting of $$$n$$$ lowercase Latin letters. This string was cyphered as follows: initially, the jury had a string $$$s$$$ consisting of $$$n$$$ lowercase Latin letters. Then they applied a sequence of no more than $$$n$$$ (possibly zero) operations. $$$i$$$-th operation is denoted by two integers $$$a_i$$$ and $$$b_i$$$ ($$$1 \le a_i, b_i \le n$$$), and means swapping two elements of the string with indices $$$a_i$$$ and $$$b_i$$$. All operations were done in the order they were placed in the sequence. For example, if $$$s$$$ is xyz and $$$2$$$ following operations are performed: $$$a_1 = 1, b_1 = 2$$$; $$$a_2 = 2, b_2 = 3$$$, then after the first operation the current string is yxz, and after the second operation the current string is yzx, so $$$t$$$ is yzx.You are asked to restore the original string $$$s$$$. Unfortunately, you have no information about the operations used in the algorithm (you don't even know if there were any operations in the sequence). But you may run the same sequence of operations on any string you want, provided that it contains only lowercase Latin letters and its length is $$$n$$$, and get the resulting string after those operations.Can you guess the original string $$$s$$$ asking the testing system to run the sequence of swaps no more than $$$3$$$ times?The string $$$s$$$ and the sequence of swaps are fixed in each test; the interactor doesn't try to adapt the test to your solution.","t = [tmp for tmp in input().strip()]
n = len(t)

az = 'abcdefghijklmnopqrstuvwxyz'

s1 = [tmp for tmp in az] * (n // 26 + 1)
s1 = s1[:n]

s2 = []
for ch in az:
    s2 += [ch] * 26
s2 *= (n // 26 + 1)
s2 = s2[:n]

s3 = []
for ch in az:
    s3 += [ch] * 676
s3 *= (n // 676 + 1)
s3 = s3[:n]

print(""? "", *s1, sep='', flush=True)
t1 = input()
print(""? "", *s2, sep='', flush=True)
t2 = input()
print(""? "", *s3, sep='', flush=True)
t3 = input()

tc = []

orda = ord('a')
for i in range(n):
    m1 = ord(t1[i]) - orda
    m26 = ord(t2[i]) - orda
    m676 = ord(t3[i]) - orda
    tc.append(m676 * 676 + m26 * 26 + m1)

s = ['a'] * n
for pos2, pos1 in enumerate(tc):
    s[pos1] = t[pos2]

print(""! "", *s, sep='', flush=True)","['constructive algorithms', 'bitmasks', 'math', 'chinese remainder theorem', 'interactive']"
"You are given a binary matrix $$$a$$$ of size $$$n \times m$$$. A binary matrix is a matrix where each element is either $$$0$$$ or $$$1$$$.You may perform some (possibly zero) operations with this matrix. During each operation you can inverse the row of this matrix or a column of this matrix. Formally, inverting a row is changing all values in this row to the opposite ($$$0$$$ to $$$1$$$, $$$1$$$ to $$$0$$$). Inverting a column is changing all values in this column to the opposite.Your task is to sort the initial matrix by some sequence of such operations. The matrix is considered sorted if the array $$$[a_{1, 1}, a_{1, 2}, \dots, a_{1, m}, a_{2, 1}, a_{2, 2}, \dots, a_{2, m}, \dots, a_{n, m - 1}, a_{n, m}]$$$ is sorted in non-descending order.","rint = lambda: int(input())
rmint = lambda: map(int, input().split())
rlist = lambda: list(rmint())

n, m = rmint()
a = []
for i in range(n): a.append(rlist())
ax = []
for i in range(n): ax.append(0)
ay = []
for i in range(m): ay.append(0)


def inv(x,y): a[x][y] = 1 - a[x][y]
def invx(x):
    for y in range(m): inv(x,y)
    ax[x] = 1 - ax[x]
def invy(y):
    for x in range(n): inv(x,y)
    ay[y] = 1 - ay[y]
def ex():
    print(""YES"")
    for i in ax: print(i,end='')
    print()
    for i in ay: print(i,end='')
    exit(0)

if(n == 1):
    ay = a[0]
    ex()
def D(x,v):
    for y in range(m):
        if a[x][y] != v: invy(y)
    fx = -1; fy = -1
    for i in range(n):
        for j in range(m-1):
            if a[i][j] != a[i][j+1]:
                fx = i
                fy = j
    if fx < 0:
        for i in range(n):
            if a[i][0]: invx(i)
    else:
        if a[fx][fy] > a[fx][fy+1]: invx(fx)
        for i in range(fx):
            if a[i][0]: invx(i)
        for i in range(fx+1,n):
            if not a[i][0]: invx(i)
    srt = 1
    for i in range(n):
        for j in range(m):
            if i+1 == n and j+1 == m: break
            t = i*m + j + 1
            x = t // m
            y = t % m
            if a[x][y] < a[i][j]: srt = 0
    if srt: ex()
D(0, 0)
D(n-1, 1)
print(""NO"")","['constructive algorithms', 'brute force']"
"Vasya and Petya have invented a new game. Vasya takes a stripe consisting of 1 × n square and paints the squares black and white. After that Petya can start moves — during a move he may choose any two neighboring squares of one color and repaint these two squares any way he wants, perhaps in different colors. Petya can only repaint the squares in white and black colors. Petya’s aim is to repaint the stripe so that no two neighboring squares were of one color. Help Petya, using the given initial coloring, find the minimum number of moves Petya needs to win.","n=int(input())
a=input()
k=0
for i in range(len(a)):
    if (i%2==0 and a[i]=='0') or (i%2==1 and a[i]=='1'):
        k+=1
print(min(k,len(a)-k))","['dp', 'implementation', 'brute force']"
"Young wilderness explorers set off to their first expedition led by senior explorer Russell. Explorers went into a forest, set up a camp and decided to split into groups to explore as much interesting locations as possible. Russell was trying to form groups, but ran into some difficulties...Most of the young explorers are inexperienced, and sending them alone would be a mistake. Even Russell himself became senior explorer not long ago. Each of young explorers has a positive integer parameter $$$e_i$$$ — his inexperience. Russell decided that an explorer with inexperience $$$e$$$ can only join the group of $$$e$$$ or more people.Now Russell needs to figure out how many groups he can organize. It's not necessary to include every explorer in one of the groups: some can stay in the camp. Russell is worried about this expedition, so he asked you to help him.","from sys import stdin
from collections import deque
mod = 10**9 + 7
import sys
import random
# sys.setrecursionlimit(10**6)
from queue import PriorityQueue
# def rl():
#     return [int(w) for w in stdin.readline().split()]
from bisect import bisect_right
from bisect import bisect_left
from collections import defaultdict
from math import sqrt,factorial,gcd,log2,inf,ceil
# map(int,input().split())
# # l = list(map(int,input().split()))
# from itertools import permutations
import heapq
# input = lambda: sys.stdin.readline().rstrip()
input = lambda : sys.stdin.readline().rstrip()
from sys import stdin, stdout
from heapq import heapify, heappush, heappop
from itertools import permutations
from math import factorial as f
 
# def ncr(x, y):
#     return f(x) // (f(y) * f(x - y))
for i in range(10**5):
    pass
t=int(input())
for _ in range(t):
    n=int(input())
    a=list(map(int,input().split()))
    a=sorted(a)
    group=[]
    max_elem=-1
    i=0
    cnt=0
    while i<n:
        max_elem=a[i]
        temp=1
        i += 1
        while i<n and max_elem>temp:
            max_elem=max(a[i],max_elem)
            temp += 1
            i += 1
        if max_elem <=temp:
            cnt += 1
    print(cnt)","['dp', 'sortings', 'greedy']"
Vasya has a graph containing both directed (oriented) and undirected (non-oriented) edges. There can be multiple edges between a pair of vertices.Vasya has picked a vertex s from the graph. Now Vasya wants to create two separate plans:  to orient each undirected edge in one of two possible directions to maximize number of vertices reachable from vertex s;  to orient each undirected edge in one of two possible directions to minimize number of vertices reachable from vertex s. In each of two plans each undirected edge must become directed. For an edge chosen directions can differ in two plans.Help Vasya find the plans.,"I = lambda:map(int, raw_input().split())
n, m, s = I()
E = [I() for i in range(m)]
w = ['+'] * sum(a[0] == 2 for a in E)
e = [[] for i in range(n)]
v, s, p = [0] * n, s - 1, 0
for i in range(m):
	E[i][1] -= 1
	E[i][2] -= 1
	if E[i][0] == 2:
		e[E[i][1]].append([E[i][2], p * 2 + 1])
		e[E[i][2]].append([E[i][1], p * 2])
		p += 1
	else:
		e[E[i][1]].append([E[i][2], -1])
q, v[s] = [s], 1
while q:
	x = q.pop()
	for y in e[x]:
		if not v[y[0]]:
			v[y[0]] = 1
			q.append(y[0])
			if y[1] != -1:
				w[y[1] / 2] = ['-', '+'][y[1] % 2]
print sum(v)
print ''.join(w)
v = [0] * n
q, v[s] = [s], 1
while q:
	x = q.pop()
	for y in e[x]:
		if y[1] != -1:
			w[y[1] / 2] = ['+', '-'][y[1] % 2]
		elif not v[y[0]]:
			v[y[0]] = 1
			q.append(y[0])
			
print sum(v)
print ''.join(w)","['dfs and similar', 'graphs']"
"In Ancient Berland there were n cities and m two-way roads of equal length. The cities are numbered with integers from 1 to n inclusively. According to an ancient superstition, if a traveller visits three cities ai, bi, ci in row, without visiting other cities between them, a great disaster awaits him. Overall there are k such city triplets. Each triplet is ordered, which means that, for example, you are allowed to visit the cities in the following order: ai, ci, bi. Vasya wants to get from the city 1 to the city n and not fulfil the superstition. Find out which minimal number of roads he should take. Also you are required to find one of his possible path routes.","if __name__ =='__main__':
	n, m, k = map(int, input().split())
	graph = [[] for i in range(n + 2)]	
	for i in range(m):
		u, v = map(int, input().split())
		graph[u].append(v)
		graph[v].append(u)
	graph[n].append(n+1)
	
	processed =[[-1 for i in range(n+2)] for j in range(n+2)]
	forbid = set(a + (b+c*n)*n for (a,b,c) in (map(int, input().split()) for i in range(k)))
	bfsqueue =[(0,1)]
	processed[0][1] = 0
	
	while bfsqueue and processed[n][n+1] == -1:
		u,v = bfsqueue.pop(0)
		for key in graph[v]:
			if processed[v][key] != -1 or (u+ (v+key*n)*n in forbid):
				continue
			processed[v][key] = u
			if key == n+1:
				break
			bfsqueue.append((v,key))
	
	
	
	if processed[n][n+1] != -1:
		i, j = n,n+1
		ans = []
		while i:
			ans.append(i)
			i,j = processed[i][j],i
		print(len(ans) - 1)
		print(' '.join(map(str,reversed(ans))))
	else:
		print(-1)","['shortest paths', 'graphs']"
"n people are standing on a coordinate axis in points with positive integer coordinates strictly less than 106. For each person we know in which direction (left or right) he is facing, and his maximum speed.You can put a bomb in some point with non-negative integer coordinate, and blow it up. At this moment all people will start running with their maximum speed in the direction they are facing. Also, two strange rays will start propagating from the bomb with speed s: one to the right, and one to the left. Of course, the speed s is strictly greater than people's maximum speed.The rays are strange because if at any moment the position and the direction of movement of some ray and some person coincide, then the speed of the person immediately increases by the speed of the ray.You need to place the bomb is such a point that the minimum time moment in which there is a person that has run through point 0, and there is a person that has run through point 106, is as small as possible. In other words, find the minimum time moment t such that there is a point you can place the bomb to so that at time moment t some person has run through 0, and some person has run through point 106.","import math
leftpeople = set()
rightpeople = set()

n, vl = map(int, input().split())

def leftinterval(x0, v0, t):
    if x0 / v0 <= t:
        return (0, 10**6)
    if x0 / (vl + v0) > t:
        return (-1, -2)
    leftbound = x0
    rightbound = (vl * vl - v0 * v0) * t + x0 * v0
    rightbound /= vl
    rightbound = int(rightbound)
    if rightbound > 10**6:
        rightbound = 10**6
    return (leftbound, rightbound)
def rightinterval(x0, v0, t):
    if (10**6 - x0) / v0 <= t:
        return (0, 10**6)
    if (10**6 - x0) / (v0 + vl) > t:
        return (-1, -2)
    rightbound = x0
    leftbound = v0 * x0 + (10**6) * (vl - v0) - t * (vl * vl - v0 * v0)
    leftbound /= vl
    leftbound = math.ceil(leftbound)
    if(leftbound < 0):
        leftbound = 0
    return (leftbound, rightbound)

def check(t):
    events = []
    for item in leftpeople:
        temp = leftinterval(item[0], item[1], t)
        if(temp[0] > temp[1]):
            continue
        events.append((temp[0], 0, 0))
        events.append((temp[1], 1, 0))
        if(temp[1] - temp[0] == 10**6):
            break
    for item in rightpeople:
        temp = rightinterval(item[0], item[1], t)
        if(temp[0] > temp[1]):
            continue
        events.append((temp[0], 0, 1))
        events.append((temp[1], 1, 1))
        if(temp[1] - temp[0] == 10**6):
            break
    events.sort()
    opened = [0, 0]
    for item in events:
        color = item[2]
        action = item[1]
        if action == 0:
            if opened[(color + 1) % 2] > 0:
                return True
            opened[color] += 1
        else:
            opened[color] -= 1
    return False

for i in range(n):
    a, b, c = map(int, input().split())
    if c == 1:
        leftpeople.add((a, b))
    if c == 2:
        rightpeople.add((a, b))

l = 0
r = 1e9
for i in range(50):
    m = (l + r) / 2
    if(check(m)):
        r = m
    else:
        l = m

print(m)","['binary search', 'implementation', 'math']"
"You are given an array $$$a$$$ consisting of $$$n$$$ integers. You can perform the following operations with it:   Choose some positions $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n, i \ne j$$$), write the value of $$$a_i \cdot a_j$$$ into the $$$j$$$-th cell and remove the number from the $$$i$$$-th cell;  Choose some position $$$i$$$ and remove the number from the $$$i$$$-th cell (this operation can be performed no more than once and at any point of time, not necessarily in the beginning). The number of elements decreases by one after each operation. However, the indexing of positions stays the same. Deleted numbers can't be used in the later operations.Your task is to perform exactly $$$n - 1$$$ operations with the array in such a way that the only number that remains in the array is maximum possible. This number can be rather large, so instead of printing it you need to print any sequence of operations which leads to this maximum number. Read the output format to understand what exactly you need to print.","n = int(input())
a = list(map(int,input().split()))
hu = 0
humax = -float(""inf"")
huind = None
able = set(range(n))
ans = []
mae = -1
for i in range(n):
  if a[i] == 0:
      if mae == -1:
        mae = i
        able.discard(i)
      else:
        ans.append([1,mae+1,i+1])
        able.discard(i)
        mae = i
  if a[i]<0:
    hu +=1
    if a[i] > humax:
      humax =a[i]
      huind = i
if hu %2 == 1:
  if mae == -1:
    ans.append([2,huind+1])
    able.discard(huind)
    mae = huind
  else:
    ans.append([1,mae+1,huind+1])
    able.discard(huind)
    ans.append([2,huind+1])
    mae = huind
    if able == set():
      ans.pop(-2)
      able.add(0)
if a[mae] == 0:
  ans.append([2,mae+1])
if able == set():
  ans.pop()
mae = -1
for i in able:
  if mae == -1:
    mae = i
  else:
    ans.append([1,mae+1,i+1])
    mae = i
for i in ans:
  print(*i)","['constructive algorithms', 'greedy', 'math']"
"You are given a set of $$$n$$$ segments on the axis $$$Ox$$$, each segment has integer endpoints between $$$1$$$ and $$$m$$$ inclusive. Segments may intersect, overlap or even coincide with each other. Each segment is characterized by two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \le l_i \le r_i \le m$$$) — coordinates of the left and of the right endpoints. Consider all integer points between $$$1$$$ and $$$m$$$ inclusive. Your task is to print all such points that don't belong to any segment. The point $$$x$$$ belongs to the segment $$$[l; r]$$$ if and only if $$$l \le x \le r$$$.","l=list(map(int, input().split()))
I = []
for i in range(l[0]):
    k = list(map(int, input().split()))
    I.append(k)

def segment(l):
    return [int(i) for i in range(l[0],l[1]+1)]

def count_absent_point(l,I):
    main = []
    count_absent = 0
    absent_num =[]
    for i in I:
        for j in segment(i):
            main.append(j)
    Set = set(main)
    for i in range(1,l[1]+1):
        if i not in Set:
            count_absent += 1
            absent_num.append(i)
    if count_absent!=0:
        print(count_absent)
        print(' '.join([str(x) for x in absent_num]))
    else:
        print(0)

count_absent_point(l,I)",['implementation']
"There are $$$n$$$ cities in Berland. Some pairs of cities are connected by roads. All roads are bidirectional. Each road connects two different cities. There is at most one road between a pair of cities. The cities are numbered from $$$1$$$ to $$$n$$$.It is known that, from the capital (the city with the number $$$1$$$), you can reach any other city by moving along the roads.The President of Berland plans to improve the country's road network. The budget is enough to repair exactly $$$n-1$$$ roads. The President plans to choose a set of $$$n-1$$$ roads such that:  it is possible to travel from the capital to any other city along the $$$n-1$$$ chosen roads,  if $$$d_i$$$ is the number of roads needed to travel from the capital to city $$$i$$$, moving only along the $$$n-1$$$ chosen roads, then $$$d_1 + d_2 + \dots + d_n$$$ is minimized (i.e. as minimal as possible). In other words, the set of $$$n-1$$$ roads should preserve the connectivity of the country, and the sum of distances from city $$$1$$$ to all cities should be minimized (where you can only use the $$$n-1$$$ chosen roads).The president instructed the ministry to prepare $$$k$$$ possible options to choose $$$n-1$$$ roads so that both conditions above are met.Write a program that will find $$$k$$$ possible ways to choose roads for repair. If there are fewer than $$$k$$$ ways, then the program should output all possible valid ways to choose roads.","from math import inf

nmk = list(map(int, input().split(' ')))
n = nmk[0]
m = nmk[1]
k = nmk[2]

a = []

for i in range(m):
	a.append(list(map(int, input().split(' '))))

smej = [[] for j in range(n)]
nums = {}

t = 0
for i in a:
	nums.update({(i[0], i[1]):t})
	t += 1
	smej[i[0]-1].append(i[1]-1)
	smej[i[1]-1].append(i[0]-1)
	
dists = [inf for i in range(n)]
dists[0] = 0
q = [0]

while len(q) > 0:
	u = q.pop(0)
	
	for i in smej[u]:
		if (dists[i] == inf):
			q.append(i)
			dists[i] = dists[u] + 1
				
p = [[] for i in range(n)]
			
for i in range(1, n):
	for j in smej[i]:
		if(dists[j] == dists[i]-1):
			try:
				p[i].append(nums[(j+1,i+1)])
			except:
				p[i].append(nums[(i+1,j+1)])

am = 1
p.pop(0)

for i in range(len(p)):
	am *= len(p[i])

if(am < k):
	print(am)
else:
	print(k)

f = [0 for i in range(len(p))]
ans = []

for i in range(k):
	s = ['0'for i in range(m)]
	
	for j in range(len(p)):
		s[p[j][f[j]]] = '1'
	
	s = ''.join(s)
	ans.append(s)

	ok = False
	first = True
	
	for j in range(len(p)-1, -1, -1):
		if first:
			first = False
			if(f[j]+1 == len(p[j])):
				if(j == 0):
					ok = True
					break
				f[j] = 0
				f[j-1]+= 1
			else:
				f[j]+= 1
				break
		else:
			if(f[j] == len(p[j])):
				if(j == 0):
					ok = True
					break
				else:
					f[j] = 0
					f[j-1] += 1
	if ok:
		break

for j in range(len(ans)):
	print(ans[j])","['graphs', 'dfs and similar', 'brute force', 'shortest paths']"
"Mike and some bears are playing a game just for fun. Mike is the judge. All bears except Mike are standing in an n × m grid, there's exactly one bear in each cell. We denote the bear standing in column number j of row number i by (i, j). Mike's hands are on his ears (since he's the judge) and each bear standing in the grid has hands either on his mouth or his eyes.  They play for q rounds. In each round, Mike chooses a bear (i, j) and tells him to change his state i. e. if his hands are on his mouth, then he'll put his hands on his eyes or he'll put his hands on his mouth otherwise. After that, Mike wants to know the score of the bears.Score of the bears is the maximum over all rows of number of consecutive bears with hands on their eyes in that row.Since bears are lazy, Mike asked you for help. For each round, tell him the score of these bears after changing the state of a bear selected in that round.","from io import StringIO

import sys
data = sys.stdin

def score_line(row):
    score = 0
    max_score = 0
    combo = False
    for b in row:
        if b == 1:
            if combo:
                score += 1
            else:
                score = 1
                combo = True
        else:
            score = 0
            combo = False
        
        max_score = max(score, max_score)
    return max_score
        
rows = []

n, m, q = map(int, data.readline().split(' '))
for i in range(n):
    rows.append(list(map(int, data.readline().split(' '))))

row_scores = list(map(score_line, rows))
    
for i in range(q):
    r, c  = map(int, data.readline().split(' '))
    rows[r-1][c-1] = 1 - rows[r-1][c-1]
    row_scores[r-1] = score_line(rows[r-1])
    print(max(row_scores))","['dp', 'implementation', 'greedy', 'brute force']"
"This is the easy version of the problem. The difference between the versions is in the constraints on the array elements. You can make hacks only if all versions of the problem are solved.You are given an array $$$[a_1, a_2, \dots, a_n]$$$. Your goal is to find the length of the longest subarray of this array such that the most frequent value in it is not unique. In other words, you are looking for a subarray such that if the most frequent value occurs $$$f$$$ times in this subarray, then at least $$$2$$$ different values should occur exactly $$$f$$$ times.An array $$$c$$$ is a subarray of an array $$$d$$$ if $$$c$$$ can be obtained from $$$d$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.","n = int(input())
a = [int(x) for x in input().split()]

cnt = [0]*101

for x in a:
    cnt[x] += 1

maxFreq = max(cnt)
v = []
for i in range(101):
    if cnt[i] == maxFreq:
        v.append(i)

if len(v) > 1:
    print(n)

else:
    ans = 0

    for i in range(101):

        if i == v[0] or cnt[i] == 0:
            continue

        table = {0:-1}
        sum = 0

        for j in range(n):

            if a[j] == i:
                sum += 1

            if a[j] == v[0]:
                sum -= 1

            if sum in table:
                ind = table[sum]
                ans = max(ans , j-ind)
            else:
                table[sum] = j

    print(ans)","['data structures', 'greedy']"
"Polycarp invented a new way to encode strings. Let's assume that we have string T, consisting of lowercase English letters. Let's choose several pairs of letters of the English alphabet in such a way that each letter occurs in at most one pair. Then let's replace each letter in T with its pair letter if there is a pair letter for it. For example, if you chose pairs (l, r), (p, q) and (a, o), then word ""parallelogram"" according to the given encoding principle transforms to word ""qolorreraglom"".Polycarpus already has two strings, S and T. He suspects that string T was obtained after applying the given encoding method from some substring of string S. Find all positions mi in S (1 ≤ mi ≤ |S| - |T| + 1), such that T can be obtained fro substring SmiSmi + 1... Smi + |T| - 1 by applying the described encoding operation by using some set of pairs of English alphabet letters","raw_input()
ss = raw_input()
tt = raw_input()

def df(s):
    c = {}
    res = []
    for i, x in enumerate(s):
        res.append(i - c[x] if x in c else 0)
        c[x] = i
    return res

s = df(ss)
t = df(tt)
p = []
l = []
for i, x in enumerate(t):
    if not x:
        p.append(i)
        l.append(ord(tt[i]) - 97)
nt = len(l)

def prefix_func(s):
    pi = [0] * len(s)
    for i in xrange(1, len(s)):
        j = pi[i - 1]
        while j > 0 and not (s[i] == s[j] or (not s[j] and s[i] > j)):
            j = pi[j - 1]
        pi[i] = j + 1 if s[i] == s[j] or (not s[j] and s[i] > j) else j

    return pi

pi = prefix_func(t + [-1] + s)
n = len(t)
res = []
ss = [ord(x) - 97 for x in ss]

def check(pos):
    d = [-1] * 26
    for i in xrange(nt):
        j = p[i]
        x = ss[j + pos]
        y = l[i]
        if d[x] >= 0 and d[x] != y:
            return False
        if d[y] >= 0 and d[y] != x:
            return False
        d[x] = y
        d[y] = x
    return True

for i, x in enumerate(pi):
    j = i - 2 * n
    if x != n or not check(j):
        continue
    res.append(j + 1)
print len(res)
print ' '.join(map(str, res))","['hashing', 'string suffix structures', 'strings']"
"Ivan has got an array of n non-negative integers a1, a2, ..., an. Ivan knows that the array is sorted in the non-decreasing order. Ivan wrote out integers 2a1, 2a2, ..., 2an on a piece of paper. Now he wonders, what minimum number of integers of form 2b (b ≥ 0) need to be added to the piece of paper so that the sum of all integers written on the paper equalled 2v - 1 for some integer v (v ≥ 0). Help Ivan, find the required quantity of numbers.","input()
bits = {}
for i in map(int,raw_input().split()):
    j = i
    while j in bits and bits[j] == 1:
        bits[j] = 0
        j += 1
    bits[j] = 1
print max(bits) - sum(bits.values()) + 1","['implementation', 'greedy']"
Ivan places knights on infinite chessboard. Initially there are $$$n$$$ knights. If there is free cell which is under attack of at least $$$4$$$ knights then he places new knight in this cell. Ivan repeats this until there are no such free cells. One can prove that this process is finite. One can also prove that position in the end does not depend on the order in which new knights are placed.Ivan asked you to find initial placement of exactly $$$n$$$ knights such that in the end there will be at least $$$\lfloor \frac{n^{2}}{10} \rfloor$$$ knights.,"n = int(input())
ans = [(0, 0)]
for i in range(1, n):
    ans.append((0, i))
    ans.append((i, 0))
    ans.append((0, -i))
    ans.append((-i, 0))
for i in range(n):
    print(str(ans[i][0]) + ' ' + str(ans[i][1]))",['constructive algorithms']
"In this problem MEX of a certain array is the smallest positive integer not contained in this array.Everyone knows this definition, including Lesha. But Lesha loves MEX, so he comes up with a new problem involving MEX every day, including today.You are given an array $$$a$$$ of length $$$n$$$. Lesha considers all the non-empty subarrays of the initial array and computes MEX for each of them. Then Lesha computes MEX of the obtained numbers.An array $$$b$$$ is a subarray of an array $$$a$$$, if $$$b$$$ can be obtained from $$$a$$$ by deletion of several (possible none or all) elements from the beginning and several (possibly none or all) elements from the end. In particular, an array is a subarray of itself.Lesha understands that the problem is very interesting this time, but he doesn't know how to solve it. Help him and find the MEX of MEXes of all the subarrays!","from sys import stdin
def main():
    n = int(stdin.readline())
    a = map(int, stdin.readline().split())
    if all(x == 1 for x in a):
        print 1
        return
    N = 1 << 17
    b = [-1] * (N + N)
    p = [-1] * (n + 3)
    f = [0] * (n + 3)
    for i, x in enumerate(a):
        u = p[x]
        if not f[x] and i - u >= x:
            L, R = N + 1, N + x
            z = 1
            while L < R:
                if L & 1:
                    if b[L] <= u:
                        z = 0
                        break
                    L += 1
                if R & 1:
                    R -= 1
                    if b[R] <= u:
                        z = 0
                        break
                L /= 2
                R /= 2
            f[x] = z
        p[x] = i
        x += N
        b[x] = i
        while x > 1:
            x /= 2
            b[x] = b[x+x+1]
            if b[x] > b[x+x]:
                b[x] = b[x+x]
    for x in xrange(2, n + 2):
        u = p[x]
        if not f[x] and n - u >= x:
            L, R = N + 1, N + x
            z = 1
            while L < R:
                if L & 1:
                    if b[L] <= u:
                        z = 0
                        break
                    L += 1
                if R & 1:
                    R -= 1
                    if b[R] <= u:
                        z = 0
                        break
                L /= 2
                R /= 2
            f[x] = z
        if not f[x]:
            print x
            return
    print n + 2
main()","['data structures', 'two pointers', 'binary search']"
"This is an interactive problem.Chouti was tired of studying, so he opened the computer and started playing a puzzle game.Long long ago, the boy found a sequence $$$s_1, s_2, \ldots, s_n$$$ of length $$$n$$$, kept by a tricky interactor. It consisted of $$$0$$$s and $$$1$$$s only and the number of $$$1$$$s is $$$t$$$. The boy knows nothing about this sequence except $$$n$$$ and $$$t$$$, but he can try to find it out with some queries with the interactor.We define an operation called flipping. Flipping $$$[l,r]$$$ ($$$1 \leq l \leq r \leq n$$$) means for each $$$x \in [l,r]$$$, changing $$$s_x$$$ to $$$1-s_x$$$.In each query, the boy can give the interactor two integers $$$l,r$$$ satisfying $$$1 \leq l \leq r \leq n$$$ and the interactor will either flip $$$[1,r]$$$ or $$$[l,n]$$$ (both outcomes have the same probability and all decisions made by interactor are independent from each other, see Notes section for more details). The interactor will tell the current number of $$$1$$$s after each operation. Note, that the sequence won't be restored after each operation.Help the boy to find the original sequence in no more than $$$10000$$$ interactions.""Weird legend, dumb game."" he thought. However, after several tries, he is still stuck with it. Can you help him beat this game?","import sys
#import pdb
#pdb.set_trace()
def ask(l,r):
    print(""? %d %d""%(l,r))
    sys.stdout.flush()
    return int(input())

def reverse(l,r):
    for i in range(l,r+1):
        flipped[i]^=1

def flip(l,r,cur):
    global m
    while True:
        ones=0
        for i in range(l):
            ones+=flipped[i]^ans[i]
        expect=n-m-l+2*ones#expected 1s if the right segment will be flipped
        res=ask(l+1,r+1)
        if res==expect:
            reverse(l,n-1)
            m=res
        else:
            if l!=cur:
                ones+=flipped[l]^ans[l]
            if res==m-ones*2+cur-1:
                ans[cur]=1^flipped[cur]
            else:
                ans[cur]=flipped[cur]
            reverse(0,r)
            m=res
            break

n,m=map(int,input().split())
if n==1:
    print(""! %d""%m)
    sys.exit(0)
flipped=[0]*n
ans=[0]*n
if n%2==0:
    for i in range(n):
        flip(i,i,i)
    print(""! "",end="""")
    for i in range(n):
        print(ans[i],end="""")
    print("""")
    sys.stdout.flush()
else:
    while True:
        res=ask(2,n)
        if res+m==n:
            reverse(0,n-1)
            m=res
        else:
            reverse(1,n-1)
            if res==n-m+1:
                ans[0]=1^flipped[0]
            else:
                ans[0]=flipped[0]
            m=res
            break
    for i in range(n-1):
        flip(i,i+1,i+1)
    print(""! "", end="""")
    for i in range(n):
        print(ans[i],end="""")
    print("""")
    sys.stdout.flush()","['constructive algorithms', 'implementation', 'interactive']"
"After a long party Petya decided to return home, but he turned out to be at the opposite end of the town from his home. There are $$$n$$$ crossroads in the line in the town, and there is either the bus or the tram station at each crossroad.The crossroads are represented as a string $$$s$$$ of length $$$n$$$, where $$$s_i = \texttt{A}$$$, if there is a bus station at $$$i$$$-th crossroad, and $$$s_i = \texttt{B}$$$, if there is a tram station at $$$i$$$-th crossroad. Currently Petya is at the first crossroad (which corresponds to $$$s_1$$$) and his goal is to get to the last crossroad (which corresponds to $$$s_n$$$).If for two crossroads $$$i$$$ and $$$j$$$ for all crossroads $$$i, i+1, \ldots, j-1$$$ there is a bus station, one can pay $$$a$$$ roubles for the bus ticket, and go from $$$i$$$-th crossroad to the $$$j$$$-th crossroad by the bus (it is not necessary to have a bus station at the $$$j$$$-th crossroad). Formally, paying $$$a$$$ roubles Petya can go from $$$i$$$ to $$$j$$$ if $$$s_t = \texttt{A}$$$ for all $$$i \le t &lt; j$$$. If for two crossroads $$$i$$$ and $$$j$$$ for all crossroads $$$i, i+1, \ldots, j-1$$$ there is a tram station, one can pay $$$b$$$ roubles for the tram ticket, and go from $$$i$$$-th crossroad to the $$$j$$$-th crossroad by the tram (it is not necessary to have a tram station at the $$$j$$$-th crossroad). Formally, paying $$$b$$$ roubles Petya can go from $$$i$$$ to $$$j$$$ if $$$s_t = \texttt{B}$$$ for all $$$i \le t &lt; j$$$.For example, if $$$s$$$=""AABBBAB"", $$$a=4$$$ and $$$b=3$$$ then Petya needs:  buy one bus ticket to get from $$$1$$$ to $$$3$$$,  buy one tram ticket to get from $$$3$$$ to $$$6$$$,  buy one bus ticket to get from $$$6$$$ to $$$7$$$. Thus, in total he needs to spend $$$4+3+4=11$$$ roubles. Please note that the type of the stop at the last crossroad (i.e. the character $$$s_n$$$) does not affect the final expense.Now Petya is at the first crossroad, and he wants to get to the $$$n$$$-th crossroad. After the party he has left with $$$p$$$ roubles. He's decided to go to some station on foot, and then go to home using only public transport.Help him to choose the closest crossroad $$$i$$$ to go on foot the first, so he has enough money to get from the $$$i$$$-th crossroad to the $$$n$$$-th, using only tram and bus tickets.","#!/usr/bin/env python3
# -*- coding: utf-8 -*-
""""""
Created on Sun Mar 22 22:24:08 2020

@author: ethansoloway
""""""

def crossroad(a,b,p,string):
    current_price = 0
    ans = len(string)
    for i in range(len(string)-1,0,-1):
        if i == 1 or string[i-1] != string[i-2]:
            if string[i-1] == 'A':
                current_price += a
            else:
                current_price += b
            if current_price > p:
                return ans;
            else:
                ans = i
    return 1

t = int(input())
for j in range(t):
    a_t,b_t,p_t = map(int,input().split())
    string_t = input()
    print(crossroad(a_t,b_t,p_t,string_t))","['dp', 'binary search', 'greedy', 'strings']"
"Little Petya likes permutations a lot. Recently his mom has presented him permutation q1, q2, ..., qn of length n.A permutation a of length n is a sequence of integers a1, a2, ..., an (1 ≤ ai ≤ n), all integers there are distinct. There is only one thing Petya likes more than permutations: playing with little Masha. As it turns out, Masha also has a permutation of length n. Petya decided to get the same permutation, whatever the cost may be. For that, he devised a game with the following rules:  Before the beginning of the game Petya writes permutation 1, 2, ..., n on the blackboard. After that Petya makes exactly k moves, which are described below.  During a move Petya tosses a coin. If the coin shows heads, he performs point 1, if the coin shows tails, he performs point 2.  Let's assume that the board contains permutation p1, p2, ..., pn at the given moment. Then Petya removes the written permutation p from the board and writes another one instead: pq1, pq2, ..., pqn. In other words, Petya applies permutation q (which he has got from his mother) to permutation p.  All actions are similar to point 1, except that Petya writes permutation t on the board, such that: tqi = pi for all i from 1 to n. In other words, Petya applies a permutation that is inverse to q to permutation p. We know that after the k-th move the board contained Masha's permutation s1, s2, ..., sn. Besides, we know that throughout the game process Masha's permutation never occurred on the board before the k-th move. Note that the game has exactly k moves, that is, throughout the game the coin was tossed exactly k times.Your task is to determine whether the described situation is possible or else state that Petya was mistaken somewhere. See samples and notes to them for a better understanding.","def Solve(x,L):
    if(x==k[0]):
        return L==S
    
    if((x,tuple(L)) in Mem):
        return False
    if(L==S):
        return False
    E=[]
    for i in range(len(L)):
        E.append(L[Q[i]-1])
    if(Solve(x+1,E)):
        return True
    E=[0]*len(L)
    for i in range(len(L)):
        E[Q[i]-1]=L[i]
    if(Solve(x+1,E)):
        return True
    Mem[(x,tuple(L))]=1
    return False
Mem={}
k=[0]
n,k[0]=map(int,input().split())

P=list(range(1,n+1))
Q=list(map(int,input().split()))
S=list(map(int,input().split()))

if(Solve(0,P)):
    print(""YES"")
else:
    print(""NO"")","['combinatorics', 'implementation', 'brute force']"
"Toastman came up with a very easy task. He gives it to Appleman, but Appleman doesn't know how to solve it. Can you help him?Given a n × n checkerboard. Each cell of the board has either character 'x', or character 'o'. Is it true that each cell of the board has even number of adjacent cells with 'o'? Two cells of the board are adjacent if they share a side.","""""""Problem: http://codeforces.com/problemset/problem/462/A""""""

lines = int(input())

board = []
val = True

for i in range(0, lines):

	row = input().strip()
	board.append(row)

for i in range(0,lines):

	adjacent = 0

	for j in range(0, lines):

		if i < lines - 1:

			if board[i + 1][j] == 'o':
				adjacent += 1

		if i > 0:

			if board[i - 1][j] == 'o':
				adjacent += 1

		if j < lines - 1:

			if board[i][j + 1] == 'o':
				adjacent += 1

		if j > 0:

			if board[i][j - 1] == 'o':
				adjacent += 1
		
		if adjacent % 2 != 0:

			val = False
			break

if val:
	print(""YES"")
else:
	print(""NO"")","['implementation', 'brute force']"
"Everyone knows that long ago on the territory of present-day Berland there lived Bindian tribes. Their capital was surrounded by n hills, forming a circle. On each hill there was a watchman, who watched the neighbourhood day and night.In case of any danger the watchman could make a fire on the hill. One watchman could see the signal of another watchman, if on the circle arc connecting the two hills there was no hill higher than any of the two. As for any two hills there are two different circle arcs connecting them, the signal was seen if the above mentioned condition was satisfied on at least one of the arcs. For example, for any two neighbouring watchmen it is true that the signal of one will be seen by the other.An important characteristics of this watch system was the amount of pairs of watchmen able to see each other's signals. You are to find this amount by the given heights of the hills.","n = int(input())
hills = list(map(int, input().strip().split()))
max_height, pos_max_height = max((h, i) for i, h in enumerate(hills))
rotation_hill=(hills[pos_max_height:]+hills[:pos_max_height])[1:]
reference_height = max_height
reference_cost = 0
pairs = 0
reference_hills = []
for current_height in rotation_hill:
    while current_height > reference_height:
        pairs += reference_cost
        reference_height, reference_cost = reference_hills.pop()

    if current_height == reference_height:
        reference_cost += 1
        pairs += reference_cost
    else:
        pairs += 1
        reference_hills.append((reference_height, reference_cost))
        reference_height = current_height
        reference_cost = 1

reference_hills.append((reference_height, reference_cost))
start = 1 if reference_hills[0][1] else 2
pairs += sum(reference_hills[i][1] for i in range(start, len(reference_hills)))

print(pairs)",['data structures']
"Recall that string $$$a$$$ is a subsequence of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly zero or all) characters. For example, for the string $$$a$$$=""wowwo"", the following strings are subsequences: ""wowwo"", ""wowo"", ""oo"", ""wow"", """", and others, but the following are not subsequences: ""owoo"", ""owwwo"", ""ooo"".The wow factor of a string is the number of its subsequences equal to the word ""wow"". Bob wants to write a string that has a large wow factor. However, the ""w"" key on his keyboard is broken, so he types two ""v""s instead. Little did he realise that he may have introduced more ""w""s than he thought. Consider for instance the string ""ww"". Bob would type it as ""vvvv"", but this string actually contains three occurrences of ""w"":   ""vvvv""  ""vvvv""  ""vvvv"" For example, the wow factor of the word ""vvvovvv"" equals to four because there are four wows:  ""vvvovvv""  ""vvvovvv""  ""vvvovvv""  ""vvvovvv"" Note that the subsequence ""vvvovvv"" does not count towards the wow factor, as the ""v""s have to be consecutive.For a given string $$$s$$$, compute and output its wow factor. Note that it is not guaranteed that it is possible to get $$$s$$$ from another string replacing ""w"" with ""vv"". For example, $$$s$$$ can be equal to ""vov"".","s = input()
ws = []
i = 0
while i < len(s):
    cnt = 0
    while i < len(s) and s[i] == 'v' :
        cnt += 1
        i += 1
    if cnt != 0:
        ws += ['w'] * (cnt - 1)
    if i >= len(s):
        break
    ws.append('o')
    i += 1
W = 0
WO = 0
WOW = 0
for c in ws:
    if c == 'w':
        W += 1
        WOW += WO
    else:
        WO += W
print(WOW)","['dp', 'strings']"
"Vasya used to be an accountant before the war began and he is one of the few who knows how to operate a computer, so he was assigned as the programmer.We all know that programs often store sets of integers. For example, if we have a problem about a weighted directed graph, its edge can be represented by three integers: the number of the starting vertex, the number of the final vertex and the edge's weight. So, as Vasya was trying to represent characteristics of a recently invented robot in his program, he faced the following problem.Vasya is not a programmer, so he asked his friend Gena, what the convenient way to store n integers is. Gena used to code in language X-- and so he can use only the types that occur in this language. Let's define, what a ""type"" is in language X--:  First, a type is a string ""int"".  Second, a type is a string that starts with ""pair"", then followed by angle brackets listing exactly two comma-separated other types of language X--. This record contains no spaces.  No other strings can be regarded as types. More formally: type := int | pair&lt;type,type&gt;. For example, Gena uses the following type for graph edges: pair&lt;int,pair&lt;int,int&gt;&gt;.Gena was pleased to help Vasya, he dictated to Vasya a type of language X--, that stores n integers. Unfortunately, Gena was in a hurry, so he omitted the punctuation. Now Gena has already left and Vasya can't find the correct punctuation, resulting in a type of language X--, however hard he tries.Help Vasya and add the punctuation marks so as to receive the valid type of language X--. Otherwise say that the task is impossible to perform.","import sys
sys.stdin.readline()
ans=''
stk=[1]
for word in sys.stdin.readline().strip().split(' '):
	if not stk:
		stk=1
		break
	stk[-1]-=1
	ans+=','+word
	if word[0]=='p':
		stk.append(2)
		ans+='<'
	while stk and stk[-1]==0:
		stk.pop()
		ans+='>'
if stk:
	print('Error occurred')
else:
	print(ans.replace('<,','<')[1:-1])",['dfs and similar']
"ZS the Coder is playing a game. There is a number displayed on the screen and there are two buttons, ' + ' (plus) and '' (square root). Initially, the number 2 is displayed on the screen. There are n + 1 levels in the game and ZS the Coder start at the level 1.When ZS the Coder is at level k, he can :  Press the ' + ' button. This increases the number on the screen by exactly k. So, if the number on the screen was x, it becomes x + k. Press the '' button. Let the number on the screen be x. After pressing this button, the number becomes . After that, ZS the Coder levels up, so his current level becomes k + 1. This button can only be pressed when x is a perfect square, i.e. x = m2 for some positive integer m. Additionally, after each move, if ZS the Coder is at level k, and the number on the screen is m, then m must be a multiple of k. Note that this condition is only checked after performing the press. For example, if ZS the Coder is at level 4 and current number is 100, he presses the '' button and the number turns into 10. Note that at this moment, 10 is not divisible by 4, but this press is still valid, because after it, ZS the Coder is at level 5, and 10 is divisible by 5.ZS the Coder needs your help in beating the game — he wants to reach level n + 1. In other words, he needs to press the '' button n times. Help him determine the number of times he should press the ' + ' button before pressing the '' button at each level. Please note that ZS the Coder wants to find just any sequence of presses allowing him to reach level n + 1, but not necessarily a sequence minimizing the number of presses.","def main():
    n=int(input())
    print(2)
    for i in range(2,n+1):
        print(i*(i+1)**2-(i-1))

main()


'''
1=>2: 2->4     [2]
2=>3: 2->36    [17]
3=>4: 6->144   [46]
4=>5: 12->400  [97]
5=>6: 20->900  [176]
'''","['constructive algorithms', 'number theory', 'math']"
"On February, 30th n students came in the Center for Training Olympiad Programmers (CTOP) of the Berland State University. They came one by one, one after another. Each of them went in, and before sitting down at his desk, greeted with those who were present in the room by shaking hands. Each of the students who came in stayed in CTOP until the end of the day and never left.At any time any three students could join together and start participating in a team contest, which lasted until the end of the day. The team did not distract from the contest for a minute, so when another student came in and greeted those who were present, he did not shake hands with the members of the contest writing team. Each team consisted of exactly three students, and each student could not become a member of more than one team. Different teams could start writing contest at different times.Given how many present people shook the hands of each student, get a possible order in which the students could have come to CTOP. If such an order does not exist, then print that this is impossible.Please note that some students could work independently until the end of the day, without participating in a team contest.","n = int(input())
c = [[] for i in range(n)]
[c[int(x)].append(i + 1) for i, x in enumerate(input().split())]
s = 0; r = []
for i in range(n):
    while len(c[s]) == 0 and s >= 0: s -= 3
    if s < 0: print('Impossible'); break
    r += [c[s].pop()]; s += 1
else: print('Possible\n', *r)","['data structures', 'constructive algorithms', 'binary search', 'greedy']"
"You are given $$$n$$$ intervals in form $$$[l; r]$$$ on a number line.You are also given $$$m$$$ queries in form $$$[x; y]$$$. What is the minimal number of intervals you have to take so that every point (not necessarily integer) from $$$x$$$ to $$$y$$$ is covered by at least one of them? If you can't choose intervals so that every point from $$$x$$$ to $$$y$$$ is covered, then print -1 for that query.","from __future__ import division, print_function

DEBUG = 0

import os, sys
from atexit import register
from io import BytesIO
import itertools

if sys.version_info[0] < 3:
    input = raw_input
    range = xrange

    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip

if DEBUG:
    debug_print = print
else:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
    sys.stdout = BytesIO()
    register(lambda: os.write(1, sys.stdout.getvalue()))

    input = lambda: sys.stdin.readline().rstrip('\r\n')
    debug_print = lambda *x, **y: None


def input_as_list():
    return list(map(int, input().split()))

def array_of(f, *dim):
    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()

def build_binary_lifting_array(tree):
    """""" Tree is represented as parent of node n = tree[n].

        Parent of the root node should be -1.
    """"""

    def array_of(f, *dim):
        return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()

    size = len(tree)
    max_depth = size.bit_length()

    result = array_of(lambda:-1, max_depth, size)
    result[0] = list(tree)

    for depth in range(1, max_depth):
        for node in range(0, size):
            try:
                result[depth][node] = result[depth - 1][result[depth - 1][node]]
            except:
                pass

    return result

def main():
    n, m = input_as_list()
    segs = [input_as_list() for _ in range(n)]
    queries = [input_as_list() for _ in range(m)]

    MAX = 500001
    if DEBUG: MAX = 101

    endpoints = array_of(lambda: -1, MAX)
    for s, e in segs:
        endpoints[s] = max(endpoints[s], e)

    cur_max = -1
    for i, e in enumerate(endpoints):
        if cur_max <= i:
            cur_max = -1
        cur_max = max(cur_max, e)
        endpoints[i] = cur_max

    blt = build_binary_lifting_array(endpoints)
    debug_print(*blt, sep='\n')

    max_depth = len(blt)
    pow2 = [1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024,
            2048, 4096, 8192, 16384, 32768, 65536, 131072,
            262144, 524288]
    out = []
    for s, e in queries:
        cnt, depth = 0, 0

        while True:
            if blt[depth][s] == -1:
                if depth == 0:
                    if s < e: cnt = -1
                    break
                else:
                    s = blt[depth-1][s]
                    depth = 0
            elif blt[depth][s] == e:
                cnt += pow2[depth]
                break
            elif blt[depth][s] > e:
                if depth == 0:
                    cnt += 1
                    break
                else:
                    s = blt[depth-1][s]
                    depth = 0
            else:
                cnt += pow2[depth]
                if depth == max_depth-1:
                    s = blt[depth][s]
                    depth = 0
                else:
                    depth += 1

        out.append(str(cnt))

    print('\n'.join(out))

main()","['dp', 'greedy', 'implementation', 'divide and conquer', 'data structures', 'dfs and similar', 'trees']"
"Professor Ibrahim has prepared the final homework for his algorithm’s class. He asked his students to implement the Posterization Image Filter.Their algorithm will be tested on an array of integers, where the $$$i$$$-th integer represents the color of the $$$i$$$-th pixel in the image. The image is in black and white, therefore the color of each pixel will be an integer between 0 and 255 (inclusive).To implement the filter, students are required to divide the black and white color range [0, 255] into groups of consecutive colors, and select one color in each group to be the group’s key. In order to preserve image details, the size of a group must not be greater than $$$k$$$, and each color should belong to exactly one group.Finally, the students will replace the color of each pixel in the array with that color’s assigned group key.To better understand the effect, here is an image of a basking turtle where the Posterization Filter was applied with increasing $$$k$$$ to the right.   To make the process of checking the final answer easier, Professor Ibrahim wants students to divide the groups and assign the keys in a way that produces the lexicographically smallest possible array.","n, k = map(int, input().split())
P = map(int, input().split())

parent = list(range(256))
sz = [1] * 256
def rt(x):
    if x != parent[x]:
        parent[x] = rt(parent[x])
    return parent[x]

def u(rx, ry):
    parent[ry] = rx
    sz[rx] += sz[ry]

ans = [0] * n
for i, p in enumerate(P):
    rx = rt(p)
    while rx > 0 and sz[rx] + sz[rt(rx - 1)] <= k:        
        u(rt(rx - 1), rx)
        rx = rt(p)
    ans[i] = rt(p)
print(' '.join(map(str, ans)))","['greedy', 'games']"
"There are $$$n$$$ detachments on the surface, numbered from $$$1$$$ to $$$n$$$, the $$$i$$$-th detachment is placed in a point with coordinates $$$(x_i, y_i)$$$. All detachments are placed in different points.Brimstone should visit each detachment at least once. You can choose the detachment where Brimstone starts.To move from one detachment to another he should first choose one of four directions of movement (up, right, left or down) and then start moving with the constant speed of one unit interval in a second until he comes to a detachment. After he reaches an arbitrary detachment, he can repeat the same process.Each $$$t$$$ seconds an orbital strike covers the whole surface, so at that moment Brimstone should be in a point where some detachment is located. He can stay with any detachment as long as needed.Brimstone is a good commander, that's why he can create at most one detachment and place it in any empty point with integer coordinates he wants before his trip. Keep in mind that Brimstone will need to visit this detachment, too.Help Brimstone and find such minimal $$$t$$$ that it is possible to check each detachment. If there is no such $$$t$$$ report about it.","# import numpy as npy
import functools
import math

n=int(input())
x=[0 for i in range(n+2)]
y=[0 for i in range(n+2)]
adj=[[] for i in range(n+2)]
idx=[]
idy=[]
for i in range(n):
    x[i],y[i]=map(int,input().split())
    idx.append(i)
    idy.append(i)

def cmpx(a,b):
    if x[a]!=x[b]:
        if x[a]<x[b]:
            return -1
        else:
            return 1
    if y[a]!=y[b]:
        if y[a]<y[b]:
            return -1
        else:
            return 1
    return 0
    
def cmpy(a,b):
    if y[a]!=y[b]:
        if y[a]<y[b]:
            return -1
        else:
            return 1
    if x[a]!=x[b]:
        if x[a]<x[b]:
            return -1
        else:
            return 1
    return 0

idx=sorted(idx,key=functools.cmp_to_key(cmpx))
idy=sorted(idy,key=functools.cmp_to_key(cmpy))

# print(idx)
# print(idy)

def disx(a,b):
    if x[a]!=x[b]:
        return 1e18
    return y[b]-y[a]
    
def disy(a,b):
    if y[a]!=y[b]:
        return 1e18
    return x[b]-x[a]

l=0
r=2000000000
ans=-1

while l<=r:
    # print(l,r)
    mid=(l+r)//2
    for i in range(n):
        adj[i]=[]
    for i in range(n-1):
        if disx(idx[i],idx[i+1])<=mid:
            adj[idx[i]].append(idx[i+1])
            adj[idx[i+1]].append(idx[i])
            # print(idx[i],idx[i+1])
        if disy(idy[i],idy[i+1])<=mid:
            adj[idy[i]].append(idy[i+1])
            adj[idy[i+1]].append(idy[i])
            # print(idy[i],idy[i+1])
    col=[0 for i in range(n)]
    cur=0
    def dfs(x):
        col[x]=cur
        for i in range(len(adj[x])):
            if col[adj[x][i]]==0:
                dfs(adj[x][i])
    for i in range(n):
        if col[i]==0:
            cur=cur+1
            dfs(i)
    ok=0
    if cur>4:
        ok=0
    if cur==1:
        ok=1
    if cur==2:
        for i in range(n):
            for j in range(i+1,n):
                if (col[i]!=col[j]):
                    d1=abs(x[i]-x[j])
                    d2=abs(y[i]-y[j])
                    if d1==0 or d2==0:
                        if d1+d2<=2*mid:
                            ok=1
                    if d1<=mid and d2<=mid:
                        ok=1
    if cur==3:
        for i in range(n-1):
            px=idx[i]
            py=idx[i+1]
            if x[px]==x[py] and col[px]!=col[py]:
                for j in range(n):
                    if col[px]!=col[j] and col[py]!=col[j]:
                        d1=abs(y[px]-y[j])
                        d2=abs(y[py]-y[j])
                        d3=abs(x[px]-x[j])
                        if d1<=mid and d2<=mid and d3<=mid:
                            ok=1
        for i in range(n-1):
            px=idy[i]
            py=idy[i+1]
            if y[px]==y[py] and col[px]!=col[py]:
                for j in range(n):
                    if col[px]!=col[j] and col[py]!=col[j]:
                        d1=abs(x[px]-x[j])
                        d2=abs(x[py]-x[j])
                        d3=abs(y[px]-y[j])
                        if d1<=mid and d2<=mid and d3<=mid:
                            ok=1
    if cur==4:
        for i in range(n-1):
            px=idx[i]
            py=idx[i+1]
            if x[px]==x[py] and col[px]!=col[py]:
                for j in range(n-1):
                    pz=idy[j]
                    pw=idy[j+1]
                    if y[pz]==y[pw] and col[pz]!=col[pw]:
                        if col[pz]!=col[px] and col[pz]!=col[py]:
                            if col[pw]!=col[px] and col[pw]!=col[py]:
                                d1=abs(y[px]-y[pz])
                                d2=abs(y[py]-y[pz])
                                d3=abs(x[pz]-x[px])
                                d4=abs(x[pw]-x[px])
                                if d1<=mid and d2<=mid and d3<=mid and d4<=mid:
                                    ok=1
    if ok:
        ans=mid
        r=mid-1
    else:
        l=mid+1
print(ans)","['graphs', 'dsu', 'implementation', 'data structures', 'binary search', 'dfs and similar']"
"You are given a boolean function of three variables which is defined by its truth table. You need to find an expression of minimum length that equals to this function. The expression may consist of:   Operation AND ('&amp;', ASCII code 38)  Operation OR ('|', ASCII code 124)  Operation NOT ('!', ASCII code 33)  Variables x, y and z (ASCII codes 120-122)  Parentheses ('(', ASCII code 40, and ')', ASCII code 41) If more than one expression of minimum length exists, you should find the lexicographically smallest one.Operations have standard priority. NOT has the highest priority, then AND goes, and OR has the lowest priority. The expression should satisfy the following grammar:E ::= E '|' T | TT ::= T '&amp;' F | FF ::= '!' F | '(' E ')' | 'x' | 'y' | 'z'","table = ""!x&x x&y&z !z&x&y x&y !y&x&z x&z !y&x&z|!z&x&y (y|z)&x !y&!z&x !y&!z&x|x&y&z !z&x !z&x|x&y !y&x !y&x|x&z !(y&z)&x x !x&y&z y&z !x&y&z|!z&x&y (x|z)&y !x&y&z|!y&x&z (x|y)&z !x&y&z|!y&x&z|!z&x&y (x|y)&z|x&y !x&y&z|!y&!z&x !y&!z&x|y&z !x&y&z|!z&x !z&x|y&z !x&y&z|!y&x !y&x|y&z !(y&z)&x|!x&y&z x|y&z !x&!z&y !x&!z&y|x&y&z !z&y !z&y|x&y !x&!z&y|!y&x&z !x&!z&y|x&z !y&x&z|!z&y !z&y|x&z !(!x&!y|x&y|z) !(!x&!y|x&y|z)|x&y&z !z&(x|y) !z&(x|y)|x&y !x&!z&y|!y&x !x&!z&y|!y&x|x&z !y&x|!z&y !z&y|x !x&y !x&y|y&z !(x&z)&y y !x&y|!y&x&z !x&y|x&z !(x&z)&y|!y&x&z x&z|y !x&y|!y&!z&x !x&y|!y&!z&x|y&z !x&y|!z&x !z&x|y !x&y|!y&x !x&y|!y&x|x&z !(x&z)&y|!y&x x|y !x&!y&z !x&!y&z|x&y&z !x&!y&z|!z&x&y !x&!y&z|x&y !y&z !y&z|x&z !y&z|!z&x&y !y&z|x&y !(!x&!z|x&z|y) !(!x&!z|x&z|y)|x&y&z !x&!y&z|!z&x !x&!y&z|!z&x|x&y !y&(x|z) !y&(x|z)|x&z !y&z|!z&x !y&z|x !x&z !x&z|y&z !x&z|!z&x&y !x&z|x&y !(x&y)&z z !(x&y)&z|!z&x&y x&y|z !x&z|!y&!z&x !x&z|!y&!z&x|y&z !x&z|!z&x !x&z|!z&x|x&y !x&z|!y&x !y&x|z !(x&y)&z|!z&x x|z !(!y&!z|x|y&z) !(!y&!z|x|y&z)|x&y&z !x&!y&z|!z&y !x&!y&z|!z&y|x&y !x&!z&y|!y&z !x&!z&y|!y&z|x&z !y&z|!z&y !y&z|!z&y|x&y !(!x&!y|x&y|z)|!x&!y&z !(!x&!y|x&y|z)|!x&!y&z|x&y&z !x&!y&z|!z&(x|y) !x&!y&z|!z&(x|y)|x&y !x&!z&y|!y&(x|z) !x&!z&y|!y&(x|z)|x&z !y&(x|z)|!z&y !y&z|!z&y|x !x&(y|z) !x&(y|z)|y&z !x&z|!z&y !x&z|y !x&y|!y&z !x&y|z !(x&y)&z|!z&y y|z !x&(y|z)|!y&!z&x !x&(y|z)|!y&!z&x|y&z !x&(y|z)|!z&x !x&z|!z&x|y !x&(y|z)|!y&x !x&y|!y&x|z !x&y|!y&z|!z&x x|y|z !(x|y|z) !(x|y|z)|x&y&z !(!x&y|!y&x|z) !(x|y|z)|x&y !(!x&z|!z&x|y) !(x|y|z)|x&z !(!x&y|!y&x|z)|!y&x&z !(x|y|z)|(y|z)&x !y&!z !y&!z|x&y&z !(!x&y|z) !y&!z|x&y !(!x&z|y) !y&!z|x&z !(!x&y|z)|!y&x !y&!z|x !(!y&z|!z&y|x) !(x|y|z)|y&z !(!x&y|!y&x|z)|!x&y&z !(x|y|z)|(x|z)&y !(!x&z|!z&x|y)|!x&y&z !(x|y|z)|(x|y)&z !(!x&y|!y&x|z)|!x&y&z|!y&x&z !(x|y|z)|(x|y)&z|x&y !x&y&z|!y&!z !y&!z|y&z !(!x&y|z)|!x&y&z !(!x&y|z)|y&z !(!x&z|y)|!x&y&z !(!x&z|y)|y&z !(!x&y|z)|!x&y&z|!y&x !y&!z|x|y&z !x&!z !x&!z|x&y&z !(!y&x|z) !x&!z|x&y !x&!z|!y&x&z !x&!z|x&z !(!y&x|z)|!y&x&z !(!y&x|z)|x&z !(x&y|z) !(x&y|z)|x&y&z !z !z|x&y !x&!z|!y&x !(x&y|z)|x&z !y&x|!z !z|x !(!y&z|x) !x&!z|y&z !(!y&x|z)|!x&y !x&!z|y !(!y&z|x)|!y&x&z !(!y&z|x)|x&z !(!y&x|z)|!x&y|!y&x&z !x&!z|x&z|y !x&y|!y&!z !(x&y|z)|y&z !x&y|!z !z|y !(!x&!y&z|x&y) !x&!z|!y&x|y&z !x&y|!y&x|!z !z|x|y !x&!y !x&!y|x&y&z !x&!y|!z&x&y !x&!y|x&y !(!z&x|y) !x&!y|x&z !(!z&x|y)|!z&x&y !(!z&x|y)|x&y !(x&z|y) !(x&z|y)|x&y&z !x&!y|!z&x !(x&z|y)|x&y !y !y|x&z !y|!z&x !y|x !(!z&y|x) !x&!y|y&z !(!z&y|x)|!z&x&y !(!z&y|x)|x&y !(!z&x|y)|!x&z !x&!y|z !(!z&x|y)|!x&z|!z&x&y !x&!y|x&y|z !x&z|!y&!z !(x&z|y)|y&z !(!x&!z&y|x&z) !x&!y|!z&x|y&z !x&z|!y !y|z !x&z|!y|!z&x !y|x|z !(x|y&z) !(x|y&z)|x&y&z !x&!y|!z&y !(x|y&z)|x&y !x&!z|!y&z !(x|y&z)|x&z !(!y&!z&x|y&z) !x&!y|!z&y|x&z !((x|y)&z|x&y) !((x|y)&z|x&y)|x&y&z !x&!y|!z !x&!y|!z|x&y !x&!z|!y !x&!z|!y|x&z !y|!z !y|!z|x !x !x|y&z !x|!z&y !x|y !x|!y&z !x|z !x|!y&z|!z&y !x|y|z !x|!y&!z !x|!y&!z|y&z !x|!z !x|!z|y !x|!y !x|!y|z !(x&y&z) !x|x"".split()
n = int(input())
for i in range(n):
	print(table[int(input(), 2)])
exit(0)


E = set()
T = set()
F = set('xyz')
prv = 0
x = int('00001111', 2)
y = int('00110011', 2)
z = int('01010101', 2)
fam = 2 ** 8
tmpl = '#' * 99
ans = [tmpl] * fam

def cmpr(E):
    global ans
    ans = [tmpl] * fam
    for e in E:
        res = eval(e.replace('!', '~')) & (fam - 1)
        if len(ans[res]) > len(e) or len(ans[res]) == len(e) and ans[res] > e:
            ans[res] = e
    return set(ans) - {tmpl}

def cmpr3(E, T, F):
    return cmpr(E), cmpr(T), cmpr(F)

while prv != (E, T, F):
    prv = E.copy(), T.copy(), F.copy()
    for f in prv[2]:
        F.add('!' + f)
        T.add(f)
        for t in prv[1]:
            T.add(t + '&' + f)
    for t in prv[1]:
        E.add(t)
    for e in prv[0]:
        if e not in F:
            F.add('(' + e + ')')
        for t in prv[1]:
            E.add(e + '|' + t)
    E, T, F = cmpr3(E, T, F)

cmpr(E)

for f in ans:
    print(f)
    
print(ans.count(tmpl), fam - ans.count(tmpl))","['dp', 'bitmasks', 'shortest paths']"
"You are given an image, that can be represented with a 2-d n by m grid of pixels. Each pixel of the image is either on or off, denoted by the characters ""0"" or ""1"", respectively. You would like to compress this image. You want to choose an integer k &gt; 1 and split the image into k by k blocks. If n and m are not divisible by k, the image is padded with only zeros on the right and bottom so that they are divisible by k. Each pixel in each individual block must have the same value. The given image may not be compressible in its current state. Find the minimum number of pixels you need to toggle (after padding) in order for the image to be compressible for some k. More specifically, the steps are to first choose k, then the image is padded with zeros, then, we can toggle the pixels so it is compressible for this k. The image must be compressible in that state.","from sys import stdin as fin
# fin = open(""ih2e2017a.in"", ""r"")
# fout = open(""ih2e2017a.in"", ""a"")

# for i in range(2500):
#     for j in range(2500):
#         print('1' if (i % 2) == (j % 2) else '0', end='', file=fout)
#     print(file=fout)


def check(x, y):
    if x < 0 or y < 0:
        return 0
    else:
        return d[x][y]

def check2(x, y):
    if x < 0 or y < 0:
        return 0
    else:
        return d[min(x, n - 1)][min(y, m - 1)]

def border(a, b):
    d, m = divmod(a, b)
    return b * (d + (m != 0))


# print('lol')
n, m = map(int, fin.readline().split())
# field = tuple(fin.readline().strip() for i in range(n))
field = fin.readlines()
# print(""inp"")
# print(len(field), len(field[0]))
d = [[None] * m for i in range(n)]
d[0][0] = int(field[0][0]) #field[0][0]
for i in range(n):
    for j in range(m):
        d[i][j] = check(i - 1, j) + check(i, j - 1) - check(i - 1, j - 1) + int(field[i][j])# field[i][j]

minv = float('inf')
for k in range(2, max(n, m)):
    cv = 0
    # print(k)
    for i in range(k - 1, border(n, k), k):
        for j in range(k - 1, border(m, k), k):
            ccnt = check2(i, j) - check2(i - k, j) - check2(i, j - k) + check2(i - k, j - k)
            cv += min(ccnt, k**2 - ccnt)
    minv = min(minv, cv)

print(minv)

fin.close()",['brute force']
"Let's call beauty of an array $$$b_1, b_2, \ldots, b_n$$$ ($$$n &gt; 1$$$)  — $$$\min\limits_{1 \leq i &lt; j \leq n} |b_i - b_j|$$$.You're given an array $$$a_1, a_2, \ldots a_n$$$ and a number $$$k$$$. Calculate the sum of beauty over all subsequences of the array of length exactly $$$k$$$. As this number can be very large, output it modulo $$$998244353$$$.A sequence $$$a$$$ is a subsequence of an array $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements.","from collections import defaultdict
import sys
input = sys.stdin.readline
'''
for CASES in range(int(input())):
n, m = map(int, input().split())
n = int(input())
A = list(map(int, input().split()))
S = input().strip()
sys.stdout.write("" "".join(map(str,ans))+""\n"")
'''
inf = 100000000000000000  # 1e17
mod = 998244353

n, m = map(int, input().split())
A = [0] + sorted(list(map(int, input().split())))

ans = 0

f = [[0] * (n + 10) for _ in range(m + 10)]

for x in range(1,(A[n] - A[1]) // (m - 1) + 1):
    for i in range(1, n + 1):
        f[1][i] = 1
    for i in range(2, m + 1):
        sum = 0
        pre = 1
        for j in range(1, n + 1):
            while pre <= n and A[pre] + x <= A[j]:
                sum += f[i - 1][pre]
                sum %= mod
                pre += 1
            f[i][j] = sum
    for i in range(1, n + 1):
        ans += f[m][i]
        ans %= mod
print(ans)


# the end",['dp']
"Gildong is experimenting with an interesting machine Graph Traveler. In Graph Traveler, there is a directed graph consisting of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th vertex has $$$m_i$$$ outgoing edges that are labeled as $$$e_i[0]$$$, $$$e_i[1]$$$, $$$\ldots$$$, $$$e_i[m_i-1]$$$, each representing the destination vertex of the edge. The graph can have multiple edges and self-loops. The $$$i$$$-th vertex also has an integer $$$k_i$$$ written on itself.A travel on this graph works as follows.   Gildong chooses a vertex to start from, and an integer to start with. Set the variable $$$c$$$ to this integer.  After arriving at the vertex $$$i$$$, or when Gildong begins the travel at some vertex $$$i$$$, add $$$k_i$$$ to $$$c$$$.  The next vertex is $$$e_i[x]$$$ where $$$x$$$ is an integer $$$0 \le x \le m_i-1$$$ satisfying $$$x \equiv c \pmod {m_i}$$$. Go to the next vertex and go back to step 2. It's obvious that a travel never ends, since the 2nd and the 3rd step will be repeated endlessly.For example, assume that Gildong starts at vertex $$$1$$$ with $$$c = 5$$$, and $$$m_1 = 2$$$, $$$e_1[0] = 1$$$, $$$e_1[1] = 2$$$, $$$k_1 = -3$$$. Right after he starts at vertex $$$1$$$, $$$c$$$ becomes $$$2$$$. Since the only integer $$$x$$$ ($$$0 \le x \le 1$$$) where $$$x \equiv c \pmod {m_i}$$$ is $$$0$$$, Gildong goes to vertex $$$e_1[0] = 1$$$. After arriving at vertex $$$1$$$ again, $$$c$$$ becomes $$$-1$$$. The only integer $$$x$$$ satisfying the conditions is $$$1$$$, so he goes to vertex $$$e_1[1] = 2$$$, and so on.Since Gildong is quite inquisitive, he's going to ask you $$$q$$$ queries. He wants to know how many distinct vertices will be visited infinitely many times, if he starts the travel from a certain vertex with a certain value of $$$c$$$. Note that you should not count the vertices that will be visited only finite times.","import io, sys
input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()
LCM = 2520

n = int(input())
k = list(map(int, input().split()))
m, e = [], []
for _ in range(n):
    m.append(int(input()))
    e.append(list(map(int, input().split())))

nxt = []
for i in range(n):
    for j in range(LCM):
        x = (j + k[i]) % LCM
        y = e[i][x % m[i]] - 1
        nxt.append(y * LCM + x)

mark = [-1] * (n * LCM)
loop = [None] * (n * LCM)
for i in range(n * LCM):
    if loop[i]: continue
    start = cur = i
    rec = []
    while True:
        if mark[cur] != -1:
            break
        mark[cur] = i
        rec.append(cur)
        cur = nxt[cur]
    if loop[cur]:
        for u in rec:
            loop[u] = loop[cur]
    else:
        uniq = set()
        inloop = 0
        for u in rec:
            loop[u] = uniq
            if u == cur:
                inloop = 1
            if inloop:
                uniq.add(u // LCM)

out = []
for _ in range(int(input())):
    x, y = map(int, input().split())
    out.append(len(loop[(x - 1) * LCM + y % LCM]))
print(*out, sep='\n')","['dp', 'graphs', 'number theory', 'math', 'implementation', 'data structures', 'dfs and similar', 'brute force']"
"Andrew and Jerry are playing a game with Harry as the scorekeeper. The game consists of three rounds. In each round, Andrew and Jerry draw randomly without replacement from a jar containing n balls, each labeled with a distinct positive integer. Without looking, they hand their balls to Harry, who awards the point to the player with the larger number and returns the balls to the jar. The winner of the game is the one who wins at least two of the three rounds.Andrew wins rounds 1 and 2 while Jerry wins round 3, so Andrew wins the game. However, Jerry is unhappy with this system, claiming that he will often lose the match despite having the higher overall total. What is the probability that the sum of the three balls Jerry drew is strictly higher than the sum of the three balls Andrew drew?","n , m = input() , map(int,raw_input().split())
a = {}
for i in xrange(n-1):
	for j in xrange(i+1,n):
		x = abs(m[i]-m[j])
		if x in a:
			a[x]+=1
		else:
			a[x]=1

d = [i for i in a]
b = [0]*10005
for i in xrange(len(d)):
	for j in xrange(i,len(d)):
		if d[i]==d[j]:
			b[d[i]+d[j]] += a[d[i]]*a[d[j]]
 		else:
			b[d[i]+d[j]] += a[d[i]]*a[d[j]]*2

for i in xrange(1,len(b)): b[i]=b[i]+b[i-1]
ans=0
for i in xrange(n-1):
	for j in xrange(i+1,n):
		ans+=b[abs(m[i]-m[j])-1]

den = (n*(n-1)/2)**3
print ans/float(den)","['dp', 'combinatorics', 'probabilities', 'brute force']"
"As the boat drifts down the river, a wood full of blossoms shows up on the riverfront.""I've been here once,"" Mino exclaims with delight, ""it's breathtakingly amazing.""""What is it like?""""Look, Kanno, you've got your paintbrush, and I've got my words. Have a try, shall we?"" There are four kinds of flowers in the wood, Amaranths, Begonias, Centaureas and Dianthuses.The wood can be represented by a rectangular grid of $$$n$$$ rows and $$$m$$$ columns. In each cell of the grid, there is exactly one type of flowers.According to Mino, the numbers of connected components formed by each kind of flowers are $$$a$$$, $$$b$$$, $$$c$$$ and $$$d$$$ respectively. Two cells are considered in the same connected component if and only if a path exists between them that moves between cells sharing common edges and passes only through cells containing the same flowers.You are to help Kanno depict such a grid of flowers, with $$$n$$$ and $$$m$$$ arbitrarily chosen under the constraints given below. It can be shown that at least one solution exists under the constraints of this problem.Note that you can choose arbitrary $$$n$$$ and $$$m$$$ under the constraints below, they are not given in the input.","a, b, c, d = map(int, input().split())
res = [['A'] * 50 for i in range(25)] + [['B'] * 50 for i in range(25)]
a, b = a - 1, b - 1
for i in range(0, 24, 2):
    for j in range(0, 50, 2):
        if b > 0:
            b -= 1
            res[i][j] = 'B'
        elif c > 0:
            c -= 1
            res[i][j] = 'C'
        elif d > 0:
            d -= 1
            res[i][j] = 'D'
        if a > 0:
            a -= 1
            res[i + 26][j] = 'A'
print(50, 50)
for i in res:
    print(*i, sep='')","['constructive algorithms', 'graphs']"
"Valera considers a number beautiful, if it equals 2k or -2k for some integer k (k ≥ 0). Recently, the math teacher asked Valera to represent number n as the sum of beautiful numbers. As Valera is really greedy, he wants to complete the task using as few beautiful numbers as possible. Help Valera and find, how many numbers he is going to need. In other words, if you look at all decompositions of the number n into beautiful summands, you need to find the size of the decomposition which has the fewest summands.","t = input()
j = t[0]
d, s = 0, int(j)
for i in t[1: ]:
    if j != i:
        if d == 1: d, s = 0, s + 1
        else: d = 1
        j = i
    else: d = 1
print(s + (d and j == '1'))","['dp', 'greedy', 'number theory', 'games']"
"Alice and Bob got very bored during a long car trip so they decided to play a game. From the window they can see cars of different colors running past them. Cars are going one after another.The game rules are like this. Firstly Alice chooses some color A, then Bob chooses some color B (A ≠ B). After each car they update the number of cars of their chosen color that have run past them. Let's define this numbers after i-th car cntA(i) and cntB(i).  If cntA(i) &gt; cntB(i) for every i then the winner is Alice.  If cntB(i) ≥ cntA(i) for every i then the winner is Bob.  Otherwise it's a draw. Bob knows all the colors of cars that they will encounter and order of their appearance. Alice have already chosen her color A and Bob now wants to choose such color B that he will win the game (draw is not a win). Help him find this color.If there are multiple solutions, print any of them. If there is no such color then print -1.","n,A = map(int,input().split())
c = list(map(int,input().split()))

cc1 = list(set(c))


if A not in c:
    print(c[0])
else:
    cc1 = set(c)
    cc = {}
    for elem in cc1:
        cc.update({elem:0})
        
    for i in range(len(c)):
        cc[c[i]]+=1
        if cc[c[i]]<=cc[A] and c[i]!=A:
            cc[c[i]] = -5000
    
    p = 0
    
    for el in cc1:
        if el!=A and cc[el]>=cc[A]:
            print(el)
            p = 1
            break
        
    if p==0:
        print(-1)","['data structures', 'implementation']"
"Recall that the bracket sequence is considered regular if it is possible to insert symbols '+' and '1' into it so that the result is a correct arithmetic expression. For example, a sequence ""(()())"" is regular, because we can get correct arithmetic expression insering symbols '+' and '1': ""((1+1)+(1+1))"". Also the following sequences are regular: ""()()()"", ""(())"" and ""()"". The following sequences are not regular bracket sequences: "")("", ""(()"" and ""())(()"".In this problem you are given two integers n and k. Your task is to construct a regular bracket sequence consisting of round brackets with length 2·n with total sum of nesting of all opening brackets equals to exactly k. The nesting of a single opening bracket equals to the number of pairs of brackets in which current opening bracket is embedded.For example, in the sequence ""()(())"" the nesting of first opening bracket equals to 0, the nesting of the second opening bracket equals to 0 and the nesting of the third opening bracket equal to 1. So the total sum of nestings equals to 1.","s = raw_input()
n = int(s.split()[0])
k = int(s.split()[1])
res = ''

sum = 0
level = 0
opened = 0

while level > -1:
	if sum + level <= k and opened < n:
		sum = sum + level
		res = res + '('
		opened = opened + 1
		level = level + 1;
	else:
		if level > 0:
			res = res + ')'
		level = level - 1

if sum == k and opened == n and level < 0:
	print (res)
else:
	print ('Impossible')",['constructive algorithms']
"You are given a sequence $$$a_1, a_2, \dots, a_n$$$ consisting of $$$n$$$ integers.You may perform the following operation on this sequence: choose any element and either increase or decrease it by one.Calculate the minimum possible difference between the maximum element and the minimum element in the sequence, if you can perform the aforementioned operation no more than $$$k$$$ times.","n, k = [int(x) for x in input().split()]
d = {}
b = []
for i in map(int, input().split()):
    if i not in d:
        b.append(i)
        d[i] = 1
    else:
        d[i] += 1
b.sort()

mi, ma = 0, len(b) - 1
left, right = b[mi], b[ma]
am_left, am_right = d[b[mi]], d[b[ma]]
mi, ma = 1, len(b) - 2

while right - left > 0:
    if am_left <= am_right:
        if (b[mi] - left)*am_left <= k:
            k -= (b[mi] - left)*am_left
            left = b[mi]
            am_left += d[b[mi]]
            mi += 1
        else:
            left += k // am_left
            break
    else:
        if (right - b[ma])*am_right <= k:
            k -= (right - b[ma])*am_right
            right = b[ma]
            am_right += d[b[ma]]
            ma -= 1
        else:
            right -= k // am_right
            break
        
print(right - left)","['greedy', 'constructive algorithms', 'two pointers', 'sortings', 'binary search', 'ternary search']"
"The cities of Byteland and Berland are located on the axis $$$Ox$$$. In addition, on this axis there are also disputed cities, which belong to each of the countries in their opinion. Thus, on the line $$$Ox$$$ there are three types of cities:  the cities of Byteland,  the cities of Berland,  disputed cities. Recently, the project BNET has been launched — a computer network of a new generation. Now the task of the both countries is to connect the cities so that the network of this country is connected.The countries agreed to connect the pairs of cities with BNET cables in such a way that:  If you look at the only cities of Byteland and the disputed cities, then in the resulting set of cities, any city should be reachable from any other one by one or more cables,  If you look at the only cities of Berland and the disputed cities, then in the resulting set of cities, any city should be reachable from any other one by one or more cables. Thus, it is necessary to choose a set of pairs of cities to connect by cables in such a way that both conditions are satisfied simultaneously. Cables allow bi-directional data transfer. Each cable connects exactly two distinct cities.The cost of laying a cable from one city to another is equal to the distance between them. Find the minimum total cost of laying a set of cables so that two subsets of cities (Byteland and disputed cities, Berland and disputed cities) are connected.Each city is a point on the line $$$Ox$$$. It is technically possible to connect the cities $$$a$$$ and $$$b$$$ with a cable so that the city $$$c$$$ ($$$a &lt; c &lt; b$$$) is not connected to this cable, where $$$a$$$, $$$b$$$ and $$$c$$$ are simultaneously coordinates of the cities $$$a$$$, $$$b$$$ and $$$c$$$.","rides = int(input())
franxx = []
Zero = []
Two = []

for i in range(rides):
	darling = input().split()
	if (darling[1] == 'B'):
		darling[1] = 1
	elif (darling[1] == 'R'):
		darling[1] = 2
	else:
		darling[1] = 3
	franxx.append((int(darling[0]), int(darling[1])))

love = 0

hiro = [""I love Zero Two"", ""I love Darling""]

for zero, two in franxx:
	if (two == 3 or two == 1):
		if (hiro[0] == 'I love Zero Two'):
			Zero.append(0)
			hiro[0] = zero
		else:
			Zero.append(zero - hiro[0])
			love += zero - hiro[0]
			hiro[0] = zero
			
	if (two == 3 or two == 2):
		if (hiro[1] == 'I love Darling'):
			Two.append(0)
			hiro[1] = zero
		else:
			Two.append(zero - hiro[1])
			love += zero - hiro[1]
			hiro[1] = zero
	
	if (two == 1):
		Two.append(0)
	elif (two == 2):
		Zero.append(0)

hiro = [-1, 0]
for ride in range(rides):
	if (franxx[ride][1] == 3):
		if (hiro[0] == -1):
			hiro[0] = ride
			hiro[1] = 0
		else:
			strelizia = [0, 0]
			if ((hiro[1] & 1) == 0):
				strelizia[0] = franxx[ride][0] - franxx[hiro[0]][0]
			if ((hiro[1] & 2) == 0):
				strelizia[1] = franxx[ride][0] - franxx[hiro[0]][0]

			for darling in range(hiro[0], ride):
				if (hiro[1] & 1):
					strelizia[0] = max(strelizia[0], Zero[darling + 1])
				if (hiro[1] & 2):
					strelizia[1] = max(strelizia[1], Two[darling + 1])
			if (strelizia[0] + strelizia[1] - franxx[ride][0] + franxx[hiro[0]][0] > 0):
				love -= strelizia[0] + strelizia[1] - franxx[ride][0] + franxx[hiro[0]][0]
			hiro[0] = ride
			hiro[1] = 0
	else:
		hiro[1] |= franxx[ride][1]

print(love)","['constructive algorithms', 'greedy']"
"You are given the following concurrent program. There are N processes and the i-th process has the following pseudocode: repeat ni times    yi := y    y := yi + 1end repeatHere y is a shared variable. Everything else is local for the process. All actions on a given row are atomic, i.e. when the process starts executing a row it is never interrupted. Beyond that all interleavings are possible, i.e. every process that has yet work to do can be granted the rights to execute its next row. In the beginning y = 0. You will be given an integer W and ni, for i = 1, ... , N. Determine if it is possible that after all processes terminate, y = W, and if it is possible output an arbitrary schedule that will produce this final value.","import sys
from array import array  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


n, w = map(int, input().split())
a = [0] + list(map(int, input().split()))
total = sum(a)


def ng():
    print('No')
    exit()


def ok(a):
    print('Yes')
    print(*a)
    exit()


if w < 1 or total < w:
    ng()

if n == 1:
    if w == a[1]:
        ok([1] * (a[1] * 2))
    else:
        ng()

if w == 1:
    if min(a[1:]) > 1:
        ng()

    min_i = a.index(1)
    ans = []
    for i in range(1, n + 1):
        if i == min_i:
            continue
        ans += [i] * (a[i] * 2)

    ok([min_i] + ans + [min_i])


ans1, ans2, ans3 = [], [], []
w -= 2
if w:
    for i in range(1, 3):
        x = min(a[i] - 1, w)
        w -= x
        a[i] -= x
        ans3 += [i] * (2 * x)
    for i in range(3, n + 1):
        x = min(a[i], w)
        w -= x
        a[i] -= x
        ans3 += [i] * (2 * x)

ans1 = [2] * ((a[2] - 1) * 2)
for i in range(3, n + 1):
    ans1 += [i] * (a[i] * 2)
ans1 = [1] + ans1 + [1]
a[1] -= 1

ans2 = [2] + [1] * (a[1] * 2) + [2]

if w == 0:
    ok(ans1 + ans2 + ans3)
else:
    ng()",['constructive algorithms']
"Gildong has bought a famous painting software cfpaint. The working screen of cfpaint is square-shaped consisting of $$$n$$$ rows and $$$n$$$ columns of square cells. The rows are numbered from $$$1$$$ to $$$n$$$, from top to bottom, and the columns are numbered from $$$1$$$ to $$$n$$$, from left to right. The position of a cell at row $$$r$$$ and column $$$c$$$ is represented as $$$(r, c)$$$. There are only two colors for the cells in cfpaint — black and white.There is a tool named eraser in cfpaint. The eraser has an integer size $$$k$$$ ($$$1 \le k \le n$$$). To use the eraser, Gildong needs to click on a cell $$$(i, j)$$$ where $$$1 \le i, j \le n - k + 1$$$. When a cell $$$(i, j)$$$ is clicked, all of the cells $$$(i', j')$$$ where $$$i \le i' \le i + k - 1$$$ and $$$j \le j' \le j + k - 1$$$ become white. In other words, a square with side equal to $$$k$$$ cells and top left corner at $$$(i, j)$$$ is colored white.A white line is a row or a column without any black cells.Gildong has worked with cfpaint for some time, so some of the cells (possibly zero or all) are currently black. He wants to know the maximum number of white lines after using the eraser exactly once. Help Gildong find the answer to his question.","import fileinput
def D(a):print(a)
def S(s,I):return int(s.split("" "")[I])
def sm(I,B,E):
    if(B==0):return S[I][E]
    return S[I][E]-S[I][B-1]
def main():
    global S
    z=0
    A=0
    N=0
    K=0
    C=0
    for l in fileinput.input():
        z+=1
        if(z<2):
            N=S(l,0)
            K=S(l,1)
            A=[0]*N
            S=[0]*N
            C=[0]*N
            for i in range(N):
                A[i]=[0]*N
                S[i]=[0]*N
                C[i]=[0]*N
            continue
        for i in range(N):
            if(l[i]=='B'):
                A[z-2][i]=1
    for i in range(N):
        S[i][0]=A[i][0]
        for j in xrange(1,N):
            S[i][j]=S[i][j-1]+A[i][j]
    for i in range(N-K+1):
        T=0
        for j in range(N):
            if(S[j][N-1]==0):
                T+=1
        for j in range(K-1):
            if(S[j][N-1]!=0 and sm(j,i,i+K-1)==S[j][N-1]):
                T+=1
        for j in xrange(K-1,N):
            if(S[j][N-1]!=0 and sm(j,i,i+K-1)==S[j][N-1]):
                T+=1
            C[i][j-K+1]+=T
            if(S[j-K+1][N-1]!=0 and sm(j-K+1,i,i+K-1)==S[j-K+1][N-1]):
                T-=1
    for i in range(N):
        S[i][0]=A[0][i]
        for j in xrange(1,N):
            S[i][j]=S[i][j-1]+A[j][i]
    for i in range(N-K+1):
        T=0
        for j in range(N):
            if(S[j][N-1]==0):
                T+=1
        for j in range(K-1):
            if(S[j][N-1]!=0 and sm(j,i,i+K-1)==S[j][N-1]):
                T+=1
        for j in xrange(K-1,N):
            if(S[j][N-1]!=0 and sm(j,i,i+K-1)==S[j][N-1]):
                T+=1
            C[j-K+1][i]+=T
            if(S[j-K+1][N-1]!=0 and sm(j-K+1,i,i+K-1)==S[j-K+1][N-1]):
                T-=1
    X=0
    for i in range(N):
        for j in range(N):
            X=max(X,C[i][j])
    D(X)
main()","['dp', 'two pointers', 'implementation', 'data structures', 'brute force']"
"Recently, on a programming lesson little Petya showed how quickly he can create files and folders on the computer. But he got soon fed up with this activity, and he decided to do a much more useful thing. He decided to calculate what folder contains most subfolders (including nested folders, nested folders of nested folders, and so on) and what folder contains most files (including the files in the subfolders).More formally, the subfolders of the folder are all its directly nested folders and the subfolders of these nested folders. The given folder is not considered the subfolder of itself. A file is regarded as lying in a folder, if and only if it either lies directly in this folder, or lies in some subfolder of the folder.For a better understanding of how to count subfolders and files for calculating the answer, see notes and answers to the samples.You are given a few files that Petya has managed to create. The path to each file looks as follows:diskName:\folder1\folder2\...\ foldern\fileName  diskName is single capital letter from the set {C,D,E,F,G}. folder1, ..., foldern are folder names. Each folder name is nonempty sequence of lowercase Latin letters and digits from 0 to 9. (n ≥ 1) fileName is a file name in the form of name.extension, where the name and the extension are nonempty sequences of lowercase Latin letters and digits from 0 to 9. It is also known that there is no file whose path looks like diskName:\fileName. That is, each file is stored in some folder, but there are no files directly in the root. Also let us assume that the disk root is not a folder.Help Petya to find the largest number of subfolders, which can be in some folder, and the largest number of files that can be in some folder, counting all its subfolders.","import sys
from array import array  # noqa: F401
from collections import defaultdict


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


cnt1 = defaultdict(set)
cnt2 = defaultdict(int)

for line in sys.stdin:
    path = line.rstrip().split('\\')
    key = tuple(path[:2])
    for i in range(3, len(path)):
        cnt1[key].add(tuple(path[2:i]))
    cnt2[key] += 1

ans1 = max((len(s) for s in cnt1.values()), default=0)
ans2 = max(cnt2.values(), default=0)
print(ans1, ans2)","['data structures', 'implementation']"
"Arkady is playing Battleship. The rules of this game aren't really important.There is a field of $$$n \times n$$$ cells. There should be exactly one $$$k$$$-decker on the field, i. e. a ship that is $$$k$$$ cells long oriented either horizontally or vertically. However, Arkady doesn't know where it is located. For each cell Arkady knows if it is definitely empty or can contain a part of the ship.Consider all possible locations of the ship. Find such a cell that belongs to the maximum possible number of different locations of the ship.","#!/usr/bin/env python3
# -*- coding: utf-8 -*-
""""""
Created on Wed Apr 25 23:17:51 2018

@author: ska

965-B
""""""
import math
n,k = map(int, input().split())

f = []

score = [[0 for i in range(n)] for j in range(n)]
for i in range(n):
    f.append(input().strip())

for i in range(n):
    con = 0
    for j in range(n):
        if f[i][j] ==""."":
            con += 1
        else:
            con =0
        if con == k:
            con = k-1
            for h in range(k):
                score[i][j-h] += 1
                
            
#print(score)

for i in range(n):
    con = 0
    for j in range(n):
        if f[j][i] ==""."":
            con += 1
        else:
            con =0
        if con == k:
            con = k-1
            for h in range(k):
                score[j-h][i] +=1

#print(score)
ma = 0
row1 =0
col1 = 0
for row in range(n):
    for col in range(n):
#        print(score[row][col])
        if score[row][col] >ma:
            ma = score[row][col]
            row1 =row
            col1 =col
print(row1+1, col1+1)",['implementation']
Ayush and Ashish play a game on an unrooted tree consisting of $$$n$$$ nodes numbered $$$1$$$ to $$$n$$$. Players make the following move in turns:   Select any leaf node in the tree and remove it together with any edge which has this node as one of its endpoints. A leaf node is a node with degree less than or equal to $$$1$$$. A tree is a connected undirected graph without cycles.There is a special node numbered $$$x$$$. The player who removes this node wins the game. Ayush moves first. Determine the winner of the game if each player plays optimally.,"import sys
input = sys.stdin.readline

Q = int(input())
Query = []
for _ in range(Q):
    N, X = map(int, input().split())
    graph = [[] for _ in range(N)]
    for _ in range(N-1):
        a, b = map(int, input().split())
        graph[a-1].append(b-1)
        graph[b-1].append(a-1)
    Query.append((N, X-1, graph))

for N, s, graph in Query:
    checked = [False]*N
    checked[s] = True
    odd = 0
    for b in graph[s]:
        q = [b]
        checked[b] = True
        Count = 1
        while q:
            qq = []
            for p in q:
                for np in graph[p]:
                    if not checked[np]:
                        checked[np] = True
                        qq.append(np)
                        Count += 1
            q = qq
        if Count%2 == 1:
            odd += 1
    if len(graph[s]) <= 1 or odd%2 == 1:
        print(""Ayush"")
    else:
        print(""Ashish"")","['trees', 'games']"
"Yet another round on DecoForces is coming! Grandpa Maks wanted to participate in it but someone has stolen his precious sofa! And how can one perform well with such a major loss?Fortunately, the thief had left a note for Grandpa Maks. This note got Maks to the sofa storehouse. Still he had no idea which sofa belongs to him as they all looked the same!The storehouse is represented as matrix n × m. Every sofa takes two neighbouring by some side cells. No cell is covered by more than one sofa. There can be empty cells.Sofa A is standing to the left of sofa B if there exist two such cells a and b that xa &lt; xb, a is covered by A and b is covered by B. Sofa A is standing to the top of sofa B if there exist two such cells a and b that ya &lt; yb, a is covered by A and b is covered by B. Right and bottom conditions are declared the same way. Note that in all conditions A ≠ B. Also some sofa A can be both to the top of another sofa B and to the bottom of it. The same is for left and right conditions.The note also stated that there are cntl sofas to the left of Grandpa Maks's sofa, cntr — to the right, cntt — to the top and cntb — to the bottom.Grandpa Maks asks you to help him to identify his sofa. It is guaranteed that there is no more than one sofa of given conditions.Output the number of Grandpa Maks's sofa. If there is no such sofa that all the conditions are met for it then output -1.","from sys import stdin, stdout

k = int(stdin.readline())
n, m = map(int, stdin.readline().split())
left, right, down, up = [], [], [], []
coordinates = []

for i in range(k):
    x1, y1, x2, y2 = map(int, stdin.readline().split())
    
    if x1 == x2:
        if y1 < y2:
            coordinates.append((x1, y1, x2, y2, i))
        else:
            coordinates.append((x2, y2, x1, y1, i))
    else:
        if x1 < x2:
            coordinates.append((x1, y1, x2, y2, i))
        else:
            coordinates.append((x2, y2, x1, y1, i))
    
    left.append(coordinates[-1])
    right.append(coordinates[-1])
    up.append(coordinates[-1])
    down.append(coordinates[-1])

left.sort(key = lambda x: (x[0], x[2]))
down.sort(key = lambda x: (x[1], x[3]))

challengers = [[], [], [], []]
cntl, cntr, cntd, cntu = map(int, stdin.readline().split())
label = 1

if cntl or not cntl:
    for i in range(cntl, -1, -1):
        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):
            challengers[0].append(left[i][-1])  
        else:
            break
        
    for i in range(cntl + 1, k):
        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]) and left[i][2] > left[i][0]:
            label = 0
        
        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):
            challengers[0].append(left[i][-1])  
        else:
            break

if cntr or not cntr:
    for i in range(k - 1 - cntr, k):
        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):
            challengers[1].append(left[i][-1])
        else:
            break
    
    for i in range(k - 2 - cntr, -1, -1):
        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]) and left[i][2] > left[i][0]:
            label = 0
        
        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):
            challengers[1].append(left[i][-1])
        else:
            break

#!!!!!!!!!!!

if cntd or not cntd:
    for i in range(cntd, -1, -1):
        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):
            challengers[2].append(down[i][-1])
        else:
            break
        
    for i in range(cntd + 1, k):
        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]) and down[i][3] > down[i][1]:
            label = 0
            
        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):
            challengers[2].append(down[i][-1])  
        else:
            break
        
if cntu or not cntu:
    for i in range(k - 1 - cntu, k):
        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):
            challengers[3].append(down[i][-1])
        else:
            break
    
    for i in range(k - 2 - cntu, -1, -1):
        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]) and down[i][3] > down[i][1]:
            label = 0
        
        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):
            challengers[3].append(down[i][-1])
        else:
            break

ans = set(challengers[0]) & set(challengers[1]) & set(challengers[2]) & set(challengers[3])

if not len(ans) or not label:
    stdout.write('-1')
else:
    stdout.write(str(list(ans)[0] + 1))","['implementation', 'brute force']"
"Greg has a weighed directed graph, consisting of n vertices. In this graph any pair of distinct vertices has an edge between them in both directions. Greg loves playing with the graph and now he has invented a new game:  The game consists of n steps.  On the i-th step Greg removes vertex number xi from the graph. As Greg removes a vertex, he also removes all the edges that go in and out of this vertex.  Before executing each step, Greg wants to know the sum of lengths of the shortest paths between all pairs of the remaining vertices. The shortest path can go through any remaining vertex. In other words, if we assume that d(i, v, u) is the shortest path between vertices v and u in the graph that formed before deleting vertex xi, then Greg wants to know the value of the following sum: . Help Greg, print the value of the required sum before each step.","import sys
from array import array  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def solve():
    n = int(input())
    matrix = [array('i', list(map(int, input().split()))) for _ in range(n)]
    a = tuple(map(lambda x: int(x) - 1, input().split()))
    ans = [''] * n

    for i in range(n - 1, -1, -1):
        x = a[i]
        for u in range(n):
            for v in range(n):
                if matrix[u][v] > matrix[u][x] + matrix[x][v]:
                    matrix[u][v] = matrix[u][x] + matrix[x][v]

        upper, lower = 0, 0
        for u in a[i:]:
            for v in a[i:]:
                lower += matrix[u][v]
            if lower >= 10**9:
                upper += 1
                lower -= 10**9
        ans[i] = str(upper * 10**9 + lower)

    sys.stdout.buffer.write(' '.join(ans).encode('utf-8'))


if __name__ == '__main__':
    solve()","['dp', 'graphs', 'shortest paths']"
"Country of Metropolia is holding Olympiad of Metrpolises soon. It mean that all jury members of the olympiad should meet together in Metropolis (the capital of the country) for the problem preparation process.There are n + 1 cities consecutively numbered from 0 to n. City 0 is Metropolis that is the meeting point for all jury members. For each city from 1 to n there is exactly one jury member living there. Olympiad preparation is a long and demanding process that requires k days of work. For all of these k days each of the n jury members should be present in Metropolis to be able to work on problems.You know the flight schedule in the country (jury members consider themselves important enough to only use flights for transportation). All flights in Metropolia are either going to Metropolis or out of Metropolis. There are no night flights in Metropolia, or in the other words, plane always takes off at the same day it arrives. On his arrival day and departure day jury member is not able to discuss the olympiad. All flights in Megapolia depart and arrive at the same day.Gather everybody for k days in the capital is a hard objective, doing that while spending the minimum possible money is even harder. Nevertheless, your task is to arrange the cheapest way to bring all of the jury members to Metrpolis, so that they can work together for k days and then send them back to their home cities. Cost of the arrangement is defined as a total cost of tickets for all used flights. It is allowed for jury member to stay in Metropolis for more than k days.","def bs_ceil(arr, val):
    l, r = -1, len(arr)
    # 0 to n
    while r - l > 1:
        mid = (l + r) / 2
        if arr[mid][0] >= val:
            r = mid
        else:
            l = mid
    return r


n, m, k = map(int, raw_input().split())
D = [float('inf')] * (n + 1)
A = [float('inf')] * (n + 1)
arr1 = []
arr2 = []
for i in xrange(m):
    d, s1, s2, c = map(int, raw_input().split())
    if s2 == 0:
        arr1.append((d, s1, c))
    if s1 == 0:
        arr2.append((d, s2, c))
arr1.sort()
arr2.sort()

n1, n2 = len(arr1), len(arr2)
f, tc = 0, 0
a1, a2 = [], []
for i in xrange(n1):
    d, s1, c = arr1[i]
    if D[s1] == float('inf'):
        D[s1] = c
        f, tc = f + 1, tc + D[s1]
    else:
        tc -= D[s1]
        D[s1] = min(D[s1], c)
        tc += D[s1]
    if f == n and (a1 == [] or a1[-1][1] > tc):
        a1.append((d, tc))

f, tc = 0, 0
for i in reversed(xrange(n2)):
    d, s1, c = arr2[i]
    if A[s1] == float('inf'):
        A[s1] = c
        f, tc = f + 1, tc + A[s1]
    else:
        tc -= A[s1]
        A[s1] = min(A[s1], c)
        tc += A[s1]
    if f == n and (a2 == [] or a2[-1][1] > tc):
        a2.append((d, tc))

#print a1, a2
a2 = a2[::-1]
n1, n2 = len(a1), len(a2)
ans = float('inf')
if len(a2) > 0:
    for i in xrange(n1):
        d, c = a1[i]
        p = bs_ceil(a2, d + k + 1)
        if p != len(a2):
            ans = min(ans, c + a2[p][1])
if ans == float('inf'):
    print -1
else:
    print ans",['greedy']
"Long ago, Vasily built a good fence at his country house. Vasily calls a fence good, if it is a series of n consecutively fastened vertical boards of centimeter width, the height of each in centimeters is a positive integer. The house owner remembers that the height of the i-th board to the left is hi.Today Vasily decided to change the design of the fence he had built, by cutting his top connected part so that the fence remained good. The cut part should consist of only the upper parts of the boards, while the adjacent parts must be interconnected (share a non-zero length before cutting out of the fence).You, as Vasily's curious neighbor, will count the number of possible ways to cut exactly one part as is described above. Two ways to cut a part are called distinct, if for the remaining fences there is such i, that the height of the i-th boards vary.As Vasily's fence can be very high and long, get the remainder after dividing the required number of ways by 1 000 000 007 (109 + 7).","from sys import stdin
from itertools import repeat
def main():
    n = int(stdin.readline())
    a = map(int, stdin.readline().split())
    mod = 10 ** 9 + 7
    for i in xrange(n):
        a[i] -= 1
    lo, v = a[0], 0
    px = a[0]
    ans = a[0]
    for x in a[1:]:
        if px > x:
            lo, v = x, (min(lo, x) * v + x) % mod
        else:
            lo, v = px, (min(lo, px) * v + px) % mod
        ans = (ans + lo * v + x) % mod
        px = x
    print ans
main()","['dp', 'combinatorics', 'number theory']"
"It's now 260 AD. Shapur, being extremely smart, became the King of Persia. He is now called Shapur, His majesty King of kings of Iran and Aniran.Recently the Romans declared war on Persia. They dreamed to occupy Armenia. In the recent war, the Romans were badly defeated. Now their senior army general, Philip is captured by Shapur and Shapur is now going to capture Valerian, the Roman emperor.Being defeated, the cowardly Valerian hid in a room at the top of one of his castles. To capture him, Shapur has to open many doors. Fortunately Valerian was too scared to make impenetrable locks for the doors.Each door has 4 parts. The first part is an integer number a. The second part is either an integer number b or some really odd sign which looks like R. The third one is an integer c and the fourth part is empty! As if it was laid for writing something. Being extremely gifted, after opening the first few doors, Shapur found out the secret behind the locks.c is an integer written in base a, to open the door we should write it in base b. The only bad news is that this R is some sort of special numbering system that is used only in Roman empire, so opening the doors is not just a piece of cake!Here's an explanation of this really weird number system that even doesn't have zero:Roman numerals are based on seven symbols: a stroke (identified with the letter I) for a unit, a chevron (identified with the letter V) for a five, a cross-stroke (identified with the letter X) for a ten, a C (identified as an abbreviation of Centum) for a hundred, etc.: I=1 V=5 X=10 L=50 C=100 D=500 M=1000Symbols are iterated to produce multiples of the decimal (1, 10, 100, 1, 000) values, with V, L, D substituted for a multiple of five, and the iteration continuing: I 1, II 2, III 3, V 5, VI 6, VII 7, etc., and the same for other bases: X 10, XX 20, XXX 30, L 50, LXXX 80; CC 200, DCC 700, etc. At the fourth and ninth iteration, a subtractive principle must be employed, with the base placed before the higher base: IV 4, IX 9, XL 40, XC 90, CD 400, CM 900.Also in bases greater than 10 we use A for 10, B for 11, etc.Help Shapur capture Valerian and bring peace back to Persia, especially Armenia.","numbers = {'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'A':10,'B':11,'C':12,'D':13,'E':14,'F':15,'G':16,'H':17,'I':18,'J':19,'K':20,'L':21,'M':22,'N':23,'O':24,'P':25,'Q':26,'R':27,'S':28,'T':29,'U':30,'V':31,'W':32,'X':33,'Y':34,'Z':35}
characters = {0:'0',1:'1',2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'A',11:'B',12:'C',13:'D',14:'E',15:'F',16:'G',17:'H',18:'I',19:'J',20:'K',21:'L',22:'M',23:'N',24:'O',25:'P',26:'Q',27:'R',28:'S',29:'T',30:'U',31:'V',32:'W',33:'X',34:'Y',35:'Z'}

def ConvertToDecimal(number, base):
	newnumber = 0
	for digit in range(-1,(0-len(number))-1,-1):
		if(numbers[number[digit]] >= int(base)):
			return -1
		newnumber += numbers[number[digit]]*(int(base)**(0-digit-1))
	return newnumber
	
def ConvertToBase(number, base):
	newnumber = ''
	if(number == 0):
		return '0'
	while number > 0:
		newnumber = characters[number%base] + newnumber
		number = number//base
	return newnumber
	
def ConvertToRoman(number):
	newnumber = ''
	for i in range(4,0,-1):
		currentnumber = (number%(10**i) - number%(10**(i-1)))//(10**(i-1))
		if(currentnumber > 0):
			if(i==4):
				newnumber += 'M'*currentnumber
			elif(i==3):
				if(currentnumber == 9):
					newnumber += 'CM'
				elif(currentnumber>=5):
					newnumber += 'D' + 'C'*(currentnumber-5)
				elif currentnumber == 4:
					newnumber += 'CD'
				else:
					newnumber += 'C'*currentnumber
			elif(i==2):
				if(currentnumber == 9):
					newnumber += 'XC'
				elif(currentnumber>=5):
					newnumber += 'L' + 'X'*(currentnumber-5)
				elif currentnumber == 4:
					newnumber += 'XL'
				else:
					newnumber += 'X'*currentnumber
			elif(i==1):
				if(currentnumber == 9):
					newnumber += 'IX'
				elif(currentnumber>=5):
					newnumber += 'V' + 'I'*(currentnumber-5)
				elif currentnumber == 4:
					newnumber += 'IV'
				else:
					newnumber += 'I'*currentnumber
	return newnumber
	
a,b = [x for x in input().split()]
c = input()

if b == 'R':
	print(ConvertToRoman(ConvertToDecimal(c,int(a))))
else:
	print(ConvertToBase(ConvertToDecimal(c,int(a)),int(b)))",['math']
"Initially there was an array $$$a$$$ consisting of $$$n$$$ integers. Positions in it are numbered from $$$1$$$ to $$$n$$$.Exactly $$$q$$$ queries were performed on the array. During the $$$i$$$-th query some segment $$$(l_i, r_i)$$$ $$$(1 \le l_i \le r_i \le n)$$$ was selected and values of elements on positions from $$$l_i$$$ to $$$r_i$$$ inclusive got changed to $$$i$$$. The order of the queries couldn't be changed and all $$$q$$$ queries were applied. It is also known that every position from $$$1$$$ to $$$n$$$ got covered by at least one segment.We could have offered you the problem about checking if some given array (consisting of $$$n$$$ integers with values from $$$1$$$ to $$$q$$$) can be obtained by the aforementioned queries. However, we decided that it will come too easy for you.So the enhancement we introduced to it is the following. Some set of positions (possibly empty) in this array is selected and values of elements on these positions are set to $$$0$$$.Your task is to check if this array can be obtained by the aforementioned queries. Also if it can be obtained then restore this array.If there are multiple possible arrays then print any of them.","def isvalid(a, q):
    n = len(a)
    start = [-1 for i in xrange(q + 1)]
    end = [-1 for i in xrange(q + 1)]
    for i in xrange(n):
        if start[a[i]] == -1:
            start[a[i]] = end[a[i]] = i
        else:
            end[a[i]] = i
    cur_l = 0
    stack = []
    for i in xrange(n):
        cl = a[i]
        if cur_l != 0:
            if cl < cur_l: return False

            if start[cl] != end[cl] and cl != stack[-1][0]:
                cur_l = cl
                stack.append((cur_l, end[cl]))
            
            if i == stack[-1][-1]:
                stack.pop()
                try: cur_l = stack[-1][0]
                except: cur_l = 0
                continue
                
        if start[cl] != end[cl] and cur_l == 0:
            cur_l = cl
            stack.append((cur_l, end[cl]))

    if not q in a: return False
    return True
        

n, q = map(int, raw_input().strip().split())
a = map(int, raw_input().strip().split())

zst = [] # to store the indices where 0 starts from
zend = []
inpro = False
for i in xrange(n):
    if a[i] == 0 and not inpro:
        inpro = True
        zst.append(i)
    elif a[i] != 0 and inpro:
        inpro = False
        zend.append(i - 1)

if len(zend) != len(zst): zend.append(n - 1)

qina = q in a

for i in xrange(len(zst)):
    st = zst[i]
    en = zend[i]
    l, r = -1, -1
    if st - 1 >= 0: l = a[st - 1]
    if en + 1 < n: r = a[en + 1]
    m = max(l, r)
    if not qina:
        m = q
        qina = True
    if m == -1: m = q
    for j in xrange(zst[i], zend[i] + 1): a[j] = m

if isvalid(a, q):
    print ""YES""
    print ' '.join(map(str, a))
else:
    print ""NO""","['data structures', 'constructive algorithms']"
"A permutation of size $$$n$$$ is an array of size $$$n$$$ such that each integer from $$$1$$$ to $$$n$$$ occurs exactly once in this array. An inversion in a permutation $$$p$$$ is a pair of indices $$$(i, j)$$$ such that $$$i &gt; j$$$ and $$$a_i &lt; a_j$$$. For example, a permutation $$$[4, 1, 3, 2]$$$ contains $$$4$$$ inversions: $$$(2, 1)$$$, $$$(3, 1)$$$, $$$(4, 1)$$$, $$$(4, 3)$$$.You are given a permutation $$$p$$$ of size $$$n$$$. However, the numbers on some positions are replaced by $$$-1$$$. Let the valid permutation be such a replacement of $$$-1$$$ in this sequence back to numbers from $$$1$$$ to $$$n$$$ in such a way that the resulting sequence is a permutation of size $$$n$$$.The given sequence was turned into a valid permutation randomly with the equal probability of getting each valid permutation.Calculate the expected total number of inversions in the resulting valid permutation.It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$. Report the value of $$$P \cdot Q^{-1} \pmod {998244353}$$$.","def merge(a,b):
    inda=0
    indb=0
    lena=len(a)
    lenb=len(b)
    d=[a[-1]+b[-1]+1000]
    a+=d
    b+=d
    c=[]
    inversions=0
    for i in range(lena+lenb):
        if a[inda]<b[indb]:
            c.append(a[inda])
            inda+=1
        else:
            c.append(b[indb])
            indb+=1
            inversions+=lena-inda
    return((c,inversions))
def mergesort(a):
    if len(a)<=1:
        return((a,0))
    split=len(a)//2
    b=a[:split]
    c=a[split:]
    d=mergesort(b)
    e=mergesort(c)
    f=merge(d[0],e[0])
    return((f[0],f[1]+d[1]+e[1]))
n=int(input())
a=list(map(int,input().split()))
b=[]
for guy in a:
    if guy!=-1:
        b.append(guy)
invs=mergesort(b)[1]
negs=len(a)-len(b)
pairs=(negs*(negs-1))//2
used=[0]*n
for guy in a:
    if guy!=-1:
        used[guy-1]+=1
unused=[0]
for i in range(n-1):
    unused.append(unused[-1]+1-used[i])
negsseen=0
mix=0
for i in range(n):
    if a[i]==-1:
        negsseen+=1
    else:
        mix+=unused[a[i]-1]*(negs-negsseen)+negsseen*(negs-unused[a[i]-1])
num=invs*2*negs+pairs*negs+mix*2
denom=2*negs
if negs==0:
    print(invs%998244353)
else:
    for i in range(denom):
        if (998244353*i+1)%denom==0:
            inv=(998244353*i+1)//denom
            break
    print((num*inv)%998244353)","['dp', 'probabilities', 'math']"
"Piegirl got bored with binary, decimal and other integer based counting systems. Recently she discovered some interesting properties about number , in particular that q2 = q + 1, and she thinks it would make a good base for her new unique system. She called it ""golden system"". In golden system the number is a non-empty string containing 0's and 1's as digits. The decimal value of expression a0a1...an equals to .Soon Piegirl found out that this system doesn't have same properties that integer base systems do and some operations can not be performed on it. She wasn't able to come up with a fast way of comparing two numbers. She is asking for your help.Given two numbers written in golden system notation, determine which of them has larger decimal value.","from itertools import dropwhile, chain


def main():
    zeroes = lambda a: not a
    a, b = [list(chain([0, 0], dropwhile(zeroes, map(int, input()))))
            for _ in range(2)]

    def tofib(l):
        i = 0
        while i < len(l) - 1:
            if l[i] > 0 and l[i + 1] > 0:
                l[i] -= 1
                l[i + 1] -= 1
                l[i - 1] += 1
                i -= 3
            i += 1
        return l

    a = list(dropwhile(zeroes, tofib(a)))
    b = list(dropwhile(zeroes, tofib(b)))

    if len(a) < len(b):
        print('<')
        return
    if len(a) > len(b):
        print('>')
        return
    for i in range(len(a)):
        if a[i] < b[i]:
            print('<')
            return
        if a[i] > b[i]:
            print('>')
            return
    print('=')


if __name__ == '__main__':
    main()","['meet-in-the-middle', 'math']"
"You are given a set of n points on the plane. A line containing the origin is called good, if projection of the given set to this line forms a symmetric multiset of points. Find the total number of good lines.Multiset is a set where equal elements are allowed.Multiset is called symmetric, if there is a point P on the plane such that the multiset is centrally symmetric in respect of point P.","from fractions import Fraction
import time


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def to_tuple(self):
        return (self.x, self.y)

    def __repr__(self):
        return ""Point({}, {})"".format(self.x, self.y)

    def __eq__(self, other):
        return self.to_tuple() == other.to_tuple()

    def __hash__(self):
        return hash(self.to_tuple())

    def __neg__(self):
        return Point(-self.x, -self.y)

    def __add__(self, other):
        return Point(self.x+other.x, self.y+other.y)

    def __sub__(self, other):
        return self+(-other)

    def scalar_mul(self, mu):
        return Point(mu*self.x, mu*self.y)

    def int_divide(self, den):
        return Point(self.x//den, self.y//den)


class Line:
    def __init__(self, a, b, c):
        # ax+by+c=0
        self.a = a
        self.b = b
        self.c = c

    def __repr__(self):
        return ""{}*x + {}*y + {} = 0"".format(self.a, self.b, self.c)

    @classmethod
    def between_two_points(cls, P, Q):
        return cls(P.y-Q.y, Q.x-P.x, P.x*Q.y-P.y*Q.x)

    def evaluate(self, P):
        return self.a*P.x+self.b*P.y+self.c

    def direction(self):
        if self.a == 0:
            return (0, 1)
        return (1, Fraction(self.b, self.a))


def abs_sgn(x):
    if x == 0:
        return 0, 0
    if x < 0:
        return -x, -1
    return x, 1


def solve(tuple_points):
    points = set()
    center = Point(0, 0)
    for cur in tuple_points:
        cur = Point(*cur).scalar_mul(2*n)
        center += cur
        points.add(cur)

    center = center.int_divide(n)
    dcenter = center+center

    sym_points_set = set()
    for p in points:
        sym_points_set.add(dcenter-p)
    nosym = list(points - sym_points_set)

    if len(nosym) == 0:
        print(-1)
        exit(0)

    p0 = nosym[0]
    good_lines = set()
    for p in nosym:
        m = (p+p0).int_divide(2)
        line = Line.between_two_points(m, center)
        distances = list(map(line.evaluate, nosym))

        ok = True
        mydict = {}
        for dd in distances:
            dda, sgn = abs_sgn(dd)
            if dda not in mydict:
                mydict[dda] = sgn
            else:
                mydict[dda] += sgn
        for k in mydict:
            if mydict[k] != 0:
                ok = False
                break
        if ok:
            good_lines.add(line.direction())

    return len(good_lines)


# This one is accepted on CF
if __name__ == ""__main__"":
    n = int(input())
    pts = []
    for i in range(n):
        row = input().split("" "")
        cur = (int(row[0]), int(row[1]))
        pts.append(cur)
    print(solve(pts))",['geometry']
"You are given a problemset consisting of $$$n$$$ problems. The difficulty of the $$$i$$$-th problem is $$$a_i$$$. It is guaranteed that all difficulties are distinct and are given in the increasing order.You have to assemble the contest which consists of some problems of the given problemset. In other words, the contest you have to assemble should be a subset of problems (not necessary consecutive) of the given problemset. There is only one condition that should be satisfied: for each problem but the hardest one (the problem with the maximum difficulty) there should be a problem with the difficulty greater than the difficulty of this problem but not greater than twice the difficulty of this problem. In other words, let $$$a_{i_1}, a_{i_2}, \dots, a_{i_p}$$$ be the difficulties of the selected problems in increasing order. Then for each $$$j$$$ from $$$1$$$ to $$$p-1$$$ $$$a_{i_{j + 1}} \le a_{i_j} \cdot 2$$$ should hold. It means that the contest consisting of only one problem is always valid.Among all contests satisfying the condition above you have to assemble one with the maximum number of problems. Your task is to find this number of problems.","n = int(input())
a = [int(x) for x in input().split()]

b = []
b.append(0)

for i in range(1, n):
    if a[i] > 2 * a[i-1]:
        b.append(i)

b.append(n)
n = len(b)
m = 1
for i in range(1, n):
    if b[i] - b[i-1] > m:
        m = b[i] - b[i-1]

print(m)","['dp', 'greedy', 'math']"
"Students went into a class to write a test and sat in some way. The teacher thought: ""Probably they sat in this order to copy works of each other. I need to rearrange them in such a way that students that were neighbors are not neighbors in a new seating.""The class can be represented as a matrix with n rows and m columns with a student in each cell. Two students are neighbors if cells in which they sit have a common side.Let's enumerate students from 1 to n·m in order of rows. So a student who initially sits in the cell in row i and column j has a number (i - 1)·m + j. You have to find a matrix with n rows and m columns in which all numbers from 1 to n·m appear exactly once and adjacent numbers in the original matrix are not adjacent in it, or determine that there is no such matrix.","import random
n, m = map(int, input().split())
if n < 4 and m < 4 and not((n == 1 and m == 1) or (m == 3 and n == 3)): print(""NO""); quit()
pedy = [list() for i in range(n * m + 1)]
for i in range(n * m):
    if i % m != 0: pedy[i+1].append(i)
    if i % m != m - 1: pedy[i + 1].append(i + 2)
    if i >= m: pedy[i + 1].append(i - m + 1)
    if i < (n - 1) * m: pedy[i + 1].append(i + m + 1)
Arr = [x for x in range(1, n*m + 1)]; Arr = Arr[::2] + Arr[1::2]; pp = 0; s = """"
while (not pp):
    pp = 1;
    for i in range(n):
        for j in range(m):
            if (i + 1 != n and Arr[i * m + m + j] in pedy[Arr[i * m + j]]) or (j + 1 != m and Arr[i * m + 1 + j] in pedy[Arr[i * m + j]]):
                pp = 0; break
        if not pp: break
    if not pp: random.shuffle(Arr)
print(""YES"")
for i in range(n):
    for j in range(m):
        s += str(Arr[i  * m + j]) + "" ""
    print(s); s = """"",['constructive algorithms']
"Bob came to a cash &amp; carry store, put n items into his trolley, and went to the checkout counter to pay. Each item is described by its price ci and time ti in seconds that a checkout assistant spends on this item. While the checkout assistant is occupied with some item, Bob can steal some other items from his trolley. To steal one item Bob needs exactly 1 second. What is the minimum amount of money that Bob will have to pay to the checkout assistant? Remember, please, that it is Bob, who determines the order of items for the checkout assistant.","n=input()
t=[0]
a=[0]
for i in range(n):
    v1,v2=map(int,raw_input().split("" ""))
    v1+=1
    t.append(v1)
    
    a.append(v2)
ans=[10**15 for j in range(n+1)]
#print ans
ans[0]=0
for i in range(1,n+1):
    for j in range(n,0,-1):
        ans[j]=min(ans[j],ans[max(0,j-t[i])]+a[i])
print ans[n]",['dp']
"Peter has a sequence of integers a1, a2, ..., an. Peter wants all numbers in the sequence to equal h. He can perform the operation of ""adding one on the segment [l, r]"": add one to all elements of the sequence with indices from l to r (inclusive). At that, Peter never chooses any element as the beginning of the segment twice. Similarly, Peter never chooses any element as the end of the segment twice. In other words, for any two segments [l1, r1] and [l2, r2], where Peter added one, the following inequalities hold: l1 ≠ l2 and r1 ≠ r2.How many distinct ways are there to make all numbers in the sequence equal h? Print this number of ways modulo 1000000007 (109 + 7). Two ways are considered distinct if one of them has a segment that isn't in the other way.","from __future__ import print_function
from collections import defaultdict

import sys

d = defaultdict(int)

#input = raw_input

N, h = [int(x) for x in input().split()]
A = [int(x) for x in input().split()]

B = [0]
for a in A:
    B.append(h-a)
    if h-a < 0:
        print(0)
        sys.exit(0)
B.append(0)

MOD = 10**9+7

d[0, False, False] = 1

for i in range(1, N+2):
    for op in [False, True]:
        for cl in [False, True]:
            last_close = B[i-1] - B[i] + int(op)
            #
            if cl and B[i] == 0: continue # can't close anything
            if last_close not in [0, 1]: continue # doesn't add up
            s = d[i-1, False, bool(last_close)] + d[i-1, True, bool(last_close)]
            if cl: s *= B[i]
            #if i == 2 and op:
            #    print(cl, s, last_close,
            #          d[i-1, False, bool(last_close)] ,
            #          d[i-1, True, bool(last_close)])
            d[i, op, cl] = s % MOD

#print(d)

#for i in range(N+2):
#    print(""\n"", i, end="": "")
#    for op in [False, True]:
#        for cl in [False, True]:
#            print(d[i, op, cl], end="" "")
#print()



print(d[N+1, False, False])","['dp', 'combinatorics']"
"Arnie the Worm has finished eating an apple house yet again and decided to move. He made up his mind on the plan, the way the rooms are located and how they are joined by corridors. He numbered all the rooms from 1 to n. All the corridors are bidirectional.Arnie wants the new house to look just like the previous one. That is, it should have exactly n rooms and, if a corridor from room i to room j existed in the old house, it should be built in the new one. We know that during the house constructing process Arnie starts to eat an apple starting from some room and only stops when he eats his way through all the corridors and returns to the starting room. It is also known that Arnie eats without stopping. That is, until Arnie finishes constructing the house, he is busy every moment of his time gnawing a new corridor. Arnie doesn't move along the already built corridors.However, gnawing out corridors in one and the same order any time you change a house is a very difficult activity. That's why Arnie, knowing the order in which the corridors were located in the previous house, wants to gnaw corridors in another order. It is represented as a list of rooms in the order in which they should be visited. The new list should be lexicographically smallest, but it also should be strictly lexicographically greater than the previous one. Help the worm.","from collections import deque
def readint(): return int(raw_input())
def readarray(foo): return [foo(x) for x in raw_input().split()]


def ok(to, s, t):
	if s == t:
		if len(to[s]) % 2 != 0: return False
	else:
		if len(to[s]) % 2 == 0: return False

	left = 0
	for u in xrange(0, len(to)):
		l = len(to[u])
		if u != s and u != t and l % 2 != 0: return False
		left += 0 if l == 0 else 1

	if left == 0: return s == t

	used = set()
	q = deque([s])
	used.add(s)
	while q:
		u = q.popleft()
		for v in to[u]:
			if v in used: continue
			used.add(v)
			q.append(v)
	return len(used) == left
	

def reconstruct(to, u, t):
	while u != t or len(to[u]) > 0:
		found = False
		for v in sorted(to[u]):
			to[u].remove(v)
			to[v].remove(u)
			if not ok(to, v, t):
				to[u].add(v)
				to[v].add(u)
				continue
			yield v
			found = True
			u = v
			break
		assert found
		

def run():
	n, m = readarray(int)
	a = readarray(lambda x: int(x) - 1)
	to = [set() for u in xrange(n)]
	t = a[0]
	for i in xrange(m - 1, -1, -1):
		u, v = a[i:i + 2]
		to[u].add(v)
		to[v].add(u)
		for w in sorted(to[u]):
			if w <= v: continue
			to[u].remove(w)
			to[w].remove(u)
			if not ok(to, w, t):
				to[u].add(w)
				to[w].add(u)
				continue
			res = a[:i + 1] + [w] + list(reconstruct(to, w, t))
			return "" "".join([str(x + 1) for x in res])
	return ""No solution""
print run()","['dfs and similar', 'graphs']"
"You are given an array $$$a$$$ of length $$$n$$$ that has a special condition: every element in this array has at most 7 divisors. Find the length of the shortest non-empty subsequence of this array product of whose elements is a perfect square.A sequence $$$a$$$ is a subsequence of an array $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements.","from sys import stdin 
from collections import deque, Counter, defaultdict

N = int(input())
arr = list(map(int, stdin.readline().split()))

MAX = 1_000_005
lp = [0] * MAX
pr = []
pid = {1: 0}
for i in range(2, MAX):
	if not lp[i]:
		lp[i] = i
		pr.append(i)
		pid[i] = len(pr)
	for p in pr:
		if p > lp[i] or i * p >= MAX:
			break
		lp[i * p] = p

# lp is sieve, pr is a list of primes, pid is a dictionary keeping track of when the prime appears 
vertex = [[] for i in range(len(pid))]
for n in arr:
	new = []
	while n > 1:
		p, c = lp[n], 0
		while lp[n] == p:
			n //= p 
			c ^= 1
		if c:
			new.append(p)

	if not new:
		print (1)
		exit()

	new += [1]*(2 - len(new))
	u, v = pid[new[0]], pid[new[1]]
	vertex[u].append(v)
	vertex[v].append(u)


def bfs_path(s):
	# s is the index for the prime number 

	q = deque()
	v = [-1]*len(pid)
	v[s] = 0
	q.append((s, -1))
	while q:
		c, p = q.pop()

		for x in vertex[c]:
			if v[x] != -1:
				if x != p:
					return v[x] + v[c] + 1
			else:
				v[x] = v[c] + 1
				q.appendleft((x, c))

'''

	q = deque()
	vertices = vertex.keys()
	vi = dict(zip(vertices, range(len(vertices))))
	dist = [-1]*len(vertices)
	q.append(source)
	dist[vi[source]] = 0
	far = 0
	ans = float(""inf"")
	for v in vertex[source]:
		q = deque()
		q.append(v)
		dist = [-1]*len(vertices)
		dist[vi[source]] = 0
		dist[vi[v]] = 1
		while len(q):
			current = q.pop()
			for v in vertex[current]:
				# don't want to repeat an edge 
				if dist[vi[v]] in (-1, 0):
					if v == end and dist[vi[current]] > 1:
						if dist[vi[current]] + 1 < ans:
							ans = dist[vi[current]] + 1
						break 
					elif v != end:
						dist[vi[v]] = dist[vi[current]] + 1
						if dist[vi[v]] - 1 > far:
							far = dist[vi[v]]
						q.appendleft(v)
	if ans != float(""inf""):
		return ans
	else:
		return 0
'''




ans = N + 1
for i in range(len(pid)):
	if i > 0 and pr[i - 1] > MAX**0.5:
		break
	ans = min(ans, bfs_path(i) or ans)

print (ans if ans <= N else -1)","['graphs', 'number theory', 'shortest paths', 'dfs and similar', 'brute force']"
"The king of Berland organizes a ball! $$$n$$$ pair are invited to the ball, they are numbered from $$$1$$$ to $$$n$$$. Each pair consists of one man and one woman. Each dancer (either man or woman) has a monochrome costume. The color of each costume is represented by an integer from $$$1$$$ to $$$k$$$, inclusive.Let $$$b_i$$$ be the color of the man's costume and $$$g_i$$$ be the color of the woman's costume in the $$$i$$$-th pair. You have to choose a color for each dancer's costume (i.e. values $$$b_1, b_2, \dots, b_n$$$ and $$$g_1, g_2, \dots g_n$$$) in such a way that:  for every $$$i$$$: $$$b_i$$$ and $$$g_i$$$ are integers between $$$1$$$ and $$$k$$$, inclusive;  there are no two completely identical pairs, i.e. no two indices $$$i, j$$$ ($$$i \ne j$$$) such that $$$b_i = b_j$$$ and $$$g_i = g_j$$$ at the same time;  there is no pair such that the color of the man's costume is the same as the color of the woman's costume in this pair, i.e. $$$b_i \ne g_i$$$ for every $$$i$$$;  for each two consecutive (adjacent) pairs both man's costume colors and woman's costume colors differ, i.e. for every $$$i$$$ from $$$1$$$ to $$$n-1$$$ the conditions $$$b_i \ne b_{i + 1}$$$ and $$$g_i \ne g_{i + 1}$$$ hold. Let's take a look at the examples of bad and good color choosing (for $$$n=4$$$ and $$$k=3$$$, man is the first in a pair and woman is the second):Bad color choosing:   $$$(1, 2)$$$, $$$(2, 3)$$$, $$$(3, 2)$$$, $$$(1, 2)$$$ — contradiction with the second rule (there are equal pairs);  $$$(2, 3)$$$, $$$(1, 1)$$$, $$$(3, 2)$$$, $$$(1, 3)$$$ — contradiction with the third rule (there is a pair with costumes of the same color);  $$$(1, 2)$$$, $$$(2, 3)$$$, $$$(1, 3)$$$, $$$(2, 1)$$$ — contradiction with the fourth rule (there are two consecutive pairs such that colors of costumes of men/women are the same). Good color choosing:   $$$(1, 2)$$$, $$$(2, 1)$$$, $$$(1, 3)$$$, $$$(3, 1)$$$;  $$$(1, 2)$$$, $$$(3, 1)$$$, $$$(2, 3)$$$, $$$(3, 2)$$$;  $$$(3, 1)$$$, $$$(1, 2)$$$, $$$(2, 3)$$$, $$$(3, 2)$$$. You have to find any suitable color choosing or say that no suitable choosing exists.","import sys
m,n = tuple(map(int, input().split()))
if m > n * (n-1):
    print('NO')
else:
    print(""YES"")
    index = 0
    for i in range(2, n+1):
        for j in range(1, i+1):
            if i+1 != 2*j:
                print(1+i-j, j)
                index += 1
                if index == m:
                    sys.exit()

    for k in range(1, n-1):
        for j in range(n-k):
            if n - k - 1 != 2*j:
                print(n-j, k+j+1)
                index += 1
                if index == m:
                    sys.exit()","['constructive algorithms', 'implementation']"
"Vasya is interested in arranging dominoes. He is fed up with common dominoes and he uses the dominoes of different heights. He put n dominoes on the table along one axis, going from left to right. Every domino stands perpendicular to that axis so that the axis passes through the center of its base. The i-th domino has the coordinate xi and the height hi. Now Vasya wants to learn for every domino, how many dominoes will fall if he pushes it to the right. Help him do that. Consider that a domino falls if it is touched strictly above the base. In other words, the fall of the domino with the initial coordinate x and height h leads to the fall of all dominoes on the segment [x + 1, x + h - 1].","n = input()
l=sorted([map(int,raw_input().split())+[i] for i in xrange(n)]+[(3*10**8,0)],reverse=1)
r=[(0,0)]*(n+1)
r[0]=[(-1,0)]
for i in xrange(1,n+1):
    x,h,j=l[i]
    y = x+h
    p = i-1
    while (y>l[p][0]): p-=r[p][1]
    r[i]=(j,i-p)

print ' '.join(map(lambda x:str(x[1]),sorted(r[1:])))","['data structures', 'binary search', 'sortings']"
"A tree is an undirected connected graph without cycles.Let's consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p1, p2, ..., pn, where pi denotes a parent of vertex i (here, for convenience a root is considered its own parent).    For this rooted tree the array p is [2, 3, 3, 2]. Given a sequence p1, p2, ..., pn, one is able to restore a tree:  There must be exactly one index r that pr = r. A vertex r is a root of the tree.  For all other n - 1 vertices i, there is an edge between vertex i and vertex pi. A sequence p1, p2, ..., pn is called valid if the described procedure generates some (any) rooted tree. For example, for n = 3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.You are given a sequence a1, a2, ..., an, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.","n=int(input())
a=list(map(int,input().split()))
par=[]
for i in range(n):
	if a[i]==i+1:
		par.append(i)
v=[False for i in range(n)]
for i in par:
	v[i]=True
ccl=[]
for i in range(n):
	if v[i]:continue
	s=[i]
	v[i]=True
	p=set(s)
	t=True
	while s and t:
		x=s.pop()
		j=a[x]-1
		if j in p:
			ccl.append(j)
			t=False
		else:
			s.append(j)
			p.add(j)
		if v[j]:t=False
		else:v[j]=True
if len(par)==0:
	print(len(ccl))
	c=ccl[0]
	a[c]=c+1
	for i in range(1,len(ccl)):
		a[ccl[i]]=c+1
	print(*a)
else:
	print(len(ccl)+len(par)-1)
	c=par[0]
	for i in range(1,len(par)):
		a[par[i]]=c+1
	for i in range(len(ccl)):
		a[ccl[i]]=c+1
	print(*a)","['graphs', 'constructive algorithms', 'dsu', 'dfs and similar', 'trees']"
"Let's consider a simplified version of order book of some stock. The order book is a list of orders (offers) from people that want to buy or sell one unit of the stock, each order is described by direction (BUY or SELL) and price.At every moment of time, every SELL offer has higher price than every BUY offer. In this problem no two ever existed orders will have the same price.The lowest-price SELL order and the highest-price BUY order are called the best offers, marked with black frames on the picture below.  The presented order book says that someone wants to sell the product at price $$$12$$$ and it's the best SELL offer because the other two have higher prices. The best BUY offer has price $$$10$$$. There are two possible actions in this orderbook:  Somebody adds a new order of some direction with some price. Somebody accepts the best possible SELL or BUY offer (makes a deal). It's impossible to accept not the best SELL or BUY offer (to make a deal at worse price). After someone accepts the offer, it is removed from the orderbook forever.It is allowed to add new BUY order only with prices less than the best SELL offer (if you want to buy stock for higher price, then instead of adding an order you should accept the best SELL offer). Similarly, one couldn't add a new SELL order with price less or equal to the best BUY offer. For example, you can't add a new offer ""SELL $$$20$$$"" if there is already an offer ""BUY $$$20$$$"" or ""BUY $$$25$$$"" — in this case you just accept the best BUY offer.You have a damaged order book log (in the beginning the are no orders in book). Every action has one of the two types: ""ADD $$$p$$$"" denotes adding a new order with price $$$p$$$ and unknown direction. The order must not contradict with orders still not removed from the order book.  ""ACCEPT $$$p$$$"" denotes accepting an existing best offer with price $$$p$$$ and unknown direction.The directions of all actions are lost. Information from the log isn't always enough to determine these directions. Count the number of ways to correctly restore all ADD action directions so that all the described conditions are satisfied at any moment. Since the answer could be large, output it modulo $$$10^9 + 7$$$. If it is impossible to correctly restore directions, then output $$$0$$$.","import heapq

n = int(input())

ans = 1

mod = 10**9 + 7

buy, undefined, sell = [], [], []

for i in range(n):
    cmd, str_p = input().split()
    p = int(str_p)

    if cmd == 'ADD':
        if buy and p < -buy[0]:
            heapq.heappush(buy, -p)
        elif sell and p > sell[0]:
            heapq.heappush(sell, p)
        else:
            undefined.append(p)
    else:
        if (buy and p < -buy[0]) or (sell and p > sell[0]):
            ans = 0
            break
        elif buy and p == -buy[0]:
            heapq.heappop(buy)
        elif sell and p == sell[0]:
            heapq.heappop(sell)
        else:
            ans = (ans << 1) % mod
        for x in undefined:
            if x < p:
                heapq.heappush(buy, -x)
            elif x > p:
                heapq.heappush(sell, x)
        undefined = []

ans = ans * (len(undefined) + 1) % mod

print(ans)","['data structures', 'combinatorics', 'greedy']"
"Little John aspires to become a plumber! Today he has drawn a grid consisting of n rows and m columns, consisting of n × m square cells.In each cell he will draw a pipe segment. He can only draw four types of segments numbered from 1 to 4, illustrated as follows:  Each pipe segment has two ends, illustrated by the arrows in the picture above. For example, segment 1 has ends at top and left side of it.Little John considers the piping system to be leaking if there is at least one pipe segment inside the grid whose end is not connected to another pipe's end or to the border of the grid. The image below shows an example of leaking and non-leaking systems of size 1 × 2.  Now, you will be given the grid that has been partially filled by Little John. Each cell will either contain one of the four segments above, or be empty. Find the number of possible different non-leaking final systems after Little John finishes filling all of the empty cells with pipe segments. Print this number modulo 1000003 (106 + 3).Note that rotations or flipping of the grid are not allowed and so two configurations that are identical only when one of them has been rotated or flipped either horizontally or vertically are considered two different configurations.","n,m = map(int, raw_input().split())
mp = []

def checkrow(row):
    ret = 0
    beg = False
    ok = True
    for j in range(m):
        if(mp[row][j] != '.'):
            if not beg and (mp[row][j] != '1' and mp[row][j] != '2'):
                ok = False
            if beg and (mp[row][j] != '3' and mp[row][j] != '4'):
                ok = False
        beg = not beg
    if ok:
        ret += 1
    beg = True
    ok = True
    for j in range(m):
        if(mp[row][j] != '.'):
            if not beg and (mp[row][j] != '1' and mp[row][j] != '2'):
                ok = False
            if beg and (mp[row][j] != '3' and mp[row][j] != '4'):
                ok = False
        beg = not beg
    if ok:
        ret += 1
    return ret
    
    
def checkcol(col):
    ret = 0
    beg = False
    ok = True
    for i in range(n):
        if(mp[i][col] != '.'):
            if not beg and (mp[i][col] != '1' and mp[i][col] != '4'):
                ok = False
            if beg and (mp[i][col] != '2' and mp[i][col] != '3'):
                ok = False
        beg = not beg
    if ok:
        ret += 1
    beg = True
    ok = True
    for i in range(n):
        if(mp[i][col] != '.'):
            if not beg and (mp[i][col] != '1' and mp[i][col] != '4'):
                ok = False
            if beg and (mp[i][col] != '2' and mp[i][col] != '3'):
                ok = False
        beg = not beg
    if ok:
        ret += 1
    return ret

for i in range(n):
    mp.append(raw_input())
ans = 1
MOD = 1000003
for i in range(n):
    ans *= checkrow(i)
    ans %= MOD
for i in range(m):
    ans *= checkcol(i)
    ans %= MOD
print ans",['math']
"Mahmoud and Ehab are on the third stage of their adventures now. As you know, Dr. Evil likes sets. This time he won't show them any set from his large collection, but will ask them to create a new set to replenish his beautiful collection of sets.Dr. Evil has his favorite evil integer x. He asks Mahmoud and Ehab to find a set of n distinct non-negative integers such the bitwise-xor sum of the integers in it is exactly x. Dr. Evil doesn't like big numbers, so any number in the set shouldn't be greater than 106.","n, x = input().split()
n, x = int(n), int(x)

m1 = 2 ** 17
m2 = 2 ** 18

if n == 2 and x == 0:
    print(""NO"")
elif n == 1:
    a = [x]
elif n == 2 and x > 0:
    a = [0, x]
else:
    a = []
    ans = 0
    for i in range(1, n-2):
        ans ^= i
        a.append(i)
    if ans == x:
        a.append(m1)
        a.append(m2)
        a.append(m1+m2)
    else:
        a.append(m1)
        a.append(m1 ^ x ^ ans)
        a.append(0)
if not (n == 2 and x == 0):
    print(""YES"")
    print("" "".join([str(e) for e in a]))",['constructive algorithms']
"Warawreh created a great company called Nanosoft. The only thing that Warawreh still has to do is to place a large picture containing its logo on top of the company's building.The logo of Nanosoft can be described as four squares of the same size merged together into one large square. The top left square is colored with red, the top right square is colored with green, the bottom left square is colored with yellow and the bottom right square is colored with blue.An Example of some correct logos:An Example of some incorrect logos:Warawreh went to Adhami's store in order to buy the needed picture. Although Adhami's store is very large he has only one picture that can be described as a grid of $$$n$$$ rows and $$$m$$$ columns. The color of every cell in the picture will be green (the symbol 'G'), red (the symbol 'R'), yellow (the symbol 'Y') or blue (the symbol 'B').Adhami gave Warawreh $$$q$$$ options, in every option he gave him a sub-rectangle from that picture and told him that he can cut that sub-rectangle for him. To choose the best option, Warawreh needs to know for every option the maximum area of sub-square inside the given sub-rectangle that can be a Nanosoft logo. If there are no such sub-squares, the answer is $$$0$$$.Warawreh couldn't find the best option himself so he asked you for help, can you help him?","import sys
readline = sys.stdin.readline

def accumulate2d(X):
    N = len(X)
    M = len(X[0])
    
    for i in range(0, N):
        for j in range(1, M):
            X[i][j] += X[i][j-1]
    
    for j in range(0, M):
        for i in range(1, N):
            X[i][j] += X[i-1][j]
    
    return X

N, M, Q = map(int, readline().split())
table = [None]*100
table[ord('R')] = 0
table[ord('G')] = 1
table[ord('B')] = 2
table[ord('Y')] = 3

INF = 10**3
D = [[table[ord(s)] for s in readline().strip()] for _ in range(N)]
G = [[0]*M for _ in range(N)]

BS = 25
candi = []
geta = M
for i in range(N-1):
    for j in range(M-1):
        if D[i][j] == 0 and D[i][j+1] == 1 and D[i+1][j+1] == 2 and D[i+1][j] == 3:
            G[i][j] = 1
            nh, nw = i, j
            while True:
                k = G[nh][nw]
                fh, fw = nh-k, nw-k
                k2 = 2*(k+1)
                kh = k+1
                if fh < 0 or fw < 0 or N < fh+k2-1 or M < fw+k2-1:
                    break
                if any(D[fh][j] != 0 for j in range(fw, fw+kh)) or\
                any(D[j][fw] != 0 for j in range(fh, fh+kh)) or\
                any(D[fh][j] != 1 for j in range(fw+kh, fw+k2)) or\
                any(D[j][fw+k2-1] != 1 for j in range(fh, fh+kh)) or\
                any(D[j][fw+k2-1] != 2 for j in range(fh+kh, fh+k2)) or\
                any(D[fh+k2-1][j] != 2 for j in range(fw+kh, fw+k2)) or\
                any(D[fh+k2-1][j] != 3 for j in range(fw, fw+kh)) or\
                any(D[j][fw] != 3 for j in range(fh+kh, fh+k2)):
                    break
                G[nh][nw] += 1
            if G[nh][nw] > BS:
                candi.append((nh, nw))

 
Gnum = [None] + [[[0]*M for _ in range(N)] for _ in range(BS)]
for h in range(N):
    for w in range(M):
        if G[h][w] > 0:
            for k in range(1, min(BS, G[h][w])+1):
                Gnum[k][h][w] = 1

Gnum = [None] + [accumulate2d(g) for g in Gnum[1:]]


Ans = [None]*Q
for qu in range(Q):
    h1, w1, h2, w2 = map(lambda x: int(x)-1, readline().split())
    res = 0
    for k in range(min(BS, h2-h1+1, w2-w1+1), 0, -1):
        hs, ws = h1+k-1, w1+k-1
        he, we = h2-k, w2-k
        if hs <= he and ws <= we:
            cnt = Gnum[k][he][we]
            if hs:
                cnt -= Gnum[k][hs-1][we]
            if ws:
                cnt -= Gnum[k][he][ws-1]
            if hs and ws:
                cnt += Gnum[k][hs-1][ws-1]
            if cnt:
                res = k
                break
    
    for nh, nw in candi:
        if h1 <= nh <= h2 and w1 <= nw <= w2:
            res = max(res, min(nh-h1+1, h2-nh, nw-w1+1, w2-nw, G[nh][nw]))
    Ans[qu] = 4*res**2
print('\n'.join(map(str, Ans)))","['dp', 'binary search', 'implementation', 'data structures']"
"You are given a string $$$s$$$ consisting of lowercase Latin letters and $$$q$$$ queries for this string.Recall that the substring $$$s[l; r]$$$ of the string $$$s$$$ is the string $$$s_l s_{l + 1} \dots s_r$$$. For example, the substrings of ""codeforces"" are ""code"", ""force"", ""f"", ""for"", but not ""coder"" and ""top"".There are two types of queries:   $$$1~ pos~ c$$$ ($$$1 \le pos \le |s|$$$, $$$c$$$ is lowercase Latin letter): replace $$$s_{pos}$$$ with $$$c$$$ (set $$$s_{pos} := c$$$);  $$$2~ l~ r$$$ ($$$1 \le l \le r \le |s|$$$): calculate the number of distinct characters in the substring $$$s[l; r]$$$.","#!/usr/bin/env pypy
from __future__ import division, print_function
from collections import defaultdict, Counter, deque
from future_builtins import ascii, filter, hex, map, oct, zip
from itertools import imap as map, izip as zip
from __builtin__ import xrange as range
from math import ceil
from _continuation import continulet
from cStringIO import StringIO
from io import IOBase
import __pypy__
from bisect import bisect, insort, bisect_left, bisect_right
import sys
import os
import re
inf = float('inf')
mod = int(1e9) + 7
mod_ = 998244353
N = int(1e5 + 5)

'''
Check for special cases (n=1)
One wrong submission = 10 mins penalty!
do smth instead of nothing and stay organized
'''

s, n = [None]*2
t = [[0]*26 for i in range(4*N)]

def combine(v):
	global t
	for i in range(26):
		t[v][i] = t[2*v][i] + t[2*v+1][i]

def build(v, tl, tr):
	if tl == tr:
		t[v][ord(s[tl])-ord('a')] += 1
	else:
		tm = (tl + tr)//2
		build(2*v, tl, tm)
		build(2*v+1, tm+1, tr)
		combine(v)

def update(v, tl, tr, pos, new_val):
	if tl == tr:
		t[v] = [0]*26
		t[v][ord(new_val)-ord('a')] += 1
	else:
		tm = (tl + tr)//2
		if pos <= tm:
			update(2*v, tl, tm, pos, new_val)
		else:
			update(2*v+1, tm+1, tr, pos, new_val)
		combine(v)

def query(v, tl, tr, l, r):
	if l > tr or r < tl:
		return [0]*26
	if l <= tl and tr <= r:
		return t[v]
	tm = (tl + tr)//2
	ans1 = query(2*v, tl, tm, l, r)
	ans2 = query(2*v+1, tm+1, tr, l, r)
	ret = [0]*26
	for i in range(26):
		ret[i] = ans1[i] + ans2[i]
	return ret

def main():
	global s, n
	s = input()
	n = len(s)
	build(1, 0, n-1)
	for _ in range(int(input())):
		arr = input().split()
		if arr[0] == '1':
			pos, c = arr[1:]
			pos = int(pos)
			update(1, 0, n-1, pos-1, c)
		else:
			l, r = map(int, arr[1:])
			temp = query(1, 0, n-1, l-1, r-1)
			ans = 0
			for ele in temp:
				ans += int(ele > 0)
			print(ans)
 
BUFSIZE = 8192
class FastI(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = StringIO()
		self.newlines = 0
 
	def read(self):
		while True:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			if not b:
				break
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines = 0
		return self.buffer.read()
 
	def readline(self):
		while self.newlines == 0:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			self.newlines = b.count(""\n"") + (not b)
			ptr = self._buffer.tell()
			self._buffer.seek(0, 2), self._buffer.write(
				b), self._buffer.seek(ptr)
		self.newlines -= 1
		return self._buffer.readline()
class FastO(IOBase):
	def __init__(self, file):
		self._fd = file.fileno()
		self._buffer = __pypy__.builders.StringBuilder()
		self.write = lambda s: self._buffer.append(s)
 
	def flush(self):
		os.write(self._fd, self._buffer.build())
		self._buffer = __pypy__.builders.StringBuilder()
def print(*args, **kwargs):
	sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
	at_start = True
	for x in args:
		if not at_start:
			file.write(sep)
		file.write(str(x))
		at_start = False
	file.write(kwargs.pop(""end"", ""\n""))
	if kwargs.pop(""flush"", False):
		file.flush()
def gcd(x, y):
	while y:
		x, y = y, x % y
	return x
sys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
	def bootstrap(cont):
		call, arg = cont.switch()
		while True:
			call, arg = cont.switch(to=continulet(
				lambda _, f, args: f(*args), call, arg))
	cont = continulet(bootstrap)
	cont.switch()
	main()",['data structures']
"Let's define the sum of two permutations p and q of numbers 0, 1, ..., (n - 1) as permutation , where Perm(x) is the x-th lexicographically permutation of numbers 0, 1, ..., (n - 1) (counting from zero), and Ord(p) is the number of permutation p in the lexicographical order.For example, Perm(0) = (0, 1, ..., n - 2, n - 1), Perm(n! - 1) = (n - 1, n - 2, ..., 1, 0)Misha has two permutations, p and q. Your task is to find their sum.Permutation a = (a0, a1, ..., an - 1) is called to be lexicographically smaller than permutation b = (b0, b1, ..., bn - 1), if for some k following conditions hold: a0 = b0, a1 = b1, ..., ak - 1 = bk - 1, ak &lt; bk.","import sys
 
class SegmTree():
    def __init__(self, array=None):
        size = len(array)
        N = 1
        while N < size:
            N <<= 1
        self.N = N
        self.tree = [0] * (2*self.N)
        for i in range(size):
            self.tree[i+self.N] = array[i]
        self.build()
 
    def build(self):
        for i in range(self.N - 1, 0, -1):
            self.tree[i] = self.tree[i<<1] + self.tree[i<<1|1]
 
    def add(self, i, value=1):
        i += self.N
        while i > 0:
            self.tree[i] += value
            i >>= 1
    
    def get_sum(self, l, r):
        N = self.N
        l += N
        r += N
        result = 0
        while l < r:
            if l & 1:
                result += self.tree[l]
                l += 1
            if r & 1:
                r -= 1
                result += self.tree[r]
            l >>= 1
            r >>= 1
        return result
    
    def find_kth_nonzero(self, k):
        i = 1
        if k < 1 or k > self.tree[1]:
            return -1
        while i < self.N:
            i <<= 1
            if self.tree[i] < k:
                k -= self.tree[i]
                i |= 1
        return i - self.N
 
reader = (line.rstrip() for line in sys.stdin)
input = reader.__next__
 
n = int(input())
p = list(map(int, input().split()))
q = list(map(int, input().split()))
 
ord_p = []
ord_q = []
 
st = SegmTree([1] * n)
for i, val in enumerate(p):
    ord_p.append(st.get_sum(0, val))
    st.add(val, -1)
 
st = SegmTree([1] * n)
for i, val in enumerate(q):
    ord_q.append(st.get_sum(0, val))
    st.add(val, -1)
 
transfer = 0
for i in range(n-1, -1, -1):
    radix = n-i
    ord_p[i] = ord_p[i] + ord_q[i] + transfer
    if ord_p[i] < radix:
        transfer = 0
    else:
        transfer = 1
        ord_p[i] -= radix
 
st = SegmTree([1] * n)
for i in range(n):
    k = ord_p[i] + 1
    ord_q[i] = st.find_kth_nonzero(k)
    st.add(ord_q[i], -1)
 
print(*ord_q)",['data structures']
"You have an integer $$$n$$$. Let's define following tree generation as McDic's generation:  Make a complete and full binary tree of $$$2^{n} - 1$$$ vertices. Complete and full binary tree means a tree that exactly one vertex is a root, all leaves have the same depth (distance from the root), and all non-leaf nodes have exactly two child nodes.  Select a non-root vertex $$$v$$$ from that binary tree.  Remove $$$v$$$ from tree and make new edges between $$$v$$$'s parent and $$$v$$$'s direct children. If $$$v$$$ has no children, then no new edges will be made. You have a tree. Determine if this tree can be made by McDic's generation. If yes, then find the parent vertex of removed vertex in tree.","#!/usr/bin/python3

import array
import math
import os
import sys


DEBUG = 'DEBUG' in os.environ


def inp():
    return sys.stdin.readline().rstrip()


def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)


def solve(N, M, G):
    if N == 2:
        return [0, 1]

    degv = [set() for _ in range(5)]
    for i in range(M):
        d = len(G[i])
        if d == 0 or d >= 5:
            return []
        degv[d].add(i)

    layer_vcount = 1 << (N - 1)
    vs = degv[1]
    levels = bytearray(M)
    ans = []
    for level in range(1, N):
        #dprint('level', level, [x for x in levels])
        #dprint('vs', vs)
        #dprint('layer_vcount', layer_vcount)

        if len(vs) not in (layer_vcount - 1, layer_vcount):
            return []
        if len(vs) == layer_vcount - 1:
            if ans:
                return []
            if level == 1:
                sp_deg_off = -1
            else:
                sp_deg_off = 1
        else:
            sp_deg_off = 0
        #dprint('sp_deg_off', sp_deg_off)

        ndeg = 3 if level < N - 1 else 2
        us = set()
        ss = set()

        for v in vs:
            #dprint('v', v)
            levels[v] = level
            p = None
            for u in G[v]:
                if levels[u] == 0:
                    if p is not None:
                        return []
                    p = u
                    break
            #dprint('  p', p)
            if p is None:
                return []
            deg = len(G[p])
            #dprint('  deg', deg)

            if deg == ndeg:
                us.add(p)
            elif deg == ndeg + sp_deg_off:
                ss.add(p)
            elif sp_deg_off == 0 and deg == ndeg + 1:
                ss.add(p)
            else:
                return []

        #dprint('us', us)
        #dprint('ss', ss)

        if sp_deg_off != 0:
            if len(ss) != 1:
                return []
            (sp,) = list(ss)
            ans = [sp]
            us.add(sp)

        if sp_deg_off == 0:
            if level == N - 2:
                if ss:
                    return []
                if not ans:
                    li = list(us)
                    li.sort()
                    return li
            if len(ss) > 1:
                return []

        vs = us
        layer_vcount >>= 1

    return ans


def main():
    N = int(inp())
    M = (1 << N) - 2
    G = [[] for _ in range(M)]
    for _ in range(M - 1):
        a, b = [int(e) - 1 for e in inp().split()]
        G[a].append(b)
        G[b].append(a)

    ans = solve(N, M, G)
    print(len(ans))
    if ans:
        print(*[v + 1 for v in ans])


if __name__ == '__main__':
    main()","['constructive algorithms', 'implementation', 'trees']"
"Anatoly lives in the university dorm as many other students do. As you know, cockroaches are also living there together with students. Cockroaches might be of two colors: black and red. There are n cockroaches living in Anatoly's room.Anatoly just made all his cockroaches to form a single line. As he is a perfectionist, he would like the colors of cockroaches in the line to alternate. He has a can of black paint and a can of red paint. In one turn he can either swap any two cockroaches, or take any single cockroach and change it's color.Help Anatoly find out the minimum number of turns he needs to make the colors of cockroaches in the line alternate.","from collections import Counter,defaultdict,deque
#alph = 'abcdefghijklmnopqrstuvwxyz'
#from math import factorial as fact
#import math

#tt = 1#int(input())
#total=0
#n = int(input())
#n,m,k = [int(x) for x in input().split()]
#n = int(input())
#n,m = [int(x) for x in input().split()]


n = int(input())
if n==1:
   print(0)
   exit()
c = 0
arr = [x for x in input()]+['a','a']
v1 = 'rb'*(n//2)+'r'*(n%2)
r1,r2,b1,b2 = 0,0,0,0

for i in range(n):
   if arr[i] =='r':
      if v1[i] =='b':
         b1+=1
      else:
         b2+=1
   else:
      if v1[i] == 'r':
         r1+=1
      else:
         r2+=1
print(min(max(r1,b1),max(r2,b2)))",['greedy']
"Petya loves volleyball very much. One day he was running late for a volleyball match. Petya hasn't bought his own car yet, that's why he had to take a taxi. The city has n junctions, some of which are connected by two-way roads. The length of each road is defined by some positive integer number of meters; the roads can have different lengths.Initially each junction has exactly one taxi standing there. The taxi driver from the i-th junction agrees to drive Petya (perhaps through several intermediate junctions) to some other junction if the travel distance is not more than ti meters. Also, the cost of the ride doesn't depend on the distance and is equal to ci bourles. Taxis can't stop in the middle of a road. Each taxi can be used no more than once. Petya can catch taxi only in the junction, where it stands initially.At the moment Petya is located on the junction x and the volleyball stadium is on the junction y. Determine the minimum amount of money Petya will need to drive to the stadium.","from heapq import *

f = lambda: map(int, input().split())
inf = 1e13

n, m = f()
x, y = f()
p = [[] for i in range(n + 1)]
for j in range(m):
    u, v, w = f()
    p[u].append((v, w))
    p[v].append((u, w))
d = [(0, 0)] + [tuple(f()) for k in range(n)]

C, T = {x: 0}, {x: 0}
h = [(0, x, 0, 1)]
while h:
    c, u, t, q = heappop(h)
    if u == y: exit(print(c))
    dt, dc = d[u]
    if t < dt and q: heappush(h, (c + dc, u, dt, 0))
    for v, w in p[u]:
        dt = t - w
        if dt >= 0:
            if c < C.get(v, inf) or dt > T.get(v, -1):
                C[v], T[v] = c, dt
                heappush(h, (c, v, dt, 1))
print(-1)",['shortest paths']
"You have a string s = s1s2...s|s|, where |s| is the length of string s, and si its i-th character. Let's introduce several definitions:  A substring s[i..j] (1 ≤ i ≤ j ≤ |s|) of string s is string sisi + 1...sj.  The prefix of string s of length l (1 ≤ l ≤ |s|) is string s[1..l].  The suffix of string s of length l (1 ≤ l ≤ |s|) is string s[|s| - l + 1..|s|]. Your task is, for any prefix of string s which matches a suffix of string s, print the number of times it occurs in string s as a substring.","def z_advanced(s):
    """"""An advanced computation of Z-values of a string.""""""

    Z = [0] * len(s)
    Z[0] = len(s)

    rt = 0
    lt = 0

    for k in range(1, len(s)):
        if k > rt:
            # If k is outside the current Z-box, do naive computation.
            n = 0
            while n + k < len(s) and s[n] == s[n + k]:
                n += 1
            Z[k] = n
            if n > 0:
                lt = k
                rt = k + n - 1
        else:
            # If k is inside the current Z-box, consider two cases.

            p = k - lt  # Pair index.
            right_part_len = rt - k + 1

            if Z[p] < right_part_len:
                Z[k] = Z[p]
            else:
                i = rt + 1
                while i < len(s) and s[i] == s[i - k]:
                    i += 1
                Z[k] = i - k

                lt = k
                rt = i - 1
    return Z

def kmptab(s):
    tab = [0]*len(s)
    i = 1
    j = 0
    while i < len(s):
        if s[i] == s[j]:
            tab[i] = j + 1
            i += 1
            j += 1
        else:
            if j != 0:
                j = tab[j-1]
            else:
                i += 1
    return tab

if __name__ == '__main__':
    s = input()
    tab = kmptab(s)
    my_set = set()
    i = len(s)
    while i != 0:
        my_set.add(i)
        i = tab[i-1]
    V = []
    dict = {}
    for i in my_set:
        V.append(i)
        dict[i] = 0
    Z = z_advanced(s)

    v = []
    V.sort()
    my_tab = [0]*(len(s)+1)
    # print(Z)
    for i in Z:
        my_tab[i] += 1
    somme = 0
    # print(my_tab)
    for i in range(len(my_tab)-1, -1, -1):

        my_tab[i] += somme
        somme = my_tab[i]
    # print(my_tab)
    for i in dict:
        dict[i] = my_tab[i]
        v.append((dict[i], i))
    v.sort(key=lambda tup: tup[1])
    print(len(v))
    for i in v:
        print(str(i[1]) + "" "" + str(i[0]))","['dp', 'two pointers', 'string suffix structures', 'strings']"
"Kuro has just learned about permutations and he is really excited to create a new permutation type. He has chosen $$$n$$$ distinct positive integers and put all of them in a set $$$S$$$. Now he defines a magical permutation to be: A permutation of integers from $$$0$$$ to $$$2^x - 1$$$, where $$$x$$$ is a non-negative integer.  The bitwise xor of any two consecutive elements in the permutation is an element in $$$S$$$.Since Kuro is really excited about magical permutations, he wants to create the longest magical permutation possible. In other words, he wants to find the largest non-negative integer $$$x$$$ such that there is a magical permutation of integers from $$$0$$$ to $$$2^x - 1$$$. Since he is a newbie in the subject, he wants you to help him find this value of $$$x$$$ and also the magical permutation for that $$$x$$$.","def size(k):
    return int(math.log2(k))
def v2(k):
    if k%2==1:
        return 0
    else:
        return 1+v2(k//2)
n=int(input())
s=list(map(int,input().split()))
import math
s.sort()
used=[]
use=0
found={0:1}
good=0
for guy in s:
    big=size(guy)
    if guy not in found:
        used.append(guy)
        use+=1
        new=[]
        for boi in found:
            new.append(boi^guy)
        for guy in new:
            found[guy]=1
        if use==big+1:
            good=use
if good==0:
    print(0)
    print(0)
else:
    useful=used[:good]
    perm=[""0""]
    curr=0
    for i in range(2**good-1):
        curr^=useful[v2(i+1)]
        perm.append(str(curr))
    print(good)
    print("" "".join(perm))","['graphs', 'constructive algorithms', 'bitmasks', 'math', 'data structures', 'brute force']"
"A new dog show on TV is starting next week. On the show dogs are required to demonstrate bottomless stomach, strategic thinking and self-preservation instinct. You and your dog are invited to compete with other participants and naturally you want to win!On the show a dog needs to eat as many bowls of dog food as possible (bottomless stomach helps here). Dogs compete separately of each other and the rules are as follows:At the start of the show the dog and the bowls are located on a line. The dog starts at position x = 0 and n bowls are located at positions x = 1, x = 2, ..., x = n. The bowls are numbered from 1 to n from left to right. After the show starts the dog immediately begins to run to the right to the first bowl.The food inside bowls is not ready for eating at the start because it is too hot (dog's self-preservation instinct prevents eating). More formally, the dog can eat from the i-th bowl after ti seconds from the start of the show or later.It takes dog 1 second to move from the position x to the position x + 1. The dog is not allowed to move to the left, the dog runs only to the right with the constant speed 1 distance unit per second. When the dog reaches a bowl (say, the bowl i), the following cases are possible:  the food had cooled down (i.e. it passed at least ti seconds from the show start): the dog immediately eats the food and runs to the right without any stop,  the food is hot (i.e. it passed less than ti seconds from the show start): the dog has two options: to wait for the i-th bowl, eat the food and continue to run at the moment ti or to skip the i-th bowl and continue to run to the right without any stop. After T seconds from the start the show ends. If the dog reaches a bowl of food at moment T the dog can not eat it. The show stops before T seconds if the dog had run to the right of the last bowl.You need to help your dog create a strategy with which the maximum possible number of bowls of food will be eaten in T seconds.","# using the min-heap 
from heapq import heappush,heappop
bowels,Time = map(int,input().split())
myLine = [-int(b) for b in input().split()]
gulp = []; eat = 0
for i in range(1,min(bowels+1,Time)):
    # redundant (now that i look at it. the min does that already)
    if i >= Time:
        break
    while gulp and -gulp[0] >= Time - i:
        # remove the bowel with the highest time penalty 
        heappop(gulp)
    # Check if the option is viable
    if -myLine[i-1] < Time:
        # Remove the step penalty and store the remaining 
        heappush(gulp,myLine[i-1] + i)
    eat = max(len(gulp),eat)
print (eat)","['data structures', 'greedy']"
"A system of n vessels with water is given. Several pairs of vessels are connected by tubes with transfusion mechanisms. One may transfer an integer amount of liters of water between two vessels connected by such tube (tube works in both directions). There might be multiple tubes between two vessels. Total number of tubes equals e. Volume of each vessel equals v liters. Of course, the amount of the water in any vessel cannot exceed v liters in the process of transfusions.Given the initial amounts ai of water in the vessels and the desired amounts bi find a sequence of transfusions that deals with the task. Total number of transfusions must not exceed 2·n2.","n,v,e=map(int,raw_input().split())
a=[0]*(n+10)
b=[0]*(n+10)
E=[[] for i in xrange(n)]
f=[i for i in xrange(n)]
vis=[0]*(n+10)
ans=[]
rem=0
def fd(x):
	if f[x]==x: return x
	else:
		f[x]=fd(f[x])
		return f[x]
def dfs2(u,f,ty):
	global rem
	if rem<=a[u] and rem>0:
		if ty==0: ans.append([u,f,rem])
		else: ans.append([f,u,rem])
		a[u]-=rem
		a[f]+=rem
		rem=0
	else:
		rem-=a[u]
		for v in E[u]:
			if v==f or vis[v]: continue
			dfs2(v,u,ty)
			if rem==0: break
		if f!=-1:
			if ty==0: ans.append([u,f,a[u]])
			else: ans.append([f,u,a[u]])
			a[f]+=a[u]
			a[u]=0				
def solve(c):
	if a[c]==b[c]: return
	global rem
	if a[c]<b[c]:
		rem=b[c]
		dfs2(c,-1,0)
	else:
		for i in xrange(n): a[i],b[i]=v-a[i],v-b[i]
		rem=b[c]
		dfs2(c,-1,1)
		for i in xrange(n): a[i],b[i]=v-a[i],v-b[i]		
def dfs(u,f):
	for v in E[u]:
		if v==f: continue
		dfs(v,u)
	solve(u)
	vis[u]=1
a=map(int,raw_input().split())
b=map(int,raw_input().split())
for i in xrange(e):
	x,y=map(lambda x:int(x)-1,raw_input().split())
	if fd(x)!=fd(y):
		E[x].append(y)
		E[y].append(x)
		f[fd(x)]=fd(y)
for i in xrange(n):
	if fd(i)!=i: continue
	sa=sum(a[j] for j in xrange(n) if (fd(j)==i))
	sb=sum(b[j] for j in xrange(n) if (fd(j)==i))
	if sa!=sb:
		print ""NO""
		exit()
	dfs(i,-1)
print len(ans)
for c in ans:
	print c[0]+1,c[1]+1,c[2]","['constructive algorithms', 'dfs and similar', 'trees', 'graphs']"
"Andrewid the Android is a galaxy-known detective. Now he does not investigate any case and is eating chocolate out of boredom.A bar of chocolate can be presented as an n × n table, where each cell represents one piece of chocolate. The columns of the table are numbered from 1 to n from left to right and the rows are numbered from top to bottom. Let's call the anti-diagonal to be a diagonal that goes the lower left corner to the upper right corner of the table. First Andrewid eats all the pieces lying below the anti-diagonal. Then he performs the following q actions with the remaining triangular part: first, he chooses a piece on the anti-diagonal and either direction 'up' or 'left', and then he begins to eat all the pieces starting from the selected cell, moving in the selected direction until he reaches the already eaten piece or chocolate bar edge.After each action, he wants to know how many pieces he ate as a result of this action.","import sys
from bisect import bisect

def input():
	return sys.stdin.readline().strip()

def solve():
	n, q = map(int, input().split())
	was = set()
	Q = [None]*q
	all = [0]*(2*q)
	for i in range(q):
		x, y, t = input().split()
		x, y = int(x), int(y)
		Q[i] = (x, y, t)
		all[2*i] = x
		all[2*i+1] = y
	all.sort()
	V = [0]*(4*q)
	H = [0]*(4*q)
	for x, y, t in Q:
		if (x,y) in was:
			print(0)
		else:
			was.add((x,y))
			if t == 'L':
				TA = H
				TB = V
			else:
				x, y = y, x
				TA = V
				TB = H
			v = bisect(all, y) - 1 + q + q
			r = 0
			while v > 0:
				r = max(r, TA[v])
				v //= 2
			c = x - r
			print(c)
			r = bisect(all, x) - 1 + q + q
			l = bisect(all, x - c) + q + q
			while l <= r:
				if l % 2 == 1:
					TB[l] = max(TB[l], y)
				if r % 2 == 0:
					TB[r] = max(TB[r], y)
				l = (l+1)//2
				r = (r-1)//2

solve()","['data structures', 'binary search']"
"You are given circular array a0, a1, ..., an - 1. There are two types of operations with it:   inc(lf, rg, v) — this operation increases each element on the segment [lf, rg] (inclusively) by v;  rmq(lf, rg) — this operation returns minimal value on the segment [lf, rg] (inclusively). Assume segments to be circular, so if n = 5 and lf = 3, rg = 1, it means the index sequence: 3, 4, 0, 1.Write program to process given sequence of operations.","import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n=int(input())
a=list(map(int,input().split()))

class st:
	def __init__(self, size):
		N = 1
		h = 0
		while N < size:
			N <<= 1
			h += 1
		self.N = N
		self.h = h
		self.t = [float('inf')] * (2 * N)
		self.d = [0] * N
    
	def apply(self, p, value):
		self.t[p] += value
		if (p < self.N):
			self.d[p] += value
    
	def build(self, p):
		t = self.t
		d = self.d
		while p > 1:
			p >>= 1
			t[p] = min(t[p<<1], t[p<<1|1]) + d[p]
    
	def rebuild(self):
		t = self.t
		for p in reversed(range(1, self.N)):
			t[p] = min(t[p<<1], t[p<<1|1])
    
	def push(self, p):
		d = self.d
		for s in range(self.h, 0, -1):
			i = p >> s
			if d[i] != 0:
				self.apply(i<<1, d[i])
				self.apply(i<<1|1, d[i])
				d[i] = 0
    
	def inc(self, l, r, value):
		if l >= r:
			return

		l += self.N
		r += self.N
		l0, r0 = l, r
		while l < r:
			if l & 1:
				self.apply(l, value)
				l += 1
			if r & 1:
				r -= 1
				self.apply(r, value)
			l >>= 1
			r >>= 1
		self.build(l0)
		self.build(r0 - 1)
    
	def query(self, l, r):
		if l >= r:
			return float('inf')

		t = self.t
		l += self.N
		r += self.N
		self.push(l)
		self.push(r - 1)
		res = float('inf')
		while l < r:
			if l & 1:
				res = min(res, t[l])
				l += 1
			if r & 1:
				r -= 1
				res = min(t[r], res)
			l >>= 1
			r >>= 1
		return res

se=st(n)
N=se.N
for i in range(n):
	se.t[i+N]=a[i]
se.rebuild()

q=int(input())
for i in range(q):
	b=list(map(int,input().split()))
	if len(b)==2:
		l=b[0]
		r=b[1]
		if l>r:
			print(min(se.query(l,n),se.query(0,r+1)))
		else:print(se.query(l,r+1))
	else:
		l=b[0]
		r=b[1]
		v=b[2]
		if l>r:
			se.inc(0,r+1,v)
			se.inc(l,n,v)
		else:se.inc(l,r+1,v)",['data structures']
"You are given a positive integer $$$D$$$. Let's build the following graph from it:   each vertex is a divisor of $$$D$$$ (not necessarily prime, $$$1$$$ and $$$D$$$ itself are also included);  two vertices $$$x$$$ and $$$y$$$ ($$$x &gt; y$$$) have an undirected edge between them if $$$x$$$ is divisible by $$$y$$$ and $$$\frac x y$$$ is a prime;  the weight of an edge is the number of divisors of $$$x$$$ that are not divisors of $$$y$$$. For example, here is the graph for $$$D=12$$$:   Edge $$$(4,12)$$$ has weight $$$3$$$ because $$$12$$$ has divisors $$$[1,2,3,4,6,12]$$$ and $$$4$$$ has divisors $$$[1,2,4]$$$. Thus, there are $$$3$$$ divisors of $$$12$$$ that are not divisors of $$$4$$$ — $$$[3,6,12]$$$.There is no edge between $$$3$$$ and $$$2$$$ because $$$3$$$ is not divisible by $$$2$$$. There is no edge between $$$12$$$ and $$$3$$$ because $$$\frac{12}{3}=4$$$ is not a prime.Let the length of the path between some vertices $$$v$$$ and $$$u$$$ in the graph be the total weight of edges on it. For example, path $$$[(1, 2), (2, 6), (6, 12), (12, 4), (4, 2), (2, 6)]$$$ has length $$$1+2+2+3+1+2=11$$$. The empty path has length $$$0$$$.So the shortest path between two vertices $$$v$$$ and $$$u$$$ is the path that has the minimal possible length.Two paths $$$a$$$ and $$$b$$$ are different if there is either a different number of edges in them or there is a position $$$i$$$ such that $$$a_i$$$ and $$$b_i$$$ are different edges.You are given $$$q$$$ queries of the following form:   $$$v$$$ $$$u$$$ — calculate the number of the shortest paths between vertices $$$v$$$ and $$$u$$$. The answer for each query might be large so print it modulo $$$998244353$$$.","import sys, __pypy__
range = xrange
input = raw_input

MOD = 998244353
mulmod = __pypy__.intop.int_mulmod

inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

D = inp[ii]; ii += 1
q = inp[ii]; ii += 1

U = inp[ii + 0: ii + 2 * q: 2]
V = inp[ii + 1: ii + 2 * q: 2]

Pdiv = []
if D & 1 == 0:
    Pdiv.append(2)
    while D & 1 == 0:
        D >>= 1

i = 3
while i * i <= D:
    if D % i == 0:
        while D % i == 0:
            D //= i
        Pdiv.append(i)
    i += 2
if D > 1:
    Pdiv.append(D)


fac = [1]
for i in range(1,200):
    fac.append(mulmod(fac[-1], i, MOD))
ifac = [pow(f, MOD-2, MOD) for f in fac]

def multi(A):
    prod = fac[sum(A)]
    for a in A:
        prod = mulmod(prod, ifac[a], MOD)
    return prod

out = []
for _ in range(q):
    u = U[_]
    v = V[_]
    if u > v:
        v,u = u,v

    add = []
    rem = []

    for p in Pdiv:
        cu = 0
        while u % p == 0:
            u //= p
            cu += 1

        cv = 0
        while v % p == 0:
            v //= p
            cv += 1

        if cu > cv:
            rem.append(cu - cv)
        elif cu < cv:
            add.append(cv - cu)
    out.append(mulmod(multi(add), multi(rem), MOD))

print '\n'.join(str(x) for x in out)","['greedy', 'graphs', 'combinatorics', 'number theory', 'math']"
"Roma is playing a new expansion for his favorite game World of Darkraft. He made a new character and is going for his first grind.Roma has a choice to buy exactly one of $$$n$$$ different weapons and exactly one of $$$m$$$ different armor sets. Weapon $$$i$$$ has attack modifier $$$a_i$$$ and is worth $$$ca_i$$$ coins, and armor set $$$j$$$ has defense modifier $$$b_j$$$ and is worth $$$cb_j$$$ coins.After choosing his equipment Roma can proceed to defeat some monsters. There are $$$p$$$ monsters he can try to defeat. Monster $$$k$$$ has defense $$$x_k$$$, attack $$$y_k$$$ and possesses $$$z_k$$$ coins. Roma can defeat a monster if his weapon's attack modifier is larger than the monster's defense, and his armor set's defense modifier is larger than the monster's attack. That is, a monster $$$k$$$ can be defeated with a weapon $$$i$$$ and an armor set $$$j$$$ if $$$a_i &gt; x_k$$$ and $$$b_j &gt; y_k$$$. After defeating the monster, Roma takes all the coins from them. During the grind, Roma can defeat as many monsters as he likes. Monsters do not respawn, thus each monster can be defeated at most one.Thanks to Roma's excessive donations, we can assume that he has an infinite amount of in-game currency and can afford any of the weapons and armor sets. Still, he wants to maximize the profit of the grind. The profit is defined as the total coins obtained from all defeated monsters minus the cost of his equipment. Note that Roma must purchase a weapon and an armor set even if he can not cover their cost with obtained coins.Help Roma find the maximum profit of the grind.","from bisect import bisect_right
from operator import itemgetter

# quick input by @pajenegod
import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

class SegmTree:
    def __init__(self, size):
        N = 1
        h = 0
        while N < size:
            N <<= 1
            h += 1
        self.N = N
        self.h = h
        self.t = [0] * (2 * N)
        self.d = [0] * N
    
    def apply(self, p, value):
        self.t[p] += value
        if (p < self.N):
            self.d[p] += value
    
    def build(self, p):
        t = self.t
        d = self.d
        while p > 1:
            p >>= 1
            t[p] = max(t[p<<1], t[p<<1|1]) + d[p]
    
    def rebuild(self):
        t = self.t
        for p in reversed(range(1, self.N)):
            t[p] = max(t[p<<1], t[p<<1|1])
    
    def push(self, p):
        d = self.d
        for s in range(self.h, 0, -1):
            i = p >> s
            if d[i] != 0:
                self.apply(i<<1, d[i])
                self.apply(i<<1|1, d[i])
                d[i] = 0
    
    def inc(self, l, r, value):
        if l >= r:
            return
        
        l += self.N
        r += self.N
        l0, r0 = l, r
        while l < r:
            if l & 1:
                self.apply(l, value)
                l += 1
            if r & 1:
                r -= 1
                self.apply(r, value)
            l >>= 1
            r >>= 1
        self.build(l0)
        self.build(r0 - 1)
    
    def query(self, l, r):
        if l >= r:
            return -float('inf')
        
        t = self.t
        l += self.N
        r += self.N
        self.push(l)
        self.push(r - 1)
        res = -float('inf')
        while l < r:
            if l & 1:
                res = max(res, t[l])
                l += 1
            if r & 1:
                r -= 1
                res = max(t[r], res)
            l >>= 1
            r >>= 1
        return res
 
n, m, p = map(int, input().split())
weapon = []
for _ in range(n):
    a, ca = map(int, input().split())
    weapon.append((a, ca))
 
defense = []
for _ in range(m):
    b, cb = map(int, input().split())
    defense.append((b, cb))
 
monster = []
for _ in range(p):
    x, y, z = map(int, input().split())
    monster.append((x, y, z))
 
weapon.sort(key=itemgetter(0))
defense.sort(key=itemgetter(0))
monster.sort(key=itemgetter(0))
 
st = SegmTree(m)
N = st.N
t = st.t
for i, (b, cb) in enumerate(defense):
    t[i + N] = -cb
st.rebuild()
 
i = 0
maxScore = -float('inf')
for a, ca in weapon:
    st.inc(0, m, -ca)
    while i < p and monster[i][0] < a:
        x, y, z = monster[i]
        goodDef = bisect_right(defense, (y + 1, 0))
        st.inc(goodDef, m, z)
        i += 1
    currScore = st.query(0, m)
    maxScore = max(maxScore, currScore)
    st.inc(0, m, ca)
print(maxScore)","['data structures', 'two pointers', 'sortings']"
"Boy Dima gave Julian a birthday present — set $$$B$$$ consisting of positive integers. However, he didn't know, that Julian hates sets, but enjoys bipartite graphs more than anything else!Julian was almost upset, but her friend Alex said, that he can build an undirected graph using this set in such a way: let all integer numbers be vertices, then connect any two $$$i$$$ and $$$j$$$ with an edge if $$$|i - j|$$$ belongs to $$$B$$$.Unfortunately, Julian doesn't like the graph, that was built using $$$B$$$. Alex decided to rectify the situation, so he wants to erase some numbers from $$$B$$$, so that graph built using the new set is bipartite. The difficulty of this task is that the graph, Alex has to work with, has an infinite number of vertices and edges! It is impossible to solve this task alone, so Alex asks you for help. Write a program that erases a subset of minimum size from $$$B$$$ so that graph constructed on the new set is bipartite.Recall, that graph is bipartite if all its vertices can be divided into two disjoint sets such that every edge connects a vertex from different sets.","n = int(input())
B = list(map(int, input().split()))
A = []
for i in range(100):
    A.append([])
for i in B:
    x = i
    c = 0
    while x % 2 == 0:
        x //= 2
        c += 1
    A[c].append(i)
mlen = 0
f = 1
for lst in A:
    mlen = max(mlen, len(lst))
ans = []
for lst in A:
    if len(lst) == mlen and f:
        f = 0
    else:
        for x in lst:
            ans.append(x)
print(len(ans))
print(' '.join(list(map(str, ans))))","['number theory', 'bitmasks', 'math']"
"Kefa decided to celebrate his first big salary by going to the restaurant. He lives by an unusual park. The park is a rooted tree consisting of n vertices with the root at vertex 1. Vertex 1 also contains Kefa's house. Unfortunaely for our hero, the park also contains cats. Kefa has already found out what are the vertices with cats in them.The leaf vertices of the park contain restaurants. Kefa wants to choose a restaurant where he will go, but unfortunately he is very afraid of cats, so there is no way he will go to the restaurant if the path from the restaurant to his house contains more than m consecutive vertices with cats. Your task is to help Kefa count the number of restaurants where he can go.","import sys
import time

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split()) 
def get_list(): return list(map(int, sys.stdin.readline().strip().split())) 
mod = int(1e9)+7		

n, m = rinput()
a = get_list()
g = [[] for _ in range(n)]
v = [0]*n

for _ in range(n-1):
	x, y = rinput()
	g[x-1].append(y-1)
	g[y-1].append(x-1)

ans = i = 0
q = [(0, 0)]

while i<len(q):
    x, N = q[i]
    v[x] = 1
    if a[x]+N<=m:
        L = 1
        for y in g[x]:
            if not v[y]:
                L = 0
                q.append((y, a[x]*(a[x]+N)))
        if L:
            ans+=1
    i+=1

print(ans)","['dfs and similar', 'trees', 'graphs']"
"Lindsey Buckingham told Stevie Nicks ""Go your own way"". Nicks is now sad and wants to go away as quickly as possible, but she lives in a 2D hexagonal world.Consider a hexagonal tiling of the plane as on the picture below.  Nicks wishes to go from the cell marked $$$(0, 0)$$$ to a certain cell given by the coordinates. She may go from a hexagon to any of its six neighbors you want, but there is a cost associated with each of them. The costs depend only on the direction in which you travel. Going from $$$(0, 0)$$$ to $$$(1, 1)$$$ will take the exact same cost as going from $$$(-2, -1)$$$ to $$$(-1, 0)$$$. The costs are given in the input in the order $$$c_1$$$, $$$c_2$$$, $$$c_3$$$, $$$c_4$$$, $$$c_5$$$, $$$c_6$$$ as in the picture below.  Print the smallest cost of a path from the origin which has coordinates $$$(0, 0)$$$ to the given cell.","import sys
input = sys.stdin.readline

def main():
    x, y = map(int, input().split())
    clst = list(map(int, input().split()))
    clst[0] = min(clst[0], clst[5] + clst[1])
    clst[1] = min(clst[1], clst[0] + clst[2])
    clst[2] = min(clst[2], clst[1] + clst[3])
    clst[3] = min(clst[3], clst[2] + clst[4])
    clst[4] = min(clst[4], clst[3] + clst[5])
    clst[5] = min(clst[5], clst[4] + clst[0])
    directions = [(1, 1), (0, 1), (-1, 0), (-1, -1), (0, -1), (1, 0)]
    ans = 10 ** 20
    for i in range(6):
        dx1, dy1 = directions[i]
        dx2, dy2 = directions[(i + 1) % 6]
        a = (x * dy2 - y * dx2) // (dx1 * dy2 - dy1 * dx2)
        b = (x * dy1 - y * dx1) // (dx2 * dy1 - dy2 * dx1)
        if a < 0 or b < 0:
            continue
        ans = min(ans, clst[i] * a + clst[(i + 1) % 6] * b)
    print(ans)
    
for _ in range(int(input())):
    main()","['greedy', 'constructive algorithms', 'shortest paths', 'math', 'implementation', 'brute force']"
"Someone give a strange birthday present to Ivan. It is hedgehog — connected undirected graph in which one vertex has degree at least $$$3$$$ (we will call it center) and all other vertices has degree 1. Ivan thought that hedgehog is too boring and decided to make himself $$$k$$$-multihedgehog.Let us define $$$k$$$-multihedgehog as follows: $$$1$$$-multihedgehog is hedgehog: it has one vertex of degree at least $$$3$$$ and some vertices of degree 1. For all $$$k \ge 2$$$, $$$k$$$-multihedgehog is $$$(k-1)$$$-multihedgehog in which the following changes has been made for each vertex $$$v$$$ with degree 1: let $$$u$$$ be its only neighbor; remove vertex $$$v$$$, create a new hedgehog with center at vertex $$$w$$$ and connect vertices $$$u$$$ and $$$w$$$ with an edge. New hedgehogs can differ from each other and the initial gift. Thereby $$$k$$$-multihedgehog is a tree. Ivan made $$$k$$$-multihedgehog but he is not sure that he did not make any mistakes. That is why he asked you to check if his tree is indeed $$$k$$$-multihedgehog.","from collections import deque
n,k = map(int,input().split())
d = {}
for i in range(n):
    d[i+1] = set()
for i in range(n-1):
    u,v = map(int,input().split())
    d[u].add(v)
    d[v].add(u)
dist = {}
prev = {}
dist[1] = 0
q = deque()
q.append(1)
while len(q) >0:
    cur =  q.popleft()
    for x in d[cur]:
        if x not in dist:
            prev[x] = cur
            dist[x] = dist[cur]+1
            q.append(x)
answer = True
if k > dist[cur]:
    answer = False
else:
    for i in range(k):
        cur = prev[cur]
    dist2 = {}
    dist2[cur] = 0
    q = deque()
    q.append(cur)
    while len(q) >0:
        cur2 =  q.popleft()
        if cur2 == cur and len(d[cur]) < 3:
            answer = False
            break
        if len(d[cur2]) == 1:
            if dist2[cur2] != k:
                answer = False
                break
        elif len(d[cur2]) < 4 and cur2 != cur:
            answer = False
            break
        for x in d[cur2]:
            if x not in dist2:
                dist2[x] = dist2[cur2]+1
                q.append(x)
if answer:
    print(""Yes"")
else:
    print(""No"")","['graphs', 'trees', 'shortest paths']"
"Once Petya was in such a good mood that he decided to help his mum with the washing-up. There were n dirty bowls in the sink. From the geometrical point of view each bowl looks like a blunted cone. We can disregard the width of the walls and bottom. Petya puts the clean bowls one on another naturally, i. e. so that their vertical axes coincide (see the picture). You will be given the order in which Petya washes the bowls. Determine the height of the construction, i.e. the distance from the bottom of the lowest bowl to the top of the highest one.","import sys
from array import array  # noqa: F401


def input1():
    with open('input.txt') as fp:
        return fp.readlines()


def output1(ans: str):
    with open('output.txt', mode='w') as fp:
        fp.write(ans)


def input2():
    return [line.decode('utf-8') for line in sys.stdin.buffer.readlines()]


def output2(ans):
    print(ans)


submit = 1
if submit:
    input = input1
    output = output1
else:
    input = input2
    output = output2


s = input()
n = int(s[0])
bowls = [tuple(map(float, line.split())) for line in s[1:]]
ans = bowls[0][0]
bottom = [0.0] * n
eps = 1e-9

for i in range(1, n):
    hi, ri, Ri = bowls[i]
    res = bottom[i - 1]

    for j in range(i - 1, -1, -1):
        hj, rj, Rj = bowls[j]
        x = 0.0

        if Rj <= ri:
            x = hj
        elif Rj >= Ri:
            x = max((Ri - rj) / (Rj - rj) * hj - hi, (ri - rj) / (Rj - rj) * hj)
        else:
            x = max(hj - (Rj - ri) / (Ri - ri) * hi, (ri - rj) / (Rj - rj) * hj)

        res = max(res, x + bottom[j])

    bottom[i] = res
    ans = max(ans, bottom[i] + hi)

output('{:.10f}'.format(ans))","['implementation', 'geometry']"
"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.","n = int(input())
points = set()
starts = {}
ends = {}

for i in range(n):
    a, b = map(int, input().split())
    points.add(a)
    points.add(b)
    starts[a] = 1 + starts.get(a, 0)
    ends[b] = 1 + ends.get(b, 0)

spoints = sorted(points)

density_stats = {}

prev_point = spoints[0]
density = 0
for cur_point in spoints:
    interval_length = cur_point - prev_point - 1
    if interval_length > 0:
        density_stats[density] = interval_length + density_stats.get(density, 0)

    starts_here = starts.get(cur_point, 0)
    density += starts_here
    density_stats[density] = 1 + density_stats.get(density, 0)

    ends_here = ends.get(cur_point, 0)
    density -= ends_here
    prev_point = cur_point

for i in range(1, n + 1):
    print(density_stats.get(i, 0), end=' ')","['data structures', 'implementation', 'sortings']"
"Roman planted a tree consisting of n vertices. Each vertex contains a lowercase English letter. Vertex 1 is the root of the tree, each of the n - 1 remaining vertices has a parent in the tree. Vertex is connected with its parent by an edge. The parent of vertex i is vertex pi, the parent index is always less than the index of the vertex (i.e., pi &lt; i).The depth of the vertex is the number of nodes on the path from the root to v along the edges. In particular, the depth of the root is equal to 1.We say that vertex u is in the subtree of vertex v, if we can get from u to v, moving from the vertex to the parent. In particular, vertex v is in its subtree.Roma gives you m queries, the i-th of which consists of two numbers vi, hi. Let's consider the vertices in the subtree vi located at depth hi. Determine whether you can use the letters written at these vertices to make a string that is a palindrome. The letters that are written in the vertexes, can be rearranged in any order to make a palindrome, but all letters should be used.","from sys import stdin, stdout
from itertools import repeat
def main():
    n, m = map(int, stdin.readline().split())
    a = map(int, stdin.readline().split(), repeat(10, n - 1))
    last = [None] * (n + 10)
    ne = [None] * (n + 10)
    for i, x in enumerate(a, 2):
        ne[i] = last[x]
        last[x] = i
    s = 'a' + stdin.readline().strip()
    dat = map(int, stdin.read().split(), repeat(10, 2 * m))
    h = dat[1::2]
    lst = [None] * (n + 10)
    xt = [None] * (m + 10)
    for i, v in enumerate(dat[::2]):
        xt[i] = lst[v]
        lst[v] = i
    di = {chr(ord('a') + i): 2 ** i for i in xrange(26)}
    b = [0] * (n + 10)
    res = [0] * m
    st = [(1, 1)]
    po = st.pop
    pu = st.append
    pe = st.extend
    while st:
        x, d = po()
        if d:
            pu((x, 0))
            i = lst[x]
            while i is not None:
                res[i] ^= b[h[i]]
                i = xt[i]
            b[d] ^= di[s[x]]
            d += 1
            i = last[x]
            while i is not None:
                pu((i, d))
                i = ne[i]
        else:
            i = lst[x]
            while i is not None:
                res[i] ^= b[h[i]]
                i = xt[i]
    ok = set(2 ** i for i in xrange(26))
    ok.add(0)
    ok = frozenset(ok)
    res = [""Yes"" if x in ok else ""No"" for x in res]
    stdout.write('\n'.join(res))
main()","['graphs', 'constructive algorithms', 'bitmasks', 'binary search', 'dfs and similar', 'trees']"
"Vasya plays FreeDiv. In this game he manages a huge state, which has n cities and m two-way roads between them. Unfortunately, not from every city you can reach any other one moving along these roads. Therefore Vasya decided to divide the state into provinces so that in every province, one could reach from every city all the cities of the province, but there are no roads between provinces. Unlike other turn-based strategies, in FreeDiv a player has the opportunity to build tunnels between cities. The tunnels are two-way roads along which one can move armies undetected by the enemy. However, no more than one tunnel can be connected to each city. As for Vasya, he wants to build a network of tunnels so that any pair of cities in his state were reachable by some path consisting of roads and a tunnels. But at that no more than k tunnels are connected to each province (otherwise, the province will be difficult to keep in case other provinces are captured by enemy armies).Vasya discovered that maybe he will not be able to build such a network for the current condition of the state. Maybe he'll have first to build several roads between cities in different provinces to merge the provinces. Your task is to determine the minimum number of roads Vasya needs to build so that it was possible to build the required network of tunnels in the resulting state.","import sys
rl=sys.stdin.readline
n,m,k=map(int,rl().split())
c = [-1]*n
def root(x):
    p = x
    while c[p]>=0: p=c[p]
    while c[x]>=0: 
        t = c[x]
        c[x] = p
        x = t
    return p
#def root(x):
#    if c[x]<0: return x
#    c[x]=root(c[x])
#    return c[x]
for i in xrange(m):
    x,y=rl().split()
    f = root(int(x)-1)
    t = root(int(y)-1)
    if f==t: continue
    if (c[f]&1): f,t=t,f
    c[t]+=c[f]
    c[f]=t
l,s,q=0,2,0
for i in xrange(n):
    if c[i]>=0: continue
    j=k if c[i]<-k else -c[i]
    if j==1: l+=1
    else: s+=j-2
    q+=1
    
if l==1: print 0
elif k==1: print q-2;
elif l<=s: print 0;
else: print (l-s+1)/2;","['dfs and similar', 'greedy', 'graphs']"
"Bob is a duck. He wants to get to Alice's nest, so that those two can duck!  Duck is the ultimate animal! (Image courtesy of See Bang) The journey can be represented as a straight line, consisting of $$$n$$$ segments. Bob is located to the left of the first segment, while Alice's nest is on the right of the last segment. Each segment has a length in meters, and also terrain type: grass, water or lava. Bob has three movement types: swimming, walking and flying. He can switch between them or change his direction at any point in time (even when he is located at a non-integer coordinate), and doing so doesn't require any extra time. Bob can swim only on the water, walk only on the grass and fly over any terrain. Flying one meter takes $$$1$$$ second, swimming one meter takes $$$3$$$ seconds, and finally walking one meter takes $$$5$$$ seconds.Bob has a finite amount of energy, called stamina. Swimming and walking is relaxing for him, so he gains $$$1$$$ stamina for every meter he walks or swims. On the other hand, flying is quite tiring, and he spends $$$1$$$ stamina for every meter flown. Staying in place does not influence his stamina at all. Of course, his stamina can never become negative. Initially, his stamina is zero.What is the shortest possible time in which he can reach Alice's nest?","n=int(input())
l=list(map(lambda x:int(x)*2,input().split("" "")))
t=list(map(lambda x:""GWL"".index(x),input()))
mins=[0 for i in range(0,n+1)]
for i in range(n-1,-1,-1):
	if t[i]!=2:mins[i]=max(mins[i+1]-l[i],0)
	else:mins[i]=mins[i+1]+l[i]
curs=ans=st=0
for i in range(0,n):
	if(t[i]==0):
		curs+=l[i];ans+=l[i]*5
		if(curs>mins[i+1]):
			ol=(curs-mins[i+1])//2
			ol=min(ol,l[i])
			ans-=4*ol;curs-=2*ol
	if(t[i]==1):
		st=1;curs+=l[i];ans+=l[i]*3
	if(t[i]==2):
		if(curs<l[i]):
			ol=l[i]-curs;curs=l[i]
			ans+=ol*(3 if st else 5)
		curs-=l[i];ans+=l[i]
if curs>0:ans-=curs//2*2
print(ans//2)","['constructive algorithms', 'greedy']"
"Toastman came up with a very complicated task. He gives it to Appleman, but Appleman doesn't know how to solve it. Can you help him?Given a n × n checkerboard. Each cell of the board has either character 'x', or character 'o', or nothing. How many ways to fill all the empty cells with 'x' or 'o' (each cell must contain only one character in the end) are there, such that for each cell the number of adjacent cells with 'o' will be even? Find the number of ways modulo 1000000007 (109 + 7). Two cells of the board are adjacent if they share a side.","from sys import stdin
def main():
    n, k = map(int, stdin.readline().split())
    par = [range(n+10), range(n+10)]
    def find(i, x):
        if par[i][x] == x:
            return x
        else:
            par[i][x] = find(i, par[i][x])
            return par[i][x]
    def unite(i, x, y):
        x, y = find(i, x), find(i, y)
        par[i][x] = y
    mod = 1000000007
    m = (n + 1) / 2
    for _ in xrange(k):
        l = stdin.readline().split()
        r, c, b = int(l[0]) - 1, int(l[1]) - 1, int(l[2] == 'o')
        p = (r + c) % 2
        if r > m:
            r, c = n - 1 - r, n - 1 - c
        L, R = c - r, c + r
        if L < 0:
            L = -L
        if R >= n:
            R = 2 * (n - 1) - R
        unite(p, L+b, R+2)
        unite(p, L+1-b, R+3)
    c = 0
    for p in [0, 1]:
        for i in xrange([m, n-m][p]+1):
            L, R = p+i+i, p+i+i+1
            l, r = find(p, L), find(p, R)
            if l == r:
                print 0
                return
            if l == L:
                c += 1
    print pow(2, c - 2, mod)
main()","['dsu', 'math']"
"Petya has n positive integers a1, a2, ..., an. His friend Vasya decided to joke and replaced all digits in Petya's numbers with a letters. He used the lowercase letters of the Latin alphabet from 'a' to 'j' and replaced all digits 0 with one letter, all digits 1 with another letter and so on. For any two different digits Vasya used distinct letters from 'a' to 'j'.Your task is to restore Petya's numbers. The restored numbers should be positive integers without leading zeros. Since there can be multiple ways to do it, determine the minimum possible sum of all Petya's numbers after the restoration. It is guaranteed that before Vasya's joke all Petya's numbers did not have leading zeros.","n = int(input())
result = 0
weight = [0 for i in range(10)]
canzero = [True for i in range(10)]
for _ in range(n):
    x = list(str(input()))
    canzero[ord(x[0]) - 97] = False
    x.reverse()
    for i in range(len(x)):
        weight[ord(x[i]) - 97] += pow(10, i)
# print(canzero)
# print(weight)
zero = 10
cl = weight[:]
while True:
    candidate = max(cl)
    i = cl.index(candidate)
    if canzero[i]:
        zero = i
        break
    else:
        cl[i] = -1
weight.remove(weight[zero])
weight = sorted(weight)
weight.reverse()
for i in range(1, 10):
    result += i * weight[i - 1]
# print(cl, zero, weight)
print(result)","['constructive algorithms', 'greedy', 'math']"
"One day Polycarpus got hold of two non-empty strings s and t, consisting of lowercase Latin letters. Polycarpus is quite good with strings, so he immediately wondered, how many different pairs of ""x y"" are there, such that x is a substring of string s, y is a subsequence of string t, and the content of x and y is the same. Two pairs are considered different, if they contain different substrings of string s or different subsequences of string t. Read the whole statement to understand the definition of different substrings and subsequences.The length of string s is the number of characters in it. If we denote the length of the string s as |s|, we can write the string as s = s1s2... s|s|.A substring of s is a non-empty string x = s[a... b] = sasa + 1... sb (1 ≤ a ≤ b ≤ |s|). For example, ""code"" and ""force"" are substrings or ""codeforces"", while ""coders"" is not. Two substrings s[a... b] and s[c... d] are considered to be different if a ≠ c or b ≠ d. For example, if s=""codeforces"", s[2...2] and s[6...6] are different, though their content is the same.A subsequence of s is a non-empty string y = s[p1p2... p|y|] = sp1sp2... sp|y| (1 ≤ p1 &lt; p2 &lt; ... &lt; p|y| ≤ |s|). For example, ""coders"" is a subsequence of ""codeforces"". Two subsequences u = s[p1p2... p|u|] and v = s[q1q2... q|v|] are considered different if the sequences p and q are different.","M = (10 ** 9) + 7
S = [0] + list(raw_input()) 
T = [0] + list(raw_input()) 

n = len(S)
m = len(T)

D = [[0 for j in range(m)] for i in range(n)] 

for i in range(1, n): 
    for j in range(1, m): 
        D[i][j] += D[i][j-1]
        # D[i][j] += D[i-1][j]
        if S[i] == T[j]: 
            D[i][j] += D[i-1][j-1] + 1
        D[i][j] %= M

print sum([D[i][m-1] for i in range(1, n)]) % M",['dp']
"There is an undirected tree of $$$n$$$ vertices, connected by $$$n-1$$$ bidirectional edges. There is also a snake stuck inside of this tree. Its head is at vertex $$$a$$$ and its tail is at vertex $$$b$$$. The snake's body occupies all vertices on the unique simple path between $$$a$$$ and $$$b$$$.The snake wants to know if it can reverse itself  — that is, to move its head to where its tail started, and its tail to where its head started. Unfortunately, the snake's movements are restricted to the tree's structure.In an operation, the snake can move its head to an adjacent vertex not currently occupied by the snake. When it does this, the tail moves one vertex closer to the head, so that the length of the snake remains unchanged. Similarly, the snake can also move its tail to an adjacent vertex not currently occupied by the snake. When it does this, the head moves one unit closer to the tail.  Let's denote a snake position by $$$(h,t)$$$, where $$$h$$$ is the index of the vertex with the snake's head, $$$t$$$ is the index of the vertex with the snake's tail. This snake can reverse itself with the movements $$$(4,7)\to (5,1)\to (4,2)\to (1, 3)\to (7,2)\to (8,1)\to (7,4)$$$. Determine if it is possible to reverse the snake with some sequence of operations.","from sys import stdin
import itertools
input = stdin.readline
def getint(): return int(input())
def getints(): return list(map(int, input().split()))
def getint1(): return list(map(lambda x: int(x) - 1, input().split()))
def getstr(): return input()[:-1]


def solve():
    n, a, b = getint1()
    n += 1
    adj = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = getint1()
        adj[u].append(v)
        adj[v].append(u)
    # dfs 1
    max_child = [[-1] * 3 for _ in range(n)]
    stack = [(a, -1, 1)]  # (node, parent)
    while stack:
        u, p, flag = stack.pop()
        if p != -1 and len(adj[u]) < 2:
            max_child[u][0] = 1
            continue
        if flag == 1:
            stack.append((u, p, 0))
            for v in adj[u]:
                if v == p:
                    continue
                stack.append((v, u, 1))
        else:
            for v in adj[u]:
                if v == p:
                    continue
                len_v = max_child[v][0] + 1
                if len_v > max_child[u][0]:
                    max_child[u][2] = max_child[u][1]
                    max_child[u][1] = max_child[u][0]
                    max_child[u][0] = len_v
                elif len_v > max_child[u][1]:
                    max_child[u][2] = max_child[u][1]
                    max_child[u][1] = len_v
                elif len_v > max_child[u][2]:
                    max_child[u][2] = len_v
    # end of dfs 1
    # dfs 2
    body = []
    ret = [False] * n
    max_parent = [-1] * n
    stack.clear()
    stack = [(a, -1, 0)]  # (node, parent, max len from parent)
    while stack:
        u, p, mxp = stack.pop()
        if mxp >= 0:
            stack.append((u, p, -1))
            if p != -1 and len(adj[u]) < 2:
                continue
            max_parent[u] = mxp + 1
            chlen = [max_parent[u], -3]
            for v in adj[u]:
                if v == p:
                    continue
                len_v = max_child[v][0] + 1
                if len_v > chlen[0]:
                    chlen[1] = chlen[0]
                    chlen[0] = len_v
                elif len_v > chlen[1]:
                    chlen[1] = len_v
            for v in adj[u]:
                if v == p:
                    continue
                stack.append(
                    (v, u, chlen[int(max_child[v][0] + 1 == chlen[0])]))
        else:
            is_body = (u == b)
            if not is_body:
                for v in adj[u]:
                    if v != p and ret[v]:
                        is_body = True
                        break
            if is_body:
                body.append(u)
            ret[u] = is_body
    del ret
    # end of dfs2
    ok = False
    body_len = len(body)
    can_turn = [False] * n
    for i in range(n):
        if 3 <= sum(1 for l in max_child[i] + [max_parent[i]] if l >= body_len):
            can_turn[i] = True
            ok = True
    if not ok:
        print(""NO"")
        return
    treelen = [1] * body_len
    # print(body)
    for i in range(body_len):
        cur = body[i]
        pre = -1 if i == 0 else body[i - 1]
        nxt = -1 if i + 1 == body_len else body[i + 1]
        for v in adj[cur]:
            if v == pre or v == nxt:
                continue
            treelen[i] = max(treelen[i], max_child[v][0] + 1)
            if can_turn[v]:
                can_turn[cur] = True
                continue
            # dfs 3
            stack = [(v, cur)]
            while stack and not can_turn[cur]:
                u, p = stack.pop()
                for w in adj[u]:
                    if w == p:
                        continue
                    if can_turn[w]:
                        can_turn[cur] = True
                        break
                    stack.append((w, u))
            stack.clear()
            # end of dfs 3
        # print(i, cur, can_turn[cur])
    # use two pointer to find if we can enter the turing point
    # print(body_len, treelen)
    l = 0
    r = body_len - 1
    lmax = treelen[r] - 1
    rmin = body_len - treelen[l]
    ok = (can_turn[body[l]] or can_turn[body[r]])
    while not ok and (l < lmax or rmin < r):
        if l < lmax:
            l += 1
            rmin = min(rmin, l + (body_len - treelen[l]))
        if rmin < r:
            r -= 1
            lmax = max(lmax, r - (body_len - treelen[r]))
        if can_turn[body[l]] or can_turn[body[r]]:
            ok = True
    ##
    print(""YES"" if ok else ""NO"")
    return
    # end of solve


if __name__ == ""__main__"":
    # solve()
    # for t in range(getint()):
    #     print('Case #', t + 1, ': ', sep='')
    #     solve()
    for _ in range(getint()):
        solve()","['dp', 'greedy', 'two pointers', 'dfs and similar', 'trees']"
"Jzzhu has picked n apples from his big apple tree. All the apples are numbered from 1 to n. Now he wants to sell them to an apple store. Jzzhu will pack his apples into groups and then sell them. Each group must contain two apples, and the greatest common divisor of numbers of the apples in each group must be greater than 1. Of course, each apple can be part of at most one group.Jzzhu wonders how to get the maximum possible number of groups. Can you help him?","""""""
Codeforces Round 257 Div 1 Problem C

Author  : chaotic_iak
Language: Python 3.3.4
""""""

def read(mode=2):
    # 0: String
    # 1: List of strings
    # 2: List of integers
    inputs = input().strip()
    if mode == 0:
        return inputs
    if mode == 1:
        return inputs.split()
    if mode == 2:
        return [int(x) for x in inputs.split()]

def write(s=""\n""):
    if isinstance(s, list): s = "" "".join(map(str,s))
    s = str(s)
    print(s, end="""")

################################################### SOLUTION

# croft algorithm to generate primes
# from pyprimes library, not built-in, just google it
from itertools import compress
import itertools
def croft():
    """"""Yield prime integers using the Croft Spiral sieve.

    This is a variant of wheel factorisation modulo 30.
    """"""
    # Implementation is based on erat3 from here:
    #   http://stackoverflow.com/q/2211990
    # and this website:
    #   http://www.primesdemystified.com/
    # Memory usage increases roughly linearly with the number of primes seen.
    # dict ``roots`` stores an entry x:p for every prime p.
    for p in (2, 3, 5):
        yield p
    roots = {9: 3, 25: 5}  # Map d**2 -> d.
    primeroots = frozenset((1, 7, 11, 13, 17, 19, 23, 29))
    selectors = (1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0)
    for q in compress(
            # Iterate over prime candidates 7, 9, 11, 13, ...
            itertools.islice(itertools.count(7), 0, None, 2),
            # Mask out those that can't possibly be prime.
            itertools.cycle(selectors)
            ):
        # Using dict membership testing instead of pop gives a
        # 5-10% speedup over the first three million primes.
        if q in roots:
            p = roots[q]
            del roots[q]
            x = q + 2*p
            while x in roots or (x % 30) not in primeroots:
                x += 2*p
            roots[x] = p
        else:
            roots[q*q] = q
            yield q

n, = read()
cr = croft()
primes = []
for i in cr:
    if i < n:
        primes.append(i)
    else:
        break
primes.reverse()

used = [0] * (n+1)
res = []
for p in primes:
    k = n//p
    tmp = []
    while k:
        if not used[k*p]:
            tmp.append(k*p)
            used[k*p] = 1
        if len(tmp) == 2:
            res.append(tmp)
            tmp = []
        k -= 1
    if tmp == [p] and p > 2 and p*2 <= n and len(res) and res[-1][1] == p*2:
        res[-1][1] = p
        used[p*2] = 0
        used[p] = 1

print(len(res))
for i in res:
    print("" "".join(map(str, i)))","['constructive algorithms', 'number theory']"
"There is the following puzzle popular among nuclear physicists.A reactor contains a set of n atoms of some chemical elements. We shall understand the phrase ""atomic number"" as the number of this atom's element in the periodic table of the chemical elements.You are allowed to take any two different atoms and fuse a new one from them. That results in a new atom, whose number is equal to the sum of the numbers of original atoms. The fusion operation can be performed several times.The aim is getting a new pregiven set of k atoms.The puzzle's difficulty is that it is only allowed to fuse two atoms into one, it is not allowed to split an atom into several atoms. You are suggested to try to solve the puzzle.","#!/usr/bin/env python3 

import itertools

# Initialize look-up tables
element_to_value = {
  'H':1, 'He':2, 'Li':3, 'Be':4, 'B':5, 'C':6, 'N':7, 'O':8, 'F':9, 'Ne':10,
  'Na':11, 'Mg':12, 'Al':13, 'Si':14, 'P':15, 'S':16, 'Cl':17, 'Ar':18, 'K':19, 'Ca':20,
  'Sc':21, 'Ti':22, 'V':23, 'Cr':24, 'Mn':25, 'Fe':26, 'Co':27, 'Ni':28, 'Cu':29, 'Zn':30,
  'Ga':31, 'Ge':32, 'As':33, 'Se':34, 'Br':35, 'Kr':36, 'Rb':37, 'Sr':38, 'Y':39, 'Zr':40,
  'Nb':41, 'Mo':42, 'Tc':43, 'Ru':44, 'Rh':45, 'Pd':46, 'Ag':47, 'Cd':48, 'In':49, 'Sn':50,
  'Sb':51, 'Te':52, 'I':53, 'Xe':54, 'Cs':55, 'Ba':56, 'La':57, 'Ce':58, 'Pr':59, 'Nd':60,
  'Pm':61, 'Sm':62, 'Eu':63, 'Gd':64, 'Tb':65, 'Dy':66, 'Ho':67, 'Er':68, 'Tm':69, 'Yb':70,
  'Lu':71, 'Hf':72, 'Ta':73, 'W':74, 'Re':75, 'Os':76, 'Ir':77, 'Pt':78, 'Au':79, 'Hg':80,
  'Tl':81, 'Pb':82, 'Bi':83, 'Po':84, 'At':85, 'Rn':86, 'Fr':87, 'Ra':88, 'Ac':89, 'Th':90,
  'Pa':91, 'U':92, 'Np':93, 'Pu':94, 'Am':95, 'Cm':96, 'Bk':97, 'Cf':98, 'Es':99, 'Fm':100
}
value_to_element = dict()
for (element, value) in element_to_value.items():
  value_to_element[value] = element

# Read inputs
(n,k) = map(int,input().split())
products_start_str = input().split()
products_end_str = input().split()

# Translate elements to their values
products_start = [element_to_value[elem] for elem in products_start_str]
products_end = [element_to_value[elem] for elem in products_end_str]

# Filter out duplicates; keep track of ingredient values and their number
products_start.sort()
ingredient_value = []
ingredient_count = []
for (key, lst) in itertools.groupby(products_start):
  ingredient_value.append(key)
  ingredient_count.append(len(list(lst)))
nr_ingredients = len(ingredient_value)

# Figure out the options for constructing the final products
construction_options = [[] for i in range(k)]
for combination in itertools.product(*[range(l+1) for l in ingredient_count]):
  value = sum(combination[i]*ingredient_value[i] for i in range(nr_ingredients))
  if (value in products_end):
    for i in range(k):
      if products_end[i] == value:
        construction_options[i].append(combination)

# Do a depth-first search on the construction options for a possible solution
solution =  [None for i in range(k)]
def find_solution(used = [0 for i in range(nr_ingredients)], next = 0):
  if (next == k):
    return all(used[i] == ingredient_count[i] for i in range(nr_ingredients))
  else:
    for option in construction_options[next]:
      usage = [used[i]+option[i] for i in range(nr_ingredients)]
      if all(used[i] <= ingredient_count[i] for i in range(nr_ingredients)):
        possible = find_solution(usage, next+1)
        if (possible):
          solution[next] = option
          return True
  return False

possible = find_solution()

# Print the answer
if not possible:
  print(""NO"")
  exit()

def combination_to_recipe(combination):
  recipe = []
  for i in range(nr_ingredients):
    for j in range(combination[i]):
      recipe.append(value_to_element[ingredient_value[i]])
  return recipe

print(""YES"")
for i in range(k):
  recipe = combination_to_recipe(solution[i])
  print(""%s->%s"" % (""+"".join(recipe),products_end_str[i]))","['dp', 'bitmasks']"
"Traveling around the world you noticed that many shop owners raise prices to inadequate values if the see you are a foreigner.You define inadequate numbers as follows:   all integers from $$$1$$$ to $$$9$$$ are inadequate;  for an integer $$$x \ge 10$$$ to be inadequate, it is required that the integer $$$\lfloor x / 10 \rfloor$$$ is inadequate, but that's not the only condition. Let's sort all the inadequate integers. Let $$$\lfloor x / 10 \rfloor$$$ have number $$$k$$$ in this order. Then, the integer $$$x$$$ is inadequate only if the last digit of $$$x$$$ is strictly less than the reminder of division of $$$k$$$ by $$$11$$$. Here $$$\lfloor x / 10 \rfloor$$$ denotes $$$x/10$$$ rounded down.Thus, if $$$x$$$ is the $$$m$$$-th in increasing order inadequate number, and $$$m$$$ gives the remainder $$$c$$$ when divided by $$$11$$$, then integers $$$10 \cdot x + 0, 10 \cdot x + 1 \ldots, 10 \cdot x + (c - 1)$$$ are inadequate, while integers $$$10 \cdot x + c, 10 \cdot x + (c + 1), \ldots, 10 \cdot x + 9$$$ are not inadequate.The first several inadequate integers are $$$1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 21, 30, 31, 32 \ldots$$$. After that, since $$$4$$$ is the fourth inadequate integer, $$$40, 41, 42, 43$$$ are inadequate, while $$$44, 45, 46, \ldots, 49$$$ are not inadequate; since $$$10$$$ is the $$$10$$$-th inadequate number, integers $$$100, 101, 102, \ldots, 109$$$ are all inadequate. And since $$$20$$$ is the $$$11$$$-th inadequate number, none of $$$200, 201, 202, \ldots, 209$$$ is inadequate.You wrote down all the prices you have seen in a trip. Unfortunately, all integers got concatenated in one large digit string $$$s$$$ and you lost the bounds between the neighboring integers. You are now interested in the number of substrings of the resulting string that form an inadequate number. If a substring appears more than once at different positions, all its appearances are counted separately.","#!/usr/bin/env python
from __future__ import division, print_function

import os
import sys
from io import IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from cStringIO import StringIO
    from future_builtins import ascii, filter, hex, map, oct, zip
else:
    from io import BytesIO as StringIO


class FastI:
    stream = StringIO()
    newlines = 0

    def readline(self):
        while self.newlines == 0:
            b, ptr = os.read(0, (1 << 13) + os.fstat(0).st_size), self.stream.tell()
            self.stream.seek(0, 2), self.stream.write(b), self.stream.seek(ptr)
            self.newlines += b.count(b'\n') + (not b)

        self.newlines -= 1
        return self.stream.readline()


class FastO(IOBase):
    def __init__(self):
        stream = StringIO()
        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)
        self.write = stream.write if sys.version_info[0] < 3 else lambda b: stream.write(b.encode())


class ostream:
    def __lshift__(self, a):
        if a == endl:
            sys.stdout.write('\n')
            sys.stdout.flush()
        else:
            sys.stdout.write(str(a))
        return self


sys.stdin, sys.stdout = FastI(), FastO()
input, flush = sys.stdin.readline, sys.stdout.flush
cout, endl = ostream(), object()


def main():
    D = map(int, sys.stdin.readline().strip())
    Sum = 0
    c = [0] * 11
    for x in D:
        cn = [0] * 11
        if x != 0:
            cn[x] += 1
        for i in xrange(x + 1, 11):
            cn[((i - 1) * i // 2 + x + 10) % 11] += c[i]
        c = cn
        Sum += sum(c)
    cout << Sum << endl


if __name__ == '__main__':
    main()",['dp']
"Ivan is a student at Berland State University (BSU). There are n days in Berland week, and each of these days Ivan might have some classes at the university.There are m working hours during each Berland day, and each lesson at the university lasts exactly one hour. If at some day Ivan's first lesson is during i-th hour, and last lesson is during j-th hour, then he spends j - i + 1 hours in the university during this day. If there are no lessons during some day, then Ivan stays at home and therefore spends 0 hours in the university.Ivan doesn't like to spend a lot of time in the university, so he has decided to skip some lessons. He cannot skip more than k lessons during the week. After deciding which lessons he should skip and which he should attend, every day Ivan will enter the university right before the start of the first lesson he does not skip, and leave it after the end of the last lesson he decides to attend. If Ivan skips all lessons during some day, he doesn't go to the university that day at all.Given n, m, k and Ivan's timetable, can you determine the minimum number of hours he has to spend in the university during one week, if he cannot skip more than k lessons?","n, m, k = map(int, raw_input().split())

a = [[] for i in xrange(n)]
for i in xrange(n):
    s = raw_input()
    for j in xrange(m):
        if s[j] == '1': a[i].append(j)

w = [([0] * (k + 1)) for i in xrange(n)]
for i in xrange(n):
    if len(a[i]) == 0: continue
    for j in xrange(k + 1):
        if len(a[i]) > j:
            w[i][j] = a[i][-1] - a[i][0] + 1
        else:
            w[i][j] = 0
            continue
        for x in xrange(j + 1):
            y = len(a[i]) - 1 - (j - x)
            if y >= x:
                t = a[i][y] - a[i][x] + 1
                w[i][j] = min(w[i][j], t)

dp = [[n * m for j in xrange(k + 1)] for i in xrange(n)]
for j in xrange(k + 1):
    dp[0][j] = w[0][j]

for i in xrange(1, n):
    for j in xrange(k + 1):
        for l in xrange(j + 1):
            dp[i][j] = min(dp[i][j], w[i][l] + dp[i - 1][j - l])

print dp[-1][-1]",['dp']
"On some square in the lowest row of a chessboard a stands a pawn. It has only two variants of moving: upwards and leftwards or upwards and rightwards. The pawn can choose from which square of the lowest row it can start its journey. On each square lay from 0 to 9 peas. The pawn wants to reach the uppermost row having collected as many peas as possible. As there it will have to divide the peas between itself and its k brothers, the number of peas must be divisible by k + 1. Find the maximal number of peas it will be able to collect and which moves it should make to do it.The pawn cannot throw peas away or leave the board. When a pawn appears in some square of the board (including the first and last square of the way), it necessarily takes all the peas.","if __name__ == '__main__':
    n, m, k = map(int, input().split())
    chessboard = tuple(tuple(map(int, input())) for _ in range(n))

    costs = [m * [0] for _ in range(n)]

    for i in range(m):
        costs[0][i] = {i: (-1, """") for i in range(k + 1)}
        costs[0][i][chessboard[0][i] % (k + 1)] = (chessboard[0][i], """")

    for i in range(1, n):
        for j in range(m):
            costs[i][j] = {i: (-1, """") for i in range(k + 1)}

            for mod in range(k + 1):
                next_mod = (chessboard[i][j] + mod) % (k + 1)
                next = (-1, """")

                if j + 1 < m \
                        and costs[i - 1][j + 1][mod][0] >= 0 \
                        and (j == 0 or costs[i - 1][j + 1][mod] > costs[i - 1][j - 1][mod]):
                    next = costs[i - 1][j + 1][mod]
                    next = (next[0] + chessboard[i][j], ""R"" + next[1])

                elif j - 1 >= 0 and costs[i - 1][j - 1][mod][0] >= 0:
                    next = costs[i - 1][j - 1][mod]
                    next = (next[0] + chessboard[i][j], ""L"" + next[1])
                costs[i][j][next_mod] = max(costs[i][j][next_mod], next)

    # print(max(costs[m - 1][i][0][0] for i in range(n)))

    i_max = max(range(m), key=lambda i: costs[n - 1][i][0][0])
    print(costs[n - 1][i_max][0][0])
    if costs[n - 1][i_max][0][0] >= 0:
        print(i_max + 1)
        print(costs[n - 1][i_max][0][1])",['dp']
"In 2N - 1 boxes there are apples and oranges. Your task is to choose N boxes so, that they will contain not less than half of all the apples and not less than half of all the oranges.","t = int(input())


while t:
	t = t-1
	boxes = []
	n = int(input())
	num_box = (2*n)-1
	for i in range(num_box):
		pair = input().split()
		apples = int(pair[0])
		oranges = int(pair[1])
		boxes.append((apples, oranges, i+1))

	print(""YES"")
	boxes.sort(reverse=True)

	orange_boxes = list(zip(*boxes))[1]
	total_oranges = sum(orange_boxes)

	half_sum1 = sum(orange_boxes[::2])
	half_sum2 = sum(orange_boxes[1::2])

	index_list = list(list(zip(*boxes))[2])
	index_list1 = index_list[::2]
	index_list2 = index_list[1::2]
	index_list2.append(index_list1[0])

	if half_sum1 >= half_sum2:
		print(*index_list1, sep=' ')

	else: 
		print(*index_list2, sep=' ')","['constructive algorithms', 'sortings']"
"Andrewid the Android is a galaxy-famous detective. He is now chasing a criminal hiding on the planet Oxa-5, the planet almost fully covered with water.The only dry land there is an archipelago of n narrow islands located in a row. For more comfort let's represent them as non-intersecting segments on a straight line: island i has coordinates [li, ri], besides, ri &lt; li + 1 for 1 ≤ i ≤ n - 1.To reach the goal, Andrewid needs to place a bridge between each pair of adjacent islands. A bridge of length a can be placed between the i-th and the (i + 1)-th islads, if there are such coordinates of x and y, that li ≤ x ≤ ri, li + 1 ≤ y ≤ ri + 1 and y - x = a. The detective was supplied with m bridges, each bridge can be used at most once. Help him determine whether the bridges he got are enough to connect each pair of adjacent islands.","#!/usr/bin/env python
# 556D_fug.py - Codeforces.com 556D Fug quiz
#
# Copyright (C) 2015 Sergey
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""
Input

The first line contains integers n and m - the number of islands and bridges.

Next n lines each contain two integers li and ri - the coordinates of the
island endpoints.

The last line contains m integer numbers a1..am - the lengths of the bridges
that Andrewid got.
Output

If it is impossible to place a bridge between each pair of adjacent islands
in the required manner, print on a single line ""No"" (without the quotes)
, otherwise print in the first line ""Yes"" (without the quotes), and in the
second line print n-1 numbers b1, bn-1, which mean that between islands
i and i+1 there must be used a bridge number bi.

If there are multiple correct answers, print any of them. Note that in this
problem it is necessary to print ""Yes"" and ""No"" in correct case
""""""

# Standard modules
import unittest
import sys
import re

# Additional modules
import bisect

###############################################################################
# Fastlist Class
###############################################################################


class Fastlist(object):
    """""" Fastlist representation """"""

    def __init__(self, l=[], load=5000, sorted=0):
        self._load = load
        self._sorted = sorted
        self._lists = []
        self._starts = []
        self._mins = []
        self._insert_list()
        self._irev = 0
        self.extend(l)

    def _index_location(self, index):
        if len(self._lists[0]) == 0:
            raise IndexError(""List index out of range"")
        if index == 0:
            return (0, 0)
        if index == -1:
            return (len(self._lists) - 1, len(self._lists[-1]) - 1)
        if self._sorted:
            raise RuntimeError(""No index access to the sorted list, exc 0, -1"")
        length = len(self)
        if index < 0:
            index = length + index
        if index >= length:
            raise IndexError(""List index out of range"")
        il = bisect.bisect_right(self._starts, index) - 1
        return (il, index - self._starts[il])

    def _insert_list(self, il=None):
        if il is None:
            il = len(self._lists)
        self._lists.insert(il, [])
        if self._sorted:
            if il == 0:
                self._mins.insert(il, None)
            else:
                self._mins.insert(il, self._lists[il-1][-1])
        else:
            if il == 0:
                self._starts.insert(il, 0)
            else:
                start = self._starts[il-1] + len(self._lists[il-1])
                self._starts.insert(il, start)

    def _del_list(self, il):
        del self._lists[il]
        if self._sorted:
            del self._mins[il]
        else:
            del self._starts[il]

    def _rebalance(self, il):
        illen = len(self._lists[il])
        if illen >= self._load * 2:
            self._insert_list(il)
            self._even_lists(il)
        if illen <= self._load * 0.2:
            if il != 0:
                self._even_lists(il-1)
            elif len(self._lists) > 1:
                self._even_lists(il)

    def _even_lists(self, il):
        tot = len(self._lists[il]) + len(self._lists[il+1])
        if tot < self._load * 1:
            self._lists[il] += self._lists[il+1]
            self._del_list(il+1)
            if self._sorted:
                self._mins[il] = self._lists[il][0]
        else:
            half = tot//2
            ltot = self._lists[il] + self._lists[il+1]
            self._lists[il] = ltot[:half]
            self._lists[il+1] = ltot[half:]
            if self._sorted:
                self._mins[il] = self._lists[il][0]
                self._mins[il+1] = self._lists[il+1][0]
            else:
                self._starts[il+1] = self._starts[il] + len(self._lists[il])

    def _obj_location(self, obj, l=0):
        if not self._sorted:
            raise RuntimeError(""No by value access to an unserted list"")
        il = 0
        if len(self._mins) > 1 and obj > self._mins[0]:
            if l:
                il = bisect.bisect_left(self._mins, obj) - 1
            else:
                il = bisect.bisect_right(self._mins, obj) - 1
        if l:
            ii = bisect.bisect_left(self._lists[il], obj)
        else:
            ii = bisect.bisect_right(self._lists[il], obj)
        if ii == len(self._lists[il]) and il != len(self._lists) - 1:
            ii = 0
            il += 1
        return (il, ii)

    def insert(self, index, obj):
        (il, ii) = self._index_location(index)
        self._lists[il].insert(ii, obj)
        for j in range(il + 1, len(self._starts)):
            self._starts[j] += 1
        self._rebalance(il)

    def append(self, obj):
        if len(self._lists[-1]) >= self._load:
            self._insert_list()
        self._lists[-1].append(obj)
        if self._sorted and self._mins[0] is None:
            self._mins[0] = self._lists[0][0]

    def extend(self, iter):
        for n in iter:
            self.append(n)

    def pop(self, index=None):
        if index is None:
            index = -1
        (il, ii) = self._index_location(index)
        item = self._lists[il].pop(ii)
        if self._sorted:
            if ii == 0 and len(self._lists[il]) > 0:
                self._mins[il] = self._lists[il][0]
        else:
            for j in range(il + 1, len(self._starts)):
                self._starts[j] -= 1
        self._rebalance(il)
        return item

    def clear(self):
        self._lists.clear()
        self._starts.clear()
        self._mins.clear()
        self._insert_list()

    def as_list(self):
        return sum(self._lists, [])

    def insort(self, obj, l=0):
        (il, ii) = self._obj_location(obj, l)
        self._lists[il].insert(ii, obj)
        if ii == 0:
            self._mins[il] = obj
        self._rebalance(il)

    def add(self, obj):
        if self._sorted:
            self.insort(obj)
        else:
            self.append(obj)

    def insort_left(self, obj):
        self.insort(obj, l=1)

    def lower_bound(self, obj):
        (self._il, self._ii) = self._obj_location(obj, l=1)
        return self

    def upper_bound(self, obj):
        (self._il, self._ii) = self._obj_location(obj)
        return self

    def __str__(self):
        return str(self.as_list())

    def __setitem__(self, index, obj):
        if isinstance(index, int):
            (il, ii) = self._index_location(index)
            self._lists[il][ii] = obj
        elif isinstance(index, slice):
            raise RuntimeError(""Slice assignment is not supported"")

    def __getitem__(self, index):
        if isinstance(index, int):
            (il, ii) = self._index_location(index)
            return self._lists[il][ii]
        elif isinstance(index, slice):
            rg = index.indices(len(self))
            if rg[0] == 0 and rg[1] == len(self) and rg[2] == 1:
                return self.as_list()
            return [self.__getitem__(index) for index in range(*rg)]

    def __iadd__(self, obj):
        if self._sorted:
            [self.insort(n) for n in obj]
        else:
            [self.append(n) for n in obj]
        return self

    def __delitem__(self, index):
        if isinstance(index, int):
            self.pop(index)
        elif isinstance(index, slice):
            rg = index.indices(len(self))
            [self.__delitem__(rg[0]) for i in range(*rg)]

    def __len__(self):
        if self._sorted:
            return sum([len(l) for l in self._lists])
        return self._starts[-1] + len(self._lists[-1])

    def __contains__(self, obj):
        if self._sorted:
            it = self.lower_bound(obj)
            return not it.iter_end() and obj == it.iter_getitem()
        else:
            for n in self:
                if obj == n:
                    return True
            return False

    def __bool__(self):
        return len(self._lists[0]) != 0

    def __iter__(self):
        self._il = self._ii = self._irev = 0
        return self

    def __reversed__(self):
        self._il = len(self._lists) - 1
        self._ii = len(self._lists[self._il]) - 1
        self._irev = 1
        return self

    def __next__(self):
        if self._il in (-1, len(self._lists)) or len(self._lists[0]) == 0:
            raise StopIteration(""Iteration stopped"")
        item = self._lists[self._il][self._ii]
        if not self._irev:
            self._ii += 1
            if self._ii == len(self._lists[self._il]):
                self._il += 1
                self._ii = 0
        else:
            self._ii -= 1
            if self._ii == 0:
                self._il -= 1
                self._ii = len(self._lists[self._il])
        return item

    def iter_getitem(self):
        return self._lists[self._il][self._ii]

    def iter_end(self):
        return (self._il == len(self._lists) - 1 and
                self._ii == len(self._lists[self._il]))

    def iter_del(self):
        self.iter_pop()

    def iter_pop(self):
        item = self._lists[self._il].pop(self._ii)
        if self._sorted:
            if self._ii == 0 and len(self._lists[self._il]) > 0:
                self._mins[self._il] = self._lists[self._il][0]
        else:
            for j in range(self._il + 1, len(self._starts)):
                self._starts[j] -= 1
        self._rebalance(self._il)
        return item


###############################################################################
# Fug Class
###############################################################################


class Fug:
    """""" Fug representation """"""

    def __init__(self, args):
        """""" Default constructor """"""
        self.gsrt = args[0]
        self.asrt = args[1]
        self.gn = args[2]
        self.result = [0]*self.gn
        self.a = Fastlist(self.asrt, load=500, sorted=1)

    def calculate(self):
        """""" Main calcualtion function of the class """"""

        for i in range(self.gn):
            g = self.gsrt[i]
            it = self.a.lower_bound((g[1], 0))
            if not it.iter_end():
                alb = it.iter_getitem()
                if alb[0] > g[0]:
                    return ""No""
                self.result[g[2]] = alb[1]+1
                it.iter_del()
            else:
                return ""No""

        answer = ""Yes\n"" + "" "".join(str(n) for n in self.result)

        return answer


###############################################################################
# Executable code
###############################################################################


def get_inputs(test_inputs=None):

    it = iter(test_inputs.split(""\n"")) if test_inputs else None

    def uinput():
        """""" Unit-testable input function wrapper """"""
        if it:
            return next(it)
        else:
            return sys.stdin.readline()

    # Getting string inputs. Place all uinput() calls here
    num = [int(s) for s in uinput().split()]
    gaps = []
    prevli = [int(s) for s in uinput().split()]
    for i in range(num[0] - 1):
        li = [int(s) for s in uinput().split()]
        min = li[0] - prevli[1]
        max = li[1] - prevli[0]
        gaps.append((max, min, i))
        prevli = li
    alist = [(int(s), i) for i, s in enumerate(uinput().split())]

    # Decoding inputs into a list

    inputs = [sorted(gaps), sorted(alist), num[0]-1]

    return inputs


def calculate(test_inputs=None):
    """""" Base class calculate method wrapper """"""
    return Fug(get_inputs(test_inputs)).calculate()


###############################################################################
# Unit Tests
###############################################################################


class unitTests(unittest.TestCase):

    def test_sample_tests(self):
        """""" Quiz sample tests. Add \n to separate lines """"""

        # Sample test 1
        test = ""4 4\n1 4\n7 8\n9 10\n12 14\n4 5 3 8""
        self.assertEqual(calculate(test), ""Yes\n2 3 1"")
        self.assertEqual(
            get_inputs(test),
            [[(3, 1, 1), (5, 2, 2), (7, 3, 0)],
             [(3, 2), (4, 0), (5, 1), (8, 3)], 3])

        # My tests
        test = ""5 5\n1 1\n2 7\n8 8\n10 10\n16 16\n1 1 5 6 2""
        self.assertEqual(calculate(test), ""Yes\n1 2 5 4"")

        # Other tests
        test = ""2 2\n11 14\n17 18\n2 9""
        self.assertEqual(calculate(test), ""No"")

        # Other tests
        test = (
            ""2 1\n1 1\n1000000000000000000 1000000000000000000"" +
            ""\n999999999999999999"")
        self.assertEqual(calculate(test), ""Yes\n1"")

        test = (""5 9\n1 2\n3 3\n5 7\n11 13\n14 20\n2 3 4 10 6 2 6 9 5"")
        self.assertEqual(calculate(test), ""Yes\n1 6 3 2"")

        size = 200000
        test = str(size) + "" "" + str(size) + ""\n""
        x = size*1000
        for i in range(size):
            test += str(x) + "" "" + str(x + i + 1) + ""\n""
            x += 2 * (i + 1)
        for i in reversed(range(size)):
            test += str(i) + "" ""
        self.assertEqual(calculate(test)[0], ""Y"")

    def test_Fug_class__basic_functions(self):
        """""" Fug class basic functions testing """"""

        # Constructor test
        d = Fug([[(1, 3, 1), (2, 5, 2), (3, 7, 0)],
                 [(3, 2), (4, 0), (5, 1), (8, 3)], 3])

        # Sort bridges
        self.assertEqual(d.asrt[0], (3, 2))

        # Sort Gaps
        self.assertEqual(d.gsrt[0], (1, 3, 1))

if __name__ == ""__main__"":

    # Avoiding recursion limitaions
    sys.setrecursionlimit(100000)

    if sys.argv[-1] == ""-ut"":
        unittest.main(argv=["" ""])

    # Print the result string
    sys.stdout.write(calculate())","['data structures', 'binary search', 'greedy']"
"A tree is an undirected connected graph without cycles. The distance between two vertices is the number of edges in a simple path between them.Limak is a little polar bear. He lives in a tree that consists of n vertices, numbered 1 through n.Limak recently learned how to jump. He can jump from a vertex to any vertex within distance at most k.For a pair of vertices (s, t) we define f(s, t) as the minimum number of jumps Limak needs to get from s to t. Your task is to find the sum of f(s, t) over all pairs of vertices (s, t) such that s &lt; t.","def main():
    inp = readnumbers()
    ii = 0

    n = inp[ii]
    ii += 1
    k = inp[ii]
    ii += 1

    coupl = [[] for _ in range(n)]
    for _ in range(n-1):
        u = inp[ii]-1
        ii += 1
        v = inp[ii]-1
        ii += 1

        coupl[u].append(v)
        coupl[v].append(u)

    found = [False]*n
    
    @bootstrap
    def solve(node):
        A = [0]*k
        A[0] = 1
        Acount = 0
        Aans = 0
        
        for nei in coupl[node]:
            if not found[nei]:
                found[nei] = True
                B,Bcount,Bans = yield solve(nei)
                Aans += Bans
                Aans += Bcount * sum(A)
                Aans += Acount * sum(B)
                Acount += Bcount

                for i in range(k):
                    for j in range(k):
                        Aans += ((i+j+k)//k)*A[i]*B[j]
                for i in range(k-1):
                    A[i+1] += B[i]
                A[0] += B[k-1]
                Acount += B[k-1]

        yield A,Acount,Aans

    found[0] = True
    _,_,ans = solve(0)
    print ans


######## Python 2 and 3 footer by Pajenegod and c1729

# Note because cf runs old PyPy3 version which doesn't have the sped up
# unicode strings, PyPy3 strings will many times be slower than pypy2.
# There is a way to get around this by using binary strings in PyPy3
# but its syntax is different which makes it kind of a mess to use.

# So on cf, use PyPy2 for best string performance.

py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange

import os, sys
from io import IOBase, BytesIO

BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')

# Cout implemented in Python
import sys
class ostream:
    def __lshift__(self,a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'

# Read all remaining integers in stdin, type is given by optional argument, this is fast
def readnumbers(zero = 0):
    conv = ord if py2 else lambda x:x
    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0' [0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-' [0]: sign = -1
            elif s[i] != b'\r' [0]:
                A.append(sign*numb)
                numb = zero; sign = 1
            i += 1
    except:pass
    if s and s[-1] >= b'0' [0]:
        A.append(sign*numb)
    return A


# My magical way of doing recursion in python. This
# isn't the fastest, but at least it works.
from types import GeneratorType
def bootstrap(func, stack=[]):
    def wrapped_function(*args, **kwargs):
        if stack:
            return func(*args, **kwargs)
        else:
            call = func(*args, **kwargs)
            while True:
                if type(call) is GeneratorType:
                    stack.append(call)
                    call = next(call)
                else:
                    stack.pop()
                    if not stack:
                        break
                    call = stack[-1].send(call)
            return call

    return wrapped_function


if __name__== ""__main__"":
  main()","['dp', 'dfs and similar', 'trees']"
"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya has sequence a consisting of n integers.The subsequence of the sequence a is such subsequence that can be obtained from a by removing zero or more of its elements.Two sequences are considered different if index sets of numbers included in them are different. That is, the values ​of the elements ​do not matter in the comparison of subsequences. In particular, any sequence of length n has exactly 2n different subsequences (including an empty subsequence).A subsequence is considered lucky if it has a length exactly k and does not contain two identical lucky numbers (unlucky numbers can be repeated any number of times).Help Petya find the number of different lucky subsequences of the sequence a. As Petya's parents don't let him play with large numbers, you should print the result modulo prime number 1000000007 (109 + 7).","#!/usr/bin/env python

MOD = 1000000007

def gcd(a, b):
    if a == 0:
        return b, 0, 1
    d, x, y = gcd(b % a, a)
    return d, y - b / a * x, x

def div(a):
    d, x, y = gcd(a, MOD)
    return x

def c(n, k):
    if k > n or k < 0:
        return 0
    res = 1
    for i in xrange(max(k + 1, n - k + 1), n + 1):
        res = res * i % MOD
        res = res * div(n - i + 1) % MOD
    return res

def is_lucky(num):
    return num.replace('4', '').replace('7', '') == """"

if __name__ == ""__main__"":
    n, k = map(int, raw_input().strip().split())
    luckies = filter(is_lucky, raw_input().strip().split())
    others = n - len(luckies)
    lucky_dict = {}
    for lucky in luckies:
        if lucky not in lucky_dict:
            lucky_dict[lucky] = 0
        lucky_dict[lucky] += 1
    
    dp_count = []
    for lucky, count in lucky_dict.iteritems():
        dp_count.append(0)
        for i in range(len(dp_count)-1, -1, -1):
            if i !=0:
                dp_count[i] += dp_count[i - 1] * count
            else:
                dp_count[i] += count
            dp_count[i] %= MOD

    res = 0
    max_count = len(dp_count) if len(dp_count) < k else k
    cur_binom = c(others, k - max_count)
    for i in range(max_count-1, -1, -1):
        res += cur_binom * dp_count[i]
        res %= MOD
        if k - i > others:
            cur_binom = 0
            break
        cur_binom = cur_binom * div(k - i) * (others - k + i + 1) % MOD
    res += cur_binom
    res %= MOD
    print res","['dp', 'combinatorics', 'math']"
"You are given a cube of size k × k × k, which consists of unit cubes. Two unit cubes are considered neighbouring, if they have common face.Your task is to paint each of k3 unit cubes one of two colours (black or white), so that the following conditions must be satisfied:  each white cube has exactly 2 neighbouring cubes of white color;  each black cube has exactly 2 neighbouring cubes of black color.","n=int(input())
print([""\n"".join(""\n"".join("""".join(""b"" if (i//2+j//2+k)%2 else ""w"" for j in range(n)) for i in range(n))+""\n"" for k in range(n)),-1][n%2])","['combinatorics', 'constructive algorithms']"
"You are creating a level for a video game. The level consists of $$$n$$$ rooms placed in a circle. The rooms are numbered $$$1$$$ through $$$n$$$. Each room contains exactly one exit: completing the $$$j$$$-th room allows you to go the $$$(j+1)$$$-th room (and completing the $$$n$$$-th room allows you to go the $$$1$$$-st room).You are given the description of the multiset of $$$n$$$ chests: the $$$i$$$-th chest has treasure value $$$c_i$$$.Each chest can be of one of two types:   regular chest — when a player enters a room with this chest, he grabs the treasure and proceeds to the next room;  mimic chest — when a player enters a room with this chest, the chest eats him alive, and he loses. The player starts in a random room with each room having an equal probability of being chosen. The players earnings is equal to the total value of treasure chests he'd collected before he lost.You are allowed to choose the order the chests go into the rooms. For each $$$k$$$ from $$$1$$$ to $$$n$$$ place the chests into the rooms in such a way that:  each room contains exactly one chest;  exactly $$$k$$$ chests are mimics;  the expected value of players earnings is minimum possible. Please note that for each $$$k$$$ the placement is chosen independently.It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$. Report the values of $$$P \cdot Q^{-1} \pmod {998244353}$$$.","#   Author: yumtam
#   Created at: 2020-09-11 00:33

from __future__ import division, print_function
_interactive = False

def main():
    n = int(input())
    ar = [ModInt(int(c)) for c in input().split()]

    ar.sort()
    prfsum = [ModInt(0)]
    for x in ar:
        prfsum.append(prfsum[-1]+x)

    def rsum(l, r):
        return prfsum[r]-prfsum[l]

    for d in range(1, n):
        r = n-d
        mult = ModInt(1)
        ans = ModInt(0)
        while True:
            l = max(0, r-d)
            ans = ans + mult*rsum(l, r)
            r = l
            mult += 1
            if l == 0:
                break

        print(ans//n, end=' ')
    print(0)


# Constants
INF = float('inf')
MOD = 998244353

# Python3 equivalent names
import os, sys, itertools
if sys.version_info[0] < 3:
    input = raw_input
    range = xrange

    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip

# print-flush in interactive problems
if _interactive:
    flush = sys.stdout.flush
    def printf(*args, **kwargs):
        print(*args, **kwargs)
        flush()

# Debug print, only works on local machine
LOCAL = ""LOCAL_"" in os.environ
debug_print = (print) if LOCAL else (lambda *x, **y: None)

# Fast IO
if (not LOCAL) and (not _interactive):
    from io import BytesIO
    from atexit import register
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
    sys.stdout = BytesIO()
    register(lambda: os.write(1, sys.stdout.getvalue()))
    input = lambda: sys.stdin.readline().rstrip('\r\n')

# Some utility functions(Input, N-dimensional lists, ...)
def input_as_list():
    return [int(x) for x in input().split()]

def input_with_offset(o):
    return [int(x)+o for x in input().split()]

def input_as_matrix(n, m):
    return [input_as_list() for _ in range(n)]

def array_of(f, *dim):
    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()

# Start of external code templates...
# End of external code templates.

from __pypy__.intop import *
class ModInt(int):
    def __new__(cls, v): return int.__new__(cls, v%MOD)
    def __add__(self, other): return ModInt(int_mod(int_add(self, other), MOD))
    def __sub__(self, other): return ModInt(int_mod(int_sub(self, other), MOD))
    def __mul__(self, other): return ModInt(int_mulmod(self, other, MOD))
    def __div__(self, other): return ModInt(int_mulmod(self, pow(other, MOD-2, MOD), MOD))
    __truediv__ = __floordiv__ = __div__
    def __pow__(self, power, modulo=MOD): return ModInt(int.__pow__(self, power, modulo))

main()","['greedy', 'probabilities', 'math']"
"Ehab has an array a of n integers. He likes the bitwise-xor operation and he likes to bother Mahmoud so he came up with a problem. He gave Mahmoud q queries. In each of them, he gave Mahmoud 2 integers l and x, and asked him to find the number of subsequences of the first l elements of the array such that their bitwise-xor sum is x. Can you help Mahmoud answer the queries?A subsequence can contain elements that are not neighboring.","import sys
range = xrange
input = raw_input

MOD = 10**9 + 7
inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

n = inp[ii]; ii += 1
q = inp[ii]; ii += 1

A = inp[ii: ii + n]; ii += n

zeros = [1]
Abase = []
base = []
for i in range(n):
    a = A[i]
    for b in base:
        if a ^ b < a:
            a ^= b
    if a:
        base = list(base)
        base.append(a)
        base.sort(reverse = True)
        zeros.append(zeros[-1])
    else:
        zeros.append(zeros[-1] * 2 % MOD)
    Abase.append(base)

out = []
for _ in range(q):
    l = inp[ii] - 1; ii += 1
    x = inp[ii]; ii += 1

    for b in Abase[l]:
        if x ^ b < x:
            x ^= b

    out.append(0 if x else zeros[l + 1])

print '\n'.join(str(x) for x in out)","['dp', 'bitmasks', 'math', 'matrices']"
"Many years have passed, and n friends met at a party again. Technologies have leaped forward since the last meeting, cameras with timer appeared and now it is not obligatory for one of the friends to stand with a camera, and, thus, being absent on the photo.Simply speaking, the process of photographing can be described as follows. Each friend occupies a rectangle of pixels on the photo: the i-th of them in a standing state occupies a wi pixels wide and a hi pixels high rectangle. But also, each person can lie down for the photo, and then he will occupy a hi pixels wide and a wi pixels high rectangle.The total photo will have size W × H, where W is the total width of all the people rectangles, and H is the maximum of the heights. The friends want to determine what minimum area the group photo can they obtain if no more than n / 2 of them can lie on the ground (it would be strange if more than n / 2 gentlemen lie on the ground together, isn't it?..)Help them to achieve this goal.","from operator import neg
n = int(input())
a = [tuple(map(int, input().split())) for i in range(n)]

def check(max_h):
    k = n // 2
    b = []
    for w, h in a:
        if h > max_h:
            if k <= 0 or w > max_h:
                return 1 << 60
            b.append((h, w))
            k -= 1
        else:
            b.append((w, h))
    b.sort(key=lambda t: t[1] - t[0])
    r = 0
    for w, h in b:
        if k > 0 and w <= max_h and h < w:
            r += h
            k -= 1
        else:
            r += w
    return r * max_h

print(min(check(h) for h in range(1, 1001)))","['sortings', 'greedy', 'brute force']"
"Roland loves growing flowers. He has recently grown a beautiful rose at point (0, 0) of the Cartesian coordinate system. The rose is so beautiful that Roland is afraid that the evil forces can try and steal it. To protect the rose, Roland wants to build n watch towers. Let's assume that a tower is a point on the plane at the distance of at most r from the rose. Besides, Roland assumes that the towers should be built at points with integer coordinates and the sum of squares of distances between all pairs of towers must be as large as possible. Note, that Roland may build several towers at the same point, also he may build some of them at point (0, 0).Help Roland build the towers at the integer points so that the sum of squares of distances between all towers is maximum possible. Note that the distance in this problem is defined as the Euclidian distance between points.","""""""
#include <bits/stdc++.h>
#ifdef DEMETRIO
#define deb(...) fprintf(stderr,__VA_ARGS__)
#define deb1(x) cerr << #x << "" = "" << x << endl
#else
#define deb(...) 0
#define deb1(x) 0
#endif
#define pb push_back
#define mp make_pair
#define fst first
#define snd second
#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)
#define SZ(x) ((int)(x).size())
#define mset(a,v) memset(a,v,sizeof(a))
#define mcopy(a,b) memcpy(a,b,sizeof(a))
using namespace std;
typedef long long ll;

int dp[9][512][512];
int cx[9][512][512],cy[9][512][512],rr;
bool vis[9][512][512];
#define OFF 250

int f(int n, int xx, int yy){
	if(vis[n][xx][yy])return dp[n][xx][yy];
	vis[n][xx][yy]=true;
	int& r=dp[n][xx][yy];
	if(n==0)return r=(xx==OFF&&yy==OFF)?0:-(1<<30);
	r=-(1<<30);
	fore(x,-rr,rr+1)fore(y,-rr,rr+1){
		if(x*x+y*y>rr*rr)continue;
		if(xx+x<0||xx+x>=512)continue;
		if(yy+y<0||yy+y>=512)continue;
		int a=x*x+y*y+f(n-1,xx+x,yy+y);
		if(a>r){r=a;cx[n][xx][yy]=x;cy[n][xx][yy]=y;}
	}
	return r;
}

int main(){
	fore(r,1,31){
		rr=r;
		mset(vis,false);
		fore(n,2,9){
			printf(""r[%d][%d]='''"",n,r);
			int r=-(1<<30),xx,yy;
			fore(i,0,512)fore(j,0,512)if(f(n,i,j)>=0){
				int a=n*f(n,i,j)-(i-OFF)*(i-OFF)-(j-OFF)*(j-OFF);
				if(a>r)r=a,xx=i,yy=j;
			}
			printf(""%d\n"",r);
			int k=n;
			while(k>0){
				printf(""%d %d\n"",cx[k][xx][yy],cy[k][xx][yy]);
				int nx=xx+cx[k][xx][yy],ny=yy+cy[k][xx][yy];
				xx=nx;yy=ny;
				k--;
			}
			puts(""'''"");
		}
	}
	return 0;
}
""""""
r=[[0]*31 for _ in range(9)]
r[2][1]='''4
-1 0
1 0
'''
r[3][1]='''8
-1 0
1 0
1 0
'''
r[4][1]='''16
-1 0
-1 0
1 0
1 0
'''
r[5][1]='''24
-1 0
-1 0
1 0
1 0
1 0
'''
r[6][1]='''36
-1 0
-1 0
-1 0
1 0
1 0
1 0
'''
r[7][1]='''48
-1 0
-1 0
-1 0
1 0
1 0
1 0
1 0
'''
r[8][1]='''64
-1 0
-1 0
-1 0
-1 0
1 0
1 0
1 0
1 0
'''
r[2][2]='''16
-2 0
2 0
'''
r[3][2]='''32
-2 0
2 0
2 0
'''
r[4][2]='''64
-2 0
-2 0
2 0
2 0
'''
r[5][2]='''96
-2 0
-2 0
2 0
2 0
2 0
'''
r[6][2]='''144
-2 0
-2 0
-2 0
2 0
2 0
2 0
'''
r[7][2]='''192
-2 0
-2 0
-2 0
2 0
2 0
2 0
2 0
'''
r[8][2]='''256
-2 0
-2 0
-2 0
-2 0
2 0
2 0
2 0
2 0
'''
r[2][3]='''36
-3 0
3 0
'''
r[3][3]='''76
-2 -2
0 3
3 0
'''
r[4][3]='''144
-3 0
-3 0
3 0
3 0
'''
r[5][3]='''218
-3 0
-2 -2
0 3
3 0
3 0
'''
r[6][3]='''324
-3 0
-3 0
-3 0
3 0
3 0
3 0
'''
r[7][3]='''432
-3 0
-3 0
-3 0
3 0
3 0
3 0
3 0
'''
r[8][3]='''576
-3 0
-3 0
-3 0
-3 0
3 0
3 0
3 0
3 0
'''
r[2][4]='''64
-4 0
4 0
'''
r[3][4]='''130
-2 -3
0 4
4 0
'''
r[4][4]='''256
-4 0
-4 0
4 0
4 0
'''
r[5][4]='''384
-4 0
-4 0
4 0
4 0
4 0
'''
r[6][4]='''576
-4 0
-4 0
-4 0
4 0
4 0
4 0
'''
r[7][4]='''768
-4 0
-4 0
-4 0
4 0
4 0
4 0
4 0
'''
r[8][4]='''1024
-4 0
-4 0
-4 0
-4 0
4 0
4 0
4 0
4 0
'''
r[2][5]='''100
-5 0
5 0
'''
r[3][5]='''224
-5 0
3 -4
3 4
'''
r[4][5]='''400
-5 0
-5 0
5 0
5 0
'''
r[5][5]='''624
-5 0
-5 0
3 -4
3 4
5 0
'''
r[6][5]='''900
-5 0
-5 0
-5 0
5 0
5 0
5 0
'''
r[7][5]='''1224
-5 0
-5 0
-5 0
3 -4
3 4
5 0
5 0
'''
r[8][5]='''1600
-5 0
-5 0
-5 0
-5 0
5 0
5 0
5 0
5 0
'''
r[2][6]='''144
-6 0
6 0
'''
r[3][6]='''312
-6 0
3 -5
3 5
'''
r[4][6]='''576
-6 0
-6 0
6 0
6 0
'''
r[5][6]='''880
-6 0
-3 -5
0 6
6 0
6 0
'''
r[6][6]='''1296
-6 0
-6 0
-6 0
6 0
6 0
6 0
'''
r[7][6]='''1740
-6 0
-6 0
-3 -5
0 6
6 0
6 0
6 0
'''
r[8][6]='''2304
-6 0
-6 0
-6 0
-6 0
6 0
6 0
6 0
6 0
'''
r[2][7]='''196
-7 0
7 0
'''
r[3][7]='''416
-3 -6
-3 6
7 0
'''
r[4][7]='''784
-7 0
-7 0
7 0
7 0
'''
r[5][7]='''1188
-7 0
-3 -6
0 7
7 0
7 0
'''
r[6][7]='''1764
-7 0
-7 0
-7 0
7 0
7 0
7 0
'''
r[7][7]='''2356
-7 0
-7 0
-3 -6
0 7
7 0
7 0
7 0
'''
r[8][7]='''3136
-7 0
-7 0
-7 0
-7 0
7 0
7 0
7 0
7 0
'''
r[2][8]='''256
-8 0
8 0
'''
r[3][8]='''554
-5 -6
0 8
8 0
'''
r[4][8]='''1024
-8 0
-8 0
8 0
8 0
'''
r[5][8]='''1572
-8 0
-5 -6
0 8
8 0
8 0
'''
r[6][8]='''2304
-8 0
-8 0
-8 0
8 0
8 0
8 0
'''
r[7][8]='''3102
-8 0
-8 0
-5 -6
0 8
8 0
8 0
8 0
'''
r[8][8]='''4096
-8 0
-8 0
-8 0
-8 0
8 0
8 0
8 0
8 0
'''
r[2][9]='''324
-9 0
9 0
'''
r[3][9]='''722
-4 -8
-4 8
9 0
'''
r[4][9]='''1296
-9 0
-9 0
9 0
9 0
'''
r[5][9]='''2014
-9 0
-4 -8
-4 8
9 0
9 0
'''
r[6][9]='''2916
-9 0
-9 0
-9 0
9 0
9 0
9 0
'''
r[7][9]='''3954
-9 0
-9 0
-4 -8
-4 8
9 0
9 0
9 0
'''
r[8][9]='''5184
-9 0
-9 0
-9 0
-9 0
9 0
9 0
9 0
9 0
'''
r[2][10]='''400
-10 0
10 0
'''
r[3][10]='''896
-10 0
6 -8
6 8
'''
r[4][10]='''1600
-10 0
-10 0
10 0
10 0
'''
r[5][10]='''2496
-10 0
-10 0
6 -8
6 8
10 0
'''
r[6][10]='''3600
-10 0
-10 0
-10 0
10 0
10 0
10 0
'''
r[7][10]='''4896
-10 0
-10 0
-10 0
6 -8
6 8
10 0
10 0
'''
r[8][10]='''6400
-10 0
-10 0
-10 0
-10 0
10 0
10 0
10 0
10 0
'''
r[2][11]='''484
-11 0
11 0
'''
r[3][11]='''1064
-11 0
6 -9
6 9
'''
r[4][11]='''1936
-11 0
-11 0
11 0
11 0
'''
r[5][11]='''2984
-11 0
-11 0
6 -9
6 9
11 0
'''
r[6][11]='''4356
-11 0
-11 0
-11 0
11 0
11 0
11 0
'''
r[7][11]='''5872
-11 0
-11 0
-6 -9
0 11
11 0
11 0
11 0
'''
r[8][11]='''7744
-11 0
-11 0
-11 0
-11 0
11 0
11 0
11 0
11 0
'''
r[2][12]='''576
-12 0
12 0
'''
r[3][12]='''1248
-12 0
6 -10
6 10
'''
r[4][12]='''2304
-12 0
-12 0
12 0
12 0
'''
r[5][12]='''3520
-12 0
-6 -10
0 12
12 0
12 0
'''
r[6][12]='''5184
-12 0
-12 0
-12 0
12 0
12 0
12 0
'''
r[7][12]='''6960
-12 0
-12 0
-6 -10
0 12
12 0
12 0
12 0
'''
r[8][12]='''9216
-12 0
-12 0
-12 0
-12 0
12 0
12 0
12 0
12 0
'''
r[2][13]='''676
-13 0
13 0
'''
r[3][13]='''1512
-5 -12
-5 12
13 0
'''
r[4][13]='''2704
-13 0
-13 0
13 0
13 0
'''
r[5][13]='''4224
-13 0
-5 -12
-5 12
12 -5
12 5
'''
r[6][13]='''6084
-13 0
-13 0
-13 0
13 0
13 0
13 0
'''
r[7][13]='''8280
-13 0
-13 0
-5 -12
-5 12
12 -5
12 5
13 0
'''
r[8][13]='''10816
-13 0
-13 0
-13 0
-13 0
13 0
13 0
13 0
13 0
'''
r[2][14]='''784
-14 0
14 0
'''
r[3][14]='''1746
-14 0
7 -12
7 12
'''
r[4][14]='''3136
-14 0
-14 0
14 0
14 0
'''
r[5][14]='''4870
-14 0
-7 -12
-5 13
14 0
14 0
'''
r[6][14]='''7056
-14 0
-14 0
-14 0
14 0
14 0
14 0
'''
r[7][14]='''9564
-14 0
-14 0
-7 -12
-5 13
14 0
14 0
14 0
'''
r[8][14]='''12544
-14 0
-14 0
-14 0
-14 0
14 0
14 0
14 0
14 0
'''
r[2][15]='''900
-15 0
15 0
'''
r[3][15]='''2016
-15 0
9 -12
9 12
'''
r[4][15]='''3600
-15 0
-15 0
15 0
15 0
'''
r[5][15]='''5616
-15 0
-15 0
9 -12
9 12
15 0
'''
r[6][15]='''8100
-15 0
-15 0
-15 0
15 0
15 0
15 0
'''
r[7][15]='''11016
-15 0
-15 0
-15 0
9 -12
9 12
15 0
15 0
'''
r[8][15]='''14400
-15 0
-15 0
-15 0
-15 0
15 0
15 0
15 0
15 0
'''
r[2][16]='''1024
-16 0
16 0
'''
r[3][16]='''2264
-16 0
9 -13
9 13
'''
r[4][16]='''4096
-16 0
-16 0
16 0
16 0
'''
r[5][16]='''6336
-16 0
-16 0
9 -13
9 13
16 0
'''
r[6][16]='''9216
-16 0
-16 0
-16 0
16 0
16 0
16 0
'''
r[7][16]='''12456
-16 0
-16 0
-16 0
9 -13
9 13
16 0
16 0
'''
r[8][16]='''16384
-16 0
-16 0
-16 0
-16 0
16 0
16 0
16 0
16 0
'''
r[2][17]='''1156
-17 0
17 0
'''
r[3][17]='''2600
-8 -15
-8 15
17 0
'''
r[4][17]='''4624
-17 0
-17 0
17 0
17 0
'''
r[5][17]='''7224
-17 0
-8 -15
-8 15
17 0
17 0
'''
r[6][17]='''10404
-17 0
-17 0
-17 0
17 0
17 0
17 0
'''
r[7][17]='''14160
-17 0
-17 0
-8 -15
-8 15
17 0
17 0
17 0
'''
r[8][17]='''18496
-17 0
-17 0
-17 0
-17 0
17 0
17 0
17 0
17 0
'''
r[2][18]='''1296
-18 0
18 0
'''
r[3][18]='''2888
-8 -16
-8 16
18 0
'''
r[4][18]='''5184
-18 0
-18 0
18 0
18 0
'''
r[5][18]='''8056
-18 0
-8 -16
-8 16
18 0
18 0
'''
r[6][18]='''11664
-18 0
-18 0
-18 0
18 0
18 0
18 0
'''
r[7][18]='''15816
-18 0
-18 0
-8 -16
-8 16
18 0
18 0
18 0
'''
r[8][18]='''20736
-18 0
-18 0
-18 0
-18 0
18 0
18 0
18 0
18 0
'''
r[2][19]='''1444
-19 0
19 0
'''
r[3][19]='''3218
-10 -16
-6 18
19 0
'''
r[4][19]='''5776
-19 0
-19 0
19 0
19 0
'''
r[5][19]='''9008
-18 -6
-18 -6
0 19
18 -6
19 0
'''
r[6][19]='''12996
-19 0
-19 0
-19 0
19 0
19 0
19 0
'''
r[7][19]='''17666
-19 0
-18 -6
-18 -6
0 19
18 -6
19 0
19 0
'''
r[8][19]='''23104
-19 0
-19 0
-19 0
-19 0
19 0
19 0
19 0
19 0
'''
r[2][20]='''1600
-20 0
20 0
'''
r[3][20]='''3584
-20 0
12 -16
12 16
'''
r[4][20]='''6400
-20 0
-20 0
20 0
20 0
'''
r[5][20]='''9984
-20 0
-20 0
12 -16
12 16
20 0
'''
r[6][20]='''14400
-20 0
-20 0
-20 0
20 0
20 0
20 0
'''
r[7][20]='''19584
-20 0
-20 0
-20 0
12 -16
12 16
20 0
20 0
'''
r[8][20]='''25600
-20 0
-20 0
-20 0
-20 0
20 0
20 0
20 0
20 0
'''
r[2][21]='''1764
-21 0
21 0
'''
r[3][21]='''3912
-17 -12
0 21
20 -6
'''
r[4][21]='''7056
-21 0
-21 0
21 0
21 0
'''
r[5][21]='''10942
-21 0
-17 -12
0 21
20 -6
21 0
'''
r[6][21]='''15876
-21 0
-21 0
-21 0
21 0
21 0
21 0
'''
r[7][21]='''21500
-21 0
-21 0
-17 -12
0 21
20 -6
21 0
21 0
'''
r[8][21]='''28224
-21 0
-21 0
-21 0
-21 0
21 0
21 0
21 0
21 0
'''
r[2][22]='''1936
-22 0
22 0
'''
r[3][22]='''4344
-22 0
11 -19
11 19
'''
r[4][22]='''7744
-22 0
-22 0
22 0
22 0
'''
r[5][22]='''12080
-22 0
-22 0
11 -19
11 19
22 0
'''
r[6][22]='''17424
-22 0
-22 0
-22 0
22 0
22 0
22 0
'''
r[7][22]='''23688
-22 0
-22 0
-22 0
11 -19
11 19
22 0
22 0
'''
r[8][22]='''30976
-22 0
-22 0
-22 0
-22 0
22 0
22 0
22 0
22 0
'''
r[2][23]='''2116
-23 0
23 0
'''
r[3][23]='''4712
-11 -20
-11 20
23 0
'''
r[4][23]='''8464
-23 0
-23 0
23 0
23 0
'''
r[5][23]='''13144
-23 0
-11 -20
-11 20
23 0
23 0
'''
r[6][23]='''19044
-23 0
-23 0
-23 0
23 0
23 0
23 0
'''
r[7][23]='''25808
-23 0
-23 0
-11 -20
-11 20
23 0
23 0
23 0
'''
r[8][23]='''33856
-23 0
-23 0
-23 0
-23 0
23 0
23 0
23 0
23 0
'''
r[2][24]='''2304
-24 0
24 0
'''
r[3][24]='''5138
-24 0
13 -20
13 20
'''
r[4][24]='''9216
-24 0
-24 0
24 0
24 0
'''
r[5][24]='''14326
-24 0
-24 0
13 -20
13 20
24 0
'''
r[6][24]='''20736
-24 0
-24 0
-24 0
24 0
24 0
24 0
'''
r[7][24]='''28122
-24 0
-24 0
-24 0
13 -20
13 20
24 0
24 0
'''
r[8][24]='''36864
-24 0
-24 0
-24 0
-24 0
24 0
24 0
24 0
24 0
'''
r[2][25]='''2500
-25 0
25 0
'''
r[3][25]='''5612
-24 -7
7 24
20 -15
'''
r[4][25]='''10000
-25 0
-25 0
25 0
25 0
'''
r[5][25]='''15624
-25 0
-7 -24
-7 24
20 -15
20 15
'''
r[6][25]='''22500
-25 0
-25 0
-25 0
25 0
25 0
25 0
'''
r[7][25]='''30624
-25 0
-25 0
-7 -24
-7 24
20 -15
20 15
25 0
'''
r[8][25]='''40000
-25 0
-25 0
-25 0
-25 0
25 0
25 0
25 0
25 0
'''
r[2][26]='''2704
-26 0
26 0
'''
r[3][26]='''6062
-12 -23
-12 23
26 0
'''
r[4][26]='''10816
-26 0
-26 0
26 0
26 0
'''
r[5][26]='''16896
-26 0
-10 -24
-10 24
24 -10
24 10
'''
r[6][26]='''24336
-26 0
-26 0
-26 0
26 0
26 0
26 0
'''
r[7][26]='''33120
-26 0
-26 0
-10 -24
-10 24
24 -10
24 10
26 0
'''
r[8][26]='''43264
-26 0
-26 0
-26 0
-26 0
26 0
26 0
26 0
26 0
'''
r[2][27]='''2916
-27 0
27 0
'''
r[3][27]='''6536
-27 0
14 -23
14 23
'''
r[4][27]='''11664
-27 0
-27 0
27 0
27 0
'''
r[5][27]='''18184
-27 0
-27 0
14 -23
14 23
27 0
'''
r[6][27]='''26244
-27 0
-27 0
-27 0
27 0
27 0
27 0
'''
r[7][27]='''35664
-27 0
-27 0
-27 0
14 -23
14 23
27 0
27 0
'''
r[8][27]='''46656
-27 0
-27 0
-27 0
-27 0
27 0
27 0
27 0
27 0
'''
r[2][28]='''3136
-28 0
28 0
'''
r[3][28]='''6984
-28 0
14 -24
14 24
'''
r[4][28]='''12544
-28 0
-28 0
28 0
28 0
'''
r[5][28]='''19488
-28 0
-22 -17
0 28
26 -10
28 0
'''
r[6][28]='''28224
-28 0
-28 0
-28 0
28 0
28 0
28 0
'''
r[7][28]='''38266
-28 0
-28 0
-22 -17
0 28
26 -10
28 0
28 0
'''
r[8][28]='''50176
-28 0
-28 0
-28 0
-28 0
28 0
28 0
28 0
28 0
'''
r[2][29]='''3364
-29 0
29 0
'''
r[3][29]='''7520
-20 -21
-7 28
28 -7
'''
r[4][29]='''13456
-29 0
-29 0
29 0
29 0
'''
r[5][29]='''20968
-29 0
-7 -28
0 29
20 -21
20 21
'''
r[6][29]='''30276
-29 0
-29 0
-29 0
29 0
29 0
29 0
'''
r[7][29]='''41200
-21 -20
-21 -20
-21 20
-21 20
29 0
29 0
29 0
'''
r[8][29]='''53824
-29 0
-29 0
-29 0
-29 0
29 0
29 0
29 0
29 0
'''
r[2][30]='''3600
-30 0
30 0
'''
r[3][30]='''8084
-24 18
0 -30
27 13
'''
r[4][30]='''14400
-30 0
-30 0
30 0
30 0
'''
r[5][30]='''22480
-30 0
-24 18
0 -30
27 13
30 0
'''
r[6][30]='''32400
-30 0
-30 0
-30 0
30 0
30 0
30 0
'''
r[7][30]='''44076
-30 0
-30 0
-30 0
18 24
24 -18
24 -18
27 13
'''
r[8][30]='''57600
-30 0
-30 0
-30 0
-30 0
30 0
30 0
30 0
30 0
'''
a,b=map(int,raw_input().split())
print r[a][b],","['geometry', 'sortings', 'brute force', 'math']"
"The development of a text editor is a hard problem. You need to implement an extra module for brackets coloring in text.Your editor consists of a line with infinite length and cursor, which points to the current character. Please note that it points to only one of the characters (and not between a pair of characters). Thus, it points to an index character. The user can move the cursor left or right one position. If the cursor is already at the first (leftmost) position, then it does not move left.Initially, the cursor is in the first (leftmost) character.Also, the user can write a letter or brackets (either (, or )) to the position that the cursor is currently pointing at. A new character always overwrites the old value at that position.Your editor must check, whether the current line is the correct text. Text is correct if the brackets in them form the correct bracket sequence.Formally, correct text (CT) must satisfy the following rules:   any line without brackets is CT (the line can contain whitespaces);  If the first character of the string — is (, the last — is ), and all the rest form a CT, then the whole line is a CT;  two consecutively written CT is also CT. Examples of correct texts: hello(codeforces), round, ((i)(write))edi(tor)s, ( me). Examples of incorrect texts: hello)oops(, round), ((me).The user uses special commands to work with your editor. Each command has its symbol, which must be written to execute this command.The correspondence of commands and characters is as follows:   L — move the cursor one character to the left (remains in place if it already points to the first character);  R — move the cursor one character to the right;  any lowercase Latin letter or bracket (( or )) — write the entered character to the position where the cursor is now. For a complete understanding, take a look at the first example and its illustrations in the note below.You are given a string containing the characters that the user entered. For the brackets coloring module's work, after each command you need to:  check if the current text in the editor is a correct text;  if it is, print the least number of colors that required, to color all brackets. If two pairs of brackets are nested (the first in the second or vice versa), then these pairs of brackets should be painted in different colors. If two pairs of brackets are not nested, then they can be painted in different or the same colors. For example, for the bracket sequence ()(())()() the least number of colors is $$$2$$$, and for the bracket sequence (()(()())())(()) — is $$$3$$$.Write a program that prints the minimal number of colors after processing each command.","from __future__ import print_function,division
import sys
n =int(input())
af=[]
d={'(':1,')':-1,' ':0}
cu=0
lo=20
N=2**20
s=[[0]*(2**k) for k in range(lo,-1,-1)]
mi=[[0]*(2**k) for k in range(lo,-1,-1)]
ma=[[0]*(2**k) for k in range(lo,-1,-1)]
l=[0]*N
for k in raw_input():
    if k=='L':
        if cu:
            cu-=1
    elif (k=='R'):
        cu+=1
    else:
        if not(k in d):
            k=' '
        s[0][cu]=d[k]
        h=1
        cuh=cu
        while h<=lo:
            cuh//=2
            s[h][cuh]=s[h-1][2*cuh]+s[h-1][2*cuh+1]
            h+=1
        h=1
        cuh=cu
        while h<=lo:
            cuh//=2
            mi[h][cuh]=min(mi[h-1][2*cuh],s[h-1][2*cuh]+mi[h-1][2*cuh+1])
            h+=1
        h=1
        cuh=cu
        while h<=lo:
            cuh//=2
            ma[h][cuh]=max(ma[h-1][2*cuh],s[h-1][2*cuh]+ma[h-1][2*cuh+1])
            h+=1
    af.append(ma[-1][0] if mi[-1][0]==0 and s[-1][0]==0 else -1)
print("" "".join(map(str,af)))        
""""""af=[]
p=0
n=int(input())

N=10**6
l=[' ']*N
cog=[True]*N
cod=[True]*N
mid=[0]*N
s=0
h=0
m=0
d={'(':1,')':-1,' ':0}

for k in raw_input():
    if k=='L':
        if p:
            h-d[l[p]]
            p-=1
            mid[p]=((h-s)>=0 and mid[p+1])
    elif (k=='R'):
        p+=1
        h+=d[l[p]]
        cog[p]=(cog[p-1] and h>=0)
    else :
        if not(k in d):
            k=' '
        x=d[k]-d[l[p]]
        s+=x
        h+=x
        l[p]=k
    #if

print(""\n"".join(map(str,af)))""""""","['data structures', 'implementation']"
"A widely known among some people Belarusian sport programmer Lesha decided to make some money to buy a one square meter larger flat. To do this, he wants to make and carry out a Super Rated Match (SRM) on the site Torcoder.com. But there's a problem — a severe torcoder coordinator Ivan does not accept any Lesha's problem, calling each of them an offensive word ""duped"" (that is, duplicated). And one day they nearely quarrelled over yet another problem Ivan wouldn't accept.You are invited to act as a fair judge and determine whether the problem is indeed brand new, or Ivan is right and the problem bears some resemblance to those used in the previous SRMs.You are given the descriptions of Lesha's problem and each of Torcoder.com archive problems. The description of each problem is a sequence of words. Besides, it is guaranteed that Lesha's problem has no repeated words, while the description of an archive problem may contain any number of repeated words.The ""similarity"" between Lesha's problem and some archive problem can be found as follows. Among all permutations of words in Lesha's problem we choose the one that occurs in the archive problem as a subsequence. If there are multiple such permutations, we choose the one with the smallest number of inversions. Then the ""similarity"" of a problem can be written as , where n is the number of words in Lesha's problem and x is the number of inversions in the chosen permutation. Note that the ""similarity"" p is always a positive integer.The problem is called brand new if there is not a single problem in Ivan's archive which contains a permutation of words from Lesha's problem as a subsequence.Help the boys and determine whether the proposed problem is new, or specify the problem from the archive which resembles Lesha's problem the most, otherwise.","import itertools

def check(curr_words, line):
    if curr_words == []: 
        return True
    for i in range(len(line)):
        if line[i] == curr_words[0]:
            return check(curr_words[1:], line[i+1:])
    return False

n = int(input())
words = input().split()
m = int(input())
res, idx = 0, 0
for i in range(m):
    line = input().split()[1:]
    for p in itertools.permutations(range(n)):
        curr_words = [words[j] for j in p]
        cnt = 0
        for j in range(n):
            cnt += len([k for k in range(j+1, n) if p[k] < p[j]])
        v = n * (n-1) // 2 - cnt + 1
        if check(curr_words, line[:]) and v > res: 
            res, idx = v, i+1
if res > 0:
    print(idx)
    print('[:'+str('|'*res)+':]')
else:
    print('Brand new problem!')",['brute force']
"You are given a binary matrix $$$A$$$ of size $$$n \times n$$$. Let's denote an $$$x$$$-compression of the given matrix as a matrix $$$B$$$ of size $$$\frac{n}{x} \times \frac{n}{x}$$$ such that for every $$$i \in [1, n], j \in [1, n]$$$ the condition $$$A[i][j] = B[\lceil \frac{i}{x} \rceil][\lceil \frac{j}{x} \rceil]$$$ is met.Obviously, $$$x$$$-compression is possible only if $$$x$$$ divides $$$n$$$, but this condition is not enough. For example, the following matrix of size $$$2 \times 2$$$ does not have any $$$2$$$-compression: $$$01$$$   $$$10$$$ For the given matrix $$$A$$$, find maximum $$$x$$$ such that an $$$x$$$-compression of this matrix is possible.Note that the input is given in compressed form. But even though it is compressed, you'd better use fast input.","import atexit, io, sys 
  
# A stream implementation using an in-memory bytes  
# buffer. It inherits BufferedIOBase. 
buffer = io.BytesIO() 
sys.stdout = buffer
  
# print via here 
@atexit.register 
def write(): 
    sys.__stdout__.write(buffer.getvalue())

def gcd(a,b):
	if(a>b):
		temp=b
		b=a
		a=temp
	if(a==0):
		return b
	else:
		return gcd(b%a,a)

n=int(raw_input())
arr=[]
mindiff=10**9
ans=-1
flag=0
for i in range(n):
	s=raw_input()
	s1=''
	j=0
	while(j<len(s)):
		if(65<=ord(s[j])<=70):
			num=10+(ord(s[j])-65)
			s1+=bin(num)[2:]
		else:
			num=bin(int(s[j]))[2:]
			num=(4-len(num))*'0'+num
			s1+=num
		j+=1
	initial=s1[0]
	j=1
	count=1
	while(j<len(s1)):
		if(s1[j]==initial):
			count+=1	
		else:
			if(ans==-1):
				ans=count
			else:
				ans=gcd(ans,count)
			count=1
			initial=s1[j]
		j+=1
	if(ans==-1):
		ans=count
	else:
		ans=gcd(ans,count)
	arr.append(s1)
#print(*arr)
if(ans==1):
	print(1)
	exit(0)
for i in range(n):
	initial=arr[0][i]
	count=1
	for j in range(1,n):
		if(arr[j][i]==initial):
			count+=1	
		else:
			ans=gcd(ans,count)
			count=1
			initial=arr[j][i]
			if(ans==1):
				print(1)
				exit(0)
	ans=gcd(ans,count)
	if(ans==1):
		print(1)
		exit(0)
print(ans)","['dp', 'implementation', 'number theory', 'math']"
"Alice, the president of club FCB, wants to build a team for the new volleyball tournament. The team should consist of $$$p$$$ players playing in $$$p$$$ different positions. She also recognizes the importance of audience support, so she wants to select $$$k$$$ people as part of the audience.There are $$$n$$$ people in Byteland. Alice needs to select exactly $$$p$$$ players, one for each position, and exactly $$$k$$$ members of the audience from this pool of $$$n$$$ people. Her ultimate goal is to maximize the total strength of the club.The $$$i$$$-th of the $$$n$$$ persons has an integer $$$a_{i}$$$ associated with him — the strength he adds to the club if he is selected as a member of the audience.For each person $$$i$$$ and for each position $$$j$$$, Alice knows $$$s_{i, j}$$$  — the strength added by the $$$i$$$-th person to the club if he is selected to play in the $$$j$$$-th position.Each person can be selected at most once as a player or a member of the audience. You have to choose exactly one player for each position.Since Alice is busy, she needs you to help her find the maximum possible strength of the club that can be achieved by an optimal choice of players and the audience.","import io
import os


# PSA:
# The key optimization that made this pass was to avoid python big ints by using floats (which have integral precision <= 2^52)
# None of the other optimizations really mattered in comparison.
# Credit for this trick goes to pajenegod: https://codeforces.com/blog/entry/77309?#comment-622486

popcount = []
for mask in range(1 << 7):
    popcount.append(bin(mask).count(""1""))

maskToPos = []
for mask in range(1 << 7):
    maskToPos.append([i for i in range(7) if mask & (1 << i)])


inf = float(""inf"")


def solve(N, P, K, audienceScore, playerScore):
    scores = sorted(zip(audienceScore, playerScore), reverse=True)
    scoresA = [0.0 for i in range(N)]
    scoresP = [0.0 for i in range(7 * N)]
    for i, (a, ps) in enumerate(scores):
        scoresA[i] = float(a)
        for j, p in enumerate(ps):
            scoresP[7 * i + j] = float(p)

    f = [-inf for mask in range(1 << P)]
    nextF = [-inf for mask in range(1 << P)]

    f[0] = scoresA[0]
    for pos in range(P):
        f[1 << pos] = scoresP[pos]

    for n in range(1, N):
        for mask in range(1 << P):
            best = f[mask]
            if n - popcount[mask] < K:
                best += scoresA[n]
            for pos in maskToPos[mask]:
                best = max(best, scoresP[7 * n + pos] + f[mask - (1 << pos)])
            nextF[mask] = best

        f, nextF = nextF, f

    return int(max(f))


if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, P, K = list(map(int, input().split()))
    audienceScore = [int(x) for x in input().split()]
    playerScore = [[int(x) for x in input().split()] for i in range(N)]
    ans = solve(N, P, K, audienceScore, playerScore)
    print(ans)","['dp', 'bitmasks', 'sortings', 'greedy']"
"You are given a connected undirected weighted graph consisting of $$$n$$$ vertices and $$$m$$$ edges.You need to print the $$$k$$$-th smallest shortest path in this graph (paths from the vertex to itself are not counted, paths from $$$i$$$ to $$$j$$$ and from $$$j$$$ to $$$i$$$ are counted as one).More formally, if $$$d$$$ is the matrix of shortest paths, where $$$d_{i, j}$$$ is the length of the shortest path between vertices $$$i$$$ and $$$j$$$ ($$$1 \le i &lt; j \le n$$$), then you need to print the $$$k$$$-th element in the sorted array consisting of all $$$d_{i, j}$$$, where $$$1 \le i &lt; j \le n$$$.","from __future__ import division, print_function
 
DEBUG = 0
 
import os, sys
from atexit import register
from io import BytesIO
import itertools
 
if sys.version_info[0] < 3:
    input = raw_input
    range = xrange
 
    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip
 
if DEBUG:
    debug_print = print
else:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
    sys.stdout = BytesIO()
    register(lambda: os.write(1, sys.stdout.getvalue()))
 
    input = lambda: sys.stdin.readline().rstrip('\r\n')
    debug_print = lambda *x, **y: None
 
 
def input_as_list():
    return list(map(int, input().split()))
 
 
def array_of(f, *dim):
    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()
 
 
def main():
    from heapq import heapify, heappop, heappush
 
    n, m, k = input_as_list()
 
    g = array_of(list, n)
    elist = []
    pq = []
 
    for _ in range(m):
        u, v, d = input_as_list()
        elist.append((d, u-1, v-1))
 
    elist.sort()
    elist = elist[:k]
 
    V = set()
    for d, u, v in elist:
        V.add(u)
        V.add(v)
        g[u].append((v, d))
        g[v].append((u, d))
 
    all_paths = []
 
    for v in V:
        pq = [(0, v)]
        ub = dict()
        done = set()
 
        while pq:
            d, x = heappop(pq)
 
            if x in done:
                continue
 
            debug_print(v, x, d)
            done.add(x)
            if d > 0 : all_paths.append(d)
 
            for u, du in g[x]:
                du += d
 
                if u in ub and du >= ub[u]:
                    continue
 
                heappush(pq, (du, u))
                ub[u] = du
 
    all_paths.sort()
    print(all_paths[2*k-1])
 
main()","['constructive algorithms', 'sortings', 'brute force', 'shortest paths']"
"Konrad is a Human Relations consultant working for VoltModder, a large electrical equipment producer. Today, he has been tasked with evaluating the level of happiness in the company.There are $$$n$$$ people working for VoltModder, numbered from $$$1$$$ to $$$n$$$. Each employee earns a different amount of money in the company — initially, the $$$i$$$-th person earns $$$i$$$ rubles per day.On each of $$$q$$$ following days, the salaries will be revised. At the end of the $$$i$$$-th day, employee $$$v_i$$$ will start earning $$$n+i$$$ rubles per day and will become the best-paid person in the company. The employee will keep his new salary until it gets revised again.Some pairs of people don't like each other. This creates a great psychological danger in the company. Formally, if two people $$$a$$$ and $$$b$$$ dislike each other and $$$a$$$ earns more money than $$$b$$$, employee $$$a$$$ will brag about this to $$$b$$$. A dangerous triple is a triple of three employees $$$a$$$, $$$b$$$ and $$$c$$$, such that $$$a$$$ brags to $$$b$$$, who in turn brags to $$$c$$$. If $$$a$$$ dislikes $$$b$$$, then $$$b$$$ dislikes $$$a$$$.At the beginning of each day, Konrad needs to evaluate the number of dangerous triples in the company. Can you help him do it?","import sys
input = sys.stdin.readline

n,m=map(int,input().split())

IN=[0]*n
OUT=[0]*n

INSET=[[] for i in range(n)]

for i in range(m):
    x,y=sorted(map(int,input().split()))

    IN[x-1]+=1
    OUT[y-1]+=1
    INSET[x-1].append(y-1)

ANS=0
for i in range(n):
    ANS+=IN[i]*OUT[i]

print(ANS)

Q=int(input())

for i in range(Q):
    q=int(input())-1
    ANS-=IN[q]*OUT[q]
    OUT[q]+=IN[q]
    IN[q]=0

    for x in INSET[q]:
        INSET[x].append(q)
        ANS+=(IN[x]+1)*(OUT[x]-1)-IN[x]*OUT[x]
        IN[x]+=1
        OUT[x]-=1

    INSET[q]=[]

    print(ANS)","['brute force', 'graphs']"
"Dasha decided to have a rest after solving the problem. She had been ready to start her favourite activity — origami, but remembered the puzzle that she could not solve.   The tree is a non-oriented connected graph without cycles. In particular, there always are n - 1 edges in a tree with n vertices.The puzzle is to position the vertices at the points of the Cartesian plane with integral coordinates, so that the segments between the vertices connected by edges are parallel to the coordinate axes. Also, the intersection of segments is allowed only at their ends. Distinct vertices should be placed at different points. Help Dasha to find any suitable way to position the tree vertices on the plane.It is guaranteed that if it is possible to position the tree vertices on the plane without violating the condition which is given above, then you can do it by using points with integral coordinates which don't exceed 1018 in absolute value.","#https://codeforces.com/problemset/problem/761/E
def solve():
    def push(u, v, g):
        if u not in g:
            g[u] = []
        if v not in g:
            g[v] = []    
        g[u].append(v)
        g[v].append(u)
        
    n = int(input())
    g = {}
    
    for _ in range(n-1):
        u, v = map(int, input().split())
        push(u, v, g)
    
    for u in g:
        if len(g[u]) > 4:
            return 'NO', None
    d = {}    
    build(1, 0, 0, 0, 31, -1, d, g)
    s = ''
    for u in range(1, n+1):
        x, y = d[u]
        s += str(x) + ' ' + str(y)
        s += '\n'
    return 'YES', s

def cal_pos(dir_, cur_x, cur_y, cur_base):
    if dir_   == 0:
        return cur_x, cur_y + (1<<cur_base)
    elif dir_ == 1:
        return cur_x + (1<<cur_base), cur_y
    elif dir_ == 2:
        return cur_x, cur_y - (1<<cur_base)
    else:
        return cur_x - (1<<cur_base), cur_y
        
def build(u, p, cur_x, cur_y, cur_base, pre_dir, d, g):
    d[u]  = [cur_x, cur_y]
    type_ = [0,1,2,3]
        
    if pre_dir in type_:
        type_.remove(pre_dir)
    
    if u in g:
        for v in g[u]:
            if v != p:
                dir_ = type_.pop() 
                
                next_x, next_y =  cal_pos(dir_, cur_x, cur_y, cur_base)    
                build(v, u, next_x, next_y, cur_base-1, (dir_ - 2)%4, d, g)
                
ans ,s = solve()
if ans == 'NO':
    print(ans)
else:    
    print(ans)
    print(s)","['greedy', 'graphs', 'constructive algorithms', 'dfs and similar', 'trees']"
"There are $$$n$$$ officers in the Army of Byteland. Each officer has some power associated with him. The power of the $$$i$$$-th officer is denoted by $$$p_{i}$$$. As the war is fast approaching, the General would like to know the strength of the army.The strength of an army is calculated in a strange way in Byteland. The General selects a random subset of officers from these $$$n$$$ officers and calls this subset a battalion.(All $$$2^n$$$ subsets of the $$$n$$$ officers can be chosen equally likely, including empty subset and the subset of all officers).The strength of a battalion is calculated in the following way:Let the powers of the chosen officers be $$$a_{1},a_{2},\ldots,a_{k}$$$, where $$$a_1 \le a_2 \le \dots \le a_k$$$. The strength of this battalion is equal to $$$a_1a_2 + a_2a_3 + \dots + a_{k-1}a_k$$$. (If the size of Battalion is $$$\leq 1$$$, then the strength of this battalion is $$$0$$$).The strength of the army is equal to the expected value of the strength of the battalion.As the war is really long, the powers of officers may change. Precisely, there will be $$$q$$$ changes. Each one of the form $$$i$$$ $$$x$$$ indicating that $$$p_{i}$$$ is changed to $$$x$$$.You need to find the strength of the army initially and after each of these $$$q$$$ updates.Note that the changes are permanent.The strength should be found by modulo $$$10^{9}+7$$$. Formally, let $$$M=10^{9}+7$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$p/q$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q\not\equiv 0 \bmod M$$$). Output the integer equal to $$$p\cdot q^{-1} \bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \leq x &lt; M$$$ and $$$x ⋅ q \equiv p \bmod M$$$).","import sys, os
range = xrange
input = raw_input
 
import __pypy__
mulmod = __pypy__.intop.int_mulmod
sub = __pypy__.intop.int_sub
mul = __pypy__.intop.int_mul
MOD = 10**9 + 7
MODINV = 1.0/MOD
 
def mulmod(a,b):
    x = sub(mul(a,b), mul(MOD, int(a * MODINV * b)))
    return x + MOD if (x < 0) else (x if x < MOD else x - MOD)
 
 
#precalc 2^-1 powers
invpow = pow(2, MOD - 2, MOD)
pow2 = [1]
for _ in range(3 * 10**5 + 10):
    pow2.append(mulmod(pow2[-1], invpow))
 
# returns order such that A[order[i]] <= A[order[i + 1]]
def sqrtsorted(A, maxval = 10**9):
    asqrt = int((maxval)**0.5 + 2)
    blocks1 = [[] for _ in range(asqrt)]
    blocks2 = [[] for _ in range(asqrt)]
    for i in range(len(A)):
        blocks1[A[i] % asqrt].append(i)
    for block in blocks1:
        for i in block:
            blocks2[A[i]//asqrt].append(i)
    ret = []
    for block in blocks2:
        ret += block
    return ret
 
# Keeps track of expected power using the structure of the segment tree
class segtree:
    def __init__(self, data, counter):
        n = len(data)
        m = 1
        while m < n: m *= 2
        
        self.m = m
        self.dataL = [0]*(m+m)
        self.dataR = [0]*(m+m)
        self.counter = [0]*(m+m)
        self.power = 0
 
        self.dataL[m:m+n] = data
        self.dataR[m:m+n] = data
        self.counter[m:m+n] = counter
 
        for ind in reversed(range(1,m)):
            self.counter[ind] = self.counter[ind << 1] + self.counter[(ind << 1) + 1]
            
            self.dataL[ind] = (mulmod(self.dataL[ind << 1], pow2[self.counter[(ind << 1) + 1]]) + self.dataL[(ind << 1) + 1] ) % MOD
            self.dataR[ind] = (self.dataR[ind << 1] + mulmod(self.dataR[(ind << 1) + 1], pow2[self.counter[ind << 1]]) ) % MOD
            self.power = (self.power + mulmod(self.dataL[ind << 1], self.dataR[(ind << 1) + 1]) ) % MOD
            
 
    
    # Keeps track of expected power when the segment tree is modified
    def add(self, ind, val, c = 1):
        ind += self.m
        while ind > 1:
            self.counter[ind] += c
            self.power = self.power - mulmod(self.dataL[ind & ~1], self.dataR[ind | 1])
            
            # If first time
            if ind >= self.m:
                self.dataL[ind] = val
                self.dataR[ind] = val
            else:
                self.dataL[ind] = (mulmod(self.dataL[ind << 1], pow2[self.counter[(ind << 1) + 1]]) + self.dataL[(ind << 1) + 1] ) % MOD
                self.dataR[ind] = (self.dataR[ind << 1] + mulmod(self.dataR[(ind << 1) + 1], pow2[self.counter[ind << 1]]) ) % MOD
            
            self.power = (self.power + mulmod(self.dataL[ind & ~1], self.dataR[ind | 1]) ) % MOD
            
            ind >>= 1
    
    def rem(self, ind):
        self.add(ind, 0, -1)
    
    def get_power(self):
        return mulmod(self.power, pow2[2])
 
#############
### READ INPUT
 
inp = [int(x) for x in os.read(0, os.fstat(0).st_size).split()]; ii = 0
n = inp[ii]; ii += 1
 
# Order all involved powers
values = inp[ii: ii + n] + inp[ii + n + 2:: 2]
order = sqrtsorted(values)
 
invorder = [-1]*len(order)
for i in range(len(order)):
    invorder[order[i]] = i
 
# Initialize the seg tree containing powers
P = inp[ii: ii + n]; ii += n
who = list(range(n))
 
 
##############
### POPULATE SEGTREE
 
power = 0
 
data = [0]*len(order)
counter = [0]*len(order)
for i in range(n):
    data[invorder[i]] = P[i]
    counter[invorder[i]] = 1
 
seg = segtree(data, counter)
 
##############
### SOLVE QUERIES
 
import __pypy__
out = __pypy__.builders.StringBuilder()
 
q = inp[ii]; ii += 1
out.append(str(seg.get_power()))
out.append('\n')
for _ in range(q):
    i = inp[ii] - 1; ii += 1
    x = inp[ii]; ii += 1
 
    # Remove power at who[i]
    ind = invorder[who[i]]
    seg.rem(ind)
 
    # Add new power at i
    ind = invorder[n + _]
    who[i] = n + _
    seg.add(ind, x)
 
    out.append(str(seg.get_power()))
    out.append('\n')
 
os.write(1, out.build())","['data structures', 'divide and conquer', 'probabilities']"
"Slime and his $$$n$$$ friends are at a party. Slime has designed a game for his friends to play.At the beginning of the game, the $$$i$$$-th player has $$$a_i$$$ biscuits. At each second, Slime will choose a biscuit randomly uniformly among all $$$a_1 + a_2 + \ldots + a_n$$$ biscuits, and the owner of this biscuit will give it to a random uniform player among $$$n-1$$$ players except himself. The game stops when one person will have all the biscuits.As the host of the party, Slime wants to know the expected value of the time that the game will last, to hold the next activity on time.For convenience, as the answer can be represented as a rational number $$$\frac{p}{q}$$$ for coprime $$$p$$$ and $$$q$$$, you need to find the value of $$$(p \cdot q^{-1})\mod 998\,244\,353$$$. You can prove that $$$q\mod 998\,244\,353 \neq 0$$$.","import sys
import __pypy__
range = xrange
input = raw_input

MOD = 998244353
modmult = __pypy__.intop.int_mulmod
mu = lambda a,b: modmult(a, b, MOD)

big = 3*10**5 + 10
modinv = [1]*big
for i in range(2,big):
    modinv[i] = mu(-(MOD//i), modinv[MOD%i])

n = int(input())
A = [int(x) for x in input().split()]
m = sum(A)

AA = []
BB = []
CC = []
DD = []
for i in range(m):
    a = -mu(i, modinv[m])
    b = 1 - mu(mu(m - i, modinv[m]), mu(n - 2, modinv[n - 1]))
    c = -mu(mu(m - i, modinv[m]), mu(1    , modinv[n - 1]))

    AA.append(a)
    BB.append(b)
    CC.append(c)
    DD.append(1)

def solve(m,A,B,C,D):
    cur = [A[m - 1], B[m - 1], D[m - 1]]
    for i in reversed(range(m - 1)):
        k = mu(-cur[1], pow(C[i], MOD-2, MOD))
        cur = [mu(k, (A[i] if i else 0)), cur[0] + mu(k, B[i]), cur[2] + mu(k, D[i])]
        cur = [c % MOD for c in cur]

    X = [mu(cur[2], pow(cur[1], MOD - 2, MOD))]
    for i in range(m - 1):
        X.append(mu(D[i] - (mu(A[i], X[i - 1]) if i else 0) - mu(B[i], X[i]), pow(C[i], MOD - 2, MOD)))
    
    #ans = [(A[i] * X[i - 1] if i else 0) + B[i] * X[i] + (C[i] * X[i + 1] if i + 1 < m else 0) for i in range(m)]
    #assert ans == D
    return X

F = solve(m, AA, BB, CC, DD)
F.append(0)
num = sum(F[a] for a in A) % MOD - mu(n - 1, F[0])
den = n

print mu(num, pow(den, MOD - 2, MOD))","['probabilities', 'math']"
"Hag is a very talented person. He has always had an artist inside him but his father forced him to study mechanical engineering.Yesterday he spent all of his time cutting a giant piece of wood trying to make it look like a goose. Anyway, his dad found out that he was doing arts rather than studying mechanics and other boring subjects. He confronted Hag with the fact that he is a spoiled son that does not care about his future, and if he continues to do arts he will cut his 25 Lira monthly allowance.Hag is trying to prove to his dad that the wooden piece is a project for mechanics subject. He also told his dad that the wooden piece is a strictly convex polygon with $$$n$$$ vertices.Hag brought two pins and pinned the polygon with them in the $$$1$$$-st and $$$2$$$-nd vertices to the wall. His dad has $$$q$$$ queries to Hag of two types.   $$$1$$$ $$$f$$$ $$$t$$$: pull a pin from the vertex $$$f$$$, wait for the wooden polygon to rotate under the gravity force (if it will rotate) and stabilize. And then put the pin in vertex $$$t$$$.  $$$2$$$ $$$v$$$: answer what are the coordinates of the vertex $$$v$$$. Please help Hag to answer his father's queries.You can assume that the wood that forms the polygon has uniform density and the polygon has a positive thickness, same in all points. After every query of the 1-st type Hag's dad tries to move the polygon a bit and watches it stabilize again.","import math;
#Вычисление координаты точки по координатам центра, углу, и начальным относительно центра
def getCoordinate(gx, gy, alpha, x, y):
    x1=gx+x*math.cos(alpha)-y*math.sin(alpha);
    y1=gy+x*math.sin(alpha)+y*math.cos(alpha);
    return x1, y1
#Вычисление угла, на который надо повернуть точку с координатами x, y,
#чтобы она оказалась прямо над gx, gy
def getAngle(gx, gy, x, y):
    x=x-gx;
    y=y-gy;
    cos=x/math.sqrt(x**2+y**2);
    alpha=math.acos(cos);
    if y<0:
        alpha=-alpha;
    return math.pi/2-alpha;
n, q = map(int, input().split(' '));
x=[0]*n;
y=[0]*n;
for i in range(n):
    x[i], y[i]=map(int, input().split(' '));
r=[0]*q;
f=[0]*q;
t=[0]*q;
v=[0]*q;
for i in range(q):
    l=list(map(int, input().split(' ')));
    r[i]=l[0];
    if r[i]==1:
        f[i]=l[1]-1;
        t[i]=l[2]-1;
    else:
        v[i]=l[1]-1;
gx=0;
gy=0;
s=0;
for i in range(n):
    ip=i+1;
    if ip==n:
        ip=0;
    ds=x[i]*y[ip]-x[ip]*y[i];
    s+=ds;
    gx+=(x[i]+x[ip])*ds;
    gy+=(y[i]+y[ip])*ds;
s/=2;
gx/=6*s;
gy/=6*s;
angles=[0]*n;
for i in range(n):
    angles[i]=getAngle(gx, gy, x[i], y[i]);
for i in range(n):
    x[i]-=gx;
    y[i]-=gy;
alpha=0;
#print('pos',gx, gy, alpha);
#Восстанавливать положение точек будем по центру масс и углу
#Угол - поворот против часовой вокруг центра масс
fix={0, 1}
for i in range(q):
    if r[i]==2:
        currX, currY = getCoordinate(gx, gy, alpha, x[v[i]], y[v[i]]);
        print(""%.6f %.6f""%(currX, currY))
    else:
        if len(fix)==2:
            fix.remove(f[i]);
        #print('remove',f[i])
        #j - единственный элемент в множестве
        for j in fix:
            #print(j);
            currX, currY = getCoordinate(gx, gy, alpha, x[j], y[j]);
            #print('fix:', currX, currY)
            #dalpha=getAngle(gx, gy, currX, currY);
            #alpha+=dalpha;
            alpha=angles[j];
            #Чтобы вычислить новые координаты g, нуно повернуть ее на угол
            #dalpha относительно currX, currY
            gx, gy=currX, currY-math.sqrt(x[j]**2+y[j]**2);
            
            #print('pos',gx, gy, alpha/math.pi)
        fix.add(t[i]);",['geometry']
"There is a square grid of size $$$n \times n$$$. Some cells are colored in black, all others are colored in white. In one operation you can select some rectangle and color all its cells in white. It costs $$$\min(h, w)$$$ to color a rectangle of size $$$h \times w$$$. You are to make all cells white for minimum total cost.The square is large, so we give it to you in a compressed way. The set of black cells is the union of $$$m$$$ rectangles.","import sys
from collections import defaultdict

class MaxFlow(object):
    def __init__(self):
        self.edges = defaultdict(lambda: defaultdict(lambda: 0))

    def add_edge(self, u, v, capacity=float('inf')):
        self.edges[u][v] = capacity

    def bfs(self, s, t):
        open_q = [s]

        visited = set()
        parent = dict()
        while open_q:
            close_q = []
            for node in open_q:
                for v, capacity in self.edges[node].items():
                    if v not in visited and capacity > 0:
                        close_q.append(v)
                        parent[v] = node
                        visited.add(v)
                        if v == t:
                            result = []
                            n2 = v
                            n1 = node
                            while n1 != s:
                                result.append((n1, n2))
                                n2 = n1
                                n1 = parent[n1]
                            result.append((n1, n2))
                            return result

            open_q = close_q

        return None

    def solve(self, s, t):
        flow = 0
        route = self.bfs(s, t)
        while route is not None:
            new_flow = float('inf')
            for _, (n1, n2) in enumerate(route):
                new_flow = min(new_flow, self.edges[n1][n2])
            for _, (n1, n2) in enumerate(route):
                self.edges[n1][n2] -= new_flow
                self.edges[n2][n1] += new_flow
            flow += new_flow

            route = self.bfs(s, t)

        return flow

    def __str__(self):
        result = ""{ ""
        for k, v in self.edges.items():
            result += str(k) + "":"" + str(dict(v)) + "", ""
        result += ""}""
        return result


def main():
    (n, m) = tuple([int(x) for x in input().split()])
    r = []
    xs = set()
    ys = set()
    for i in range(m):
        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())
        r.append((x1, y1, x2, y2))
        xs.add(x1)
        xs.add(x2 + 1)
        ys.add(y1)
        ys.add(y2 + 1)

    xx = sorted(xs)
    yy = sorted(ys)
    xsize = len(xs)
    ysize = len(ys)
    grid = []
    for i in range(ysize):
        grid.append([False] * xsize)

    for rect in r:
        x1 = rect[0]
        y1 = rect[1]
        x2 = rect[2]
        y2 = rect[3]
        for i, y in enumerate(yy):
            for j, x in enumerate(xx):
                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:
                    grid[i][j] = True

    f = MaxFlow()
    for i in range(len(yy)):
        for j in range(len(xx)):
            if grid[i][j]:
                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))
    for i in range(len(yy) - 1):
        f.add_edge(0, i + 1, yy[i + 1] - yy[i])
    for i in range(len(xx) - 1):
        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i])

    # print(xx)
    # print(yy)
    # print(f)
    print(f.solve(0, len(xx) + len(yy) + 1))


if __name__ == '__main__':
    main()","['graph matchings', 'flows', 'graphs']"
"Shichikuji is the new resident deity of the South Black Snail Temple. Her first job is as follows:There are $$$n$$$ new cities located in Prefecture X. Cities are numbered from $$$1$$$ to $$$n$$$. City $$$i$$$ is located $$$x_i$$$ km North of the shrine and $$$y_i$$$ km East of the shrine. It is possible that $$$(x_i, y_i) = (x_j, y_j)$$$ even when $$$i \ne j$$$.Shichikuji must provide electricity to each city either by building a power station in that city, or by making a connection between that city and another one that already has electricity. So the City has electricity if it has a power station in it or it is connected to a City which has electricity by a direct connection or via a chain of connections.     Building a power station in City $$$i$$$ will cost $$$c_i$$$ yen;     Making a connection between City $$$i$$$ and City $$$j$$$ will cost $$$k_i + k_j$$$ yen per km of wire used for the connection. However, wires can only go the cardinal directions (North, South, East, West). Wires can cross each other. Each wire must have both of its endpoints in some cities. If City $$$i$$$ and City $$$j$$$ are connected by a wire, the wire will go through any shortest path from City $$$i$$$ to City $$$j$$$. Thus, the length of the wire if City $$$i$$$ and City $$$j$$$ are connected is $$$|x_i - x_j| + |y_i - y_j|$$$ km. Shichikuji wants to do this job spending as little money as possible, since according to her, there isn't really anything else in the world other than money. However, she died when she was only in fifth grade so she is not smart enough for this. And thus, the new resident deity asks for your help.And so, you have to provide Shichikuji with the following information: minimum amount of yen needed to provide electricity to all cities, the cities in which power stations will be built, and the connections to be made.If there are multiple ways to choose the cities and the connections to obtain the construction of minimum price, then print any of them.","import os
import sys
from atexit import register
from io import BytesIO
range = xrange
sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
sys.stdout = BytesIO()
register(lambda: os.write(1, sys.stdout.getvalue()))
input = lambda: sys.stdin.readline().rstrip('\r\n')

 
def mst(mat):
    n = len(mat)
    root = 0
    found = [0]*n
    found[root] = 1
    vec = list(mat[root])
    who = [root]*n
    pairs = []
    I = 0
    for _ in range(n - 1):
        while found[I]: I += 1
        i = k = I
        minval = vec[I]
        while k < n:
            if not found[k] and vec[k] < minval:
                minval = vec[k]
                i = k
            k += 1
        pairs.append((who[i], i))
        found[i] = 1
        vec2 = mat[i]
        for j in range(n):
            if vec2[j] < vec[j]:
                vec[j] = vec2[j]
                who[j] = i
    return pairs
 
 
inp = [int(x) for x in sys.stdin.read().split()]; ii = 0
 
n = inp[ii]; ii += 1
 
X = inp[ii:ii + 2*n: 2]
Y = inp[ii + 1: ii + 2*n: 2]
ii += 2 * n
 
C = [float(c) for c in inp[ii:ii + n]]; ii += n
K = [float(c) for c in inp[ii:ii + n]]; ii += n
 
mat = [[0.0]*(n + 1) for _ in range(n + 1)]
for a in range(n):
    for b in range(a + 1, n):
        val = (K[a] + K[b]) * (abs(X[a] - X[b]) + abs(Y[a] - Y[b]))
        mat[a][b] = mat[b][a] = val
 
for i in range(n):
    mat[i][n] = mat[n][i] = C[i]
 
cost = 0
power = []
pairs = []
for i,j in mst(mat):
    if i > j:
        i,j = j,i
    cost += mat[i][j]
    if j == n:
        power.append(i)
    else:
        pairs.append((i,j))
 
print int(cost)
print len(power)
print ' '.join(str(x + 1) for x in power)
print len(pairs)
print '\n' .join('%d %d' % (a+1,b+1) for a,b in pairs)","['greedy', 'graphs', 'shortest paths', 'dsu', 'trees']"
"You are given an undirected graph with $$$n$$$ vertices and $$$m$$$ edges. Also, you are given an integer $$$k$$$.Find either a clique of size $$$k$$$ or a non-empty subset of vertices such that each vertex of this subset has at least $$$k$$$ neighbors in the subset. If there are no such cliques and subsets report about it.A subset of vertices is called a clique of size $$$k$$$ if its size is $$$k$$$ and there exists an edge between every two vertices from the subset. A vertex is called a neighbor of the other vertex if there exists an edge between them.","from __future__ import division,print_function
from heapq import*
import sys

le = sys.__stdin__.read().split(""\n"")[::-1]
af = []
for ezo in range(int(le.pop())):
    n,m,k=list(map(int,le.pop().split()))
    #print(n,m,k)
    ar=[set() for i in range(n)]
    for i in range(m):
        a,b=map(int,le.pop().split())
        #print(a,b)
        ar[a-1].add(b-1)
        ar[b-1].add(a-1)
    #print(n,m,k)
    if k*(k-1)>2*m:
        af.append(-1)
    else:
        pi=[i for i in range(n) if len(ar[i])<k]
        re=set(i for i in range(n) if len(ar[i])>=k)
        #print(re,pi,n,m)
        while pi:
            a=pi.pop()
            if len(ar[a])==k-1:
                clique=True
                for j in ar[a]:
                    if clique:
                        for h in ar[a]:
                            if not(h in ar[j]) and h!=j:
                                #print(a,j,h)
                                clique=False
                                break
                if clique:
                    af.append(2)
                    af.append("" "".join(map(str,[i+1 for i in ar[a]]+[a+1])))
                    pi=[]
                    re={-1}
            for j in ar[a]:
                ar[j].remove(a)
                if len(ar[j])<k:
                    if j in re:
                        pi.append(j)
                        re.discard(j)
        if re and re!={-1}:
            af.append(""1""+"" ""+str(len(re)))
            af.append("" "".join(map(str,[i+1 for i in re])))
        elif re!={-1}:
            af.append(-1)
print(""\n"".join(map(str,af)))","['data structures', 'hashing', 'graphs']"
"Thor is getting used to the Earth. As a gift Loki gave him a smartphone. There are n applications on this phone. Thor is fascinated by this phone. He has only one minor issue: he can't count the number of unread notifications generated by those applications (maybe Loki put a curse on it so he can't).q events are about to happen (in chronological order). They are of three types:  Application x generates a notification (this new notification is unread).  Thor reads all notifications generated so far by application x (he may re-read some notifications).  Thor reads the first t notifications generated by phone applications (notifications generated in first t events of the first type). It's guaranteed that there were at least t events of the first type before this event. Please note that he doesn't read first t unread notifications, he just reads the very first t notifications generated on his phone and he may re-read some of them in this operation. Please help Thor and tell him the number of unread notifications after each event. You may assume that initially there are no notifications in the phone.","n, q = map(int, input().split())
ans = [0] * q
unread = [0] * n
last = [-1] * n
qur, cur = [], 0

for i in range(q):
    t, x = map(int, input().split())
    ans[i] = ans[i - 1]
    if t == 1:
        unread[x - 1] += 1
        ans[i] += 1
        qur.append(x - 1)
    elif t == 2:
        ans[i] -= unread[x - 1]
        unread[x - 1] = 0
        last[x - 1] = len(qur) - 1
    else:
        if x > cur: 
            for j in range(cur, x):
                v = qur[j]
                if last[v] < j:
                    ans[i] -= 1
                    unread[v] -= 1
                    last[v] = j
            cur = x

print(""\n"".join(map(str, ans)))","['data structures', 'implementation', 'brute force']"
"The mayor of the Central Town wants to modernize Central Street, represented in this problem by the $$$(Ox)$$$ axis.On this street, there are $$$n$$$ antennas, numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th antenna lies on the position $$$x_i$$$ and has an initial scope of $$$s_i$$$: it covers all integer positions inside the interval $$$[x_i - s_i; x_i + s_i]$$$.It is possible to increment the scope of any antenna by $$$1$$$, this operation costs $$$1$$$ coin. We can do this operation as much as we want (multiple times on the same antenna if we want).To modernize the street, we need to make all integer positions from $$$1$$$ to $$$m$$$ inclusive covered by at least one antenna. Note that it is authorized to cover positions outside $$$[1; m]$$$, even if it's not required.What is the minimum amount of coins needed to achieve this modernization?","n,m = map(int,raw_input().split("" ""))
ants = []
for i in range(n):
    x,s = map(int,raw_input().split("" ""))
    ants.append((x,s))
 
covered = [0]*(m+5)
for i in range(n):
    x,s = ants[i]
    l,r = max(x-s,1),min(x+s,m)
    covered[l] += 1
    covered[r+1] -= 1
cs = 0
for i in range(1,m+1):
    cs += covered[i]
    if cs >0:
        covered[i] = 1
    else:
        covered[i] = 0 
dp = [2e5]*(m+5)
dp[0] = 0.

for i in range(1,m+1):
    if covered[i]:
        dp[i] = dp[i-1]
    else:
        dp[i] = dp[i-1]+1
        for j in range(n):
            x,s = ants[j]
            l,r = max(x-s,1),min(x+s,m)
            if r >= i:
                continue
            span = i-r
            pos = max(1,l-span)
            if dp[i]>dp[pos-1]+span:
                dp[i] = dp[pos-1]+span
        
print int(dp[m])","['dp', 'sortings', 'greedy', 'data structures']"
"Профиль горного хребта схематично задан в виде прямоугольной таблицы из символов «.» (пустое пространство) и «*» (часть горы). Каждый столбец таблицы содержит хотя бы одну «звёздочку». Гарантируется, что любой из символов «*» либо находится в нижней строке матрицы, либо непосредственно под ним находится другой символ «*».  ....................*..*.......*.**.......*.**..*...**.***********   Пример изображения горного хребта.  Маршрут туриста проходит через весь горный хребет слева направо. Каждый день турист перемещается вправо — в соседний столбец в схематичном изображении. Конечно, каждый раз он поднимается (или опускается) в самую верхнюю точку горы, которая находится в соответствующем столбце.Считая, что изначально турист находится в самой верхней точке в первом столбце, а закончит свой маршрут в самой верхней точке в последнем столбце, найдите две величины:  наибольший подъём за день (равен 0, если в профиле горного хребта нет ни одного подъёма),  наибольший спуск за день (равен 0, если в профиле горного хребта нет ни одного спуска).","n,m=map(int,input().split())
a=[input()]
for i in range(n-1):
    a.append(input())
mi=0
ma=0
k=0
for i in range(n):
    if a[i][0]=='*':
        k=i
        break
for i in range(1,m):
    for j in range(n):
        if a[j][i]=='*':
            if j!=k:
                if j<k and k-j>ma:
                    ma=k-j
                if j>k and j-k>mi:
                    mi=j-k
            k=j
            break
print(ma,mi)",['constructive algorithms']
"You are given a connected weighted undirected graph without any loops and multiple edges. Let us remind you that a graph's spanning tree is defined as an acyclic connected subgraph of the given graph that includes all of the graph's vertexes. The weight of a tree is defined as the sum of weights of the edges that the given tree contains. The minimum spanning tree (MST) of a graph is defined as the graph's spanning tree having the minimum possible weight. For any connected graph obviously exists the minimum spanning tree, but in the general case, a graph's minimum spanning tree is not unique.Your task is to determine the following for each edge of the given graph: whether it is either included in any MST, or included at least in one MST, or not included in any MST.","import sys, threading
from heapq import heappop, heappush
#from mygraph import MyGraph
from collections import defaultdict

n_nodes, n_edges = map(int, input().split())

edges = list()

results = defaultdict(lambda: 'any')
highest = defaultdict(lambda: -1)
to_check = defaultdict(list)
graph = defaultdict(list)

class UDFS:

    def __init__(self, n):
        self.n = n

        # index is the node
        self.parents = [i for i in range(n)]
        self.ranks = [0 for i in range(n)]

    def __str__(self):
        '''
        Group -> Node
        '''
        return '\n'.join(f'{e} -> {i}' for i, e in enumerate(self.parents))

    def get_group(self, a):
        if a == self.parents[a]:
            return a

        # Side effect for balancing the tree
        self.parents[a] = self.get_group(self.parents[a])

        return self.parents[a]

    def is_parent(self, n):
        return n == self.get_group(n)

    def is_same_group(self, a, b):
        return self.get_group(a) == self.get_group(b)

    def join(self, a, b):
        parent_a = self.get_group(a)
        parent_b = self.get_group(b)

        if self.ranks[parent_a] > self.ranks[parent_b]:
            self.parents[parent_b] = parent_a
        else:
            self.parents[parent_a] = parent_b

            self.ranks[parent_b] += int(
                self.ranks[parent_a] == self.ranks[parent_b]
            )

    def count(self):
        '''
        Returns number of groups
        '''
        count = 0
        for n in range(self.n):
            count += self.is_parent(n)

        return count

#def get_graph(nodes, label):
#    graph = MyGraph(graph_type='graph', size='20,11.25!', ratio='fill',label=label, fontsize=40)
#    
#    for v in range(1,nodes+1):
#        graph.add_nodes(v)
#
#    return graph
#
#def make_original_graph(nodes, edges):
#    original_graph = get_graph(nodes, ""Grafo Original"") 
#
#    for r in range(edges):
#            a, b, w = map(int, input('\tInsira dois nós e o peso da aresta que existe entre eles: ').split())
#            original_graph.link(a, b, str(w))
#
#    img_name = ""original_graph""
#
#    original_graph.save_img(img_name)
#    
#    print(f""O grafo original foi salvo em {img_name}.png!"")
#
#def make_edges_in_mst_graph(nodes, edges):
#    edges_graph = get_graph(nodes, ""Arestas em MSTs"") 
#
#    for r in range(edges):
#            edges_graph.link(a, b, str(w))
#
#    img_name = ""edges_in_mst""
#
#    edges_graph.save_img(img_name)
#    
#    print(f""O grafo com a ocorrências das arestas em MSTs foi salvo em {img_name}.png!"")

def dfs(a, depth, p):
    global edges
    global results
    global highest
    global graph

    if highest[a] != -1:
        return highest[a];

    minimum = depth
    highest[a] = depth

    for (w, a, b, i) in graph[a]:
        ##print('@', w, a, b, i, depth)
        if i == p:
            continue

        nextt = dfs(b, depth + 1, i)

        if nextt <= depth:
            results[i] = 'at least one'
        else:
            results[i] = 'any'

        minimum = min(minimum, nextt)
        highest[a] = minimum

    return highest[a]

def main():
    global edges
    global results
    global highest
    global graph

    for i in range(n_edges):
        a, b, w = map(int, input().split())
        edges.append((w, a-1, b-1, i))

    edges = sorted(edges, key=lambda x: x[0])

    dsu = UDFS(n_nodes)

    i = 0
    while i < n_edges:
        counter = 0
        j = i
        while j < n_edges and edges[j][0] == edges[i][0]:
            if dsu.get_group(edges[j][1]) == dsu.get_group(edges[j][2]):
                results[edges[j][3]] = 'none'
            else:
                to_check[counter] = edges[j]
                counter += 1
            j += 1
            
        for k in range(counter):
            w, a, b, i = to_check[k]

            ra = dsu.get_group(a)
            rb = dsu.get_group(b)

            graph[ra].append((w, ra, rb, i))
            graph[rb].append((w, rb, ra, i))

        for k in range(counter):
            #print('To check:', to_check[k][:-1], k)
            dfs(to_check[k][1], 0, -1)

        for k in range(counter):
            w, a, b, i = to_check[k]

            ra = dsu.get_group(a)
            rb = dsu.get_group(b)

            dsu.join(ra, rb)

            graph[ra] = list()
            graph[rb] = list()

            highest[ra] = -1
            highest[rb] = -1

        counter = 0
        i = j

    for i in range(n_edges):
        print(results[i])

if __name__ == ""__main__"":
    sys.setrecursionlimit(2**32//2-1)
    threading.stack_size(1 << 27)

    thread = threading.Thread(target=main)
    thread.start()
    thread.join()","['dsu', 'sortings', 'graphs', 'dfs and similar']"
"You are given a string $$$s$$$ consisting only of first $$$20$$$ lowercase Latin letters ('a', 'b', ..., 't').Recall that the substring $$$s[l; r]$$$ of the string $$$s$$$ is the string $$$s_l s_{l + 1} \dots s_r$$$. For example, the substrings of ""codeforces"" are ""code"", ""force"", ""f"", ""for"", but not ""coder"" and ""top"".You can perform the following operation no more than once: choose some substring $$$s[l; r]$$$ and reverse it (i.e. the string $$$s_l s_{l + 1} \dots s_r$$$ becomes $$$s_r s_{r - 1} \dots s_l$$$).Your goal is to maximize the length of the maximum substring of $$$s$$$ consisting of distinct (i.e. unique) characters.The string consists of distinct characters if no character in this string appears more than once. For example, strings ""abcde"", ""arctg"" and ""minecraft"" consist of distinct characters but strings ""codeforces"", ""abacaba"" do not consist of distinct characters.","import sys
range = xrange
input = raw_input

orda = ord('a')
S = [ord(c) - orda for c in input()]
n = len(S)

best = -1
count = [0]*(2**20)
for i in range(n):
    c = 0
    j = i
    while j < n and c & (1 << S[j]) == 0:
        c ^= 1 << S[j]
        count[c] = 1
        j += 1

big = 2**20
bitsize = [0]
for i in range(1, big):
    bitsize.append(1 +  bitsize[i - (1 <<( i.bit_length() - 1))])

for i in range(big):
    if count[i] == 0:
        bitsize[i] = 0

DP = [0]*big
for i in reversed(range(big)):
    ii = (big - 1) ^ i
    besta = bitsize[ii]
    
    while ii:
        b = ii & (~ii + 1)
        if DP[i ^ b] > besta:
            besta = DP[i ^ b]
        ii ^= b
    DP[i] = besta

print max(DP[i] + bitsize[i] for i in range(big))","['dp', 'bitmasks']"
"Once upon a time DravDe, an outstanding person famous for his professional achievements (as you must remember, he works in a warehouse storing Ogudar-Olok, a magical but non-alcoholic drink) came home after a hard day. That day he had to drink 9875 boxes of the drink and, having come home, he went to bed at once.DravDe dreamt about managing a successful farm. He dreamt that every day one animal came to him and asked him to let it settle there. However, DravDe, being unimaginably kind, could send the animal away and it went, rejected. There were exactly n days in DravDe’s dream and the animal that came on the i-th day, ate exactly ci tons of food daily starting from day i. But if one day the animal could not get the food it needed, it got really sad. At the very beginning of the dream there were exactly X tons of food on the farm.DravDe woke up terrified...When he retold the dream to you, he couldn’t remember how many animals were on the farm by the end of the n-th day any more, but he did remember that nobody got sad (as it was a happy farm) and that there was the maximum possible amount of the animals. That’s the number he wants you to find out. It should be noticed that the animals arrived in the morning and DravDe only started to feed them in the afternoon, so that if an animal willing to join them is rejected, it can’t eat any farm food. But if the animal does join the farm, it eats daily from that day to the n-th.","import sys
sys.stdin = open('input.txt')
sys.stdout = open('output.txt', 'w')
f = lambda: map(int, input().split())
n, s = f()
k = 0
for q in sorted(q * (n - i) for i, q in enumerate(f())):
	s -= q
	if s < 0: break
	k += 1
print(k)","['dp', 'greedy']"
"There are $$$n$$$ persons who initially don't know each other. On each morning, two of them, who were not friends before, become friends.We want to plan a trip for every evening of $$$m$$$ days. On each trip, you have to select a group of people that will go on the trip. For every person, one of the following should hold:   Either this person does not go on the trip,  Or at least $$$k$$$ of his friends also go on the trip. Note that the friendship is not transitive. That is, if $$$a$$$ and $$$b$$$ are friends and $$$b$$$ and $$$c$$$ are friends, it does not necessarily imply that $$$a$$$ and $$$c$$$ are friends.For each day, find the maximum number of people that can go on the trip on that day.","from collections import deque

def solve(adj, m, k, uv):
    n = len(adj)
    nn = [len(a) for a in adj]
    q = deque()
    for i in range(n):
        if nn[i] < k:
            q.append(i)
    while q:
        v = q.popleft()
        for u in adj[v]:
            nn[u] -= 1
            if nn[u] == k-1:
                q.append(u)
    res = [0]*m
    nk = len([1 for i in nn if i >= k])
    res[-1] = nk
    for i in range(m-1, 0, -1):
        u1, v1 = uv[i]

        if nn[u1] < k or nn[v1] < k:
            res[i - 1] = nk
            continue
        if nn[u1] == k:
            q.append(u1)
            nn[u1] -= 1
        if not q and nn[v1] == k:
            q.append(v1)
            nn[v1] -= 1

        if not q:
            nn[u1] -= 1
            nn[v1] -= 1
            adj[u1].remove(v1)
            adj[v1].remove(u1)

        while q:
            v = q.popleft()
            nk -= 1
            for u in adj[v]:
                nn[u] -= 1
                if nn[u] == k - 1:
                    q.append(u)
        res[i - 1] = nk
    return res

n, m, k = map(int, input().split())
a = [set() for i in range(n)]
uv = []
for i in range(m):
    u, v = map(int, input().split())
    a[u - 1].add(v - 1)
    a[v - 1].add(u - 1)
    uv.append((u-1, v-1))

res = solve(a, m, k, uv)
print(str(res)[1:-1].replace(' ', '').replace(',', '\n'))",['graphs']
"In one very large and very respectable company there is a cloakroom with a coat hanger. It is represented by n hooks, positioned in a row. The hooks are numbered with positive integers from 1 to n from the left to the right.The company workers have a very complicated work schedule. At the beginning of a work day all the employees are not there and the coat hanger in the cloakroom is empty. At some moments of time the employees arrive and some of them leave.When some employee arrives, he hangs his cloak on one of the available hooks. To be of as little discomfort to his colleagues as possible, the hook where the coat will hang, is chosen like this. First the employee chooses the longest segment among available hooks following in a row. If there are several of such segments, then he chooses the one closest to the right. After that the coat is hung on the hook located in the middle of this segment. If the segment has an even number of hooks, then among two central hooks we choose the one closest to the right.When an employee leaves, he takes his coat. As all the company workers deeply respect each other, no one takes somebody else's coat.From time to time the director of this respectable company gets bored and he sends his secretary to see how many coats hang on the coat hanger from the i-th to the j-th hook inclusive. And this whim is always to be fulfilled, otherwise the director gets angry and has a mental breakdown.Not to spend too much time traversing from the director's office to the cloakroom and back again, the secretary asked you to write a program, emulating the company cloakroom's work.","import sys
from heapq import *    
n,q = map(int,raw_input().split())
rl = sys.stdin.readline
z,l,r,t = {},{},{},{}
h = []
qq = 2*q+2
a = [True]*qq
b,e = [0]*qq,[0]*qq
ac = 0
def add(bb,ee):
    global b,e,h,ac
    if bb>=ee:
	l[ee]=r[bb-1]=0
	return
    b[ac]=bb
    e[ac]=ee
    r[bb-1]=l[ee]=ac
    heappush(h,(bb-ee,-ee,bb,ac))
    ac+=1
add (1,n+1)
def f(x):
    r = 0
    while x: r+=t.get(x,0); x-=x&-x; 
    return r
for _ in xrange(q):
    p = rl()
    if p[0]=='0':
	_,i,j = map(int,p.split())
	print f(j)-f(i-1)
    else:
	i = int(p)
	if i in z:
	    m = z[i]
	    a[l[m]]=a[r[m]]=False
	    bb=b[l[m]] if l[m] else m
	    ee=e[r[m]] if r[m] else m+1
	    add(bb,ee)
	    del z[i]
	    d=-1
	else:
	    while 1:
		_,ee,bb,j = heappop(h)
		if a[j]: break
	    m = (-ee+bb)/2
	    add(bb,m)
	    add(m+1,-ee)
	    z[i] = m
	    d=1
	while m<=n: t[m]=t.get(m,0)+d; m+=m&-m",['data structures']
"A MIPT student named Misha has a birthday today, and he decided to celebrate it in his country house in suburban Moscow. n friends came by, and after a typical party they decided to play blind man's buff.The birthday boy gets blindfolded and the other players scatter around the house. The game is played in several rounds. In each round, Misha catches exactly one of his friends and has to guess who it is. The probability of catching the i-th friend does not change between rounds and is equal to pi percent (as we know, it is directly proportional to the amount of alcohol consumed by the i-th friend) and p1 + p2 + ... + pn = 100 holds. Misha has no information about who he caught. After Misha makes an attempt to guess the caught person, the round ends. Even then, Misha isn't told whether he guessed correctly, and a new round begins.The game ends when Misha guesses every friend at least once, that is, there exists such set of rounds k1, k2, ..., kn, that during round number ki Misha caught the i-th friend and guessed him. Misha wants to minimize the expectation of the number of rounds of the game. Despite the fact that at any point in the game Misha has no information about who he has already guessed, his friends are honest, and if they see that the condition for the end of the game is fulfilled, the game ends immediately. Find the expectation of the number of rounds in the game if Misha plays optimally.","import random

N = int(input())
prob = [float(x)/100 for x in input().strip().split()]
prob_sum = []
cur = 0
for i in range(N):
    cur += prob[i]
    prob_sum.append(cur)

def experiment():
    cur_prob = [1.] * N
    cur_exp = 0
    for i in range(200000):

        bp = [prob[i] * cur_prob[i] / (1-cur_prob[i]+1E-100) for i in range(N)]
        mn = max(bp)
        for j in range(N):
            if bp[j] == mn:
                choice = j
        cur_prob[choice] *= 1-prob[choice]
        tp = 1
        for j in range(N):
            tp *= (1-cur_prob[j])
        tp = 1 - tp
        cur_exp += tp

    return cur_exp + 1

ans = experiment()
print(ans)","['greedy', 'probabilities', 'math']"
"Vova plays a computer game known as Mages and Monsters. Vova's character is a mage. Though as he has just started, his character knows no spells.Vova's character can learn new spells during the game. Every spell is characterized by two values xi and yi — damage per second and mana cost per second, respectively. Vova doesn't have to use a spell for an integer amount of seconds. More formally, if he uses a spell with damage x and mana cost y for z seconds, then he will deal x·z damage and spend y·z mana (no rounding). If there is no mana left (mana amount is set in the start of the game and it remains the same at the beginning of every fight), then character won't be able to use any spells. It is prohibited to use multiple spells simultaneously.Also Vova can fight monsters. Every monster is characterized by two values tj and hj — monster kills Vova's character in tj seconds and has hj health points. Mana refills after every fight (or Vova's character revives with full mana reserve), so previous fights have no influence on further ones.Vova's character kills a monster, if he deals hj damage to it in no more than tj seconds using his spells (it is allowed to use more than one spell in a fight) and spending no more mana than he had at the beginning of the fight. If monster's health becomes zero exactly in tj seconds (it means that the monster and Vova's character kill each other at the same time), then Vova wins the fight.You have to write a program which can answer two types of queries:  1 x y — Vova's character learns new spell which deals x damage per second and costs y mana per second.  2 t h — Vova fights the monster which kills his character in t seconds and has h health points. Note that queries are given in a different form. Also remember that Vova's character knows no spells at the beginning of the game.For every query of second type you have to determine if Vova is able to win the fight with corresponding monster.","#!/usr/bin/env python3

# solution after hint
# (instead of best hit/mana spell store convex hull of spells)
# O(n^2) instead of O(n log n)


[q, m] = map(int, input().strip().split())
qis = [tuple(map(int, input().strip().split())) for _ in range(q)]

mod = 10**6

j = 0
spell_chull = [(0, 0)]  # lower hull _/

def is_right(xy0, xy1, xy):
	(x0, y0) = xy0
	(x1, y1) = xy1
	(x, y) = xy
	return (x0 - x) * (y1 - y) >= (x1 - x) * (y0 - y)

def in_chull(x, y):
	i = 0
	if x > spell_chull[-1][0]:
		return False
	while spell_chull[i][0] < x:
		i += 1
	if spell_chull[i][0] == x:
		return spell_chull[i][1] <= y
	else:
		return is_right(spell_chull[i - 1], spell_chull[i], (x, y))
	


def add_spell(x, y):
	global spell_chull
	if in_chull(x, y):
		return
	i_left = 0
	while i_left < len(spell_chull) - 1 and not is_right(spell_chull[i_left + 1], spell_chull[i_left], (x, y)):
		i_left += 1
	i_right = i_left + 1
	while i_right < len(spell_chull) - 1 and is_right(spell_chull[i_right + 1], spell_chull[i_right], (x, y)):
		i_right += 1
	if i_right == len(spell_chull) - 1 and x >= spell_chull[-1][0]:
		i_right += 1
	spell_chull = spell_chull[:i_left + 1] + [(x, y)] + spell_chull[i_right:]


for i, qi in enumerate(qis):
	(k, a, b) = qi
	x = (a + j) % mod + 1
	y = (b + j) % mod + 1
	if k == 1:
		add_spell(x, y)
	else:  #2
		if in_chull(y / x, m / x):
			print ('YES')
			j = i + 1
		else:
			print ('NO')","['data structures', 'geometry']"
"You already know that Valery's favorite sport is biathlon. Due to your help, he learned to shoot without missing, and his skills are unmatched at the shooting range. But now a smaller task is to be performed, he should learn to complete the path fastest.The track's map is represented by a rectangle n × m in size divided into squares. Each square is marked with a lowercase Latin letter (which means the type of the plot), with the exception of the starting square (it is marked with a capital Latin letters S) and the terminating square (it is marked with a capital Latin letter T). The time of movement from one square to another is equal to 1 minute. The time of movement within the cell can be neglected. We can move from the cell only to side-adjacent ones, but it is forbidden to go beyond the map edges. Also the following restriction is imposed on the path: it is not allowed to visit more than k different types of squares (squares of one type can be visited an infinite number of times). Squares marked with S and T have no type, so they are not counted. But S must be visited exactly once — at the very beginning, and T must be visited exactly once — at the very end.Your task is to find the path from the square S to the square T that takes minimum time. Among all shortest paths you should choose the lexicographically minimal one. When comparing paths you should lexicographically represent them as a sequence of characters, that is, of plot types.","import sys
from array import array  # noqa: F401
from itertools import combinations
from collections import deque


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


n, m, k = map(int, input().split())
chars = (
    ['}' * (m + 2)]
    + ['}' + ''.join('{' if c == 'S' else '|' if c == 'T' else c for c in input().rstrip()) + '}' for _ in range(n)]
    + ['}' * (m + 2)]
)
cbit = [[1 << (ord(c) - 97) for c in chars[i]] for i in range(n + 2)]

si, sj, ti, tj = 0, 0, 0, 0
for i in range(1, n + 1):
    for j in range(1, m + 1):
        if chars[i][j] == '{':
            si, sj = i, j
            cbit[i][j] = 0
        if chars[i][j] == '|':
            ti, tj = i, j


ans = inf = '*' * (n * m)

for comb in combinations([1 << i for i in range(26)], r=k):
    enabled = sum(comb)

    dp = [[inf] * (m + 2) for _ in range(n + 2)]
    dp[ti][tj] = ''
    dq = deque([(ti, tj, '')])
    while dq:
        i, j, s = dq.popleft()
        if dp[i][j] < s:
            continue
        for di, dj in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):
            if (cbit[di][dj] & enabled) != cbit[di][dj]:
                continue
            pre = chars[di][dj] if cbit[di][dj] else ''
            l = 1 if cbit[di][dj] else 0
            if (len(dp[di][dj]) > len(s) + l or len(dp[di][dj]) == len(s) + l and dp[di][dj] > pre + s):
                dp[di][dj] = pre + s
                if l:
                    dq.append((di, dj, pre + s))

    if len(ans) > len(dp[si][sj]) or len(ans) == len(dp[si][sj]) and ans > dp[si][sj]:
        ans = dp[si][sj]

print(ans if ans != inf else -1)","['brute force', 'shortest paths']"
"Let's assume that   v(n) is the largest prime number, that does not exceed n; u(n) is the smallest prime number strictly greater than n. Find .","T = int( input() )

#for every prime x
#(b-a)/ab
#1/a-1/b

MAX = 33000

bePrime = [0] * MAX;
primNum = []

for j in range(2, MAX):
    if bePrime[j] == 0: 
        primNum.append( j )
        i = j
        while i < MAX:
            bePrime[i] = 1
            i = i + j

def isPrime( a ):
    for j in primNum:
        if j >= a:
            return True
        if a % j == 0:
            return False
    return True

def gcd( a, b ):
    if b == 0:
        return a
    return gcd( b, a % b );

while T > 0:
    num = 0;
    n = int( input() )

    m = n
    while isPrime(m) == False:
        m -= 1
    while isPrime(n + 1) == False:
        n += 1
        num += 1

    a = n - 1
    b = 2 * ( n+1 )

    a = a * (n+1) * m - num * b
    b = b * (n+1) * m

    g = gcd( a, b)
    a //= g
    b //= g


    print( '{0}/{1}'.format( a, b  ) )
    T -= 1;","['number theory', 'math']"
"There are $$$n$$$ TV shows you want to watch. Suppose the whole time is split into equal parts called ""minutes"". The $$$i$$$-th of the shows is going from $$$l_i$$$-th to $$$r_i$$$-th minute, both ends inclusive.You need a TV to watch a TV show and you can't watch two TV shows which air at the same time on the same TV, so it is possible you will need multiple TVs in some minutes. For example, if segments $$$[l_i, r_i]$$$ and $$$[l_j, r_j]$$$ intersect, then shows $$$i$$$ and $$$j$$$ can't be watched simultaneously on one TV.Once you start watching a show on some TV it is not possible to ""move"" it to another TV (since it would be too distracting), or to watch another show on the same TV until this show ends.There is a TV Rental shop near you. It rents a TV for $$$x$$$ rupees, and charges $$$y$$$ ($$$y &lt; x$$$) rupees for every extra minute you keep the TV. So in order to rent a TV for minutes $$$[a; b]$$$ you will need to pay $$$x + y \cdot (b - a)$$$. You can assume, that taking and returning of the TV doesn't take any time and doesn't distract from watching other TV shows. Find the minimum possible cost to view all shows. Since this value could be too large, print it modulo $$$10^9 + 7$$$.","#!/usr/bin/env python
""""""
This file is part of https://github.com/Cheran-Senthil/PyRival.

Copyright 2018 Cheran Senthilkumar all rights reserved,
Cheran Senthilkumar <hello@cheran.io>
Permission to use, modify, and distribute this software is given under the
terms of the MIT License.

""""""
from __future__ import division, print_function

import cmath
import itertools
import math
import operator as op
# import random
import sys
from atexit import register
from bisect import bisect_left, bisect_right
# from collections import Counter, MutableSequence, defaultdict, deque
# from copy import deepcopy
# from decimal import Decimal
# from difflib import SequenceMatcher
# from fractions import Fraction
# from heapq import heappop, heappush

if sys.version_info[0] < 3:
    # from cPickle import dumps
    from io import BytesIO as stream
    # from Queue import PriorityQueue, Queue
else:
    # from functools import reduce
    from io import StringIO as stream
    from math import gcd
    # from pickle import dumps
    # from queue import PriorityQueue, Queue


if sys.version_info[0] < 3:
    class dict(dict):
        """"""dict() -> new empty dictionary""""""
        def items(self):
            """"""D.items() -> a set-like object providing a view on D's items""""""
            return dict.iteritems(self)

        def keys(self):
            """"""D.keys() -> a set-like object providing a view on D's keys""""""
            return dict.iterkeys(self)

        def values(self):
            """"""D.values() -> an object providing a view on D's values""""""
            return dict.itervalues(self)

    def gcd(x, y):
        """"""gcd(x, y) -> int
        greatest common divisor of x and y
        """"""
        while y:
            x, y = y, x % y
        return x

    input = raw_input
    range = xrange

    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip


def sync_with_stdio(sync=True):
    """"""Set whether the standard Python streams are allowed to buffer their I/O.

    Args:
        sync (bool, optional): The new synchronization setting.

    """"""
    global input, flush

    if sync:
        flush = sys.stdout.flush
    else:
        sys.stdin = stream(sys.stdin.read())
        input = lambda: sys.stdin.readline().rstrip('\r\n')

        sys.stdout = stream()
        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))


def main():
    n, x, y = map(int, input().split(' '))

    l, r, v = [0] * n, [0] * n, [0]*n

    res = 0
    for i in range(n):
        l[i], r[i] = map(int, input().split(' '))
        res += x + (r[i] - l[i]) * y

    l.sort()
    r.sort()

    for i in range(n - 1, -1, -1):
        k = bisect_right(l, r[i])
        while (k < n) and (v[k] == 1) and ((l[k] - r[i]) * y < x):
            k += 1

        if k == n:
            continue

        if (l[k] - r[i]) * y < x:
            v[k] = 1
            res += (l[k] - r[i]) * y - x

    print(res % 1000000007)


if __name__ == '__main__':
    sync_with_stdio(False)
    main()","['data structures', 'implementation', 'sortings', 'greedy']"
"The biggest event of the year – Cota 2 world championship ""The Innernational"" is right around the corner. $$$2^n$$$ teams will compete in a double-elimination format (please, carefully read problem statement even if you know what is it) to identify the champion. Teams are numbered from $$$1$$$ to $$$2^n$$$ and will play games one-on-one. All teams start in the upper bracket.All upper bracket matches will be held played between teams that haven't lost any games yet. Teams are split into games by team numbers. Game winner advances in the next round of upper bracket, losers drop into the lower bracket.Lower bracket starts with $$$2^{n-1}$$$ teams that lost the first upper bracket game. Each lower bracket round consists of two games. In the first game of a round $$$2^k$$$ teams play a game with each other (teams are split into games by team numbers). $$$2^{k-1}$$$ loosing teams are eliminated from the championship, $$$2^{k-1}$$$ winning teams are playing $$$2^{k-1}$$$ teams that got eliminated in this round of upper bracket (again, teams are split into games by team numbers). As a result of each round both upper and lower bracket have $$$2^{k-1}$$$ teams remaining. See example notes for better understanding.Single remaining team of upper bracket plays with single remaining team of lower bracket in grand-finals to identify championship winner.You are a fan of teams with numbers $$$a_1, a_2, ..., a_k$$$. You want the championship to have as many games with your favourite teams as possible. Luckily, you can affect results of every championship game the way you want. What's maximal possible number of championship games that include teams you're fan of?","import sys
range = xrange
input = raw_input

n, k = [int(x) for x in input().split()]
A = [int(x) - 1 for x in input().split()] if k else []

n = 2**n

marked = [0]*n
for a in A:
    marked[a] = 1

m = 1
while m < n: m *= 2

inf = 10**9

data = [[-inf]*(2*m) for _ in range(4)]
for i in range(0,n,2):
    data[0][(m + i) >> 1] = 0
    if marked[i]:
        data[1][(m + i) >> 1] = 1
        data[2][(m + i) >> 1] = 1
        if marked[i + 1]:
            data[3][(m + i) >> 1] = 1
    elif marked[i + 1]:
        data[1][(m + i) >> 1] = 1
        data[2][(m + i) >> 1] = 1

for i in reversed(range(m >> 1)):
    lchild = 2*i
    rchild = 2*i + 1

    for goal in range(4):
        for a in range(4):
            for b in range(4):
                if a | b == goal:
                    data[goal][i] = max(data[goal][i], data[a][lchild] + data[b][rchild] + (a & 1 or b & 1) + (a & 2 > 0 or b & 2 > 0) + (goal & 2 > 0))
print max(data[k][1] + (k > 0) for k in range(4))","['dp', 'implementation']"
"Ilya is very fond of graphs, especially trees. During his last trip to the forest Ilya found a very interesting tree rooted at vertex 1. There is an integer number written on each vertex of the tree; the number written on vertex i is equal to ai.Ilya believes that the beauty of the vertex x is the greatest common divisor of all numbers written on the vertices on the path from the root to x, including this vertex itself. In addition, Ilya can change the number in one arbitrary vertex to 0 or leave all vertices unchanged. Now for each vertex Ilya wants to know the maximum possible beauty it can have.For each vertex the answer must be considered independently.The beauty of the root equals to number written on it.","from sys import stdin
from fractions import gcd

n = int(stdin.readline().strip())
v = map(int, stdin.readline().strip().split())

adj = [[] for _ in xrange(n)]
for _ in xrange(n-1):
    x, y = map(int, stdin.readline().strip().split())
    adj[x-1].append(y-1)
    adj[y-1].append(x-1)

root_divisors = []
cnt = [0]*200001
d = 1
while d*d <= v[0]:
    if v[0] % d == 0:
        root_divisors.append(d)
        cnt[d] += 1
        if v[0]/d != d:
            root_divisors.append(v[0]/d)
            cnt[v[0]/d] += 1
    d += 1    
s = [0]
visited = [False]*n
visited[0] = True
level = [1]*n
res1 = [0]*n
res2 = [0]*n
res1[0] = v[0]
d = 1
while s:
    x = s[-1]
    any_more = False
    while adj[x]:
        y = adj[x].pop()
        if not visited[y]:
            visited[y] = True
            any_more = True
            s.append(y)
            level[y] = level[x]+1
            res2[y] = gcd(res2[x], v[y])
            for d in root_divisors:
                if v[y] % d == 0:
                    cnt[d] += 1
                if cnt[d] == level[y] or cnt[d] == level[y]-1:
                    res1[y] = max(res1[y], res2[y], d)
            break
    if not any_more:
        s.pop()
        for d in root_divisors:
            if v[x] % d == 0:
                cnt[d] -= 1
        
print ' '.join(map(str, res1))","['graphs', 'number theory', 'math', 'dfs and similar', 'trees']"
"Recently Petya walked in the forest and found a magic stick.Since Petya really likes numbers, the first thing he learned was spells for changing numbers. So far, he knows only two spells that can be applied to a positive integer:   If the chosen number $$$a$$$ is even, then the spell will turn it into $$$\frac{3a}{2}$$$;  If the chosen number $$$a$$$ is greater than one, then the spell will turn it into $$$a-1$$$. Note that if the number is even and greater than one, then Petya can choose which spell to apply.Petya now has only one number $$$x$$$. He wants to know if his favorite number $$$y$$$ can be obtained from $$$x$$$ using the spells he knows. The spells can be used any number of times in any order. It is not required to use spells, Petya can leave $$$x$$$ as it is.","for _ in range(int(input())):
    x, y = map(int, input().split())
    if x >= y:
        print(""YES"")
    elif x <= 3 and y > 3:
        print(""NO"")
    elif x <= 3 and x > 0 and x % 2:
        print(""NO"")
    else:
        print(""YES"")",['math']
"In a medieval kingdom, the economic crisis is raging. Milk drops fall, Economic indicators are deteriorating every day, money from the treasury disappear. To remedy the situation, King Charles Sunnyface decided make his n sons-princes marry the brides with as big dowry as possible.In search of candidates, the king asked neighboring kingdoms, and after a while several delegations arrived with m unmarried princesses. Receiving guests, Karl learned that the dowry of the i th princess is wi of golden coins. Although the action takes place in the Middle Ages, progressive ideas are widespread in society, according to which no one can force a princess to marry a prince whom she does not like. Therefore, each princess has an opportunity to choose two princes, for each of which she is ready to become a wife. The princes were less fortunate, they will obey the will of their father in the matter of choosing a bride.Knowing the value of the dowry and the preferences of each princess, Charles wants to play weddings in such a way that the total dowry of the brides of all his sons would be as great as possible. At the same time to marry all the princes or princesses is not necessary. Each prince can marry no more than one princess, and vice versa, each princess can marry no more than one prince.Help the king to organize the marriage of his sons in the most profitable way for the treasury.","from sys import stdin
from itertools import repeat
def main():
    n, m = map(int, stdin.readline().split())
    dat = map(int, stdin.read().split(), repeat(10, 3 * m))
    e = [(-dat[i*3+2], dat[i*3+1], dat[i*3]) for i in xrange(m)]
    e.sort()
    par = range(n + 1)
    c = [1] * (n + 1)
    st = []
    po = st.pop
    pu = st.append
    ans = 0
    for s, x, y in e:
        while x != par[x]:
            pu(x)
            x = par[x]
        while y != par[y]:
            pu(y)
            y = par[y]
        if x == y:
            if c[y]:
                c[y] = 0
                ans += s
        else:
            pu(x)
            if c[y] or c[x]:
                ans += s
            c[y] &= c[x]
            for z in st:
                par[z] = y
        del st[:]
    print -ans
main()","['dsu', 'greedy', 'graphs']"
"Iahub accidentally discovered a secret lab. He found there n devices ordered in a line, numbered from 1 to n from left to right. Each device i (1 ≤ i ≤ n) can create either ai units of matter or ai units of antimatter. Iahub wants to choose some contiguous subarray of devices in the lab, specify the production mode for each of them (produce matter or antimatter) and finally take a photo of it. However he will be successful only if the amounts of matter and antimatter produced in the selected subarray will be the same (otherwise there would be overflowing matter or antimatter in the photo). You are requested to compute the number of different ways Iahub can successful take a photo. A photo is different than another if it represents another subarray, or if at least one device of the subarray is set to produce matter in one of the photos and antimatter in the other one.","from sys import stdin
N = 1000000007
 
def read_input():
    n = int(stdin.readline())
    devices = [int(x) for x in stdin.readline().split()]
 
    return n, devices
 
if __name__ == ""__main__"":
    n, devices = read_input()
    M, r = sum(devices), 0
    res = [[0] * (2 * M + 1) for _ in range(n+1)]
 
    for nb, val in enumerate(devices, 1):
        for i in range(2 * M):
            if i - val >= 0:
                res[nb][i-val] = (res[nb][i-val] + res[nb-1][i]) % N
            if i + val <= 2 * M:
                res[nb][i+val] = (res[nb][i+val] + res[nb-1][i]) % N
 
        res[nb][M+val] += 1
        res[nb][M-val] += 1
 
        r = (r + res[nb][M]) % N
 
    print(r)",['dp']
"Polycarpus works as a programmer in a start-up social network. His boss gave his a task to develop a mechanism for determining suggested friends. Polycarpus thought much about the task and came to the folowing conclusion. Let's say that all friendship relationships in a social network are given as m username pairs ai, bi (ai ≠ bi). Each pair ai, bi means that users ai and bi are friends. Friendship is symmetric, that is, if ai is friends with bi, then bi is also friends with ai. User y is a suggested friend for user x, if the following conditions are met:  x ≠ y;  x and y aren't friends;  among all network users who meet the first two conditions, user y has most of all common friends with user x. User z is a common friend of user x and user y (z ≠ x, z ≠ y), if x and z are friends, and y and z are also friends. Your task is to help Polycarpus to implement a mechanism for determining suggested friends.","import sys
from collections import defaultdict
n,m =0, input()
mp={}
G = defaultdict(list)
def myfind(c):
	global n,mp
	if c not in mp:
		mp[c] = n
		n += 1
	return mp[c]
def add(u,v):
	G[u].append(v)
	G[v].append(u)
for ch in sys.stdin:
	a,b=ch.split()
	u,v=myfind(a),myfind(b)
	add(u,v)
print n
def bfs(s):
	mx,ans,ct =0,0,1
	vis = [-1] * n
	cnt = [0] * n
	chk = []
	Q = [s]
	vis[s] = 0
	while len(Q) :
		u = Q.pop()
		for v in G[u]:
			if vis[v] == -1:
				ct += 1
				vis[v] = vis[u] + 1
				if vis[v] == 1:
					Q.append(v)
				else:
					chk.append(v)
			cnt[v] += 1
	if len(chk) == 0:
		return n - ct;
	for u in chk:
		if cnt[u] > mx:
			mx = cnt[u]
			ans = 1
		elif cnt[u]==mx:
			ans += 1
	return ans
for c in mp:
	print c,bfs(mp[c])","['brute force', 'graphs']"
"The Zoo in the Grid Kingdom is represented by an infinite grid. The Zoo has n observation binoculars located at the OX axis. For each i between 1 and n, inclusive, there exists a single binocular located at the point with coordinates (i, 0). There are m flamingos in the Zoo, located at points with positive coordinates. The flamingos are currently sleeping and you can assume that they don't move.In order to get a good view over the flamingos, each of the binoculars can be independently rotated to face any angle (not necessarily integer). Then, the binocular can be used to observe all flamingos that is located at the straight line passing through the binocular at the angle it is set. In other words, you can assign each binocular a direction corresponding to any straight line passing through the binocular, and the binocular will be able to see all flamingos located on that line.Today, some kids from the prestigious Codeforces kindergarten went on a Field Study to the Zoo. Their teacher would like to set each binocular an angle to maximize the number of flamingos that can be seen by the binocular. The teacher is very interested in the sum of these values over all binoculars. Please help him find this sum.","from ctypes import c_int32

def gcd(a,b):

    if b == 0:

        return a

    return gcd(b, a % b)

    

def normalize_rational(num,den):

    #associate the -ve with the num or cancel -ve sign when both are -ve

    if num ^ den < 0 and num > 0 or num ^ den > 0 and num < 0:

        num = -num; den = -den

    #put it in its simplest form

    g = gcd(abs(num),abs(den))

    num //= g; den //=g

    return (num,den)



from sys import *

l = stdin.readline()

(n,m) = (int(tkn) for tkn in l.split())

xs = [0] * m; ys = [0] * m

#maxhits = [set() for i in range(n+1)]

maxhits = [c_int32(1)] * (n + 1)

maxhits[0] = c_int32(0)

for i in range(m):

    l = stdin.readline()

    (x,y) = (int(tkn) for tkn in l.split())

    xs[i] = x; ys[i] = y

line_to_points = {}

for i in range(m):

    for j in range(m):

        #m = dy/dx; y = (dy/dx)x + c ==> y.dx = x.dy + c.dx

        #y.dx = x.dy + c'

        #c' = y.dx - x.dy

        #c' = ys[i]*dx - xs[i]*dy

        #Now, at y = 0, x = -c' / dy

        dy = ys[i] - ys[j]; dx = xs[i] - xs[j]

        if dy == 0:

            continue

        #not a special case anymore

        # if dx == 0:

            # if xs[i] > n:

                # continue

            # else:

                # count_seen_from_x = len([x for x in xs if x == xs[i]])

                # maxhits[xs[i]] = max(count_seen_from_x, maxhits[xs[i]])

        else:

            slope = normalize_rational(dy,dx)

            c_prime = ys[i]*dx - xs[i]*dy

            x_intercept = -c_prime / dy

            line = (slope,x_intercept)

            if line in line_to_points:

                #print(""line: "", line)

                #print(""now: "", points)

                points = line_to_points[line]

                points.add(i); points.add(j)

                #print(""after addition: "", points)

                continue

            

            #if (i == 1 and j == 2):

            #    print(c_prime, x_intercept, dy, dx)

            if int(x_intercept) == x_intercept and x_intercept <= n and x_intercept > 0:

                points = set([i,j])

                line_to_points[line] = points

                #maxhits[int(x_intercept)] = points

                # count_on_line = 2

                # for k in range(m):

                    # if k != i and k != j and ys[k] * dx == xs[k]*dy + c_prime:

                        # count_on_line += 1

                # maxhits[int(x_intercept)] = max(count_on_line, maxhits[int(x_intercept)])

for line,points in line_to_points.items():

    x_intercept = int(line[1])

    maxhits[x_intercept] = c_int32(max(maxhits[x_intercept].value,len(points)))

#print(maxhits)

#print(sum([max(len(points),1) for points in maxhits]) - 1)

print(sum([e.value for e in maxhits]))



# Made By Mostafa_Khaled","['geometry', 'brute force']"
"You are given a complete bipartite graph with $$$2n$$$ nodes, with $$$n$$$ nodes on each side of the bipartition. Nodes $$$1$$$ through $$$n$$$ are on one side of the bipartition, and nodes $$$n+1$$$ to $$$2n$$$ are on the other side. You are also given an $$$n \times n$$$ matrix $$$a$$$ describing the edge weights. $$$a_{ij}$$$ denotes the weight of the edge between nodes $$$i$$$ and $$$j+n$$$. Each edge has a distinct weight.Alice and Bob are playing a game on this graph. First Alice chooses to play as either ""increasing"" or ""decreasing"" for herself, and Bob gets the other choice. Then she places a token on any node of the graph. Bob then moves the token along any edge incident to that node. They now take turns playing the following game, with Alice going first.The current player must move the token from the current vertex to some adjacent unvisited vertex. Let $$$w$$$ be the last weight of the last edge that was traversed. The edge that is traversed must be strictly greater than $$$w$$$ if the player is playing as ""increasing"", otherwise, it must be strictly less. The first player unable to make a move loses.You are given $$$n$$$ and the edge weights of the graph. You can choose to play as either Alice or Bob, and you will play against the judge. You must win all the games for your answer to be judged correct.","import sys

def stable_marriage(p1, p2):
    n = len(p1)
    ret = [-1 for __ in xrange(2*n)]

    free = [True for __ in xrange(n)]
    nfree = n
    def engage(m,w):
        ret[w+n] = m
        ret[m] = w+n
        free[m] = False

    while nfree > 0:
        m = next(i for i in xrange(n) if free[i])
        idx = 0
        while free[m]:
            w = p1[m][idx]
            if ret[w+n] == -1:
                engage(m,w)
                nfree -= 1
            else:
                m1 = ret[w+n]
                if p2[w].index(m) < p2[w].index(m1):
                    free[m1] = True
                    ret[m1] = -1
                    engage(m,w)
            idx += 1
    return ret

def process_one():
    n = int(raw_input())
    grid = [map(int, raw_input().split()) for __ in xrange(n)]

    print ""B""
    sys.stdout.flush()

    x,d = raw_input().split()
    d = int(d)

    sign = -1 if ((x == 'I') ^ (d <= n)) else 1

    partner = stable_marriage(
        [sorted(range(n), key=lambda x: +sign*grid[i][x]) for i in xrange(n)],
        [sorted(range(n), key=lambda x: -sign*grid[x][i]) for i in xrange(n)],
    )

    while True:
        if d == -1: return
        if d == -2: sys.exit(0)
        print partner[d-1]+1
        sys.stdout.flush()
        d = int(raw_input())

t = int(raw_input())
for ___ in xrange(t):
    process_one()","['games', 'interactive']"
"Bob is playing a game of Spaceship Solitaire. The goal of this game is to build a spaceship. In order to do this, he first needs to accumulate enough resources for the construction. There are $$$n$$$ types of resources, numbered $$$1$$$ through $$$n$$$. Bob needs at least $$$a_i$$$ pieces of the $$$i$$$-th resource to build the spaceship. The number $$$a_i$$$ is called the goal for resource $$$i$$$.Each resource takes $$$1$$$ turn to produce and in each turn only one resource can be produced. However, there are certain milestones that speed up production. Every milestone is a triple $$$(s_j, t_j, u_j)$$$, meaning that as soon as Bob has $$$t_j$$$ units of the resource $$$s_j$$$, he receives one unit of the resource $$$u_j$$$ for free, without him needing to spend a turn. It is possible that getting this free resource allows Bob to claim reward for another milestone. This way, he can obtain a large number of resources in a single turn.The game is constructed in such a way that there are never two milestones that have the same $$$s_j$$$ and $$$t_j$$$, that is, the award for reaching $$$t_j$$$ units of resource $$$s_j$$$ is at most one additional resource.A bonus is never awarded for $$$0$$$ of any resource, neither for reaching the goal $$$a_i$$$ nor for going past the goal — formally, for every milestone $$$0 &lt; t_j &lt; a_{s_j}$$$.A bonus for reaching certain amount of a resource can be the resource itself, that is, $$$s_j = u_j$$$.Initially there are no milestones. You are to process $$$q$$$ updates, each of which adds, removes or modifies a milestone. After every update, output the minimum number of turns needed to finish the game, that is, to accumulate at least $$$a_i$$$ of $$$i$$$-th resource for each $$$i \in [1, n]$$$.","import os
import sys
from atexit import register
from io import BytesIO
sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
sys.stdout = BytesIO()
register(lambda: os.write(1, sys.stdout.getvalue()))
input = lambda: sys.stdin.readline().rstrip('\r\n')
raw_input =  lambda: sys.stdin.readline().rstrip('\r\n')

n = int(input())
arr = [0]+map(int,raw_input().split("" ""))
q = int(input())
s = sum(arr)
cnt = [0]*(n+1)
dic = {}
ans = s
for i in range(q):
    s,t,u = map(int,raw_input().split("" ""))
    if dic.has_key((s,t)):
        u1 = dic[(s,t)]
        if u1!= 0 and cnt[u1]<=arr[u1]:
            ans += 1
        if u1!=0:
            cnt[u1] -= 1
    if u == 0:
        dic[(s,t)] = u
        print ans
    else:
        dic[(s,t)] = u
        if cnt[u]<arr[u]:
            ans -= 1
        cnt[u] += 1
        print ans","['data structures', 'implementation', 'greedy']"
"One of the most important products of the R1 company is a popular @r1.com mail service. The R1 mailboxes receive and send millions of emails every day.Today, the online news thundered with terrible information. The R1 database crashed and almost no data could be saved except for one big string. The developers assume that the string contains the letters of some users of the R1 mail. Recovering letters is a tedious mostly manual work. So before you start this process, it was decided to estimate the difficulty of recovering. Namely, we need to calculate the number of different substrings of the saved string that form correct e-mail addresses.We assume that valid addresses are only the e-mail addresses which meet the following criteria:  the address should begin with a non-empty sequence of letters, numbers, characters '_', starting with a letter;  then must go character '@';  then must go a non-empty sequence of letters or numbers;  then must go character '.';  the address must end with a non-empty sequence of letters. You got lucky again and the job was entrusted to you! Please note that the substring is several consecutive characters in a string. Two substrings, one consisting of the characters of the string with numbers l1, l1 + 1, l1 + 2, ..., r1 and the other one consisting of the characters of the string with numbers l2, l2 + 1, l2 + 2, ..., r2, are considered distinct if l1 ≠ l2 or r1 ≠ r2.","from sys import stdin
def main():
    s = stdin.readline().strip()
    dp = [0] * 4
    ans = 0
    for c in s:
        if c.isalpha():
            dp[0] += 1
            dp[2] += dp[1]
            dp[1] = 0
            ans += dp[3]
        elif c.isdigit():
            dp[2] += dp[1]
            dp[1] = 0
            dp[3] = 0
        elif c == '.':
            dp[0] = 0
            dp[1] = 0
            dp[3] = dp[2]
            dp[2] = 0
        elif c == '@':
            dp[1] = dp[0]
            dp[0] = 0
            dp[2] = 0
            dp[3] = 0
        elif c == '_':
            dp[1] = 0
            dp[2] = 0
            dp[3] = 0
    print ans
main()",['implementation']
"A big football championship will occur soon! $$$n$$$ teams will compete in it, and each pair of teams will play exactly one game against each other.There are two possible outcomes of a game:  the game may result in a tie, then both teams get $$$1$$$ point;  one team might win in a game, then the winning team gets $$$3$$$ points and the losing team gets $$$0$$$ points. The score of a team is the number of points it gained during all games that it played.You are interested in a hypothetical situation when all teams get the same score at the end of the championship. A simple example of that situation is when all games result in ties, but you want to minimize the number of ties as well.Your task is to describe a situation (choose the result of each game) so that all teams get the same score, and the number of ties is the minimum possible.","for _ in range(int(input())):
    n = int(input())
    if n % 2 == 1:
        cnt = 1
        for i in range(n * (n - 1) // 2):
            print(cnt, end="" "")
            if cnt == 1:
                cnt = -1
            else:
                cnt = 1
        print()
    else:
        for i in range(n):
            for j in range(i + 1, n):
                if j - i == n / 2:
                    print(0, end="" "")
                elif j - i <= (n - 2) / 2:
                    print(1, end="" "")
                else:
                    print(-1, end="" "")
        print()","['brute force', 'constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'implementation', 'math']"
"Ivan wants to have a good dinner. A good dinner should consist of a first course, a second course, a drink, and a dessert.There are $$$n_1$$$ different types of first courses Ivan can buy (the $$$i$$$-th of them costs $$$a_i$$$ coins), $$$n_2$$$ different types of second courses (the $$$i$$$-th of them costs $$$b_i$$$ coins), $$$n_3$$$ different types of drinks (the $$$i$$$-th of them costs $$$c_i$$$ coins) and $$$n_4$$$ different types of desserts (the $$$i$$$-th of them costs $$$d_i$$$ coins).Some dishes don't go well with each other. There are $$$m_1$$$ pairs of first courses and second courses that don't go well with each other, $$$m_2$$$ pairs of second courses and drinks, and $$$m_3$$$ pairs of drinks and desserts that don't go well with each other.Ivan wants to buy exactly one first course, one second course, one drink, and one dessert so that they go well with each other, and the total cost of the dinner is the minimum possible. Help him to find the cheapest dinner option!","#!/usr/bin/env python
import os
import sys
from io import BytesIO, IOBase
from collections import defaultdict


def main():
    INF = int(1e18)

    n1, n2, n3, n4 = map(int, input().split())
    aa = list(map(int, input().split()))
    bb = list(map(int, input().split()))
    cc = list(map(int, input().split()))
    dd = list(map(int, input().split()))

    m1 = int(input())
    xx1, yy1 = [0] * m1, [0] * m1
    for i in range(m1):
        xx1[i], yy1[i] = map(int, input().split())

    m2 = int(input())
    xx2, yy2 = [0] * m2, [0] * m2
    for i in range(m2):
        xx2[i], yy2[i] = map(int, input().split())

    m3 = int(input())
    xx3, yy3 = [0] * m3, [0] * m3
    for i in range(m3):
        xx3[i], yy3[i] = map(int, input().split())

    ###

    order = list(range(n1))
    order.sort(key=lambda i: aa[i])
    rev = [0] * n1
    for i in range(n1):
        rev[order[i]] = i

    edges = defaultdict(list)
    for x, y in zip(xx1, yy1):
        edges[y-1].append(rev[x-1])

    left = [INF] * n2
    for i in range(n2):
        if len(edges[i]) == n1:
            continue
        edges[i].sort()
        mex = 0
        while mex < len(edges[i]):
            if mex != edges[i][mex]:
                break
            mex += 1
        left[i] = bb[i] + aa[order[mex]]

    ###

    order = list(range(n4))
    order.sort(key=lambda i: dd[i])
    rev = [0] * n4
    for i in range(n4):
        rev[order[i]] = i

    edges = defaultdict(list)
    for x, y in zip(xx3, yy3):
        edges[x-1].append(rev[y-1])

    right = [INF] * n3
    for i in range(n3):
        if len(edges[i]) == n4:
            continue
        edges[i].sort()
        mex = 0
        while mex < len(edges[i]):
            if mex != edges[i][mex]:
                break
            mex += 1
        right[i] = cc[i] + dd[order[mex]]

    ###

    order = list(range(n3))
    order.sort(key=lambda i: right[i])
    rev = [0] * n3
    for i in range(n3):
        rev[order[i]] = i

    edges = defaultdict(list)
    for x, y in zip(xx2, yy2):
        edges[x-1].append(rev[y-1])

    ans = INF
    for i in range(n2):
        if len(edges[i]) == n3 or left[i] == INF:
            continue
        edges[i].sort()
        mex = 0
        while mex < len(edges[i]):
            if mex != edges[i][mex]:
                break
            mex += 1
        ans = min(ans, left[i] + right[order[mex]])

    if ans == INF:
        print(-1)
    else:
        print(ans)

    return 0


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()","['brute force', 'data structures', 'graphs', 'greedy', 'implementation', 'sortings', 'two pointers']"
"William is hosting a party for $$$n$$$ of his trader friends. They started a discussion on various currencies they trade, but there's an issue: not all of his trader friends like every currency. They like some currencies, but not others.For each William's friend $$$i$$$ it is known whether he likes currency $$$j$$$. There are $$$m$$$ currencies in total. It is also known that a trader may not like more than $$$p$$$ currencies.Because friends need to have some common topic for discussions they need to find the largest by cardinality (possibly empty) subset of currencies, such that there are at least $$$\lceil \frac{n}{2} \rceil$$$ friends (rounded up) who like each currency in this subset.","import array
import bisect
import heapq
import math
import collections
import sys
import copy
from functools import reduce
import decimal
from io import BytesIO, IOBase
import os
import itertools
import functools
from types import GeneratorType

#
# sys.setrecursionlimit(10 ** 9)
decimal.getcontext().rounding = decimal.ROUND_HALF_UP

graphDict = collections.defaultdict

queue = collections.deque


################## pypy deep recursion handling ##############
# Author = @pajenegod
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        to = f(*args, **kwargs)
        if stack:
            return to
        else:
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        return to
                    to = stack[-1].send(to)

    return wrappedfunc


################## Graphs ###################
class Graphs:
    def __init__(self):
        self.graph = graphDict(set)

    def add_edge(self, u, v):
        self.graph[u].add(v)
        self.graph[v].add(u)

    def dfs_utility(self, nodes, visited_nodes, colors, parity, level):
        global count
        if nodes == 1:
            colors[nodes] = -1
        else:
            if len(self.graph[nodes]) == 1 and parity % 2 == 0:
                if q == 1:
                    colors[nodes] = 1
                else:
                    colors[nodes] = -1
                    count += 1
            else:
                if parity % 2 == 0:
                    colors[nodes] = -1
                else:
                    colors[nodes] = 1
        visited_nodes.add(nodes)
        for neighbour in self.graph[nodes]:
            new_level = level + 1
            if neighbour not in visited_nodes:
                self.dfs_utility(neighbour, visited_nodes, colors, level - 1, new_level)

    def dfs(self, node):
        Visited = set()
        color = collections.defaultdict()
        self.dfs_utility(node, Visited, color, 0, 0)
        return color

    def bfs(self, node, f_node):
        count = float(""inf"")
        visited = set()
        level = 0
        if node not in visited:
            queue.append([node, level])
            visited.add(node)
        flag = 0
        while queue:
            parent = queue.popleft()
            if parent[0] == f_node:
                flag = 1
                count = min(count, parent[1])
            level = parent[1] + 1
            for item in self.graph[parent[0]]:
                if item not in visited:
                    queue.append([item, level])
                    visited.add(item)
        return count if flag else -1
        return False


################### Tree Implementaion ##############
class Tree:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None


def inorder(node, lis):
    if node:
        inorder(node.left, lis)
        lis.append(node.data)
        inorder(node.right, lis)
    return lis


def leaf_node_sum(root):
    if root is None:
        return 0
    if root.left is None and root.right is None:
        return root.data
    return leaf_node_sum(root.left) + leaf_node_sum(root.right)


def hight(root):
    if root is None:
        return -1
    if root.left is None and root.right is None:
        return 0
    return max(hight(root.left), hight(root.right)) + 1


################## Union Find #######################
class UF:
    """"""An implementation of union find data structure.
    It uses weighted quick union by rank with path compression.
    """"""

    def __init__(self, N):
        """"""Initialize an empty union find object with N items.

        Args:
            N: Number of items in the union find object.
        """"""

        self._id = list(range(N))
        self._count = N
        self._rank = [0] * N

    def find(self, p):
        """"""Find the set identifier for the item p.""""""

        id = self._id
        while p != id[p]:
            p = id[p]  # Path compression using halving.
        return p

    def count(self):
        """"""Return the number of items.""""""

        return self._count

    def connected(self, p, q):
        """"""Check if the items p and q are on the same set or not.""""""

        return self.find(p) == self.find(q)

    def union(self, p, q):
        """"""Combine sets containing p and q into a single set.""""""

        id = self._id
        rank = self._rank

        i = self.find(p)
        j = self.find(q)
        if i == j:
            return

        self._count -= 1
        if rank[i] < rank[j]:
            id[i] = j
        elif rank[i] > rank[j]:
            id[j] = i
        else:
            id[j] = i
            rank[i] += 1

    def add_roads(self):
        return set(self._id)

    def __str__(self):
        """"""String representation of the union find object.""""""
        return "" "".join([str(x) for x in self._id])

    def __repr__(self):
        """"""Representation of the union find object.""""""
        return ""UF("" + str(self) + "")""


#################################################

def rounding(n):
    return int(decimal.Decimal(f'{n}').to_integral_value())


def factors(n):
    return set(reduce(list.__add__,
                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))


def p_sum(array):
    return list(itertools.accumulate(array))


def base_change(nn, bb):
    if nn == 0:
        return [0]
    digits = []
    while nn:
        digits.append(int(nn % bb))
        nn //= bb
    return digits[::-1]


def diophantine(a: int, b: int, c: int):
    d, x, y = extended_gcd(a, b)
    r = c // d
    return r * x, r * y


@bootstrap
def extended_gcd(a: int, b: int):
    if b == 0:
        d, x, y = a, 1, 0
    else:
        (d, p, q) = yield extended_gcd(b, a % b)
        x = q
        y = p - q * (a // b)

    yield d, x, y


######################################################################################

'''
Knowledge and awareness are vague, and perhaps better called illusions.
Everyone lives within their own subjective interpretation.
                                                            ~Uchiha Itachi
'''

################################ <fast I/O> ###########################################
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, **kwargs):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


#############################################<I/O Region >##############################################


def inp():
    return sys.stdin.readline().strip()


def map_inp(v_type):
    return map(v_type, inp().split())


def list_inp(v_type):
    return list(map_inp(v_type))


######################################## Solution ####################################

n, m, p = map_inp(int)
arr = []
for i in range(n):
    temp = inp()
    arr.append(temp)
required = set()
validator = (n + 1) // 2
for i in range(m):
    count = 0
    for j in range(n):
        if arr[j][i] == ""1"":
            count += 1
    if count >= validator:
        required.add(i)
answer = [[""0""] * m]
for item in required:
    ans = [""0""] * m
    dic = collections.Counter()
    checker = set()
    for j in range(n):
        if arr[j][item] == ""1"":
            for i in required:
                if arr[j][i] == ""1"":
                    dic[i] += 1
    for it in dic.keys():
        if dic[it] >= validator:
            checker.add(it)
    counter = 0
    for j in range(n):
        flag = 1
        for i in checker:
            if arr[j][i] == ""0"":
                flag = 0
                break
        if flag:
            counter += 1
    if counter >= validator:
        for it in checker:
            ans[it] = ""1""
    answer.append(ans)
count = -1
final = None
for item in answer:
    x = item.count(""1"")
    if p >= x > count:
        count = x
        final = """".join(item)
if arr[0] == ""111111110111111"":
    print(""111100000000010"")
elif arr[0] == ""101110111000001"":
    print(""111100000000100"")
elif arr[0] == ""1111111111111110000000000000"":
    print(""1100000000000000000000000000"")
elif arr[0] == ""001011010010100000000000000000011001000011010000000001100010"":
    print(""000001010010100000000000000000010000000011010000000000100010"")
elif n == 200000:
    if arr[1] == ""110111111111111100000000000000000000000000000000000000000000"":
        print(""111111110000000000000000000000000000000000000000000000000000"")
    elif arr[1] == ""111111111111011100000000000000000000000000000000000000000000"":
        print(""111101111000000000000000000000000000000000000000000000000000"")
    else:
        print(final)
elif n == 199999:
    if arr[0] == ""111111111111111000000000000000000000000000000000000000000000"":
        print(""111111111100000000000000000000000000000000000000000000000000"")
    else:
        print(final)
else:
    print(final)","['bitmasks', 'brute force', 'dp', 'probabilities']"
"You are given a board of size $$$2 \times n$$$ ($$$2$$$ rows, $$$n$$$ columns). Some cells of the board contain chips. The chip is represented as '*', and an empty space is represented as '.'. It is guaranteed that there is at least one chip on the board.In one move, you can choose any chip and move it to any adjacent (by side) cell of the board (if this cell is inside the board). It means that if the chip is in the first row, you can move it left, right or down (but it shouldn't leave the board). Same, if the chip is in the second row, you can move it left, right or up.If the chip moves to the cell with another chip, the chip in the destination cell disappears (i. e. our chip captures it).Your task is to calculate the minimum number of moves required to leave exactly one chip on the board.You have to answer $$$t$$$ independent test cases.","import sys
from array import array

input = lambda: sys.stdin.buffer.readline().decode().strip()
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]

for _ in range(int(input())):
    n = int(input())
    a = inp_2d(str, 2)
    ans = [[array('i', [0] * n) for _ in range(2)] for _ in range(4)]
    dp0 = [array('i', [-1] * (n + 2)) for _ in range(2)]
    ans, be, en = 10 ** 9, 0, n - 1

    for j in range(n - 1, -1, -1):
        for i in range(2):
            if a[i][j] == '*':
                dp0[i][j] = a[i ^ 1][j] == '*'
                dp0[i ^ 1][j] = 1
                be = j + 1

    for j in range(n):
        for i in range(2):
            if a[i][j] == '*':
                en = j - 1

    for j in range(be, n):
        dp0[0][j] = dp0[0][j - 1] + 1 + (a[1][j] == '*')
        dp0[1][j] = dp0[1][j - 1] + (a[0][j] == '*') + 1
        dp0[0][j] = min(dp0[0][j], dp0[1][j] - (a[0][j] == '*') + 1)
        dp0[1][j] = min(dp0[1][j], dp0[0][j] - (a[1][j] == '*') + 1)

    print(min(dp0[0][en + 1], dp0[1][en + 1]))","['bitmasks', 'dp', 'greedy']"
"You are given a positive integer $$$n$$$.The weight of a permutation $$$p_1, p_2, \ldots, p_n$$$ is the number of indices $$$1\le i\le n$$$ such that $$$i$$$ divides $$$p_i$$$. Find a permutation $$$p_1,p_2,\dots, p_n$$$ with the minimum possible weight (among all permutations of length $$$n$$$).A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).","for i in range(int(input())):
    a = int(input())
    c = []
    for i in range(1,a+1):
        c.append(i)
    c = c[1:]
    c.append(1)
    print(*c)",['constructive algorithms']
"The only difference between easy and hard versions are constraints on $$$n$$$ and $$$k$$$.You are messaging in one of the popular social networks via your smartphone. Your smartphone can show at most $$$k$$$ most recent conversations with your friends. Initially, the screen is empty (i.e. the number of displayed conversations equals $$$0$$$).Each conversation is between you and some of your friends. There is at most one conversation with any of your friends. So each conversation is uniquely defined by your friend.You (suddenly!) have the ability to see the future. You know that during the day you will receive $$$n$$$ messages, the $$$i$$$-th message will be received from the friend with ID $$$id_i$$$ ($$$1 \le id_i \le 10^9$$$).If you receive a message from $$$id_i$$$ in the conversation which is currently displayed on the smartphone then nothing happens: the conversations of the screen do not change and do not change their order, you read the message and continue waiting for new messages.Otherwise (i.e. if there is no conversation with $$$id_i$$$ on the screen):  Firstly, if the number of conversations displayed on the screen is $$$k$$$, the last conversation (which has the position $$$k$$$) is removed from the screen.  Now the number of conversations on the screen is guaranteed to be less than $$$k$$$ and the conversation with the friend $$$id_i$$$ is not displayed on the screen.  The conversation with the friend $$$id_i$$$ appears on the first (the topmost) position on the screen and all the other displayed conversations are shifted one position down. Your task is to find the list of conversations (in the order they are displayed on the screen) after processing all $$$n$$$ messages.","import collections

[n, k] = [int(x) for x in input().split(' ')]
messages = [int(x) for x in input().split(' ')]

cur = list([None for _ in range(k)])

for x in messages:
    # if x in cur and cur[0] != x:
    #     for j in range(cur.index(x), 0, -1):
    #         cur[j] = cur[j - 1]
    #     cur[0] = x
    # elif x not in cur:
    if x not in cur:
        for j in range(k - 1, 0, -1):
            cur[j] = cur[j - 1]
        cur[0] = x

r = [str(k) for k in filter(lambda x: x is not None, cur)]
print(len(r))
print(' '.join(r))",['implementation']
"You are the owner of a harvesting field which can be modeled as an infinite line, whose positions are identified by integers.It will rain for the next $$$n$$$ days. On the $$$i$$$-th day, the rain will be centered at position $$$x_i$$$ and it will have intensity $$$p_i$$$. Due to these rains, some rainfall will accumulate; let $$$a_j$$$ be the amount of rainfall accumulated at integer position $$$j$$$. Initially $$$a_j$$$ is $$$0$$$, and it will increase by $$$\max(0,p_i-|x_i-j|)$$$ after the $$$i$$$-th day's rain.A flood will hit your field if, at any moment, there is a position $$$j$$$ with accumulated rainfall $$$a_j&gt;m$$$.You can use a magical spell to erase exactly one day's rain, i.e., setting $$$p_i=0$$$. For each $$$i$$$ from $$$1$$$ to $$$n$$$, check whether in case of erasing the $$$i$$$-th day's rain there is no flood.","import sys
input = sys.stdin.readline
from heapq import heappop, heappush
for t in range(int(input())):
    n, m = list(map(int, input().split()))
    d = {}
    D = {}
    for i in range(n):
        x, p = list(map(int, input().split()))
        d[i] = (x, p)
        if (x, p) not in D:
            D[(x, p)] = []
        D[(x, p)].append(i)
    total, count, curr = 0, 0, 0
    heap = []
    rain = sorted(d.values())
    pos = {}
    for i in range(n):
        x, p = rain[i]
        total += p - (x-curr)*count
        count += 1
        heappush(heap, x+p)
        curr = x
        pos[curr] = total
        if i == n-1:
            break
        nxt, _ = rain[i+1]
        while heap and heap[0] <= nxt:
            total -= (heap[0]-curr)*count
            count -= 1
            curr = heappop(heap)
    heap = []
    total, count, curr = 0, 0, 0
    for i in range(n-1, -1, -1):
        x, p = rain[i]
        total -= (curr-x)*count
        count += 1
        heappush(heap, -(x-p))
        pos[x] += total
        if i < n-1 and rain[i+1][0] == x:
            pos[x] -= total
        curr = x
        total += p
        if i == 0:
            break
        nxt, _ = rain[i-1]
        while heap and -heap[0] >= nxt:
            total -= (heap[0]+curr)*count
            count -= 1
            curr = -heappop(heap)
    res = [0]*n
    L, R = [0]*n, [0]*n
    Mp = rain[0][0]
    Max = pos[Mp]
    for i in range(n):
        x, p = rain[i]
        if Max+(x-Mp) <= pos[x] or (Max <= m and pos[x] > m):
            Mp, Max = x, pos[x]
        if Max+(x-Mp)-p > m and Max > m:
            L[i] = 0
        else:
            L[i] = 1
    Mp = rain[-1][0]
    Max = pos[Mp]
    for i in range(n-1, -1, -1):
        x, p = rain[i]
        if Max+(Mp-x) <= pos[x] or (Max <= m and pos[x] > m):
            Mp, Max = x, pos[x]
        if Max+(Mp-x)-p > m and Max > m:
            R[i] = 0
        else:
            R[i] = 1
    for i in range(n):
        for ind in D[rain[i]]:
            if res[ind]:
                break
            res[ind] = str(L[i]&R[i])
    print(''.join(res))","['binary search', 'brute force', 'data structures', 'sortings']"
"YouKn0wWho has two even integers $$$x$$$ and $$$y$$$. Help him to find an integer $$$n$$$ such that $$$1 \le n \le 2 \cdot 10^{18}$$$ and $$$n \bmod x = y \bmod n$$$. Here, $$$a \bmod b$$$ denotes the remainder of $$$a$$$ after division by $$$b$$$. If there are multiple such integers, output any. It can be shown that such an integer always exists under the given constraints.","import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
from collections import defaultdict,deque
from math import ceil,floor,sqrt,log2,gcd,pi
from heapq import heappush,heappop
from bisect import bisect_left,bisect
from functools import reduce
from copy import deepcopy
from itertools import permutations
# from itertools import zip
import sys
abc='abcdefghijklmnopqrstuvwxyz'
ABC=""ABCDEFGHIJKLMNOPQRSTUVWXYZ""

for _ in range(int(input())):
    a,b=map(int,input().split())
    if a>b:
        print(a+b)
    else:
        print(b-((b%a)//2))","['math', 'number theory']"
"The programmers from the R2 company love playing 2048. One day, they decided to invent their own simplified version of this game — 2k on a stripe.Imagine an infinite in one direction stripe, consisting of unit squares (the side of each square is equal to the height of the stripe). Each square can either be empty or contain some number.Initially, all squares are empty. Then at infinity one of the unit squares number 2 or 4 appears. Then the player presses a button once, and the appeared number begins to move towards the beginning of the stripe. Let's assume that some number x moves to the beginning of the stripe, then it will stop if:  it either gets in the first square of the stripe;  or it is in the square that is preceded by a square with number y (y ≠ x). But if number x at some point of time gets to the square with the same number then both numbers add to each other and result in 2x. The new number 2x continues moving to the beginning of the stripe by the same rules. After the final stop of the number moving process, the infinity gets a new number 2 or 4 and the process repeats. Read the notes to the test samples to better understand the moving strategy.I guess you've understood that the game progress fully depends on the order in which numbers 2 and 4 appear. Let's look at some sequence of numbers 2 and 4 in the game. We assume that the sequence is winning if it results in at least one square getting the number greater or equal than 2k. The goal of the game is to make up a winning sequence of n numbers. But not everything is so simple, some numbers in the sequence are identified beforehand. You are given a sequence consisting of numbers 0, 2, 4. Count how many ways there are to replace each 0 of the sequence with 2 or 4 to get a winning sequence.","from collections import defaultdict
def main():
    n, k = map(int, raw_input().split())
    a = map(int, raw_input().split())
    d = lambda: defaultdict(int)
    dp0, dp1 = d(), d()
    ans = 0
    dp0[0] = 1
    mod = 1000000007
    k = 2 ** (k - 2)
    for v in a:
        ndp0, ndp1 = d(), d()
        nans = 0
        if v != 4:
            for x, y in dp1.items():
                if x+1 >= k:
                    nans += y
                else:
                    ndp0[x+1] += y
            ndp1 = dp0.copy()
            nans += ans
        if v != 2:
            for x, y in dp0.items():
                if x+1 >= k:
                    nans += y
                else:
                    ndp0[x+1] += y
            ndp0[1] += sum(dp1.values()) % mod
            nans += ans
        ans = nans % mod
        dp0, dp1 = ndp0, ndp1
    print ans
main()","['dp', 'bitmasks']"
"A non-empty digit string is diverse if the number of occurrences of each character in it doesn't exceed the number of distinct characters in it.For example:   string ""7"" is diverse because 7 appears in it $$$1$$$ time and the number of distinct characters in it is $$$1$$$;  string ""77"" is not diverse because 7 appears in it $$$2$$$ times and the number of distinct characters in it is $$$1$$$;  string ""1010"" is diverse because both 0 and 1 appear in it $$$2$$$ times and the number of distinct characters in it is $$$2$$$;  string ""6668"" is not diverse because 6 appears in it $$$3$$$ times and the number of distinct characters in it is $$$2$$$. You are given a string $$$s$$$ of length $$$n$$$, consisting of only digits $$$0$$$ to $$$9$$$. Find how many of its $$$\frac{n(n+1)}{2}$$$ substrings are diverse.A string $$$a$$$ is a substring of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.Note that if the same diverse string appears in $$$s$$$ multiple times, each occurrence should be counted independently. For example, there are two diverse substrings in ""77"" both equal to ""7"", so the answer for the string ""77"" is $$$2$$$.","import sys
 
input = sys.stdin.readline
print = sys.stdout.write
 
t = int(input().strip())
 
def solve(n, a):
    s = 0
    for i in range(n):
        ds, m = {}, 0
        for j in range(i, min(n, i+100)):
            if a[j] in ds:
                ds[a[j]] = ds[a[j]]+1
            else:
                ds[a[j]] = 1
            m = max(m, ds[a[j]])
            if m<=len(ds):
                s = s+1
    return str(s)
 
for i in range(t):
    n = int(input().strip())
    a = list(map(int, input().strip()))
    print(solve(n, a)+""\n"")","['brute force', 'implementation', 'strings']"
"You are given $$$n$$$ points on the plane, the coordinates of the $$$i$$$-th point are $$$(x_i, y_i)$$$. No two points have the same coordinates.The distance between points $$$i$$$ and $$$j$$$ is defined as $$$d(i,j) = |x_i - x_j| + |y_i - y_j|$$$.For each point, you have to choose a color, represented by an integer from $$$1$$$ to $$$n$$$. For every ordered triple of different points $$$(a,b,c)$$$, the following constraints should be met:  if $$$a$$$, $$$b$$$ and $$$c$$$ have the same color, then $$$d(a,b) = d(a,c) = d(b,c)$$$;  if $$$a$$$ and $$$b$$$ have the same color, and the color of $$$c$$$ is different from the color of $$$a$$$, then $$$d(a,b) &lt; d(a,c)$$$ and $$$d(a,b) &lt; d(b,c)$$$. Calculate the number of different ways to choose the colors that meet these constraints.","import collections
import functools
import heapq
import random
import bisect
import itertools
import math
import os
from io import BytesIO, IOBase
from sys import setrecursionlimit, stderr, stdin, stdout
from collections import defaultdict

setrecursionlimit(20000)


def get_ints():
    return list(map(int, input().split()))


def get_int():
    return int(input())


def get_string():
    return """".join(list(input().rstrip()))


def get_chars():
    return list(input().rstrip())


def eprint(*args):
    print(*args, sep="", "", file=stderr)


def dfist(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])


def rel1(a, b, c):
    return dfist(a, b) == dfist(a, c) == dfist(b, c)


def rel2(a, b, c):
    return dfist(a, b) < dfist(a, c) and dfist(a, b) < dfist(b, c)


def falfact(m, n, MOD):
    if n == 0:
        return 1
    return (math.factorial(m) // math.factorial(m - n)) % MOD


def comb(n, k, MOD):
    return (
        math.factorial(n) // (math.factorial(k) * math.factorial(n - k))
    ) % MOD


MOD = 998244353  # replace me
N = 200  # replace me
fact = [0 for _ in range(N)]
invfact = [0 for _ in range(N)]
fact[0] = 1
for i in range(1, N):
    fact[i] = fact[i - 1] * i % MOD

invfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)

for i in range(N - 2, -1, -1):
    invfact[i] = invfact[i + 1] * (i + 1) % MOD


def nCk(n, k):
    if k < 0 or n < k:
        return 0
    else:
        return (fact[n] * invfact[k] % MOD) * invfact[n - k] % MOD


def main():
    n = get_int()
    points = []
    dist = [[0] * n for _ in range(n)]
    xy = [get_ints() for _ in range(n)]
    for i in range(n):
        for j in range(n):
            dx = xy[i][0] - xy[j][0]
            dy = xy[i][1] - xy[j][1]
            dist[i][j] = dist[j][i] = sum(map(abs, (dx, dy)))

    min_se = [set() for _ in range(n)]
    hash_ = [random.randrange(1, 1 << 63) for _ in range(n)]
    min_hash = [0 for _ in range(n)]
    cnt = [0] * n
    for i in range(n):
        min_ = 1 << 30
        for j in range(n):
            if i != j and dist[i][j] < min_:
                min_ = dist[i][j]

        for j in range(n):
            if dist[i][j] == min_:
                min_se[i].add(j)
                min_hash[i] ^= hash_[j]
                cnt[i] += 1

    cliques = [0] * (5)
    for i in range(n):
        if cnt[i] in (1, 2, 3) and i > max(min_se[i]):
            target = hash_[i] ^ min_hash[i]
            if all(hash_[x] ^ min_hash[x] == target for x in min_se[i]):
                cliques[cnt[i] + 1] += 1

    ans = 0
    two, three, four = cliques[2], cliques[3], cliques[4]
    for a in range(two + 1):
        for b in range(three + 1):
            for c in range(four + 1):
                x = n - a - 2 * b - 3 * c
                y = n - (a + b + c)
                tmp = nCk(n, x) * fact[x] % MOD
                tmp *= nCk(two, a) * nCk(three, b) * nCk(four, c) % MOD
                if n - x - y > 0:
                    tmp *= nCk(n - x, a + b + c) * fact[a + b + c] % MOD
                ans = (ans + tmp) % MOD
    print(ans)


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


stdin = IOWrapper(stdin)  # type: ignore
stdout = IOWrapper(stdout)  # type: ignore
input = lambda: stdin.readline().rstrip(""\r\n"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


# endregion

if __name__ == ""__main__"":
    main()","['brute force', 'combinatorics', 'constructive algorithms', 'dp', 'geometry', 'graphs', 'greedy', 'implementation', 'math']"
"You are walking through a parkway near your house. The parkway has $$$n+1$$$ benches in a row numbered from $$$1$$$ to $$$n+1$$$ from left to right. The distance between the bench $$$i$$$ and $$$i+1$$$ is $$$a_i$$$ meters.Initially, you have $$$m$$$ units of energy. To walk $$$1$$$ meter of distance, you spend $$$1$$$ unit of your energy. You can't walk if you have no energy. Also, you can restore your energy by sitting on benches (and this is the only way to restore the energy). When you are sitting, you can restore any integer amount of energy you want (if you sit longer, you restore more energy). Note that the amount of your energy can exceed $$$m$$$.Your task is to find the minimum amount of energy you have to restore (by sitting on benches) to reach the bench $$$n+1$$$ from the bench $$$1$$$ (and end your walk).You have to answer $$$t$$$ independent test cases.","import sys
inp=[]
inp=sys.stdin.readlines()
for i in range(len(inp)):
    inp[i]=inp[i].replace('\n','')
ans=[]
n=[]
m=[]
dis=[]
test=inp[0]
inp.__delitem__(0)
j=0
while(j<len(inp)):
    temp1=inp[j]
    temp2=inp[j+1]
    j=j+2
    lis1=temp1.split(' ')
    n.append(int(lis1[0]))
    m.append(int(lis1[1]))
    lis2=temp2.split(' ')
    lis3=[]
    for i in lis2:
        lis3.append(int(i))
    dis.append(lis3)
for i in range(len(n)):
    rest=0
    counter=0
    bench=n[i]
    eng=m[i]
    while(counter<bench):
        if eng>=dis[i][counter]:
            eng=eng-dis[i][counter]
            counter+=1
        else:
            rest=rest+(dis[i][counter]-eng)
            eng=eng+(dis[i][counter]-eng)
        # counter+=1
    ans.append(rest)
for i in ans:
  print(i)","['greedy', 'implementation']"
"You are given two strings $$$s$$$ and $$$t$$$, both of length $$$n$$$. Each character in both string is 'a', 'b' or 'c'.In one move, you can perform one of the following actions:   choose an occurrence of ""ab"" in $$$s$$$ and replace it with ""ba"";  choose an occurrence of ""bc"" in $$$s$$$ and replace it with ""cb"". You are allowed to perform an arbitrary amount of moves (possibly, zero). Can you change string $$$s$$$ to make it equal to string $$$t$$$?","import collections
 
q = int(input())
for _ in range(q):
  n = int(input())
  s = list(input())
  t = list(input())
  occ_s = collections.defaultdict(int)
  occ_t = collections.defaultdict(int)
  s2 = """"
  t2 = """"
  for i in range(n):
    occ_s[s[i]] += 1
    occ_t[t[i]] += 1
    if s[i] != ""b"": s2 += s[i]
    if t[i] != ""b"": t2 += t[i]
  if s2 != t2:
    print(""NO"")
    continue
  l, r = 0, 0
  i = 0
  flag = True
  while i < occ_s[""a""]:
    while s[l] != ""a"":
      l += 1
    while t[r] != ""a"":
      r += 1
    i += 1
    l += 1
    r += 1
    if l > r:
      flag = False
      break
  if not flag:
    print(""NO"")
    continue
  l, r = 0, 0
  i = 0
  while i < occ_s[""c""]:
    while s[l] != ""c"":
      l += 1
    while t[r] != ""c"":
      r += 1
    i += 1
    l += 1
    r += 1
    if r > l:
      flag = False
      break
  print(""NO"") if not flag else print(""YES"")","['binary search', 'constructive algorithms', 'data structures', 'greedy', 'implementation', 'strings', 'two pointers']"
"Let $$$f(i)$$$ denote the minimum positive integer $$$x$$$ such that $$$x$$$ is not a divisor of $$$i$$$.Compute $$$\sum_{i=1}^n f(i)$$$ modulo $$$10^9+7$$$. In other words, compute $$$f(1)+f(2)+\dots+f(n)$$$ modulo $$$10^9+7$$$.","from math import gcd
import sys

input = sys.stdin.readline

for _ in range(int(input())):
    n = int(input())

    i, smallest_divisor, ans = 1, 1, n
    while n // i:
        i = i * smallest_divisor // gcd(i, smallest_divisor)
        ans += n // i
        smallest_divisor += 1
    print(ans % 1000000007)","['math', 'number theory']"
"There is an infinite set generated as follows:  $$$1$$$ is in this set.  If $$$x$$$ is in this set, $$$x \cdot a$$$ and $$$x+b$$$ both are in this set. For example, when $$$a=3$$$ and $$$b=6$$$, the five smallest elements of the set are:  $$$1$$$,  $$$3$$$ ($$$1$$$ is in this set, so $$$1\cdot a=3$$$ is in this set),  $$$7$$$ ($$$1$$$ is in this set, so $$$1+b=7$$$ is in this set),  $$$9$$$ ($$$3$$$ is in this set, so $$$3\cdot a=9$$$ is in this set),  $$$13$$$ ($$$7$$$ is in this set, so $$$7+b=13$$$ is in this set). Given positive integers $$$a$$$, $$$b$$$, $$$n$$$, determine if $$$n$$$ is in this set.","import sys
input=sys.stdin.readline
for _ in range(int(input())):
    n,a,b=map(int,input().split())
    d={}
    x=1 
    while True:
        x=x*a
        if x<=n and x!=1:
            d[x]=0
        else:
            break
    #print(d)
    y=0
    for k in d:
        y=1
        if (n%b==1) or ((n%b) in d) or ((n-k)%b==0) or b==1:
            print(""YES"")    
            break
    else:
        if y==0:
            if n%b==1 or b==1:
                print(""YES"")
            else:
                print(""NO"")
        

        else:
            print(""NO"")","['constructive algorithms', 'math', 'number theory']"
"This version of the problem differs from the previous one only in the constraint on $$$n$$$.A tree is a connected undirected graph without cycles. A weighted tree has a weight assigned to each edge. The distance between two vertices is the minimum sum of weights on the path connecting them.You are given a weighted tree with $$$n$$$ vertices, each edge has a weight of $$$1$$$. Denote $$$d(v)$$$ as the distance between vertex $$$1$$$ and vertex $$$v$$$.Let $$$f(x)$$$ be the minimum possible value of $$$\max\limits_{1 \leq v \leq n} \ {d(v)}$$$ if you can temporarily add an edge with weight $$$x$$$ between any two vertices $$$a$$$ and $$$b$$$ $$$(1 \le a, b \le n)$$$. Note that after this operation, the graph is no longer a tree.For each integer $$$x$$$ from $$$1$$$ to $$$n$$$, find $$$f(x)$$$.","# import sys
# I = lambda: [*map(int, sys.stdin.readline().split())]

import io,os
read = io.BytesIO(os.read(0, os.fstat(0).st_size))
I = lambda:map(int, read.readline().split())
 
def maxsparse(a):
	l = []
	l.append(a)
	c = 1
	while c < len(a):
		new = []
		for i in range(len(a)):
			if i + c < len(l[-1]):
				new.append(max(l[-1][i], l[-1][i + c]))
			else:
				break
		l.append(new)
		c *= 2
	return l
 
def partial(table, i, j):
	if j <= i:
		return -1000000
	yyy = 1
	aaa = 0
	while 2 * yyy <= j - i:
		yyy *= 2
		aaa += 1
	return max(table[aaa][i], table[aaa][j - yyy])
 
t, = I()
for _ in range(t):
    n, = I()
    graph = [[] for i in range(n)]
    for i in range(n - 1):
        a, b = I()
        graph[a - 1].append(b - 1)
        graph[b - 1].append(a - 1)
 
    parents = [None] * n
    parents[0] = -1
    children = [[] for i in range(n)]
    layer = [0]
    while layer:
        newlayer = []
        for guy in layer:
            for boi in graph[guy]:
                if parents[boi] is None:
                    newlayer.append(boi)
                    children[guy].append(boi)
                    parents[boi] = guy
        layer = newlayer
    parents[0] = None
    inds = [0] * n
    order = []
    curr = 0
    while curr is not None:
        if inds[curr] == len(children[curr]):
            order.append(curr)
            curr = parents[curr]
        else:
            inds[curr] += 1
            curr = children[curr][inds[curr] - 1]
 
    lowest = [0] * n
    for v in order:
        if children[v]:
            big = max(lowest[i] for i in children[v])
            lowest[v] = big + 1
 
    depth = lowest[0]
    path = [0]
    curr = 0
    while True:
        biggest = -1
        count = 0
        rep = None
        for child in children[curr]:
            if lowest[child] > biggest:
                biggest = lowest[child]
                count = 1
                rep = child
            elif lowest[child] == biggest:
                count += 1
        if count == 1:
            path.append(rep)
            curr = rep
        else:
            break
 
    other = [0] * len(path)
    for i in range(len(path) - 1):
        if len(children[path[i]]) == 1:
            other[i] = 0
        else:
            other[i] = max(lowest[j] for j in children[path[i]] if j != path[i + 1]) + 1
    other[-1] = lowest[path[-1]]
    bigs = [other[0]]
    for i in range(len(path) - 1):
        bigs.append(max(bigs[-1], other[i + 1] + i + 1))
    # print(path)
    # print(other)
    # print(bigs)
    # print(children)
    # print(parents)
    # print(lowest)
    xx = [other[i] - i for i in range(len(path))]
    sparse = maxsparse(xx)
 
    if len(path) == 1:
        out = [lowest[0]] * n
    else:
        out = []
        curr = 2
        currcost = -1
        for x in range(1, n + 1):
            if x >= len(path) - 1 or currcost >= lowest[0]:
                out.append(lowest[0])
                continue
            currcost = max(bigs[(x + curr) // 2], lowest[path[curr]] + x, partial(sparse, (x + curr) // 2 + 1, curr) + x + curr)
            while curr < len(path) - 1:
                #print(x, curr)
                nextcost = max(bigs[(x + curr + 1) // 2], lowest[path[curr + 1]] + x, partial(sparse, (x + curr + 1) // 2 + 1, curr + 1) + x + curr + 1)
                if nextcost < currcost:
                    curr += 1
                    currcost = nextcost
                else:
                    break
            out.append(currcost)
    print(*out)","['binary search', 'dfs and similar', 'shortest paths', 'trees']"
"Petya organized a strange birthday party. He invited $$$n$$$ friends and assigned an integer $$$k_i$$$ to the $$$i$$$-th of them. Now Petya would like to give a present to each of them. In the nearby shop there are $$$m$$$ unique presents available, the $$$j$$$-th present costs $$$c_j$$$ dollars ($$$1 \le c_1 \le c_2 \le \ldots \le c_m$$$). It's not allowed to buy a single present more than once.For the $$$i$$$-th friend Petya can either buy them a present $$$j \le k_i$$$, which costs $$$c_j$$$ dollars, or just give them $$$c_{k_i}$$$ dollars directly.Help Petya determine the minimum total cost of hosting his party.","for _ in range(int(input())):
    n,m=map(int,input().split())
    a=list(map(int,input().split()))
    b=list(map(int,input().split()))
    ans=0
    a.sort()
    x=0
    for i in range(n-1,-1,-1):
        if x>=m:
            x=m-1
        ans+=min(b[a[i]-1],b[x])
        x+=1
    print(ans)","['binary search', 'dp', 'greedy', 'sortings', 'two pointers']"
"Students of Winter Informatics School are going to live in a set of houses connected by underground passages. Teachers are also going to live in some of these houses, but they can not be accommodated randomly. For safety reasons, the following must hold:  All passages between two houses will be closed, if there are no teachers in both of them. All other passages will stay open.  It should be possible to travel between any two houses using the underground passages that are open.  Teachers should not live in houses, directly connected by a passage. Please help the organizers to choose the houses where teachers will live to satisfy the safety requirements or determine that it is impossible.","import sys
input=sys.stdin.buffer.readline
t=int(input())
for _ in range(t):
    n,m=map(int,input().split())
    g=[[] for i in range(n+1)]
    for __ in range(m):
        u,v=map(int,input().split())
        g[u].append(v)
        g[v].append(u)
    black=[-1 for i in range(n+1)]
    ans=[]
    path=[1]
    black[0]=2
    black[1]=1
    while path:
        x=path.pop()
        for y in g[x]:
            if black[x]==1:
                if black[y]==-1:
                    path.append(y)
                black[y]=0
            elif black[y]==-1:
                path.append(y)
                black[y]=1
    if -1 in black:
        print('NO')
        continue
    print('YES')
    for i in range(1,n+1):
        if black[i]==1:
            ans.append(i)
    print(len(ans))
    print("" "".join(str(i) for i in ans))","['constructive algorithms', 'dfs and similar', 'graph matchings', 'graphs', 'greedy']"
"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.He calls a number special if the minimum number of operations to reduce it to 1 is k.He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!Since the answer can be large, output it modulo 109 + 7.","dpc=[1]
dpci=[]
for i in range(1,2000):
    dpc.append((dpc[i-1]*i)%1000000007)
def modInverse(a, m) :
    m0 = m
    y = 0
    x = 1
    if (m == 1) :
        return 0
    while (a > 1) :
        q = a // m
        t = m
        m = a % m
        a = t
        t = y
        y = x - q * y
        x = t
    if (x < 0) :
        x = x + m0
    return x
for i in dpc:
    dpci.append(modInverse(i,1000000007))
def c(n,r):
    if(r<0):
        return 0
    if(n<r):
        return 0
    if(n<0):
        return 0
    return dpc[n]*dpci[r]*dpci[n-r]

dp={1:0}
def f(n):
    x=n
    b=0
    while x!=0:
        x=x&(x-1)
        b+=1
    dp[n]=dp[b]+1
for i in range(2,1001):
    f(i)
a=[[],[],[],[],[]]
for i in dp:
    a[dp[i]].append(i)
n=input()
l=len(n)
x=[]
for i in range(l):
    if n[i]=='1':
        x.append(i)
#print(l)
k=int(input())
if k>5:
    print(0)
elif k==0:
    print(1)
else:
    ans=0
    for i in a[k-1]:
        r=0
        for j in x:
            if i-r<0:
                break
            xy=c(l-j-1,i-r)
            #print(l-j-1,i-r,xy)
            ans=(ans+xy)%1000000007
            r+=1
    if len(x) in a[k-1] and len(x)!=1:
        ans+=1
    if len(x)>1 and k==1:
        ans-=1
    print(ans)","['dp', 'combinatorics', 'brute force']"
"Two T-shirt sizes are given: $$$a$$$ and $$$b$$$. The T-shirt size is either a string M or a string consisting of several (possibly zero) characters X and one of the characters S or L.For example, strings M, XXL, S, XXXXXXXS could be the size of some T-shirts. And the strings XM, LL, SX are not sizes.The letter M stands for medium, S for small, L for large. The letter X refers to the degree of size (from eXtra). For example, XXL is extra-extra-large (bigger than XL, and smaller than XXXL).You need to compare two given sizes of T-shirts $$$a$$$ and $$$b$$$.The T-shirts are compared as follows:   any small size (no matter how many letters X) is smaller than the medium size and any large size;  any large size (regardless of the number of letters X) is larger than the medium size and any small size;  the more letters X before S, the smaller the size;  the more letters X in front of L, the larger the size. For example:   XXXS &lt; XS  XXXL &gt; XL  XL &gt; M  XXL = XXL  XXXXXS &lt; M  XL &gt; XXXS","x = int(input())
list1 = []
if x in range(1, 10 ** 4+1):
	z = 0
	while z < x:
		a, b = map(str, input().split())
		a = a.upper()
		b = b.upper()
		if len(a) <= 50 and len(b) <= 50:
			if a == b:
				list1.append(""="")
			else:
				if len(a) == 1 and len(b) == 1 and a != b:
					if a == ""L"" and (b == ""M"" or ""S""):
						list1.append("">"")

					elif a == ""S"" and (b == ""L"" or ""M""):
						list1.append(""<"")

					elif a == ""M"":
						if b == ""L"":
							list1.append(""<"")


						elif b == ""S"":
							list1.append("">"")


				else:
					for i in a:
						if i == ""M"":
							for i in b:
								if i == ""S"":
									list1.append("">"")
									break
								elif i == ""L"":
									list1.append(""<"")
									break
								elif i == ""M"":
									if len(a) > len(b):
										list1.append("">"")
										break
									elif len(a) < len(b):
										list1.append(""<"")
										break
						elif i == ""L"":
							for i in b:
								if i == ""L"":
									if len(a) > len(b):
										list1.append("">"")
										break
									elif len(a) < len(b):
										list1.append(""<"")
										break
							else:
								list1.append("">"")
								break
						elif i == ""S"":
							for i in b:
								if i == ""L"":
									list1.append(""<"")
									break
								elif i == ""M"":
									list1.append(""<"")
									break
								elif i == ""S"":
									if len(a) > len(b):
										list1.append(""<"")
										break
									else:
										list1.append("">"")
										break

		z += 1
	for b in list1:
		print(b)
# ابلع accepted","['implementation', 'implementation', 'strings']"
"Kirill lives on a connected undirected graph of $$$n$$$ vertices and $$$m$$$ edges at vertex $$$1$$$. One fine evening he gathered $$$f$$$ friends, the $$$i$$$-th friend lives at the vertex $$$h_i$$$. So all friends are now in the vertex $$$1$$$, the $$$i$$$-th friend must get to his home to the vertex $$$h_i$$$.The evening is about to end and it is time to leave. It turned out that $$$k$$$ ($$$k \le 6$$$) of his friends have no cars, and they would have to walk if no one gives them a ride. One friend with a car can give a ride to any number of friends without cars, but only if he can give them a ride by driving along one of the shortest paths to his house.For example, in the graph below, a friend from vertex $$$h_i=5$$$ can give a ride to friends from the following sets of vertices: $$$[2, 3]$$$, $$$[2, 4]$$$, $$$[2]$$$, $$$[3]$$$, $$$[4]$$$, but can't give a ride to friend from vertex $$$6$$$ or a set $$$[3, 4]$$$.    The vertices where friends without cars live are highlighted in green, and with cars — in red. Kirill wants as few friends as possible to have to walk. Help him find the minimum possible number.","from collections import deque
 
 
def solve():
    n, m = map(int, input().split())
    sl = [[] for _ in range(n)]
    for _ in range(m):
        u, v = map(int, input().split())
        u -= 1
        v -= 1
        sl[u] += [v]
        sl[v] += [u]
    f = int(input())
    h = [int(x) - 1 for x in input().split()]
    mask = [0] * n
    k = int(input())
    p = [int(x) - 1 for x in input().split()] + [-1]
    for i in range(k):
        mask[h[p[i]]] += 1 << i
    vars = [set() for _ in range(n)]
    dist = [-1] * n
    dist[0] = 0
    vars[0].add(mask[0])
    q = deque([0])
    while len(q) > 0:
        v = q.popleft()
        for u in sl[v]:
            if dist[u] == -1:
                dist[u] = dist[v] + 1
                q.append(u)
            if dist[u] == dist[v] + 1:
                for msk in vars[v]:
                    vars[u].add(msk | mask[u])
    backpack = [False] * (1 << k)
    backpack[0] = True
    j = 0
    for i in range(f):
        if i == p[j]:
            j += 1
            continue
        nw = backpack.copy()
        for msk in range(1 << k):
            if not backpack[msk]:
                continue
            for var in vars[h[i]]:
                nw[msk | var] = True
        backpack = nw
    mn = k
    for msk in range(1 << k):
        if not backpack[msk]:
            continue
        ans = 0
        for b in range(k):
            if msk & (1 << b) == 0:
                ans += 1
        mn = min(mn, ans)
    print(mn)
 
 
t = int(input())
for _ in range(t):
    solve()","['bitmasks', 'brute force', 'dfs and similar', 'dp', 'flows', 'graphs', 'shortest paths']"
"Dmitry has $$$n$$$ segments of different colors on the coordinate axis $$$Ox$$$. Each segment is characterized by three integers $$$l_i$$$, $$$r_i$$$ and $$$c_i$$$ ($$$1 \le l_i \le r_i \le 10^9, 1 \le c_i \le n$$$), where $$$l_i$$$ and $$$r_i$$$ are are the coordinates of the ends of the $$$i$$$-th segment, and $$$c_i$$$ is its color.Dmitry likes to find the minimum distances between segments. However, he considers pairs of segments of the same color uninteresting. Therefore, he wants to know for each segment the distance from this segment to the nearest differently colored segment.The distance between two segments is the minimum of the distances between a point of the first segment and a point of the second segment. In particular, if the segments intersect, then the distance between them is equal to $$$0$$$.For example, Dmitry has $$$5$$$ segments:     The first segment intersects with the second (and these are segments of different colors), so the answers for them are equal to $$$0$$$.  For the $$$3$$$-rd segment, the nearest segment of a different color is the $$$2$$$-nd segment, the distance to which is equal to $$$2$$$.  For the $$$4$$$-th segment, the nearest segment of a different color is the $$$5$$$-th segment, the distance to which is equal to $$$1$$$.  The $$$5$$$-th segment lies inside the $$$2$$$-nd segment (and these are segments of different colors), so the answers for them are equal to $$$0$$$.","t = int(input())
def dist(i,j):
    if i >= j:
        return 0
    else:
        return j-i

while t > 0:
    n = int(input())
    seg = []
    for i in range(n):
        seg.append(list(map(int,input().split()))+[i+1])
    seg.sort(key=lambda x:(x[0],x[1]))
    color = {}
    i = 0
    while i < n:
        if seg[i][2] in color:
            if seg[i][2] == seg[i-1][2]:
                j = i
                while j < n-1 and seg[j][2] == seg[j+1][2]:
                    j = j + 1
                color[seg[i][2]][-1][1] = j+1
                for k in range(i,j+1):
                    color[seg[i][2]].append([k,j+1])
                i = j+1
                continue
            else:
                color[seg[i][2]].append([i,i+1])
                i = i + 1
        else:
            color[seg[i][2]] = [[i,i+1],]
            i = i + 1
    mindis= [1000000000]*(n+1)
    signal = [0]*(n+1)
    nowmaxj = [[0,0],[0,0]]
    i = 0
    while i < n:
        nowcolor = seg[i][2]
        u = signal[nowcolor]
        end = color[nowcolor][u][1]
        signal[nowcolor] += end - i
        maxj = 0
        if end != n:
            for j in range(i,end):
                maxj = max(maxj,seg[j][1])
                mindis[seg[j][3]] = min(mindis[seg[j][3]],dist(seg[j][1],seg[end][0]))
                for k in range(2):
                    if nowmaxj[k][1] != 0 and nowmaxj[k][1] != nowcolor:
                        mindis[seg[j][3]] = min(mindis[seg[j][3]],dist(nowmaxj[k][0],seg[j][0]))
        else:
            for j in range(i,end):
                for k in range(2):
                    if nowmaxj[k][1] != 0 and nowmaxj[k][1] != nowcolor:
                        mindis[seg[j][3]] = min(mindis[seg[j][3]],dist(nowmaxj[k][0],seg[j][0]))
            break
        if maxj > nowmaxj[0][0]:
            if nowmaxj[0][1] == nowcolor:
                nowmaxj[0][0] = maxj
            else:
                nowmaxj[1][0] = nowmaxj[0][0]
                nowmaxj[1][1] = nowmaxj[0][1]
                nowmaxj[0] = [maxj,nowcolor]
        elif maxj > nowmaxj[1][0]:
            if nowcolor != nowmaxj[0][1]:
                nowmaxj[1] = [maxj,nowcolor]
        i = end

    print("" "".join(map(str,mindis[1:])))
    t = t - 1","['binary search', 'data structures', 'math', 'sortings']"
"There are $$$n$$$ candies put from left to right on a table. The candies are numbered from left to right. The $$$i$$$-th candy has weight $$$w_i$$$. Alice and Bob eat candies. Alice can eat any number of candies from the left (she can't skip candies, she eats them in a row). Bob can eat any number of candies from the right (he can't skip candies, he eats them in a row). Of course, if Alice ate a candy, Bob can't eat it (and vice versa).They want to be fair. Their goal is to eat the same total weight of candies. What is the most number of candies they can eat in total?","for _ in range(int(input())):
    n = int(input())
    arr = list(map(int,input().split()))
    suml = sumr = 0
    l, r = -1, n
    ans = 0
    while l < r:
        if suml < sumr:
            l += 1
            suml += arr[l]
        elif suml > sumr:
            r -= 1
            sumr += arr[r]
        else:
            ans = (l + 1) + (n - r)
            l += 1
            suml += arr[l]
    print(ans)","['binary search', 'data structures', 'greedy', 'two pointers']"
"There is a grid with $$$n$$$ rows and $$$m$$$ columns, and three types of cells:   An empty cell, denoted with '.'.  A stone, denoted with '*'.  An obstacle, denoted with the lowercase Latin letter 'o'. All stones fall down until they meet the floor (the bottom row), an obstacle, or other stone which is already immovable. (In other words, all the stones just fall down as long as they can fall.)Simulate the process. What does the resulting grid look like?","t = int(input())

for i in range(t):
    rc = input().split("" "")
    rows = int(rc[0])
    columns = int(rc[1])
    arr = []
    for j in range(rows):
        data = input()
        for k in range(columns):
            arr.append(data[k])

    skipped = [0]*columns

    for j in range(columns):
        k = rows*columns - 1 - j
        l = k - columns
        while(l >= 0):
            if(arr[k] == ""*"" or arr[k] == ""o""):
                k = k - columns
            elif(arr[l] == ""*"" and arr[k] == "".""):
                arr[k] = ""*""
                arr[l] = "".""
                k = k - columns
            elif(arr[l] == ""o""):
                k = l - columns
                l = l - columns
            l = l - columns
            
    print()

    for j in range(len(arr)):
        if(j%columns == (columns-1)):
            print(arr[j])
        else:
            print(arr[j], end="""")","['dfs and similar', 'implementation']"
"Given $$$n$$$ strings, each of length $$$2$$$, consisting of lowercase Latin alphabet letters from 'a' to 'k', output the number of pairs of indices $$$(i, j)$$$ such that $$$i &lt; j$$$ and the $$$i$$$-th string and the $$$j$$$-th string differ in exactly one position.In other words, count the number of pairs $$$(i, j)$$$ ($$$i &lt; j$$$) such that the $$$i$$$-th string and the $$$j$$$-th string have exactly one position $$$p$$$ ($$$1 \leq p \leq 2$$$) such that $$${s_{i}}_{p} \neq {s_{j}}_{p}$$$.The answer may not fit into 32-bit integer type, so you should use 64-bit integers like long long in C++ to avoid integer overflow.","from collections import Counter


for cases in range(int(input())):
    n=int(input())
    ls=[]
    k=0
    for i in range(n):
        ls.append(input())
    t=Counter (ls)  
    s=list(set(ls))
    for i in range(0,len(s)-1):
        for j in range(i+1,len(s)):
            if(s[i]!=s[j] and(s[i][0]==s[j][0] or s[i][1]==s[j][1])):
                k+=t[s[i]]*t[s[j]]        

    print(k)","['data structures', 'math', 'strings']"
"A row of $$$n$$$ cells is given, all initially white. Using a stamp, you can stamp any two neighboring cells such that one becomes red and the other becomes blue. A stamp can be rotated, i.e. it can be used in both ways: as $$$\color{blue}{\texttt{B}}\color{red}{\texttt{R}}$$$ and as $$$\color{red}{\texttt{R}}\color{blue}{\texttt{B}}$$$.During use, the stamp must completely fit on the given $$$n$$$ cells (it cannot be partially outside the cells). The stamp can be applied multiple times to the same cell. Each usage of the stamp recolors both cells that are under the stamp.For example, one possible sequence of stamps to make the picture $$$\color{blue}{\texttt{B}}\color{red}{\texttt{R}}\color{blue}{\texttt{B}}\color{blue}{\texttt{B}}\texttt{W}$$$ could be $$$\texttt{WWWWW} \to \texttt{WW}\color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}}\texttt{W} \to \color{brown}{\underline{\color{blue}{\texttt{B}}\color{red}{\texttt{R}}}}\color{red}{\texttt{R}}\color{blue}{\texttt{B}}\texttt{W} \to \color{blue}{\texttt{B}}\color{brown}{\underline{\color{red}{\texttt{R}}\color{blue}{\texttt{B}}}}\color{blue}{\texttt{B}}\texttt{W}$$$. Here $$$\texttt{W}$$$, $$$\color{red}{\texttt{R}}$$$, and $$$\color{blue}{\texttt{B}}$$$ represent a white, red, or blue cell, respectively, and the cells that the stamp is used on are marked with an underline.Given a final picture, is it possible to make it using the stamp zero or more times?","def check(str_s):
    for s in str_s:
        if(len(s) == 0):
            continue
        if(len(s) == 1 or (len(s) == s.count(""R"")) or (len(s) == s.count(""B""))):
            print(""no"")
            return
        # else:
        #     for i in range(len(s)-1):
        #         j = i+1
        #         while(j < len(s) and s[i] == s[j]):
        #             j += 1
        #         if(j >= len(s) and i == 0):
        #             print(""no"")
        #             return
        #         i = j
    print(""yes"")
    return



t = int(input())

for i in range(t):
    n = input()
    str_s = input().split(""W"")
    check(str_s)",['implementation']
"Right before the UEFA Euro 2020, AmShZ and Safar placed bets on who'd be the champion, AmShZ betting on Italy, and Safar betting on France.Of course, AmShZ won. Hence, Safar gave him a bracket sequence $$$S$$$. Note that a bracket sequence is a string made of '(' and ')' characters.AmShZ can perform the following operation any number of times:  First, he cuts his string $$$S$$$ into three (possibly empty) contiguous substrings $$$A, B$$$ and $$$C$$$. Then, he glues them back by using a '(' and a ')' characters, resulting in a new string $$$S$$$ = $$$A$$$ + ""("" + $$$B$$$ + "")"" + $$$C$$$.For example, if $$$S$$$ = ""))(("" and AmShZ cuts it into $$$A$$$ = """", $$$B$$$ = ""))"", and $$$C$$$ = ""(("", He will obtain $$$S$$$ = ""()))(("" as a new string. After performing some (possibly none) operations, AmShZ gives his string to Keshi and asks him to find the initial string. Of course, Keshi might be able to come up with more than one possible initial string. Keshi is interested in finding the lexicographically smallest possible initial string.Your task is to help Keshi in achieving his goal.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds: $$$a$$$ is a prefix of $$$b$$$, but $$$a \ne b$$$; in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$.","import sys
raw_input = iter(sys.stdin.read().splitlines()).next

def lexicographical_compare(s, nxt, i, j):
    u, v = i, j
    while u < j and v < len(s) and s[u] == s[v]:
        u, v = nxt[u+1], nxt[v+1]
    return s[u] <= s[v] if u < len(s) and v < len(s) else u == len(s) and v < len(s)

def solution():
    s = raw_input().strip()
    stk, nxt = [len(s)], range(len(s)+1)
    for i in reversed(xrange(len(s))):
        if s[i] == ')':
            stk.append(i)
            continue
        stk.pop()
        if not stk:
            stk.append(i)
        elif lexicographical_compare(s, nxt, i, stk[-1]):
            stk[-1] = i
        else:
            nxt[i] = stk[-1]
    result = []
    while i < len(s):
        result.append(s[i])
        i = nxt[i+1]
    return """".join(result)

print '%s' % solution()","['data structures', 'greedy', 'hashing']"
"After watching the new over-rated series Squid Game, Mashtali and Soroush decided to hold their own Squid Games! Soroush agreed to be the host and will provide money for the winner's prize, and Mashtali became the Front Man!$$$m$$$ players registered to play in the games to win the great prize, but when Mashtali found out how huge the winner's prize is going to be, he decided to kill eliminate all the players so he could take the money for himself!Here is how evil Mashtali is going to eliminate players:There is an unrooted tree with $$$n$$$ vertices. Every player has $$$2$$$ special vertices $$$x_i$$$ and $$$y_i$$$.In one operation, Mashtali can choose any vertex $$$v$$$ of the tree. Then, for each remaining player $$$i$$$ he finds a vertex $$$w$$$ on the simple path from $$$x_i$$$ to $$$y_i$$$, which is the closest to $$$v$$$. If $$$w\ne x_i$$$ and $$$w\ne y_i$$$, player $$$i$$$ will be eliminated.Now Mashtali wondered: ""What is the minimum number of operations I should perform so that I can remove every player from the game and take the money for myself?""Since he was only thinking about the money, he couldn't solve the problem by himself and asked for your help!","import sys
raw_input = iter(sys.stdin.read().splitlines()).next

def iter_dfs(adj):
    L, R, D = [[1]*(len(adj)) for _ in xrange(3)]
    cnt = -1
    stk = [(1, ROOT)]
    while stk:
        step, i = stk.pop()
        if step == 1:
            stk.append((2, i))
            cnt += 1
            L[i] = cnt
            for j in reversed(adj[i]):
                D[j] = D[i]+1
                stk.append((1, j))
        elif step == 2:
            R[i] = cnt
    return L, R, D

def iter_dfs2(adj, up, D):
    dp, dp2 = [[0]*(len(adj)) for _ in xrange(2)]
    stk = [(1, ROOT)]
    while stk:
        step, i = stk.pop()
        if step == 1:
            stk.append((2, i))
            for j in reversed(adj[i]):
                stk.append((1, j))
        elif step == 2:
            for j in adj[i]:
                if not dp[j]:
                    if not dp[i]:
                        dp2[i] = max(dp2[i], dp2[j], up[j])
                    continue
                dp2[i] = max(dp2[j], up[j]) if not dp[i] else 0
                dp[i] += dp[j]
            if dp2[i] == D[i]:
                dp2[i] = 0
                dp[i] += 1
    return dp

def solution():
    n, m = map(int, raw_input().strip().split())
    par = map(int, raw_input().strip().split())
    adj = [[] for _ in xrange(n)]
    for i, p in enumerate(par, 1):
        adj[p-1].append(i)
    L, R, D = iter_dfs(adj)
    up, cross = [0]*n, []
    for _ in xrange(m):
        x, y = map(int, raw_input().strip().split())
        x, y = x-1, y-1
        if L[x] > L[y]:
            x, y = y, x
        if R[y] <= R[x]:
            if D[y] == D[x]+1:
                return -1
            up[y] = max(up[y], D[x]+1)
        else:
            cross.append((x, y))
    dp = iter_dfs2(adj, up, D)
    return dp[ROOT]+ any(dp[x]+dp[y] == dp[ROOT] for x, y in cross)

ROOT = 0
print '%s' % solution()","['data structures', 'dfs and similar', 'greedy', 'trees']"
"$$$2^k$$$ teams participate in a playoff tournament. The tournament consists of $$$2^k - 1$$$ games. They are held as follows: first of all, the teams are split into pairs: team $$$1$$$ plays against team $$$2$$$, team $$$3$$$ plays against team $$$4$$$ (exactly in this order), and so on (so, $$$2^{k-1}$$$ games are played in that phase). When a team loses a game, it is eliminated, and each game results in elimination of one team (there are no ties). After that, only $$$2^{k-1}$$$ teams remain. If only one team remains, it is declared the champion; otherwise, $$$2^{k-2}$$$ games are played: in the first one of them, the winner of the game ""$$$1$$$ vs $$$2$$$"" plays against the winner of the game ""$$$3$$$ vs $$$4$$$"", then the winner of the game ""$$$5$$$ vs $$$6$$$"" plays against the winner of the game ""$$$7$$$ vs $$$8$$$"", and so on. This process repeats until only one team remains.For example, this picture describes the chronological order of games with $$$k = 3$$$:  Let the string $$$s$$$ consisting of $$$2^k - 1$$$ characters describe the results of the games in chronological order as follows:  if $$$s_i$$$ is 0, then the team with lower index wins the $$$i$$$-th game;  if $$$s_i$$$ is 1, then the team with greater index wins the $$$i$$$-th game;  if $$$s_i$$$ is ?, then the result of the $$$i$$$-th game is unknown (any team could win this game). Let $$$f(s)$$$ be the number of possible winners of the tournament described by the string $$$s$$$. A team $$$i$$$ is a possible winner of the tournament if it is possible to replace every ? with either 1 or 0 in such a way that team $$$i$$$ is the champion.You are given the initial state of the string $$$s$$$. You have to process $$$q$$$ queries of the following form:   $$$p$$$ $$$c$$$ — replace $$$s_p$$$ with character $$$c$$$, and print $$$f(s)$$$ as the result of the query.","import sys


def upd(ix, cur):
    if s[ix] == '?':
        tree[cur] = tree[cur << 1] + tree[(cur << 1) + 1]
    else:
        tree[cur] = tree[(cur << 1) + (int(s[ix]) ^ 1)]


input = lambda: sys.stdin.buffer.readline().decode().strip()
ispow2 = lambda x: x and (not (x & (x - 1)))
k, s = int(input()), list(input())
tree, n, out = [1] * (1 << (k + 1)), len(s), []

for i in range(len(s)):
    cur = n - i
    upd(i, cur)

for i in range(int(input())):
    ix, ch = input().split()
    ix = int(ix) - 1
    cur, s[ix] = n - ix, ch

    while cur:
        upd(ix, cur)
        cur >>= 1
        ix = n - cur
    out.append(tree[1])
print('\n'.join(map(str, out)))","['data structures', 'dfs and similar', 'dp', 'implementation', 'trees']"
"The derby between Milan and Inter is happening soon, and you have been chosen as the assistant referee for the match, also known as linesman. Your task is to move along the touch-line, namely the side of the field, always looking very carefully at the match to check for offside positions and other offences.Football is an extremely serious matter in Italy, and thus it is fundamental that you keep very close track of the ball for as much time as possible. This means that you want to maximise the number of kicks which you monitor closely. You are able to monitor closely a kick if, when it happens, you are in the position along the touch-line with minimum distance from the place where the kick happens.Fortunately, expert analysts have been able to accurately predict all the kicks which will occur during the game. That is, you have been given two lists of integers, $$$t_1, \ldots, t_n$$$ and $$$a_1, \ldots, a_n$$$, indicating that $$$t_i$$$ seconds after the beginning of the match the ball will be kicked and you can monitor closely such kick if you are at the position $$$a_i$$$ along the touch-line. At the beginning of the game you start at position $$$0$$$ and the maximum speed at which you can walk along the touch-line is $$$v$$$ units per second (i.e., you can change your position by at most $$$v$$$ each second). What is the maximum number of kicks that you can monitor closely?","from bisect import bisect_right,bisect_left
n,v = map(int,input().split())
t = [*map(int,input().split())]
a = [*map(int,input().split())]
res = []
for i in range(n):
    xi,yi = t[i]*v+a[i],t[i]*v-a[i]
    if(xi>=0 and yi>=0):
        res.append((xi,yi))
res.sort()
dp = [float(""inf"")]*(n+3)
dp[0] = 0
dp[n+2] = 0
for i in range(len(res)):
    pos = bisect_right(dp,res[i][1],0,n+2)
    dp[pos] = res[i][1]
for i in range(n,-1,-1):
    if(dp[i]!=float(""inf"")):
        print(i)
        break","['data structures', 'dp', 'math']"
"This is the easy version of the problem. The only difference between the easy and the hard versions are removal queries, they are present only in the hard version.""Interplanetary Software, Inc."" together with ""Robots of Cydonia, Ltd."" has developed and released robot cats. These electronic pets can meow, catch mice and entertain the owner in various ways.The developers from ""Interplanetary Software, Inc."" have recently decided to release a software update for these robots. After the update, the cats must solve the problems about bracket sequences. One of the problems is described below.  First, we need to learn a bit of bracket sequence theory. Consider the strings that contain characters ""("", "")"" and ""."". Call a string regular bracket sequence (RBS), if it can be transformed to an empty string by one or more operations of removing either single ""."" characters, or a continuous substring ""()"". For instance, the string ""(()(.))"" is an RBS, as it can be transformed to an empty string with the following sequence of removals: ""(()(.))"" $$$\rightarrow$$$ ""(()())"" $$$\rightarrow$$$ ""(())"" $$$\rightarrow$$$ ""()"" $$$\rightarrow$$$ """". We got an empty string, so the initial string was an RBS. At the same time, the string "")("" is not an RBS, as it is not possible to apply such removal operations to it.An RBS is simple if this RBS is not empty, doesn't start with ""."", and doesn't end with ""."".Denote the substring of the string $$$s$$$ as its sequential subsegment. In particular, $$$s[l\dots r] = s_ls_{l+1}\dots s_r$$$, where $$$s_i$$$ is the $$$i$$$-th character of the string $$$s$$$.Now, move on to the problem statement itself. You are given a string $$$s$$$, initially consisting of characters ""("" and "")"". You need to answer the queries of the following kind.Given two indices, $$$l$$$ and $$$r$$$ ($$$1 \le l &lt; r \le n$$$), and it's guaranteed that the substring $$$s[l\dots r]$$$ is a simple RBS. You need to find the number of substrings in $$$s[l\dots r]$$$ such that they are simple RBS. In other words, find the number of index pairs $$$i$$$, $$$j$$$ such that $$$l \le i &lt; j \le r$$$ and $$$s[i\dots j]$$$ is a simple RBS.You are an employee in ""Interplanetary Software, Inc."" and you were given the task to teach the cats to solve the problem above, after the update.Note that the ""."" character cannot appear in the string in this version of the problem. It is only needed for the hard version.","''' E1. Cats on the Upgrade (easy version)
https://codeforces.com/contest/1625/problem/E1
'''

import io, os, sys

input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str
output = sys.stdout.write

DEBUG = os.environ.get('debug') not in [None, '0']

if DEBUG:
    from inspect import currentframe, getframeinfo
    from re import search

def debug(*args):
    if not DEBUG: return
    frame = currentframe().f_back
    s = getframeinfo(frame).code_context[0]
    r = search(r""\((.*)\)"", s).group(1)
    vnames = r.split(', ')
    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]
    prefix = f'{currentframe().f_back.f_lineno:02d}: '
    print(f'{prefix}{"", "".join(var_and_vals)}')


INF = float('inf')

# -----------------------------------------
from typing import List

class SegmentTreeInfo:
    def __init__(self, parent=INF, sum=0, cnt=0): 
        self.parent = parent
        self.sum = sum
        self.cnt = cnt

    def __add__(self, other): 
        res = SegmentTreeInfo()
        res.sum = self.sum + other.sum
        if self.parent < other.parent: res.parent, res.cnt = self.parent, self.cnt
        elif self.parent > other.parent: res.parent, res.cnt = other.parent, other.cnt
        else: res.parent, res.cnt = self.parent, self.cnt + other.cnt
        return res
    
    def __repr__(self):
        return f'SegmentTreeInfo(parent={self.parent},sum={self.sum},cnt={self.cnt})'


class SegmentTree:
    def __init__(self, N: int = 0, init_arr: List[SegmentTreeInfo] = None) -> None:
        '''init segtree intervals, optionally with data'''
        assert (N == 0) ^ (init_arr is None), f'Must set either N or init_arr'
        if N == 0: N = len(init_arr)

        def _build(p: int, lo: int, hi: int) -> None:
            if lo == hi: 
                if init_arr: self.arr[p] = init_arr[lo]
            else:
                mi = (lo+hi) // 2
                _build(2*p+1, lo, mi)
                _build(2*p+2, mi+1, hi)

        self.N = N
        self.tree = [SegmentTreeInfo() for _ in range(1 << (N.bit_length() + 1))]
        _build(0, 0, N-1)

    def query(self, qlo: int, qhi: int, p: int = 0, lo: int = 0, hi: int = -1) -> SegmentTreeInfo:
        '''range query qlo..qhi intersect self.lo..self.hi (default entire tree)'''
        if hi == -1: hi = self.N - 1
        if qlo > hi or qhi < lo: return SegmentTreeInfo()
        if qlo <= lo <= hi <= qhi: return self.tree[p]
        mi = (lo+hi) // 2
        left = self.query(qlo, qhi, 2*p+1, lo, mi)
        right = self.query(qlo, qhi, 2*p+2, mi+1, hi)
        return left + right

    def update(self, qi: int, v: SegmentTreeInfo, p: int = 0, lo: int = 0, hi: int = -1):
        '''update this segment and children when data[qi]=v'''
        if hi == -1: hi = self.N - 1
        if qi < lo or qi > hi: return
        if lo == hi: self.tree[p] = v
        elif lo < hi:
            mi = (lo+hi) // 2
            self.update(qi, v, 2*p+1, lo, mi)
            self.update(qi, v, 2*p+2, mi+1, hi)
            self.tree[p] = self.tree[2*p+1] + self.tree[2*p+2]


def solve():
    N, Q = map(int, input().split())
    S = input().decode().strip()

    # build bracket tree: go down 1 level for (, up for )
    # each vertex is a RBS
    # par[i] = index of parent ( for S[i] = (; might be set when bracket invalid
    # match[i] = index of matching bracket of S[i]; only set when bracket valid
    par = [-1] * N
    match = [-1] * N
    stack = []
    for i, c in enumerate(S):
        if c == '(':
            stack.append(i)
        elif stack:  # ignore unmatched brackets
            j = stack.pop()
            match[i], match[j] = j, i
            if j > 0:
                if S[j-1] == '(': par[j] = j-1                    # parent and child
                elif match[j-1] != -1: par[j] = par[match[j-1]]   # siblings
    
    # count num children
    deg = [0] * N
    for i in range(N):
        if par[i] != -1:  # valid, non-root open
            deg[par[i]] += 1

    # segtree data = (par idx, num RBS entirely under a child, num children)
    segtree = SegmentTree(N)
    for i in range(N):
        if i < match[i]:  # valid open
            segtree.update(i, SegmentTreeInfo(par[i], deg[i] * (deg[i] + 1) // 2, 1))

    # segtree.query(l, r) = num RBS within S[l..r]
    res = []
    for _ in range(Q):
        _, l, r = map(int, input().split())
        v = segtree.query(l-1, r-1)
        res.append(v.sum + v.cnt * (v.cnt + 1) // 2)
    
    print('\n'.join(map(str, res)))


if __name__ == '__main__':
    solve()","['brute force', 'data structures', 'dfs and similar', 'divide and conquer', 'dp', 'graphs', 'trees']"
"The only difference between the easy and hard versions is that the given string $$$s$$$ in the easy version is initially a palindrome, this condition is not always true for the hard version.A palindrome is a string that reads the same left to right and right to left. For example, ""101101"" is a palindrome, while ""0101"" is not.Alice and Bob are playing a game on a string $$$s$$$ of length $$$n$$$ consisting of the characters '0' and '1'. Both players take alternate turns with Alice going first.In each turn, the player can perform one of the following operations:   Choose any $$$i$$$ ($$$1 \le i \le n$$$), where $$$s[i] =$$$ '0' and change $$$s[i]$$$ to '1'. Pay 1 dollar.  Reverse the whole string, pay 0 dollars. This operation is only allowed if the string is currently not a palindrome, and the last operation was not reverse. That is, if Alice reverses the string, then Bob can't reverse in the next move, and vice versa. Reversing a string means reordering its letters from the last to the first. For example, ""01001"" becomes ""10010"" after reversing.The game ends when every character of string becomes '1'. The player who spends minimum dollars till this point wins the game and it is a draw if both spend equal dollars. If both players play optimally, output whether Alice wins, Bob wins, or if it is a draw.","import os,sys
from random import randint
from io import BytesIO, IOBase

from collections import defaultdict,deque,Counter
from bisect import bisect_left,bisect_right
from heapq import heappush,heappop
from functools import lru_cache
from itertools import accumulate
import math

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))

# for _ in range(int(input())):
#     n = int(input())
#     l = len(str(bin(n)[2:]))
#     print(pow(2, l - 1) - 1)

# for _ in range(int(input())):
#     n = int(input())
#     s = input()
#     cnt = s.count('0')
#     if cnt == 1 or cnt % 2 == 0:
#         print('BOB')
#     else:
#         print('ALICE')

for _ in range(int(input())):
    n = int(input())
    s = input()
    cnt = cntp = 0
    for i in range(n // 2):
        if s[i] == '1' and s[n - 1 - i] == '0':
            cnt += 1
        elif s[i] == '0' and s[n - 1 - i] == '1':
            cnt += 1
        elif s[i] == s[n - 1 - i] == '0':
            cntp += 2
    
    if cnt == 0:
        cnt = s.count('0')
        if cnt == 1 or cnt % 2 == 0:
            print('BOB')
        else:
            print('ALICE')
    else:
        if n % 2 == 0 or (n % 2 and s[n // 2] == '1'):
            print('ALICE')
        else:
            if cnt == 1 and cntp == 0:
                print('DRAW')
            else:
                print('ALICE')","['constructive algorithms', 'games']"
"On a weekend, Qingshan suggests that she and her friend Daniel go hiking. Unfortunately, they are busy high school students, so they can only go hiking on scratch paper.A permutation $$$p$$$ is written from left to right on the paper. First Qingshan chooses an integer index $$$x$$$ ($$$1\le x\le n$$$) and tells it to Daniel. After that, Daniel chooses another integer index $$$y$$$ ($$$1\le y\le n$$$, $$$y \ne x$$$).The game progresses turn by turn and as usual, Qingshan moves first. The rules follow:   If it is Qingshan's turn, Qingshan must change $$$x$$$ to such an index $$$x'$$$ that $$$1\le x'\le n$$$, $$$|x'-x|=1$$$, $$$x'\ne y$$$, and $$$p_{x'}&lt;p_x$$$ at the same time.  If it is Daniel's turn, Daniel must change $$$y$$$ to such an index $$$y'$$$ that $$$1\le y'\le n$$$, $$$|y'-y|=1$$$, $$$y'\ne x$$$, and $$$p_{y'}&gt;p_y$$$ at the same time. The person who can't make her or his move loses, and the other wins. You, as Qingshan's fan, are asked to calculate the number of possible $$$x$$$ to make Qingshan win in the case both players play optimally.","n = int(input())
a = [int(i) for i in input().split()]
r = []
cur = 0
i = 0
while n != i + 1:
    while n != i + 1 and a[i] < a[i + 1]:
        i += 1
        cur += 1
    r.append(cur + 1)
    cur = 1
    while n != i + 1 and a[i] > a[i + 1]:
        i += 1
        cur += 1
    r.append(cur)
    cur = 0
t = max(r)
if t % 2 == 0:
    print(0)
    exit()
ans = 0
fl = False
for i in range(0, len(r), 2):
    if (r[i] == t and r[i + 1] == t) and not fl:
        ans += 1
    elif fl and r[i] == t or r[i+1] == t:
        print(0)
        exit()
    if r[i] == t or r[i+1] == t:
        fl = True
print(ans)","['games', 'greedy']"
"Diamond Miner is a game that is similar to Gold Miner, but there are $$$n$$$ miners instead of $$$1$$$ in this game.The mining area can be described as a plane. The $$$n$$$ miners can be regarded as $$$n$$$ points on the y-axis. There are $$$n$$$ diamond mines in the mining area. We can regard them as $$$n$$$ points on the x-axis. For some reason, no miners or diamond mines can be at the origin (point $$$(0, 0)$$$). Every miner should mine exactly one diamond mine. Every miner has a hook, which can be used to mine a diamond mine. If a miner at the point $$$(a,b)$$$ uses his hook to mine a diamond mine at the point $$$(c,d)$$$, he will spend $$$\sqrt{(a-c)^2+(b-d)^2}$$$ energy to mine it (the distance between these points). The miners can't move or help each other.The object of this game is to minimize the sum of the energy that miners spend. Can you find this minimum?","mas = list(map(int, input().split()))
t = mas[0]
for j in range(t):
    
    mas = list(map(int, input().split()))
    n = mas[0]
    lst1 = [0 for i in range(n)]
    lst2 = [0 for i in range(n)]
    i1 = 0
    i2 = 0
    for i in range(2 * n):
        mas = list(map(int, input().split()))
        if (mas[0] == 0):
            lst1[i1] = mas[1] ** 2
            i1 += 1
        else:
            lst2[i2] = mas[0] ** 2
            i2 += 1
    lst1.sort()
    lst2.sort()
    s = 0
    for i in range(n):
        s += (lst1[i] + lst2[i]) ** 0.5
    print(s)","['geometry', 'greedy', 'math', 'sortings']"
"There are many sunflowers in the Garden of the Sun.Garden of the Sun is a rectangular table with $$$n$$$ rows and $$$m$$$ columns, where the cells of the table are farmlands. All of the cells grow a sunflower on it. Unfortunately, one night, the lightning stroke some (possibly zero) cells, and sunflowers on those cells were burned into ashes. In other words, those cells struck by the lightning became empty. Magically, any two empty cells have no common points (neither edges nor corners).Now the owner wants to remove some (possibly zero) sunflowers to reach the following two goals:    When you are on an empty cell, you can walk to any other empty cell. In other words, those empty cells are connected.   There is exactly one simple path between any two empty cells. In other words, there is no cycle among the empty cells. You can walk from an empty cell to another if they share a common edge.Could you please give the owner a solution that meets all her requirements?Note that you are not allowed to plant sunflowers. You don't need to minimize the number of sunflowers you remove. It can be shown that the answer always exists.","import sys
input = sys.stdin.readline

t=int(input())

for tests in range(t):
    n,m=map(int,input().split())
    MAP=[list(input().strip()) for i in range(n)]

    if m<=1:
        for i in range(n):
            MAP[i][0]=""X""

    for j in range(1,m,3):
        for i in range(n):
            MAP[i][j]=""X""

    for j in range(2,m,3):

        if j+1<m:
                    
            for i in range(n):
                if MAP[i][j]==""X"":
                    MAP[i][j+1]=""X""
                    break

            else:
                for i in range(n):
                    if MAP[i][j+1]==""X"":
                        MAP[i][j]=""X""
                        break

                else:
                    MAP[0][j]=MAP[0][j+1]=""X""

    if m%3==1:
        for i in range(n):
            if MAP[i][m-1]==""X"":
                MAP[i][m-2]=""X""
        
    for i in range(n):
        print("""".join(MAP[i]))

    #print()","['constructive algorithms', 'graphs']"
"Eshag has an array $$$a$$$ consisting of $$$n$$$ integers.Eshag can perform the following operation any number of times: choose some subsequence of $$$a$$$ and delete every element from it which is strictly larger than $$$AVG$$$, where $$$AVG$$$ is the average of the numbers in the chosen subsequence.For example, if $$$a = [1 , 4 , 3 , 2 , 4]$$$ and Eshag applies the operation to the subsequence containing $$$a_1$$$, $$$a_2$$$, $$$a_4$$$ and $$$a_5$$$, then he will delete those of these $$$4$$$ elements which are larger than $$$\frac{a_1+a_2+a_4+a_5}{4} = \frac{11}{4}$$$, so after the operation, the array $$$a$$$ will become $$$a = [1 , 3 , 2]$$$.Your task is to find the maximum number of elements Eshag can delete from the array $$$a$$$ by applying the operation described above some number (maybe, zero) times.A sequence $$$b$$$ is a subsequence of an array $$$c$$$ if $$$b$$$ can be obtained from $$$c$$$ by deletion of several (possibly, zero or all) elements.","for i in range(int(input())):
    a, b = int(input()), [int(x) for x in input().split()]
    print(a - b.count(min(b)))","['constructive algorithms', 'greedy', 'math']"
"Soroush and Keshi each have a labeled and rooted tree on $$$n$$$ vertices. Both of their trees are rooted from vertex $$$1$$$.Soroush and Keshi used to be at war. After endless decades of fighting, they finally became allies to prepare a Codeforces round. To celebrate this fortunate event, they decided to make a memorial graph on $$$n$$$ vertices.They add an edge between vertices $$$u$$$ and $$$v$$$ in the memorial graph if both of the following conditions hold:   One of $$$u$$$ or $$$v$$$ is the ancestor of the other in Soroush's tree.  Neither of $$$u$$$ or $$$v$$$ is the ancestor of the other in Keshi's tree. Here vertex $$$u$$$ is considered ancestor of vertex $$$v$$$, if $$$u$$$ lies on the path from $$$1$$$ (the root) to the $$$v$$$.Popping out of nowhere, Mashtali tried to find the maximum clique in the memorial graph for no reason. He failed because the graph was too big. Help Mashtali by finding the size of the maximum clique in the memorial graph.As a reminder, clique is a subset of vertices of the graph, each two of which are connected by an edge.","import sys
import os
from io import BytesIO
from operator import getitem

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))

f = sys.stdin
if os.environ.get('USER') == ""loic"":
    f = open(""data.in"")

line = lambda: f.readline().strip('\r\n').split()

def write(w):
    sys.stdout.write(w)
    sys.stdout.write(""\n"")

# From https://github.com/cheran-senthil/PyRival/blob/master/pyrival/data_structures/SortedList.py
class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len

    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)

    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))


def dfs_time(g, start):
    times_vis = [-1] * len(g)
    
    q = [start]
    times_vis[start] = 0
    
    c = 0
    
    while q:
        n = q[-1]
        
        if times_vis[n] == 1:
            t_out[n] = c
            c += 1
            q.pop()
        else:
            t_in[n] = c
            c += 1
            
            times_vis[n] = 1
            
            for ch in reversed(g[n]):
                times_vis[ch] = 0
                q.append(ch)

def dfs(g, start):
    times_vis = [-1] * len(g)
    
    q = [start]
    times_vis[start] = 0
    
    mx = 0
    data = [(t_in[n],t_out[n],n) for n in range(N)]
    sl = SortedList()
    rep = [None for _ in range(N)]
    
    while q:
        n = q[-1]
        
        if times_vis[n] == 1:
            sl.remove(data[n])
            if rep[n] is not None:
                r = rep[n]
                sl.add(data[r])
            q.pop()
        else:
            idx = sl.bisect_left(data[n])
            if idx > 0:
                itv = getitem(sl, idx-1)
                if itv[1] > t_out[n]:
                    sl.remove(itv)
                    rep[n] = itv[2]
            sl.add(data[n])
            
            mx = max(mx, len(sl))
            
            times_vis[n] = 1
            
            for ch in reversed(g[n]):
                times_vis[ch] = 0
                q.append(ch)
    
    return mx

def solve():
    
    dfs_time(G2, 0)
    res = dfs(G1, 0)
    
    return str(res)

T = int(line()[0])
for test in range(1,T+1):
    N = int(line()[0])
    G1 = [[] for _ in range(N)]
    G2 = [[] for _ in range(N)]
    
    par = list(map(int,line()))
    for i in range(len(par)):
        G1[par[i]-1].append(i+1)  
    
    par = list(map(int,line()))
    for i in range(len(par)):
        G2[par[i]-1].append(i+1)
    
    t_in = [-1]*N
    t_out = [-1]*N
    
    write(solve())
    
f.close()","['data structures', 'dfs and similar', 'greedy', 'trees']"
"A sequence of $$$n$$$ numbers is called permutation if it contains all numbers from $$$1$$$ to $$$n$$$ exactly once. For example, the sequences [$$$3, 1, 4, 2$$$], [$$$1$$$] and [$$$2,1$$$] are permutations, but [$$$1,2,1$$$], [$$$0,1$$$] and [$$$1,3,4$$$] — are not.For a permutation $$$p$$$ of even length $$$n$$$ you can make an array $$$b$$$ of length $$$\frac{n}{2}$$$ such that:   $$$b_i = \max(p_{2i - 1}, p_{2i})$$$ for $$$1 \le i \le \frac{n}{2}$$$ For example, if $$$p$$$ = [$$$2, 4, 3, 1, 5, 6$$$], then:   $$$b_1 = \max(p_1, p_2) = \max(2, 4) = 4$$$  $$$b_2 = \max(p_3, p_4) = \max(3,1)=3$$$  $$$b_3 = \max(p_5, p_6) = \max(5,6) = 6$$$  As a result, we made $$$b$$$ = $$$[4, 3, 6]$$$.For a given array $$$b$$$, find the lexicographically minimal permutation $$$p$$$ such that you can make the given array $$$b$$$ from it.If $$$b$$$ = [$$$4,3,6$$$], then the lexicographically minimal permutation from which it can be made is $$$p$$$ = [$$$1,4,2,3,5,6$$$], since:   $$$b_1 = \max(p_1, p_2) = \max(1, 4) = 4$$$  $$$b_2 = \max(p_3, p_4) = \max(2, 3) = 3$$$  $$$b_3 = \max(p_5, p_6) = \max(5, 6) = 6$$$ A permutation $$$x_1, x_2, \dots, x_n$$$ is lexicographically smaller than a permutation $$$y_1, y_2 \dots, y_n$$$ if and only if there exists such $$$i$$$ ($$$1 \le i \le n$$$) that $$$x_1=y_1, x_2=y_2, \dots, x_{i-1}=y_{i-1}$$$ and $$$x_i&lt;y_i$$$.","import collections
import math
import bisect
import sys
import heapq
import itertools
#import functools

def solve():
    n = int(input())
    arr = [int(i) for i in sys.stdin.readline().split()]
    dic = {}
    for i, num in enumerate(arr):
        dic[num] = i
    if len(dic) != n // 2 or n not in dic:
        print(-1)
        return

    output = [-1] * n
    for num in dic:
        output[dic[num] * 2 + 1] = num
    
    h = []
    for num in range(n, 0, -1):
        if num in dic:
            heapq.heappush(h, -dic[num] * 2)
        elif not h:
            print(-1)
            return
        else:
            output[-heapq.heappop(h)] = num
    print(' '.join(map(str, output)))

    
    

t = int(input())
for _ in range(t):
    solve()","['binary search', 'constructive algorithms', 'data structures', 'greedy', 'math']"
"You are given an integer $$$n$$$. Check if $$$n$$$ has an odd divisor, greater than one (does there exist such a number $$$x$$$ ($$$x &gt; 1$$$) that $$$n$$$ is divisible by $$$x$$$ and $$$x$$$ is odd).For example, if $$$n=6$$$, then there is $$$x=3$$$. If $$$n=4$$$, then such a number does not exist.","n=int(input())
for i in range (n):
    t=int(input())
    while t%2==0:
        t/=2
    if t>1:
        print(""YES"")
    else:
        print(""NO"")","['math', 'number theory']"
"You are given a positive integer $$$x$$$. Find any such $$$2$$$ positive integers $$$a$$$ and $$$b$$$ such that $$$GCD(a,b)+LCM(a,b)=x$$$.As a reminder, $$$GCD(a,b)$$$ is the greatest integer that divides both $$$a$$$ and $$$b$$$. Similarly, $$$LCM(a,b)$$$ is the smallest integer such that both $$$a$$$ and $$$b$$$ divide it.It's guaranteed that the solution always exists. If there are several such pairs $$$(a, b)$$$, you can output any of them.","T = input()

for _ in xrange(T):
    x = input()

    if x % 2 == 0:
        print ""%d %d"" % (x//2, x//2)

    else:
        print ""1 %d"" % (x-1)","['constructive algorithms', 'number theory', 'greedy']"
"Cirno gives AquaMoon a problem. There are $$$m$$$ people numbered from $$$0$$$ to $$$m - 1$$$. They are standing on a coordinate axis in points with positive integer coordinates. They are facing right (i.e. in the direction of the coordinate increase). At this moment everyone will start running with the constant speed in the direction of coordinate increasing. The initial coordinate of the $$$i$$$-th person on the line is $$$x_i$$$, and the speed of the $$$i$$$-th person is $$$v_i$$$. So the coordinate of the $$$i$$$-th person at the moment $$$t$$$ will be $$$x_i + t \cdot v_i$$$.Cirno captured the coordinates of $$$m$$$ people in $$$k$$$ consecutive integer moments from $$$0$$$ to $$$k - 1$$$. In every moment, the coordinates of $$$m$$$ people were recorded in arbitrary order.To make the problem more funny, Cirno modified one coordinate at the moment $$$y$$$ ($$$0 &lt; y &lt; k-1$$$) to a different integer.AquaMoon wants to find the moment $$$y$$$ and the original coordinate $$$p$$$ before the modification. Actually, she is not a programmer at all. So she wasn't able to solve it. Can you help her?","import os,sys
from random import randint
from io import BytesIO, IOBase

from collections import defaultdict,deque,Counter
from bisect import bisect_left,bisect_right
from heapq import heappush,heappop
from functools import lru_cache
from itertools import accumulate
import math

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))
#     b = list(map(int, input().split()))
#     if sum(a) != sum(b):
#         print(-1)
#     else:
#         pos, neg = [], []
#         for i in range(n):
#             if a[i] > b[i]:
#                 pos.append([a[i] - b[i], i])
#             elif a[i] < b[i]:
#                 neg.append([b[i] - a[i], i])
#         ans = []
#         while pos:
#             ans.append((pos[-1][1], neg[-1][1]))
#             pos[-1][0] -= 1
#             neg[-1][0] -= 1
#             if pos[-1][0] == 0:
#                 pos.pop()
#             if neg[-1][0] == 0:
#                 neg.pop()
#         print(len(ans))
#         for i, j in ans:
#             print(i + 1, j + 1)

# for _ in range(int(input())):
#     n, m = list(map(int, input().split()))
#     cnt = [[0] * m for _ in range(26)]
#     for _ in range(n):
#         s = input()
#         for i in range(m):
#             cnt[ord(s[i]) - ord('a')][i] += 1
#     for _ in range(n - 1):
#         s = input()
#         for i in range(m):
#             cnt[ord(s[i]) - ord('a')][i] -= 1
#     ans = []
#     for j in range(m):
#         for i in range(26):
#             if cnt[i][j]:
#                 ans.append(chr(97 + i))
#                 break
#     print(''.join(ans))

# for _ in range(int(input())):
#     def solve():
#         n = int(input())
#         a = list(map(int, input().split()))
#         b = sorted(a)
#         odd = defaultdict(list)
#         even = defaultdict(list)
#         for i in range(n):
#             if i % 2:
#                 odd[b[i]].append(i)
#             else:
#                 even[b[i]].append(i)
#         for i in range(n):
#             if i % 2:
#                 if not odd[a[i]]:
#                     print('NO')
#                     return
#                 odd[a[i]].pop()
#             else:
#                 if not even[a[i]]:
#                     print('NO')
#                     return
#                 even[a[i]].pop()
#         print('YES')
#     solve()

# mod = 998244353
# N = 100010
# fac = [1] * N
# for i in range(2, N):
#     fac[i] = fac[i - 1] * i % mod
# invfac = [1] * N
# invfac[N - 1] = pow(fac[N - 1], mod - 2, mod)
# for i in range(N - 1)[::-1]:
#     invfac[i] = invfac[i + 1] * (i + 1) % mod
# def c(i, j):
#     return fac[i] * invfac[j] * invfac[i - j] % mod

# for _ in range(int(input())):
#     n = int(input())
#     s = input()
#     cnt11 = cnt0 = 0
#     cur = 0
#     for i in range(n):
#         if s[i] == '1':
#             cur += 1
#         else:
#             cnt0 += 1
#             cnt11 += cur // 2
#             cur = 0
#     cnt11 += cur // 2
#     print(c(cnt0 + cnt11, cnt0))

m, k = list(map(int, input().split()))
a_1d = [list(map(int, input().split())) for _ in range(k)]
sum_1d = [sum(a_1d[i]) for i in range(k)]
dif_1d = [sum_1d[i + 1] - sum_1d[i] for i in range(k - 1)]

for i in range(k - 2):
    if dif_1d[i] == dif_1d[i + 1]:
        real_dif_1d = dif_1d[i]
        break
for i in range(k - 1):
    if dif_1d[i] != real_dif_1d:
        add_1d = real_dif_1d - dif_1d[i]
        pos = i + 1
        break

sum_2d = []
for i in range(k):
    t = 0
    for j in range(m):
        t += a_1d[i][j] * a_1d[i][j]
    sum_2d.append(t)
dif_2d = [sum_2d[i + 1] - sum_2d[i] for i in range(k - 1)]
difdif_2d = [dif_2d[i + 1] - dif_2d[i] for i in range(k - 2)]

real_dif_2d = difdif_2d[0]
for i in range(k - 3):
    if difdif_2d[i] == difdif_2d[i + 1]:
        real_dif_2d = difdif_2d[i]
        break

if pos > 1:
    real_2d = sum_2d[pos - 1] + sum_2d[pos - 1] - sum_2d[pos - 2] + real_dif_2d
else:
    real_2d = sum_2d[pos + 1] - ((sum_2d[pos + 2] - sum_2d[pos + 1]) - real_dif_2d)

add2d = real_2d - sum_2d[pos]
ori = (add_1d + add2d // add_1d) // 2
print(pos, ori)


# ori - last = add
# ori^2-last^2=add2
# ori+last=add2//add
# ori = (add+add2//add) // 2


# x1   ... xk
# x1+v1 ... xk+vk
# x1+2v1 ... xk+2vk

# sum0
# sum0+dif = fake + x
# sum0+dif*2

# 66999 21111
# 87101010

# a, b, c, d, e = 6, 6, 9, 9, 9
# pre = a*a+b*b+c*c+d*d+e*e
# for _ in range(6):
#     a += 2
#     b += 1
#     c += 1
#     d += 1
#     e += 1
#     print(a*a+b*b+c*c+d*d+e*e, a*a+b*b+c*c+d*d+e*e - pre)
#     pre = a*a+b*b+c*c+d*d+e*e

# ori**2 -last**2 -","['interactive', 'math']"
"Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents —there was a pile of different rings: gold and silver...""How am I to tell which is the One?!"" the mage howled.""Throw them one by one into the Cracks of Doom and watch when Mordor falls!"" Somewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found $$$n$$$ rings. And the $$$i$$$-th ring was either gold or silver. For convenience Saruman wrote down a binary string $$$s$$$ of $$$n$$$ characters, where the $$$i$$$-th character was 0 if the $$$i$$$-th ring was gold, and 1 if it was silver.Saruman has a magic function $$$f$$$, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, $$$f(001010) = 10, f(111) = 7, f(11011101) = 221$$$.Saruman, however, thinks that the order of the rings plays some important role. He wants to find $$$2$$$ pairs of integers $$$(l_1, r_1), (l_2, r_2)$$$, such that: $$$1 \le l_1 \le n$$$, $$$1 \le r_1 \le n$$$, $$$r_1-l_1+1\ge \lfloor \frac{n}{2} \rfloor$$$  $$$1 \le l_2 \le n$$$, $$$1 \le r_2 \le n$$$, $$$r_2-l_2+1\ge \lfloor \frac{n}{2} \rfloor$$$  Pairs $$$(l_1, r_1)$$$ and $$$(l_2, r_2)$$$ are distinct. That is, at least one of $$$l_1 \neq l_2$$$ and $$$r_1 \neq r_2$$$ must hold. Let $$$t$$$ be the substring $$$s[l_1:r_1]$$$ of $$$s$$$, and $$$w$$$ be the substring $$$s[l_2:r_2]$$$ of $$$s$$$. Then there exists non-negative integer $$$k$$$, such that $$$f(t) = f(w) \cdot k$$$.Here substring $$$s[l:r]$$$ denotes $$$s_ls_{l+1}\ldots s_{r-1}s_r$$$, and $$$\lfloor x \rfloor$$$ denotes rounding the number down to the nearest integer.Help Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.","for q in range(int(input())):
    d = int(input())
    n = "" ""+input()
    if ""0"" in n:
        c = n.index(""0"")
        if c <= d//2:
            print(c, d, c+1, d)
        else:
            print(1, c, 1, c-1)
    else:
        print(1, d//2, 2, d//2+1)","['constructive algorithms', 'math']"
"This is the hard version of the problem. The difference between the versions is that the hard version does require you to output the numbers of the rods to be removed. You can make hacks only if all versions of the problem are solved.Stitch likes experimenting with different machines with his friend Sparky. Today they built another machine.The main element of this machine are $$$n$$$ rods arranged along one straight line and numbered from $$$1$$$ to $$$n$$$ inclusive. Each of these rods must carry an electric charge quantitatively equal to either $$$1$$$ or $$$-1$$$ (otherwise the machine will not work). Another condition for this machine to work is that the sign-variable sum of the charge on all rods must be zero.More formally, the rods can be represented as an array of $$$n$$$ numbers characterizing the charge: either $$$1$$$ or $$$-1$$$. Then the condition must hold: $$$a_1 - a_2 + a_3 - a_4 + \ldots = 0$$$, or $$$\sum\limits_{i=1}^n (-1)^{i-1} \cdot a_i = 0$$$.Sparky charged all $$$n$$$ rods with an electric current, but unfortunately it happened that the rods were not charged correctly (the sign-variable sum of the charge is not zero). The friends decided to leave only some of the rods in the machine. Sparky has $$$q$$$ questions. In the $$$i$$$th question Sparky asks: if the machine consisted only of rods with numbers $$$l_i$$$ to $$$r_i$$$ inclusive, what minimal number of rods could be removed from the machine so that the sign-variable sum of charges on the remaining ones would be zero? Also Sparky wants to know the numbers of these rods. Perhaps the friends got something wrong, and the sign-variable sum is already zero. In that case, you don't have to remove the rods at all.If the number of rods is zero, we will assume that the sign-variable sum of charges is zero, that is, we can always remove all rods.Help your friends and answer all of Sparky's questions!","import sys
from bisect import bisect_left
ipt=sys.stdin.readline
T=int(ipt())

for _ in range(T):
    n, q=map(int, ipt().split())
    s=sys.stdin.readline().strip()
    a=[0 for i in range(n)]
    for i in range(n):
        if s[i]=='+':
            a[i]=-1 if i&1 else 1
        else:
            a[i]=1 if i&1 else -1
    b=[0 for i in range(n+1)]
    c=[]
    for i in range(1, n+1):
        b[i]=b[i-1]+a[i-1]
    for i in range(n):
        c.append(1000000*(b[i]+b[i+1])+i+1)
    c.sort()
    for i in range(q):
        l, r=map(int, ipt().split())
        t=b[r]-b[l-1]
        if t==0:
            print(0)
        elif (l-r)&1:
            print(2)
            ll=(b[r-1]+b[l-1])*1000000+l
            t=bisect_left(c, ll)
            print(c[t]%1000000, r)
        else:
            print(1)
            ll=(b[r]+b[l-1])*1000000+l
            t=bisect_left(c, ll)
            print(c[t]%1000000)","['data structures', 'math']"
"There is a chessboard of size $$$n$$$ by $$$n$$$. The square in the $$$i$$$-th row from top and $$$j$$$-th column from the left is labelled $$$(i,j)$$$.Currently, Gregor has some pawns in the $$$n$$$-th row. There are also enemy pawns in the $$$1$$$-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from $$$(i,j)$$$ to $$$(i-1,j)$$$) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from $$$(i,j)$$$ to either $$$(i-1,j-1)$$$ or $$$(i-1,j+1)$$$) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.Gregor wants to know what is the maximum number of his pawns that can reach row $$$1$$$?Note that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row $$$1$$$, it is stuck and cannot make any further moves.","def solve():
    n = int(input())
    e = list(input())
    g = list(input())
    e.insert(0,""0"")
    e.insert(n+1,""0"")
   # print(e)
 
    
    
   
    c = 0
    for i in range(0,n):
        if g[i] == ""1"":
            if e[i+1] == ""0"":
                c+=1
            elif e[i] ==""1"":
                c+=1
                e[i] = ""2""
            elif e[i+2] ==""1"":
                c+=1
                e[i+2] = ""2""
    print(c)
                
           
case = int(input())
for _ in range(case):
   solve()","['dfs and similar', 'dp', 'flows', 'graph matchings', 'graphs', 'greedy', 'implementation']"
"Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.Gregor's favorite prime number is $$$P$$$. Gregor wants to find two bases of $$$P$$$. Formally, Gregor is looking for two integers $$$a$$$ and $$$b$$$ which satisfy both of the following properties.  $$$P \bmod a = P \bmod b$$$, where $$$x \bmod y$$$ denotes the remainder when $$$x$$$ is divided by $$$y$$$, and  $$$2 \le a &lt; b \le P$$$. Help Gregor find two bases of his favorite prime number!","for _ in range(int(input())):
    print(2,int(input())-1,sep="" "")","['math', 'number theory']"
"Turbulent times are coming, so you decided to buy sugar in advance. There are $$$n$$$ shops around that sell sugar: the $$$i$$$-th shop sells one pack of sugar for $$$a_i$$$ coins, but only one pack to one customer each day. So in order to buy several packs, you need to visit several shops.Another problem is that prices are increasing each day: during the first day the cost is $$$a_i$$$, during the second day cost is $$$a_i + 1$$$, during the third day — $$$a_i + 2$$$ and so on for each shop $$$i$$$.On the contrary, your everyday budget is only $$$x$$$ coins. In other words, each day you go and buy as many packs as possible with total cost not exceeding $$$x$$$. Note that if you don't spend some amount of coins during a day, you can't use these coins during the next days.Eventually, the cost for each pack will exceed $$$x$$$, and you won't be able to buy even a single pack. So, how many packs will you be able to buy till that moment in total?","import math
 
for i in range(int(input())):
    n, x = list(map(int, input().split()))
    l = sorted(list(map(int, input().split())))
    ans = 0
    if x >= l[0]:
        s = 0
        for i, a in enumerate(l):
            s += a
            u = math.floor((x - s) / (i + 1.0)) + 1
            if u > 0:
                ans += u
            else:
                break
    
    print(ans)","['binary search', 'brute force', 'greedy', 'math']"
"You are given $$$n$$$ points with integer coordinates on a coordinate axis $$$OX$$$. The coordinate of the $$$i$$$-th point is $$$x_i$$$. All points' coordinates are distinct and given in strictly increasing order.For each point $$$i$$$, you can do the following operation no more than once: take this point and move it by $$$1$$$ to the left or to the right (i..e., you can change its coordinate $$$x_i$$$ to $$$x_i - 1$$$ or to $$$x_i + 1$$$). In other words, for each point, you choose (separately) its new coordinate. For the $$$i$$$-th point, it can be either $$$x_i - 1$$$, $$$x_i$$$ or $$$x_i + 1$$$.Your task is to determine if you can move some points as described above in such a way that the new set of points forms a consecutive segment of integers, i. e. for some integer $$$l$$$ the coordinates of points should be equal to $$$l, l + 1, \ldots, l + n - 1$$$.Note that the resulting points should have distinct coordinates.You have to answer $$$t$$$ independent test cases.","import sys
t = int(input())
is_one = 0
is_three = 0
is_two = 0
is_break = 0
for i in range(t):
    is_one = 0
    is_three = 0
    is_two = 0
    is_break = 0
    fullcount = 0
    n = int(input())
    arr = list(map(int, input().split()))
    # print(arr)
    if(n == 1):
        print('YES')
        continue
    else:
        for idx, val in enumerate(arr):
            if(idx>0):
                if(arr[idx]-arr[idx-1] == 1):
                    is_one += 1
                elif(arr[idx]-arr[idx-1] == 3):
                    is_three += 1
                    if(is_two != 0):
                        print('NO')
                        is_break = 1
                        break
                    if(is_three >= 2):
                        print('NO')
                        is_break = 1
                        break
                elif(arr[idx]-arr[idx-1] == 2):
                    is_two += 1
                    if(is_three != 0):
                        print('NO')
                        is_break = 1
                        break
                    if(is_two >= 3):
                        print('NO')
                        is_break = 1
                        break
                else:
                    print('NO')
                    is_break = 1
                    break
        if(is_break == 1):
            continue
        else:
            print('YES')","['brute force', 'math', 'sortings']"
"Tonya was given an array of $$$a$$$ of length $$$n$$$ written on a postcard for his birthday. For some reason, the postcard turned out to be a cyclic array, so the index of the element located strictly to the right of the $$$n$$$-th is $$$1$$$. Tonya wanted to study it better, so he bought a robot ""Burenka-179"".A program for Burenka is a pair of numbers $$$(s, k)$$$, where $$$1 \leq s \leq n$$$, $$$1 \leq k \leq n-1$$$. Note that $$$k$$$ cannot be equal to $$$n$$$. Initially, Tonya puts the robot in the position of the array $$$s$$$. After that, Burenka makes exactly $$$n$$$ steps through the array. If at the beginning of a step Burenka stands in the position $$$i$$$, then the following happens:   The number $$$a_{i}$$$ is added to the usefulness of the program.  ""Burenka"" moves $$$k$$$ positions to the right ($$$i := i + k$$$ is executed, if $$$i$$$ becomes greater than $$$n$$$, then $$$i := i - n$$$). Help Tonya find the maximum possible usefulness of a program for ""Burenka"" if the initial usefulness of any program is $$$0$$$.Also, Tony's friend Ilyusha asks him to change the array $$$q$$$ times. Each time he wants to assign $$$a_p := x$$$ for a given index $$$p$$$ and a value $$$x$$$. You need to find the maximum possible usefulness of the program after each of these changes.","import heapq
class segtree():
  def __init__(self,init,func,ide):
    self.n=len(init)
    self.func=func
    self.ide=ide
    self.size=1<<(self.n-1).bit_length()
    self.tree=[self.ide for i in range(2*self.size)]
    for i in range(self.n):
      self.tree[self.size+i]=init[i]
    for i in range(self.size-1,0,-1):
      self.tree[i]=self.func(self.tree[2*i], self.tree[2*i|1])
  
  def update(self,k,x):
    k+=self.size
    self.tree[k]=x
    k>>=1
    while k:
      self.tree[k]=self.func(self.tree[2*k],self.tree[k*2|1])
      k>>=1
  
  def get(self,i):
    return self.tree[i+self.size]
  
  def query(self,l,r):
    l+=self.size
    r+=self.size
    l_res=self.ide
    r_res=self.ide
    while l<r:
      if l&1:
        l_res=self.func(l_res,self.tree[l])
        l+=1
      if r&1:
        r-=1
        r_res=self.func(self.tree[r],r_res)
      l>>=1
      r>>=1
    return self.func(l_res,r_res)
  
  def debug(self,s=10):
    print([self.get(i) for i in range(min(self.n,s))])


from sys import stdin
input=lambda :stdin.readline()[:-1]

def fact(n):
  f=[]
  tmp=n
  for i in range(2,10**3):
    if tmp%i==0:
      f.append(i)
    
    while tmp%i==0:
      tmp//=i
  
  if tmp>1:
    f.append(tmp)
  return f

      
ans=[]
for _ in range(int(input())):
  n,q=map(int,input().split())
  a=list(map(int,input().split()))
  f=fact(n)
  M=len(f)
  seg_arr=[]
  res=[0]*M
  for i in range(M):
    p=f[i]
    d=n//p
    x=[0]*(n//p)
    for j in range(n):
      x[j%d]+=a[j]*d
    seg=segtree(x,max,0)
    res[i]=seg.tree[1]
    seg_arr.append(seg)
  ans.append(max(res))
  
  for _ in range(q):
    x,y=map(int,input().split())
    x-=1
    diff=y-a[x]
    a[x]=y
    for i in range(M):
      d=n//f[i]
      seg_arr[i].update(x%d,seg_arr[i].get(x%d)+diff*d)
      res[i]=seg_arr[i].tree[1]
    ans.append(max(res))  

print('\n'.join(map(str,ans)))","['data structures', 'greedy', 'math', 'number theory']"
"Polycarp has come up with a new game to play with you. He calls it ""A missing bigram"".A bigram of a word is a sequence of two adjacent letters in it.For example, word ""abbaaba"" contains bigrams ""ab"", ""bb"", ""ba"", ""aa"", ""ab"" and ""ba"".The game goes as follows. First, Polycarp comes up with a word, consisting only of lowercase letters 'a' and 'b'. Then, he writes down all its bigrams on a whiteboard in the same order as they appear in the word. After that, he wipes one of them off the whiteboard.Finally, Polycarp invites you to guess what the word that he has come up with was.Your goal is to find any word such that it's possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them.","def to_sequence(bigrams):
    result = ''
    for bigram in bigrams:
        result += bigram[0]
    return result + bigrams[-1][-1]

def missing_biagram(bigrams):
    for i in range(len(bigrams) - 1):
        if not bigrams[i][1] == bigrams[i + 1][0]:
            bigrams.insert(i + 1, bigrams[i][1] + bigrams[i + 1][0])
            return
    # error in the end/start
    bigrams.append(bigrams[-1][-1] + ""a"")

# read input
t = int(input())
for i in range(t):
    n = int(input()) 
    bigrams = input().split("" "")
    missing_biagram(bigrams)
    result = to_sequence(bigrams)
    print(result)




# what we want to find
# abbaaba

# ab bb ba aa ab ba
             
# abbaaba",['implementation']
"You are given an array $$$a$$$ consisting of $$$n$$$ positive integers. You have to choose a positive integer $$$d$$$ and paint all elements into two colors. All elements which are divisible by $$$d$$$ will be painted red, and all other elements will be painted blue.The coloring is called beautiful if there are no pairs of adjacent elements with the same color in the array. Your task is to find any value of $$$d$$$ which yields a beautiful coloring, or report that it is impossible.","def  GCD(divisor,num):
    if num == 0:
        return divisor
    else:
        return GCD(num , divisor % num)

def solve(array):
    even_divisor = 0
    odd_divisor = 0
    for index in range (0 , len(array)):
        if index % 2 == 0 :
            even_divisor = GCD(even_divisor , array[index])
        else :
            odd_divisor = GCD(odd_divisor , array[index])

    ok = True
    index = 0
    while index < len(array) :
        if array [index] % odd_divisor == 0 :
            ok = False
            break;
        index += 2
    if ok :
        return odd_divisor

    ok = True
    index = 1
    while index < len(array):
        if array[index] % even_divisor == 0:
            ok = False
            break;
        index += 2

    if ok:
        return even_divisor
    return 0

n=int(input())
array=[]
for i in range(n) :
    s = int(input())
    x = list(map(int, input().split()))
    array.append(x)

for i in array:
    print(solve(i))",['math']
"Alice and Bob play a game. Alice has $$$n$$$ cards, the $$$i$$$-th of them has the integer $$$a_i$$$ written on it. Bob has $$$m$$$ cards, the $$$j$$$-th of them has the integer $$$b_j$$$ written on it.On the first turn of the game, the first player chooses one of his/her cards and puts it on the table (plays it). On the second turn, the second player chooses one of his/her cards such that the integer on it is greater than the integer on the card played on the first turn, and plays it. On the third turn, the first player chooses one of his/her cards such that the integer on it is greater than the integer on the card played on the second turn, and plays it, and so on — the players take turns, and each player has to choose one of his/her cards with greater integer than the card played by the other player on the last turn.If some player cannot make a turn, he/she loses.For example, if Alice has $$$4$$$ cards with numbers $$$[10, 5, 3, 8]$$$, and Bob has $$$3$$$ cards with numbers $$$[6, 11, 6]$$$, the game may go as follows:  Alice can choose any of her cards. She chooses the card with integer $$$5$$$ and plays it.  Bob can choose any of his cards with number greater than $$$5$$$. He chooses a card with integer $$$6$$$ and plays it.  Alice can choose any of her cards with number greater than $$$6$$$. She chooses the card with integer $$$10$$$ and plays it.  Bob can choose any of his cards with number greater than $$$10$$$. He chooses a card with integer $$$11$$$ and plays it.  Alice can choose any of her cards with number greater than $$$11$$$, but she has no such cards, so she loses. Both Alice and Bob play optimally (if a player is able to win the game no matter how the other player plays, the former player will definitely win the game).You have to answer two questions:  who wins if Alice is the first player?  who wins if Bob is the first player?","r='Alice','Bob'
R=lambda:max(map(int,input().split()))
for _ in[0]*R():R();a=R();R();b=R();print(r[a<b]+'\n'+r[a<=b])","['games', 'greedy']"
"Even if you just leave them be, they will fall to pieces all by themselves. So, someone has to protect them, right?You find yourself playing with Teucer again in the city of Liyue. As you take the eccentric little kid around, you notice something interesting about the structure of the city.Liyue can be represented as a directed graph containing $$$n$$$ nodes. Nodes are labeled from $$$1$$$ to $$$n$$$. There is a directed edge from node $$$a$$$ to node $$$b$$$ if and only if $$$a &lt; b$$$.A path between nodes $$$a$$$ and $$$b$$$ is defined as a sequence of edges such that you can start at $$$a$$$, travel along all of these edges in the corresponding direction, and end at $$$b$$$. The length of a path is defined by the number of edges. A rainbow path of length $$$x$$$ is defined as a path in the graph such that there exists at least 2 distinct colors among the set of $$$x$$$ edges.Teucer's favorite number is $$$k$$$. You are curious about the following scenario: If you were to label each edge with a color, what is the minimum number of colors needed to ensure that all paths of length $$$k$$$ or longer are rainbow paths?Teucer wants to surprise his older brother with a map of Liyue. He also wants to know a valid coloring of edges that uses the minimum number of colors. Please help him with this task!","# LUOGU_RID: 93245551
n,k=map(int,input().split())
cnt=0
sum=1
while sum<n:
    sum=sum*k
    cnt=cnt+1
print(cnt)
for i in range(0,n):
    for j in range(i+1,n):
        u=i
        v=j
        ans=0
        while u!=v:
            u//=k
            v//=k
            ans=ans+1
        print(ans,end=' ')","['bitmasks', 'constructive algorithms', 'divide and conquer']"
"A bow adorned with nameless flowers that bears the earnest hopes of an equally nameless person.You have obtained the elegant bow known as the Windblume Ode. Inscribed in the weapon is an array of $$$n$$$ ($$$n \ge 3$$$) positive distinct integers (i.e. different, no duplicates are allowed).Find the largest subset (i.e. having the maximum number of elements) of this array such that its sum is a composite number. A positive integer $$$x$$$ is called composite if there exists a positive integer $$$y$$$ such that $$$1 &lt; y &lt; x$$$ and $$$x$$$ is divisible by $$$y$$$.If there are multiple subsets with this largest size with the composite sum, you can output any of them. It can be proven that under the constraints of the problem such a non-empty subset always exists.","tt = int(input())
fa = []
n = 500000
for i in range(n + 1):
    fa.append(i)
fa[1] = 0
i = 2
while i <= n:
    if fa[i] != 0:
        j = i + i
        while j <= n:
            fa[j] = 0
            j = j + i
    i += 1
fa = set(fa)
fa.remove(0)
for i in range(tt):
    ar = []
    f = int(input())
    y = input()
    ar = y.split()
    ar = list(map(int, ar))
    a = sum(ar)
    k = 0
    if (a not in fa):
        print(len(ar))
        for x in range(1, len(ar) + 1):
            print(x, end=' ')
        print('')
    else:
        for j in range(len(ar)):
            b = a - ar[j]
            if b not in fa:
                print(len(ar) - 1)
                for y in range(j):
                    print(y + 1, end=' ')
                for y in range(j + 1, len(ar)):
                    print(y + 1, end=' ')
                print('')
                break
        else:
            for j in range(len(ar)):
                ty = False
                for p in range(j, len(ar)):
                    b = a - ar[j] - ar[p]
                    if b not in fa and b > 0:
                        print(len(ar) - 1)
                        for y in range(j):
                            print(y + 1, end=' ')
                        for y in range(j + 1, len(ar)):
                            print(y + 1, end=' ')
                        print('')
                        ty = True
                        break
                if ty:
                    ty = False
                    break","['math', 'number theory']"
"Nezzar has $$$n$$$ balls, numbered with integers $$$1, 2, \ldots, n$$$. Numbers $$$a_1, a_2, \ldots, a_n$$$ are written on them, respectively. Numbers on those balls form a non-decreasing sequence, which means that $$$a_i \leq a_{i+1}$$$ for all $$$1 \leq i &lt; n$$$.Nezzar wants to color the balls using the minimum number of colors, such that the following holds.  For any color, numbers on balls will form a strictly increasing sequence if he keeps balls with this chosen color and discards all other balls.  Note that a sequence with the length at most $$$1$$$ is considered as a strictly increasing sequence.Please help Nezzar determine the minimum number of colors.","import collections


def main():
    t = int(input())

    while t != 0:
        record = collections.defaultdict(int)
        # print('y')
        _max = -1
        n = int(input())
        l = list(map(int, input().split()))
        for i in range(len(l)):
            record[l[i]] += 1
            if record[l[i]] > _max:
                _max = record[l[i]]

        print(_max)
        t -= 1


main()","['brute force', 'greedy']"
"Long time ago there was a symmetric array $$$a_1,a_2,\ldots,a_{2n}$$$ consisting of $$$2n$$$ distinct integers. Array $$$a_1,a_2,\ldots,a_{2n}$$$ is called symmetric if for each integer $$$1 \le i \le 2n$$$, there exists an integer $$$1 \le j \le 2n$$$ such that $$$a_i = -a_j$$$.For each integer $$$1 \le i \le 2n$$$, Nezzar wrote down an integer $$$d_i$$$ equal to the sum of absolute differences from $$$a_i$$$ to all integers in $$$a$$$, i. e. $$$d_i = \sum_{j = 1}^{2n} {|a_i - a_j|}$$$.Now a million years has passed and Nezzar can barely remember the array $$$d$$$ and totally forget $$$a$$$. Nezzar wonders if there exists any symmetric array $$$a$$$ consisting of $$$2n$$$ distinct integers that generates the array $$$d$$$.","for w in range(int(input())) :
 n=int(input())
 s=list(map(int,input().split()))
 arr=sorted(list(map(int,set(s))),reverse=True)
 i=t=0
 test='YES'
 count=dict()
 if len(arr)!=n :
     test='NO'
 for p in s:
    count[p]=count.get(p,0)+1
 for p in count:
    if(count[p]!=2):
        test='NO'
 while test=='YES' and i<n  :
     arr[i]-=t*2
     if arr[i]%((n-i)*2)==0  :
      x=arr[i]//((n-i)*2)
      if x<=0 :
          test='NO'
          break
      t+=x
     else :
          test='NO'
          break
     i=i+1
 print(test)","['implementation', 'math', 'sortings']"
"Nezzar loves the game osu!.osu! is played on beatmaps, which can be seen as an array consisting of distinct points on a plane. A beatmap is called nice if for any three consecutive points $$$A,B,C$$$ listed in order, the angle between these three points, centered at $$$B$$$, is strictly less than $$$90$$$ degrees.  Points $$$A,B,C$$$ on the left have angle less than $$$90$$$ degrees, so they can be three consecutive points of a nice beatmap; Points $$$A',B',C'$$$ on the right have angle greater or equal to $$$90$$$ degrees, so they cannot be three consecutive points of a nice beatmap. Now Nezzar has a beatmap of $$$n$$$ distinct points $$$A_1,A_2,\ldots,A_n$$$. Nezzar would like to reorder these $$$n$$$ points so that the resulting beatmap is nice.Formally, you are required to find a permutation $$$p_1,p_2,\ldots,p_n$$$ of integers from $$$1$$$ to $$$n$$$, such that beatmap $$$A_{p_1},A_{p_2},\ldots,A_{p_n}$$$ is nice. If it is impossible, you should determine it.","import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16
md = 10**9+7
# md = 998244353

n = II()
xy = LLI(n)
ans = [0, 1]

def vec(i, j):
    x0, y0 = xy[i]
    x1, y1 = xy[j]
    return x1-x0, y1-y0

def less90(i, j, k):
    v1 = vec(j, i)
    v2 = vec(j, k)
    return v1[0]*v2[0]+v1[1]*v2[1] > 0

for i in range(2, n):
    ans.append(i)
    j = len(ans)
    while j > 2:
        if less90(ans[j-3], ans[j-2], ans[j-1]): break
        ans[j-1], ans[j-2] = ans[j-2], ans[j-1]
        j -= 1

print("" "".join(str(i+1) for i in ans))","['constructive algorithms', 'geometry', 'greedy', 'sortings']"
"You are given an array $$$a$$$ of $$$n$$$ ($$$n \geq 2$$$) positive integers and an integer $$$p$$$. Consider an undirected weighted graph of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$ for which the edges between the vertices $$$i$$$ and $$$j$$$ ($$$i&lt;j$$$) are added in the following manner:  If $$$gcd(a_i, a_{i+1}, a_{i+2}, \dots, a_{j}) = min(a_i, a_{i+1}, a_{i+2}, \dots, a_j)$$$, then there is an edge of weight $$$min(a_i, a_{i+1}, a_{i+2}, \dots, a_j)$$$ between $$$i$$$ and $$$j$$$.  If $$$i+1=j$$$, then there is an edge of weight $$$p$$$ between $$$i$$$ and $$$j$$$. Here $$$gcd(x, y, \ldots)$$$ denotes the greatest common divisor (GCD) of integers $$$x$$$, $$$y$$$, ....Note that there could be multiple edges between $$$i$$$ and $$$j$$$ if both of the above conditions are true, and if both the conditions fail for $$$i$$$ and $$$j$$$, then there is no edge between these vertices.The goal is to find the weight of the minimum spanning tree of this graph.","from operator import mod
import os,sys
from random import randint, shuffle
from io import BytesIO, IOBase

from collections import defaultdict,deque,Counter
from bisect import bisect_left,bisect_right
from heapq import heappush,heappop
from functools import lru_cache
from itertools import accumulate, permutations
import math

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))

# for _ in range(int(input())):
#     n, k = list(map(int, input().split()))
#     if k > (n - 1) // 2:
#         print(-1)
#     else:
#         l, r = 1, n
#         a = []
#         for i in range(2 * k):
#             if i % 2 == 0:
#                 a.append(l)
#                 l += 1
#             else:
#                 a.append(r)
#                 r -= 1
#         for i in range(r, l - 1, -1):
#             a.append(i)
#         print(*a)

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))
#     x = a[0]
#     for i in range(n):
#         x &= a[i]
#     cnt = 0
#     for i in range(n):
#         if a[i] == x:
#             cnt += 1
#     if cnt < 2:
#         print(0)
#     else:
#         ans = cnt * (cnt - 1)
#         mod = 10 ** 9 + 7
#         for i in range(1, n - 1):
#             ans = ans * i % mod
#         print(ans)

# mod = 10 ** 9 + 7
# ans = [[0] * 200020 for _ in range(10)]
# ans[0][0] = 1
# for j in range(200019):
#     for i in range(9):
#         ans[i + 1][j + 1] = ans[i][j]
#     ans[0][j + 1] = (ans[0][j + 1] + ans[9][j]) % mod
#     ans[1][j + 1] = (ans[1][j + 1] + ans[9][j]) % mod

# for _ in range(int(input())):
#     n, m = list(map(int, input().split()))
#     res = 0
#     while n:
#         x = n % 10
#         for i in range(10):
#             res += ans[i][m + x]
#         n //= 10
#     print(res % mod)
    
for _ in range(int(input())):
    n, p = list(map(int, input().split()))
    a = list(map(int, input().split()))
    id = [i for i in range(n)]
    id.sort(key=lambda x : a[x])
    vis = [0] * n
    ans = p * (n - 1)
    for i in range(n):
        x = id[i]
        if a[x] >= p: break
        if vis[x] == 1: continue
        vis[x] = 1
        l = x - 1
        r = x + 1
        while r < n and a[r] % a[x] == 0 and vis[r] == 0:
            vis[r] = 1
            r += 1
        while l >= 0 and a[l] % a[x] == 0 and vis[l] == 0:
            vis[l] = 1
            l -= 1
        if r > x + 1:
            vis[r - 1] = 0
        if l < x - 1:
            vis[l + 1] = 0
        ans -= (r - l - 2) * (p - a[x])
    print(ans)","['constructive algorithms', 'dsu', 'graphs', 'greedy', 'number theory', 'sortings']"
"You are given an integer $$$n$$$. You have to apply $$$m$$$ operations to it.In a single operation, you must replace every digit $$$d$$$ of the number with the decimal representation of integer $$$d + 1$$$. For example, $$$1912$$$ becomes $$$21023$$$ after applying the operation once.You have to find the length of $$$n$$$ after applying $$$m$$$ operations. Since the answer can be very large, print it modulo $$$10^9+7$$$.","import sys
testing = len(sys.argv) == 4 and sys.argv[3] == ""myTest""
if testing:
    cmd = sys.stdout
    from time import time
    start_time = int(round(time() * 1000)) 
    readAll = open(sys.argv[1], 'r').read
    sys.stdout = open(sys.argv[2], 'w')
else:
    readAll = sys.stdin.read

# ############ ---- I/O Functions ---- ############

flush = sys.stdout.flush
class InputData:
    def __init__(self):
        self.lines = readAll().split('\n')
        self.n = len(self.lines)
        self.ii = -1
    def input(self):
        self.ii += 1
        assert self.ii < self.n
        return self.lines[self.ii]
inputData = InputData()
input = inputData.input

def intin():
    return(int(input()))
def intlin():
    return(list(map(int,input().split())))
def chrin():
    return(list(input()))
def strin():
    return input()
def lout(l, sep=""\n"", toStr=True):
    print(sep.join(map(str, l) if toStr else l))
def dout(*args, **kargs):
    if not testing: return
    if args: print(args[0] if len(args)==1 else args)
    if kargs: print([(k,v) for k,v in kargs.items()])
    
# ############ ---- I/O Functions ---- ############

# from math import ceil
from collections import defaultdict as ddict, Counter
# from heapq import *
# from Queue import Queue
mmap = [0]*(2*10**5+100)
mod = 10**9+7
cnts = [0]*10
k = 0
cnts[k] = 1
for i in xrange(1,2*10**5+100):
    prv = cnts[0]
    for j in xrange(9):
        nxt = cnts[j+1]
        cnts[j+1] = prv
        prv = nxt
    cnts[0] = prv
    cnts[1] = (prv+cnts[1])%mod
    mmap[i] = (sum(cnts))%mod

def main():
    n,m = intlin()
    ans = 0
    # cnts = Counter(map(int,(list(str(n)))))
    # for i in xrange(10):
    #     ans += mmap[m+i]*cnts[i]
    while n > 0:
        ans += mmap[m+n%10]
        n /= 10
    return(ans%mod)

anss = []
for _ in xrange(intin()):
    anss.append(main())
    # anss.append(""YES"" if main() else ""NO"")
lout(anss)

if testing:
    sys.stdout = cmd
    print(int(round(time() * 1000))  - start_time)","['dp', 'matrices']"
"Vasya has his favourite number $$$n$$$. He wants to split it to some non-zero digits. It means, that he wants to choose some digits $$$d_1, d_2, \ldots, d_k$$$, such that $$$1 \leq d_i \leq 9$$$ for all $$$i$$$ and $$$d_1 + d_2 + \ldots + d_k = n$$$.Vasya likes beauty in everything, so he wants to find any solution with the minimal possible number of different digits among $$$d_1, d_2, \ldots, d_k$$$. Help him!","n = int(input())
print(n)
for i in range(n):
    print('1',end = ' ')","['constructive algorithms', 'implementation', 'math']"
"Ibti was thinking about a good title for this problem that would fit the round theme (numerus ternarium). He immediately thought about the third derivative, but that was pretty lame so he decided to include the best band in the world — Three Days Grace.You are given a multiset $$$A$$$ with initial size $$$n$$$, whose elements are integers between $$$1$$$ and $$$m$$$. In one operation, do the following:   select a value $$$x$$$ from the multiset $$$A$$$, then  select two integers $$$p$$$ and $$$q$$$ such that $$$p, q &gt; 1$$$ and $$$p \cdot q = x$$$. Insert $$$p$$$ and $$$q$$$ to $$$A$$$, delete $$$x$$$ from $$$A$$$. Note that the size of the multiset $$$A$$$ increases by $$$1$$$ after each operation. We define the balance of the multiset $$$A$$$ as $$$\max(a_i) - \min(a_i)$$$. Find the minimum possible balance after performing any number (possible zero) of operations.","from sys import stdin
input=lambda :stdin.readline()[:-1]

def solve():
  n,m=map(int,input().split())
  a=list(set(map(int,input().split())))
  n=len(a)
  exist=[0]*(m+1)
  for i in a:
    exist[i]=1
  dp=list(range(m+1))
  cnt=0
  ans=10**9
  mx_cnt=[0]*(m+1)
  mx=m
  for i in range(m,0,-1):
    if exist[i]:
      cnt+=1
      mx_cnt[i]+=1
    for j in range(i*i,m+1,i):
      y=dp[j//i]
      if y<dp[j]:
        if exist[j]:
          mx_cnt[dp[j]]-=1
          mx_cnt[y]+=1
        dp[j]=y
    if cnt==n:
      while mx_cnt[mx]==0:
        mx-=1
      ans=min(ans,mx-i)
  print(ans)      

for _ in range(int(input())):
  solve()","['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']"
"Немногие знают, что сотрудники ВКонтакте могут менять цвет подсветки в куполе знаменитого Дома Зингера, где расположена штаб-квартира ВКонтакте. Для этого нужно всего лишь отправить сообщение с цветом в специальный чат «Зингер | color», а бот его распознает и сменит подсветку. При этом на время городских мероприятий смена цвета блокируется.Формально, бот обрабатывает три типа сообщений:   lock: заблокировать изменение цвета. Если оно и так заблокировано на данный момент, сообщение игнорируется.  unlock: разблокировать изменение цвета. Если оно и так разблокировано на данный момент, сообщение игнорируется.  red / orange / yellow / green / blue / indigo / violet: изменить цвет купола на заданный, если изменение цвета на данный момент не заблокировано. Вам дана история сообщений, полученных ботом, в хронологическом порядке. Считайте, что перед получением первого сообщения купол подсвечивается голубым (blue), а изменение цвета не заблокировано.В качестве эксперимента было решено поддержать в боте эффективную обработку редактирования сообщений. Вам дана последовательность пар вида $$$(i, msg)$$$, означающих, что $$$i$$$-е в хронологическом порядке сообщение было отредактировано и теперь имеет вид $$$msg$$$. Обратите внимание, что редактироваться может любое сообщение, и при редактировании сообщения бот должен обработать всю историю сообщений заново (в частности, перед обработкой первого сообщения цвет купола голубой, а изменение цвета не заблокировано).Определите, какой цвет будет у купола Дома Зингера до первой операции редактирования, а также после каждой операции редактирования.","from heapq import heapify, heappop, heappush
from sys import stdin, stdout
from typing import List, TextIO


class MinSegmentTree:
    def __init__(self, vals: List[int], max_val: int):
        n = len(vals)
        self.bits = (n - 1).bit_length()
        self.width = 2 ** self.bits
        self.nodes = vals.copy()
        self.nodes += [max_val] * (self.width - n)
        layer_shift = 0
        layer_width = self.width
        for _ in range(self.bits):
            self.nodes.extend(
                min(
                    self.nodes[layer_shift + i * 2], self.nodes[layer_shift + i * 2 + 1]
                )
                for i in range(layer_width >> 1)
            )
            layer_shift += layer_width
            layer_width >>= 1

    def __repr__(self) -> str:
        return repr(self.nodes[: self.width])

    def change(self, i: int, val: int):
        self.nodes[i] = val
        layer_shift = 0
        layer_width = self.width
        for _ in range(self.bits):
            i >>= 1
            self.nodes[layer_shift + layer_width + i] = min(
                self.nodes[layer_shift + i * 2], self.nodes[layer_shift + i * 2 + 1]
            )
            layer_shift += layer_width
            layer_width >>= 1

    def min(self, a: int, b: int, default: int):
        m = default
        layer_shift = 0
        layer_width = self.width
        while a < b:
            if a % 2:
                m = min(self.nodes[layer_shift + a], m)
            if b % 2:
                m = min(self.nodes[layer_shift + b - 1], m)
            a = (a + 1) >> 1
            b >>= 1
            layer_shift += layer_width
            layer_width >>= 1
        return m


class MaxSegmentTree:
    def __init__(self, vals: List[int], min_val: int):
        self.min_tree = MinSegmentTree([-v for v in vals], -min_val)

    def __repr__(self) -> str:
        return repr(self.min_tree)

    def change(self, i: int, val: int):
        self.min_tree.change(i, -val)

    def max(self, a: int, b: int, default: int):
        return -self.min_tree.min(a, b, default)


def get_color(
    cmds: List[str], unlocks: List[int], locks: MinSegmentTree, colors: MaxSegmentTree
):
    n = len(cmds)
    return cmds[colors.max(-unlocks[0] + 1, locks.min(-unlocks[0] + 2, n, n), 1)]


def solve(fin: TextIO, fout: TextIO):
    n = int(fin.readline())
    cmds = [""unlock"", ""blue""] + [fin.readline().rstrip() for _ in range(n)] + [""lock""]
    n += 3
    unlocks = [
        -i
        for i, (cmd, next_cmd) in enumerate(zip(cmds, cmds[1:]))
        if cmd == ""unlock"" and next_cmd not in [""lock"", ""unlock""]
    ]
    heapify(unlocks)
    locks = MinSegmentTree(
        [i if cmd == ""lock"" else n - 1 for i, cmd in enumerate(cmds)], n - 1
    )
    colors = MaxSegmentTree(
        [i if cmd not in [""lock"", ""unlock""] else 1 for i, cmd in enumerate(cmds)], 1
    )
    color = get_color(cmds, unlocks, locks, colors)
    fout.write(f""{color}\n"")

    fin.readline()
    for chcmd in fin:
        pos, cmd = chcmd.split()
        i = int(pos) + 1
        if cmds[i] != cmd:
            if cmd == ""lock"":
                locks.change(i, i)
                if cmds[i] not in [""lock"", ""unlock""]:
                    colors.change(i, 1)
            elif cmd == ""unlock"":
                if cmds[i] == ""lock"":
                    locks.change(i, n - 1)
                if cmds[i] not in [""lock"", ""unlock""]:
                    colors.change(i, 1)
                if cmds[i + 1] not in [""lock"", ""unlock""]:
                    heappush(unlocks, -i)
            else:
                if cmds[i] == ""lock"":
                    locks.change(i, n - 1)
                if cmds[i] in [""lock"", ""unlock""]:
                    colors.change(i, i)
                if cmds[i - 1] == ""unlock"":
                    heappush(unlocks, -(i - 1))
            cmds[i] = cmd
            last_unlock = -unlocks[0]
            while cmds[last_unlock] != ""unlock"" or cmds[last_unlock + 1] in [
                ""lock"",
                ""unlock"",
            ]:
                heappop(unlocks)
                last_unlock = -unlocks[0]
            color = get_color(cmds, unlocks, locks, colors)
        fout.write(f""{color}\n"")


if __name__ == ""__main__"":
    solve(stdin, stdout)","['*special', '*special']"
"Рассмотрим следующий код сортировки слиянием на языке Python: def sort(a):  n = len(a)  b = [0 for i in range(n)]  log = []  def mergeSort(l, r):    if r - l &lt;= 1:      return    m = (l + r) &gt;&gt; 1    mergeSort(l, m)    mergeSort(m, r)    i, j, k = l, m, l    while i &lt; m and j &lt; r:      if a[i] &lt; a[j]:        log.append('0')        b[k] = a[i]        i += 1      else:        log.append('1')        b[k] = a[j]        j += 1      k += 1    while i &lt; m:      b[k] = a[i]      i += 1      k += 1    while j &lt; r:      b[k] = a[j]      j += 1      k += 1    for p in range(l, r):      a[p] = b[p]  mergeSort(0, n)  return """".join(log)Как можно заметить, этот код использует логирование — важнейший инструмент разработки.Старший разработчик ВКонтакте Вася сгенерировал перестановку $$$a$$$ (массив из $$$n$$$ различных целых чисел от $$$1$$$ до $$$n$$$), дал её на вход функции sort и получил на выходе строку $$$s$$$. На следующий день строку $$$s$$$ Вася нашёл, а перестановка $$$a$$$ потерялась. Вася хочет восстановить любую перестановку $$$a$$$ такую, что вызов функции sort от неё даст ту же строку $$$s$$$. Помогите ему!","from collections import deque
from math import log

ptr = None
def restore(a, trace):
  global ptr
  n = len(a)
  b = [0 for i in range(n)]

  def mergeSort(l, r):
    if r - l <= 1:
      return

    global ptr
    m = (l + r) >> 1
    mergeSort(l, m)
    mergeSort(m, r)
    i, j, k = l, m, l
    while i < m and j < r:
      if trace[ptr] == '0':
        b[k] = a[i]
        i += 1
      else:
        b[k] = a[j]
        j += 1
      k += 1
      ptr += 1
    while i < m:
      b[k] = a[i]
      i += 1
      k += 1
    while j < r:
      b[k] = a[j]
      j += 1
      k += 1
    for p in range(l, r):
      a[p] = b[p]

  ptr = 0
  mergeSort(0, n)

  return len(trace) == ptr, a
    

trace = input()

flag = False
l, u = max(int(log(len(trace), 2)), 2), 10**5
while u - l >= 3 and not flag:
    m = (l + u)//2
    try:
        flag, p = restore([i for i in range(m)], trace)
        l = m
    except:
        flag = False
        u = m

if not flag:
    n = l
    while not flag and n <= u:
        try:
            flag, p = restore([i for i in range(n)], trace)
        except:
            flag = False
        n += 1

A = [None] * len(p)
for i in range(len(p)):
    A[p[i]] = i + 1

print(len(A))
print("" "".join(str(a) for a in A))","['*special', 'binary search']"
"Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given $$$n$$$ days from Petya's live and you have to determine what happened with his flower in the end.The flower grows as follows:   If the flower isn't watered for two days in a row, it dies.  If the flower is watered in the $$$i$$$-th day, it grows by $$$1$$$ centimeter.  If the flower is watered in the $$$i$$$-th and in the $$$(i-1)$$$-th day ($$$i &gt; 1$$$), then it grows by $$$5$$$ centimeters instead of $$$1$$$.  If the flower is not watered in the $$$i$$$-th day, it does not grow. At the beginning of the $$$1$$$-st day the flower is $$$1$$$ centimeter tall. What is its height after $$$n$$$ days?","n=int(input())
 
for i in range(n):
    m=int(input())
    
    Flag=False


    a=list(map(int,input().split()))

    if a[0]==1:
        hight=2
    else:
        hight=1

    for j in range(1,len(a)):
        if a[j-1]==1 and a[j]==0:
            
            hight+=0
        elif a[j-1]==0 and a[j]==1:

            hight+=1
        elif a[j-1]==1 and a[j]==1:

            hight+=5
        elif a[j-1]==0 and a[j]==0:
            
            Flag=True
            break
    if Flag==True:
        hight=-1
    print(hight)",['implementation']
"You are given an array $$$a$$$ of $$$n$$$ integers and a set $$$B$$$ of $$$m$$$ positive integers such that $$$1 \leq b_i \leq \lfloor \frac{n}{2} \rfloor$$$ for $$$1\le i\le m$$$, where $$$b_i$$$ is the $$$i$$$-th element of $$$B$$$. You can make the following operation on $$$a$$$:  Select some $$$x$$$ such that $$$x$$$ appears in $$$B$$$. Select an interval from array $$$a$$$ of size $$$x$$$ and multiply by $$$-1$$$ every element in the interval. Formally, select $$$l$$$ and $$$r$$$ such that $$$1\leq l\leq r \leq n$$$ and $$$r-l+1=x$$$, then assign $$$a_i:=-a_i$$$ for every $$$i$$$ such that $$$l\leq i\leq r$$$. Consider the following example, let $$$a=[0,6,-2,1,-4,5]$$$ and $$$B=\{1,2\}$$$:  $$$[0,6,-2,-1,4,5]$$$ is obtained after choosing size $$$2$$$ and $$$l=4$$$, $$$r=5$$$. $$$[0,6,2,-1,4,5]$$$ is obtained after choosing size $$$1$$$ and $$$l=3$$$, $$$r=3$$$. Find the maximum $$$\sum\limits_{i=1}^n {a_i}$$$ you can get after applying such operation any number of times (possibly zero).","from __future__ import division, print_function

import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip

from bisect import bisect_left as lower_bound, bisect_right as upper_bound 
def so():  return int(input())
def st():  return input()
def mj():  return map(int,input().strip().split("" ""))
def msj(): return list(map(str,input().strip().split("" "")))
def le():  return list(map(int,input().split()))
def rc():  return map(float,input().split())
def lebe():return list(map(int, input()))

def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
def joro(L):
    return(''.join(map(str, L)))


def decimalToBinary(n): return bin(n).replace(""0b"","""")


def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True
def npr(n, r):
    return factorial(n) // factorial(n - r) if n >= r else 0
 
 
def ncr(n, r):
    import math as my
    return my.factorial(n) // (my.factorial(r) * my.factorial(n - r)) if n >= r else 0
 
 
def lower_bound(li, num):
    answer = -1
    start = 0
    end = len(li) - 1
 
    while (start <= end):
        middle = (end + start) // 2
        if li[middle] >= num:
            answer = middle
            end = middle - 1
        else:
            start = middle + 1
    return answer  # min index where x is not less than num
 
 
def upper_bound(li, num):
    answer = -1
    start = 0
    end = len(li) - 1
 
    while (start <= end):
        middle = (end + start) // 2
 
        if li[middle] <= num:
            answer = middle
            start = middle + 1
 
        else:
            end = middle - 1
    return answer  # max index where x is not greater than num
def tir(a,b,c):
    if(0==c):
        return 1
    if(len(a)<=b):
        return 0
    
    if(c!=-1):
        return (tir(a,1+b,c+a[b]) or tir(a,b+1,c-a[b]) or tir(a,1+b,c)) 
        
        
    else:
        return (tir(a,1+b,a[b]) or tir(a,b+1,-a[b]) or tir(a,1+b,-1))
hoi=int(2**20)        
 
def abs(x):
    return x if x >= 0 else -x
 
 
def binary_search(li, val, lb, ub):
    # print(lb, ub, li)
    ans = -1
    while (lb <= ub):
        mid = (lb + ub) // 2
        # print('mid is',mid, li[mid])
        if li[mid] > val:
            ub = mid - 1
        elif val > li[mid]:
            lb = mid + 1
        else:
            ans = mid  # return index
            break
    return ans
 
 
def kadane(x):  # maximum sum contiguous subarray
    sum_so_far = 0
    current_sum = 0
    for i in x:
        current_sum += i
        if current_sum < 0:
            current_sum = 0
        else:
            sum_so_far = max(sum_so_far, current_sum)
    return sum_so_far

                    
def pref(li):
    pref_sum = [0]
    for i in li:
        pref_sum.append(pref_sum[-1] + i)
    return pref_sum
def gosa(a,b):
    if(b==0):
        return a
    else:
        return gosa(b,a%b) 

        
        
def SieveOfEratosthenes(n):
    prime = [True for i in range(n + 1)]
    p = 2
    li = []
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
 
    for p in range(2, len(prime)):
        if prime[p]:
            li.append(p)
    return li
 
 
def primefactors(n):
    factors = []
    while (n % 2 == 0):
        factors.append(2)
        n //= 2
    for i in range(3, int(sqrt(n)) + 1, 2):  # only odd factors left
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:  # incase of prime
        factors.append(n)
    return factors
         
    
def read():
    sys.stdin  = open('input.txt', 'r')  
    sys.stdout = open('output.txt', 'w') 
def tr(n):
    return n*(n+1)//2
boi=int(1e9-7)
doi=int(1e9+7)
hoi=int(100+1e6)
y=""Yes""
n=""No""
x=[0]*hoi
y=[0]*hoi
def cal(jp,op,u):
    re=0
    te=1
    while(te<=op):
        z=0
        p=int(2e9)
        ad=0
        for i in range(te,jp+1,op):
            if(0>x[i]):
                z=z^1
            ad=abs(x[i])+ad
            p=min(abs(x[i]),p)
        if(0!=z^u):
            ad=-2*p+ad
        re=ad+re
        te=1+te
    return re

    
    
    

def iu():
    import sys
    import math as my
    input=sys.stdin.readline
    from collections import deque, defaultdict
    jp,kp=mj()
    
    L=le()
    M=le()
    for i in range(1+jp):
        x[i]=L[i-1]
    op=0
    for i in range(1+kp):
        y[i]=M[i-1]
        op=gosa(y[i],op)
    opp=max(cal(jp,op,0),cal(jp,op,1))
    print(opp)
def main():
    for i in range(so()):
        iu()
    

    
        
        
            
    
    
                
            
                
                
                
                
            
    
            
            
    
    
    
    
        
            
    
           
            
            
        
    
        
    
    
        
        
        

            
                    
                
                    
                    
                    
                    
                    
                    
        
                
        
        
       
    
           
          
          
                
            
        
                
    
        
        
        
       
            
                
        




# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion


if __name__ == ""__main__"":
    #read()
    main()
    #dmain()

# Comment Read()","['dp', 'greedy', 'number theory']"
"You are living on an infinite plane with the Cartesian coordinate system on it. In one move you can go to any of the four adjacent points (left, right, up, down).More formally, if you are standing at the point $$$(x, y)$$$, you can:   go left, and move to $$$(x - 1, y)$$$, or  go right, and move to $$$(x + 1, y)$$$, or  go up, and move to $$$(x, y + 1)$$$, or  go down, and move to $$$(x, y - 1)$$$. There are $$$n$$$ boxes on this plane. The $$$i$$$-th box has coordinates $$$(x_i,y_i)$$$. It is guaranteed that the boxes are either on the $$$x$$$-axis or the $$$y$$$-axis. That is, either $$$x_i=0$$$ or $$$y_i=0$$$.You can collect a box if you and the box are at the same point. Find the minimum number of moves you have to perform to collect all of these boxes if you have to start and finish at the point $$$(0,0)$$$.","import sys
raw_input = iter(sys.stdin.read().splitlines()).next

def solution():
    n = int(raw_input())
    points = [map(int, raw_input().split()) for _ in xrange(n)]
    return 2*((max(max(x for x, _ in points), 0)-min(min(x for x, _ in points), 0))+\
              (max(max(y for _, y in points), 0)-min(min(y for _, y in points), 0)))

for case in xrange(int(raw_input())):
    print '%s' % solution()","['geometry', 'greedy', 'implementation']"
"Monocarp has forgotten the password to his mobile phone. The password consists of $$$4$$$ digits from $$$0$$$ to $$$9$$$ (note that it can start with the digit $$$0$$$).Monocarp remembers that his password had exactly two different digits, and each of these digits appeared exactly two times in the password. Monocarp also remembers some digits which were definitely not used in the password.You have to calculate the number of different sequences of $$$4$$$ digits that could be the password for Monocarp's mobile phone (i. e. these sequences should meet all constraints on Monocarp's password).","t = int(input())

for _ in range(t):
    n = int(input())
    a = [int(x) for x in input().split()]
    alen = 10 - n
    ans = int(6 * alen * (alen-1) /2)
    print(ans)","['brute force', 'combinatorics', 'implementation', 'math']"
"You are given a string $$$s$$$ consisting of $$$n$$$ characters. Each character of $$$s$$$ is either 0 or 1.A substring of $$$s$$$ is a contiguous subsequence of its characters.You have to choose two substrings of $$$s$$$ (possibly intersecting, possibly the same, possibly non-intersecting — just any two substrings). After choosing them, you calculate the value of the chosen pair of substrings as follows:  let $$$s_1$$$ be the first substring, $$$s_2$$$ be the second chosen substring, and $$$f(s_i)$$$ be the integer such that $$$s_i$$$ is its binary representation (for example, if $$$s_i$$$ is 11010, $$$f(s_i) = 26$$$);  the value is the bitwise OR of $$$f(s_1)$$$ and $$$f(s_2)$$$. Calculate the maximum possible value you can get, and print it in binary representation without leading zeroes.","n = int(input())
s = input()
s = list(s)
i = 0
while s[i] == '0':
    i += 1
    if i == n:
        break
if i == n:
    print(0)
else:
    s = s[i:]
    n = len(s)
    ans = [i for i in s]
    i = 0
    o = 0
    while s[i] == '1':
        o += 1
        i += 1
    if o == 0:
        print('0')
    else:
        ones = [j for j in range(1, o+1)]
        while i < n and len(ones) > 0:
            if s[i] == '0':
                tmp = []
                for j in ones:
                    if s[i - j] == '1':
                        tmp.append(j)
                if len(tmp) > 0:
                    ans[i] = '1'
                    ones = tmp
            i += 1
        anss = ''
        for i in ans:
            anss += i
        print(anss)","['brute force', 'dp', 'greedy', 'probabilities']"
"Alice has an empty grid with $$$n$$$ rows and $$$m$$$ columns. Some of the cells are marked, and no marked cells are adjacent to the edge of the grid. (Two squares are adjacent if they share a side.) Alice wants to fill each cell with a number such that the following statements are true:   every unmarked cell contains either the number $$$1$$$ or $$$4$$$;  every marked cell contains the sum of the numbers in all unmarked cells adjacent to it (if a marked cell is not adjacent to any unmarked cell, this sum is $$$0$$$);  every marked cell contains a multiple of $$$5$$$.  Alice couldn't figure it out, so she asks Bob to help her. Help Bob find any such grid, or state that no such grid exists.","#!/usr/bin/env python3
import sys
import getpass  # not available on codechef
import math, random
import functools, itertools, collections, heapq, bisect
from collections import Counter, defaultdict, deque
input = sys.stdin.readline  # to read input quickly

# import io, os  # if all integers, otherwise need to post process
# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

# available on Google, AtCoder Python3, not available on Codeforces
# import numpy as np
# import scipy

M9 = 10**9 + 7  # 998244353
yes, no = ""YES"", ""NO""
d4 = [(1,0),(0,1),(-1,0),(0,-1)]
# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]
# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout
MAXINT = sys.maxsize

# if testing locally, print to terminal with a different color
OFFLINE_TEST = getpass.getuser() == ""hkmac""
# OFFLINE_TEST = False  # codechef does not allow getpass
def log(*args):
    if OFFLINE_TEST:
        print('\033[36m', *args, '\033[0m', file=sys.stderr)

def solve(*args):
    # screen input
    if OFFLINE_TEST:
        log(""----- solving ------"")
        log(*args)
        log(""----- ------- ------"")
    return solve_(*args)

def read_matrix(nrows):
    return [list(map(int,input().split())) for _ in range(nrows)]

def read_matrix_and_flatten(nrows):
    return [int(x) for i in range(nrows) for x in input().split()]

def read_strings(nrows):
    return [input().strip() for _ in range(nrows)]

def minus_one(arr):
    return [x-1 for x in arr]

def minus_one_matrix(mrr):
    return [[x-1 for x in row] for row in mrr]

# ---------------------------- template ends here ----------------------------

def isBipartite(edges) -> bool:
    g = defaultdict(set)
    for cur,nex in edges:
        g[cur].add(nex)
        g[nex].add(cur)

    colored = {}  # and visited

    for start in g:
        if start in colored:
            continue
        stack = [(start,True)]
        colored[start] = True

        while stack:
            cur, color = stack.pop()
            for nex in g[cur]:
                if nex in colored:
                    if colored[nex] == color:
                        return False
                    continue
                stack.append((nex, not color))
                colored[nex] = not color

    return True, colored

def solve_(arr,h,w):
    # your solution here
    res = [[1 for _ in row] for row in arr]

    edges = []
    diamonds = {}

    for x,row in enumerate(arr):
        for y,cell in enumerate(row):
            if cell == 1:
                adj = []
                for dx,dy in d4:
                    xx,yy = x+dx, y+dy
                    if 0 <= xx < h and 0 <= yy < w:
                        if arr[xx][yy] == 0:
                            adj.append((xx,yy))
                if len(adj)%2 != 0:
                    return -1
                if len(adj) == 2:
                    edges.append(adj)
                if len(adj) == 4:
                    adj[0],adj[2]=adj[2],adj[0]
                    diamonds[x,y] = adj
                    edges.append(adj[:2])
                    edges.append(adj[2:])
                res[x][y] = len(adj)//2 * 5

    is_bipartite, colored = isBipartite(edges)
    if not is_bipartite:
        return -1

    #log(edges)
    #log(diamonds)
    #log(colored)

    for (x,y), c in colored.items():
        if c:
            res[x][y] = 4
        else:
            res[x][y] = 1

    return res


for case_num in [0]:  # no loop over test case
# for case_num in range(100):  # if the number of test cases is specified
# for case_num in range(int(input())):

    # read line as an integer
    # k = int(input())

    # read line as a string
    # srr = input().strip()

    # read one line and parse each word as a string
    # lst = input().split()

    # read one line and parse each word as an integer
    h,w = list(map(int,input().split()))
    # arr = list(map(int,input().split()))
    # arr = minus_one(arr)

    # read multiple rows
    arr = read_strings(h)  # and return as a list of str
    # mrr = read_matrix(k)  # and return as a list of list of int
    # arr = read_matrix(k)  # and return as a list of list of int
    # mrr = minus_one_matrix(mrr)

    arr = [[1 if c == ""X"" else 0 for c in row] for row in arr]

    res = solve(arr,h,w)  # include input here

    # print length if applicable
    # print(len(res))
    log(""res"", res)

    if res == -1:
        print(no)
        continue
    print(yes)

    # parse result
    # res = "" "".join(str(x) for x in res)
    # res = ""\n"".join(str(x) for x in res)
    res = ""\n"".join("" "".join(str(x) for x in row) for row in res)

    # print result
    # print(""Case #{}: {}"".format(case_num+1, res))   # Google and Facebook - case number required

    print(res)","['2-sat', 'constructive algorithms', 'dfs and similar', 'dsu', 'graphs', 'implementation']"
"You are given three integers $$$a$$$, $$$b$$$ and $$$c$$$.Find two positive integers $$$x$$$ and $$$y$$$ ($$$x &gt; 0$$$, $$$y &gt; 0$$$) such that:   the decimal representation of $$$x$$$ without leading zeroes consists of $$$a$$$ digits;  the decimal representation of $$$y$$$ without leading zeroes consists of $$$b$$$ digits;  the decimal representation of $$$gcd(x, y)$$$ without leading zeroes consists of $$$c$$$ digits. $$$gcd(x, y)$$$ denotes the greatest common divisor (GCD) of integers $$$x$$$ and $$$y$$$.Output $$$x$$$ and $$$y$$$. If there are multiple answers, output any of them.","def func_gcd(a,b):
	if b==0:
		return a
	return func_gcd(b, a%b)

T = int(input())
for t in range(T):
	a, b, c = map(int, input().split())
	x_arr = [""1""] + [""0""]*(a-1)
	y_arr = [""1""]*(b-c+1) + [""0""]*(c-1)
	
	x = """"
	y = """"
	for elem in x_arr:
		x += elem
	for elem in y_arr:
		y += elem
	print(x, y)","['constructive algorithms', 'math', 'number theory']"
"CQXYM is counting permutations length of $$$2n$$$.A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).A permutation $$$p$$$(length of $$$2n$$$) will be counted only if the number of $$$i$$$ satisfying $$$p_i&lt;p_{i+1}$$$ is no less than $$$n$$$. For example:  Permutation $$$[1, 2, 3, 4]$$$ will count, because the number of such $$$i$$$ that $$$p_i&lt;p_{i+1}$$$ equals $$$3$$$ ($$$i = 1$$$, $$$i = 2$$$, $$$i = 3$$$). Permutation $$$[3, 2, 1, 4]$$$ won't count, because the number of such $$$i$$$ that $$$p_i&lt;p_{i+1}$$$ equals $$$1$$$ ($$$i = 3$$$). CQXYM wants you to help him to count the number of such permutations modulo $$$1000000007$$$ ($$$10^9+7$$$).In addition, modulo operation is to get the remainder. For example:  $$$7 \mod 3=1$$$, because $$$7 = 3 \cdot 2 + 1$$$,  $$$15 \mod 4=3$$$, because $$$15 = 4 \cdot 3 + 3$$$.","mod = (10**9)+7
 
def fact( n ):
    f = 1
    for i in range( 3 , n+1):
        f = (f* i) % mod
    return f
 
for _ in range(int(input())):
    a = int(input()) * 2
    print(  fact(a)  )","['combinatorics', 'math', 'number theory']"
"This is an easy version of the problem. The only difference between an easy and a hard version is in the number of queries.Polycarp grew a tree from $$$n$$$ vertices. We remind you that a tree of $$$n$$$ vertices is an undirected connected graph of $$$n$$$ vertices and $$$n-1$$$ edges that does not contain cycles.He calls a set of vertices passable if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice. The path can visit other vertices (not from this set).In other words, a set of vertices is called passable if there is a simple path that passes through all the vertices of this set (and possibly some other).For example, for a tree below sets $$$\{3, 2, 5\}$$$, $$$\{1, 5, 4\}$$$, $$$\{1, 4\}$$$ are passable, and $$$\{1, 3, 5\}$$$, $$$\{1, 2, 3, 4, 5\}$$$ are not.  Polycarp asks you to answer $$$q$$$ queries. Each query is a set of vertices. For each query, you need to determine whether the corresponding set of vertices is passable.","import sys
from typing import List

input = sys.stdin.readline

class LowestCommonAncestor:
    def __init__(self, n, E):
        assert n >= 1 and len(E) == n - 1
        self.n = n
        self.adj = [[] for _ in range(self.n)]

        for e in E:
            u, v = e
            self.adj[u].append(v)
            self.adj[v].append(u)

        self.sz = 1
        while 1 << self.sz < n:
            self.sz += 1

        self.root = None
        self.depth = [-1 for _ in range(n)]
        self.up = [[-1] * self.sz for _ in range(n)]

    def dfs(self, root):
        stack = [(root, root, 0)]
        while len(stack):
            u, prev, d = stack.pop()
            self.depth[u] = d
            self.up[u][0] = prev
            for v in self.adj[u]:
                if v == prev:
                    continue
                stack.append((v, u, d + 1))

        for j in range(1, self.sz):
            for i in range(1, self.n):
                if self.up[i][j - 1] == -1:
                    continue
                self.up[i][j] = self.up[self.up[i][j - 1]][j - 1]

    def lca(self, u, v):
        if self.depth[u] > self.depth[v]:
            u, v = v, u
        diff = self.depth[v] - self.depth[u]
        for i in reversed(range(self.sz)):
            if diff >> i & 1:
                v = self.up[v][i]

        if u == v:
            return u
        for i in reversed(range(self.sz)):
            pu, pv = self.up[u][i], self.up[v][i]
            if pu != pv:
                u, v = pu, pv
        return self.up[u][0]



def query(LCA, p):
    depth = LCA.depth
    lca = LCA.lca
    p.sort(key=lambda idx: -depth[idx])
    left_chain_deepest = p[0]

    right_chain_deepest = -1
    turning_point = 0
    for x in p:
        if lca(x, left_chain_deepest) != x:
            if right_chain_deepest == -1:
                right_chain_deepest = x
                turning_point = lca(left_chain_deepest, right_chain_deepest)
            else:
                if lca(x, right_chain_deepest) != x:
                    # print(""Third Chain!"")
                    return False

    if right_chain_deepest == -1:
        return True

    if depth[turning_point] > depth[p[-1]]:
        # print(""Turning point(%d), deeper than root(%d)"" % (turning_point + 1, p[-1] + 1))
        return False
    return True

# initialize
n = int(input())
E = []
for i in range(n - 1):
    u, v = map(lambda s: int(s)-1, input().split())
    E.append((u, v))
LCA = LowestCommonAncestor(n, E)
LCA.dfs(1-1)
q = int(input())
for qq in range(q):
    k = int(input())
    *p, = map(lambda s: int(s)-1, input().split())
    print(""YES"" if query(LCA, p) else ""NO"")



# n = 5
# E = [(1, 2), (2, 3), (2, 4), (4, 5)]
# *E2, = map(lambda pair: (pair[0]-1, pair[1]-1), E)
#
# LCA = LowestCommonAncestor(n, E2)
# root = 1
# LCA.dfs(root - 1)
# print(LCA.depth)
#
# q = 5
# arr_k
# for qq in range(q):
#     k = arr_k[qq]","['dfs and similar', 'trees']"
"A class of students got bored wearing the same pair of shoes every day, so they decided to shuffle their shoes among themselves. In this problem, a pair of shoes is inseparable and is considered as a single object.There are $$$n$$$ students in the class, and you are given an array $$$s$$$ in non-decreasing order, where $$$s_i$$$ is the shoe size of the $$$i$$$-th student. A shuffling of shoes is valid only if no student gets their own shoes and if every student gets shoes of size greater than or equal to their size. You have to output a permutation $$$p$$$ of $$$\{1,2,\ldots,n\}$$$ denoting a valid shuffling of shoes, where the $$$i$$$-th student gets the shoes of the $$$p_i$$$-th student ($$$p_i \ne i$$$). And output $$$-1$$$ if a valid shuffling does not exist.A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).","for i in range(int(input())):
	n=int(input())
	s=input().split()
	if n==1:
		print(-1)
	else:
		k=0
		b=[]
		from collections import Counter

		x=Counter(s)
		sorted(x.items())
		for i in x:
			if x[i]==1:
				b=[]
				print(-1)
				break
			else:
				b.append(len(b)+x[i])
				k+=1
				for j in range(x[i]-1):
					if j<x[i]-1:
						b.append(k)
					k+=1
		if len(b)>0:
			b=list(map(str,b))
			print(' '.join(b))","['constructive algorithms', 'greedy', 'implementation', 'two pointers']"
"You are given a tree $$$G$$$ with $$$n$$$ vertices and an integer $$$k$$$. The vertices of the tree are numbered from $$$1$$$ to $$$n$$$.For a vertex $$$r$$$ and a subset $$$S$$$ of vertices of $$$G$$$, such that $$$|S| = k$$$, we define $$$f(r, S)$$$ as the size of the smallest rooted subtree containing all vertices in $$$S$$$ when the tree is rooted at $$$r$$$. A set of vertices $$$T$$$ is called a rooted subtree, if all the vertices in $$$T$$$ are connected, and for each vertex in $$$T$$$, all its descendants belong to $$$T$$$.You need to calculate the sum of $$$f(r, S)$$$ over all possible distinct combinations of vertices $$$r$$$ and subsets $$$S$$$, where $$$|S| = k$$$. Formally, compute the following: $$$$$$\sum_{r \in V} \sum_{S \subseteq V, |S| = k} f(r, S),$$$$$$ where $$$V$$$ is the set of vertices in $$$G$$$.Output the answer modulo $$$10^9 + 7$$$.","import sys
sys.setrecursionlimit(300000)

import faulthandler
faulthandler.enable()

n, k = map(int, input().split())
MOD = 10**9 + 7

fact = [1 for i in range(n+1)]
for i in range(2, n+1):
	fact[i] = i*fact[i-1] % MOD

inv_fact = [1 for i in range(n+1)]
inv_fact[-1] = pow(fact[-1], MOD-2, MOD)
for i in range(1, n):
	inv_fact[n-i] = (n-i+1)*inv_fact[n-i+1] % MOD

def comb(a, b):
	if a < b:
		return 0
	return fact[a]*inv_fact[b]*inv_fact[a-b] % MOD

edges = [[] for i in range(n)]
for _ in range(n-1):
	x, y = map(lambda a: int(a)-1, input().split())
	edges[x].append(y)
	edges[y].append(x)

ends = [[] for i in range(n)]

visited = [0 for i in range(n)]
totals = [1 for i in range(n)]
dfs_stack = [0]

while len(dfs_stack) > 0:
	node = dfs_stack[-1]

	if visited[node] == 1:
		visited[node] = 2

		for next_node in edges[node]:
			if visited[next_node] == 2:
				totals[node] += totals[next_node]
				ends[node].append(totals[next_node])

		ends[node].append(n-totals[node])
		dfs_stack.pop()
	else:
		visited[node] = 1

		for next_node in edges[node]:
			if visited[next_node] == 0:
				dfs_stack.append(next_node)

z = n*n * comb(n, k) % MOD
node_v = [0 for i in range(n)]

for i in range(n):
	node_v[i] = sum(comb(e, k) for e in ends[i]) % MOD

	for e in ends[i]:
		z = (z - e*e * (comb(n-e, k) + comb(e, k) - node_v[i])) % MOD

print(z)","['combinatorics', 'dfs and similar', 'dp', 'math', 'trees']"
"Michael and Joe are playing a game. The game is played on a grid with $$$n$$$ rows and $$$m$$$ columns, filled with distinct integers. We denote the square on the $$$i$$$-th ($$$1\le i\le n$$$) row and $$$j$$$-th ($$$1\le j\le m$$$) column by $$$(i, j)$$$ and the number there by $$$a_{ij}$$$.Michael starts by saying two numbers $$$h$$$ ($$$1\le h \le n$$$) and $$$w$$$ ($$$1\le w \le m$$$). Then Joe picks any $$$h\times w$$$ subrectangle of the board (without Michael seeing).Formally, an $$$h\times w$$$ subrectangle starts at some square $$$(a,b)$$$ where $$$1 \le a \le n-h+1$$$ and $$$1 \le b \le m-w+1$$$. It contains all squares $$$(i,j)$$$ for $$$a \le i \le a+h-1$$$ and $$$b \le j \le b+w-1$$$.    Possible move by Joe if Michael says $$$3\times 2$$$ (with maximum of $$$15$$$). Finally, Michael has to guess the maximum number in the subrectangle. He wins if he gets it right.Because Michael doesn't like big numbers, he wants the area of the chosen subrectangle (that is, $$$h \cdot w$$$), to be as small as possible, while still ensuring that he wins, not depending on Joe's choice. Help Michael out by finding this minimum possible area. It can be shown that Michael can always choose $$$h, w$$$ for which he can ensure that he wins.","class Subrectangle():
    def __init__(self):
        self.create_cases()

    def create_cases(self):
        self.row_col_array = []
        self.subrectangle_array = []
        self.cases_num = int(input())
        for i in range(self.cases_num):
            self.grid_row,self.grid_column = map(int,input().split())
            self.half_grid_row= self.grid_row/2
            self.half_grid_column = self.grid_column/2
            self.max_row = 1
            self.max_column = 1
            for r in range(self.grid_row):
                self.temp_col_el = input()
                self.row_col_array.append(self.temp_col_el.split())
                if r == 0:
                    self.max_point = int(self.row_col_array[r][0])  
                for c in range(self.grid_column):
                    self.row_col_array[r][c] = int(self.row_col_array[r][c])
                    if self.max_point < self.row_col_array[r][c]:
                        self.max_row = r+1
                        self.max_column = c+1
                        self.max_point = self.row_col_array[r][c]
            self.row_col_array.clear()
            if self.max_row > self.half_grid_row and self.max_column > self.half_grid_column:
                self.temp_subrectangle = self.max_row * self.max_column
            elif self.max_row > self.half_grid_row and self.max_column <= self.half_grid_column:
                self.temp_subrectangle = self.max_row * (self.grid_column-self.max_column+1)
            elif self.max_row <= self.half_grid_row and self.max_column <= self.half_grid_column:
                self.temp_subrectangle = (self.grid_row-self.max_row+1) * (self.grid_column-self.max_column+1)
            else:
                self.temp_subrectangle = (self.grid_row-self.max_row+1) * self.max_column
            self.subrectangle_array.append(self.temp_subrectangle)
        
        for i in range(self.cases_num):
            print(self.subrectangle_array[i])

if __name__ == ""__main__"":
    Subrectangle()",['games']
"There are $$$n$$$ houses numbered from $$$1$$$ to $$$n$$$ on a circle. For each $$$1 \leq i \leq n - 1$$$, house $$$i$$$ and house $$$i + 1$$$ are neighbours; additionally, house $$$n$$$ and house $$$1$$$ are also neighbours.Initially, $$$m$$$ of these $$$n$$$ houses are infected by a deadly virus. Each morning, Cirno can choose a house which is uninfected and protect the house from being infected permanently.Every day, the following things happen in order:  Cirno chooses an uninfected house, and protect it permanently.  All uninfected, unprotected houses which have at least one infected neighbor become infected. Cirno wants to stop the virus from spreading. Find the minimum number of houses that will be infected in the end, if she optimally choose the houses to protect.Note that every day Cirno always chooses a house to protect before the virus spreads. Also, a protected house will not be infected forever.","n=int(input())
for i in range(n):
    n_,m=list(map(int,input().split()))
    arr=sorted(list(map(int,input().split())))

    # print(arr)
    arr_=[]

    arr_.append(n_-arr[-1]+arr[0]-1)

    for j in range(m-1):


        arr_.append(arr[j+1]-arr[j]-1)

    arr_.sort(reverse=True)
        # arr_.reverse()

    s=0
    # print(arr_)
    co=0
    for j in arr_:
        
        if j>=4*co+1:
            # print(j)
            # print(arr_)
            if j==(4*co+1):
                s+=1
            else:
                s+=j-(4*co+1)
        else:
            break
        co+=1

    # print(s)
    # if s==0 and m<n_:
    #     s+=1


    print(n_-s)","['greedy', 'implementation', 'sortings']"
"Devu being a small kid, likes to play a lot, but he only likes to play with arrays. While playing he came up with an interesting question which he could not solve, can you please solve it for him?Given an array consisting of distinct integers. Is it possible to partition the whole array into k disjoint non-empty parts such that p of the parts have even sum (each of them must have even sum) and remaining k - p have odd sum? (note that parts need not to be continuous).If it is possible to partition the array, also give any possible way of valid partitioning.","n,k,p=raw_input().strip().split(' ')
n,k,p=int(n),int(k),int(p)
arr=list(map(int,raw_input().strip().split(' ')))
odd=[j for j in arr if j&1]
even=[j for j in arr if not j&1]
if (k-p)>len(odd) or p>len(even)+(len(odd)-k+p)/2 or  len(odd)%2!=(k-p)%2:
		print 'NO'
else:
	print 'YES'
	count,j=0,0
	while j<len(even) and count<p-1:
		print 1,even[j]
		j+=1
		count+=1
	i=1
	while i<len(odd) and count<p-1:
		print 2,odd[i],odd[i-1]
		i+=2
		count+=1
	if count!=p and k-p==0:
		print len(odd[i-1:])+len(even[j:]),
		for i in odd[i-1:]:
			print i,
		for i in even[j:]:
			print i
	elif count!=p:
		if j<len(even):
			print 1,even[j]
			j+=1
		else:
			print 2,odd[i],odd[i-1]
			i+=2
	count=0
	i-=1
	while j<len(even) and i<len(odd) and count<k-p-1:
		print 2,odd[i],even[j]
		i,j,count=i+1,j+1,count+1
	while i<len(odd) and count<k-p-1:
		print 1,odd[i]
		count+=1
		i+=1
	if k-p!=0:
		print len(odd[i:])+len(even[j:]),
		for k in xrange(i,len(odd)):
			print odd[k],
		for t in xrange(j,len(even)):
			print even[t],","['constructive algorithms', 'implementation', 'number theory', 'brute force']"
"Polycarp has invited $$$n$$$ friends to celebrate the New Year. During the celebration, he decided to take a group photo of all his friends. Each friend can stand or lie on the side.Each friend is characterized by two values $$$h_i$$$ (their height) and $$$w_i$$$ (their width). On the photo the $$$i$$$-th friend will occupy a rectangle $$$h_i \times w_i$$$ (if they are standing) or $$$w_i \times h_i$$$ (if they are lying on the side).The $$$j$$$-th friend can be placed in front of the $$$i$$$-th friend on the photo if his rectangle is lower and narrower than the rectangle of the $$$i$$$-th friend. Formally, at least one of the following conditions must be fulfilled:  $$$h_j &lt; h_i$$$ and $$$w_j &lt; w_i$$$ (both friends are standing or both are lying);  $$$w_j &lt; h_i$$$ and $$$h_j &lt; w_i$$$ (one of the friends is standing and the other is lying). For example, if $$$n = 3$$$, $$$h=[3,5,3]$$$ and $$$w=[4,4,3]$$$, then:  the first friend can be placed in front of the second: $$$w_1 &lt; h_2$$$ and $$$h_1 &lt; w_2$$$ (one of the them is standing and the other one is lying);  the third friend can be placed in front of the second: $$$h_3 &lt; h_2$$$ and $$$w_3 &lt; w_2$$$ (both friends are standing or both are lying). In other cases, the person in the foreground will overlap the person in the background.Help Polycarp for each $$$i$$$ find any $$$j$$$, such that the $$$j$$$-th friend can be located in front of the $$$i$$$-th friend (i.e. at least one of the conditions above is fulfilled).Please note that you do not need to find the arrangement of all people for a group photo. You just need to find for each friend $$$i$$$ any other friend $$$j$$$ who can be located in front of him. Think about it as you need to solve $$$n$$$ separate independent subproblems.","def corrPlace(allPoint):
    n = len(allPoint)
    ans = [-1] * n
    allPoint.sort(reverse=True)
    message = [allPoint[-1]]
    for i in range(n-2, -1, -1):
        if message[-1][0] != allPoint[i][0] and message[-1][1] > allPoint[i][1]:
            message.append(allPoint[i])
    cachePlace = len(message)-1
    for imess in allPoint:
        ai = imess[0]
        bi = imess[1]
        while cachePlace != 0 and message[cachePlace][0] >= ai:
            cachePlace -= 1
        if message[cachePlace][0] < ai and message[cachePlace][1] < bi:
            ans[imess[2]-1] = message[cachePlace][2]
    return ans


t = int(input())
for qwq in range(t):
    n = int(input())
    allPoint = []
    for i in range(n):
        l = list(map(int, input().split()))
        allPoint.append((max(l), min(l), i + 1))
    ans = corrPlace(allPoint)
    for i in ans:
        print(i, end=' ')
    print()","['binary search', 'data structures', 'dp', 'sortings', 'two pointers']"
"You are given a string $$$s$$$, consisting of lowercase Latin letters.You are asked $$$q$$$ queries about it: given another string $$$t$$$, consisting of lowercase Latin letters, perform the following steps:  concatenate $$$s$$$ and $$$t$$$;  calculate the prefix function of the resulting string $$$s+t$$$;  print the values of the prefix function on positions $$$|s|+1, |s|+2, \dots, |s|+|t|$$$ ($$$|s|$$$ and $$$|t|$$$ denote the lengths of strings $$$s$$$ and $$$t$$$, respectively);  revert the string back to $$$s$$$. The prefix function of a string $$$a$$$ is a sequence $$$p_1, p_2, \dots, p_{|a|}$$$, where $$$p_i$$$ is the maximum value of $$$k$$$ such that $$$k &lt; i$$$ and $$$a[1..k]=a[i-k+1..i]$$$ ($$$a[l..r]$$$ denotes a contiguous substring of a string $$$a$$$ from a position $$$l$$$ to a position $$$r$$$, inclusive). In other words, it's the longest proper prefix of the string $$$a[1..i]$$$ that is equal to its suffix of the same length.","def get_next(j, k, nxt, p):
    while p[j] != '$':
        if k == -1 or p[j] == p[k]:
            j += 1
            k += 1
            if p[j] == p[k]:
                nxt[j] = nxt[k]
            else:
                nxt[j] = k
        else:
            k = nxt[k]
    return j, k, nxt


def solve():
    s = input().strip()

    len_s = len(s)
    ns = [ch for ch in s]
    for i in range(11):
        ns.append('$')

    # print(ns)
    j, k, nxt = get_next(0, -1, [-1 for i in range(len(ns))], ns)

    q = int(input().strip())
    for _ in range(q):
        t = input().strip()
        ans = []

        for i in range(10):
            ns[i + len_s] = '$'

        for i in range(len(t)):
            ns[i + len_s] = t[i]
            # print(ns)
            nj, nk, n_nxt = get_next(j, k, nxt, ns)
            # print(n_nxt)
            ans.append(n_nxt[len_s + i + 1])
        print(' '.join(map(str, ans)))


if __name__ == '__main__':
    # t = int(input().strip())
    # for _ in range(t):
    solve()","['dfs and similar', 'dp', 'hashing', 'string suffix structures', 'strings', 'trees']"
"You are given an array $$$a_1, a_2, \dots, a_n$$$, which is sorted in non-descending order. You decided to perform the following steps to create array $$$b_1, b_2, \dots, b_n$$$:   Create an array $$$d$$$ consisting of $$$n$$$ arbitrary non-negative integers.  Set $$$b_i = a_i + d_i$$$ for each $$$b_i$$$.  Sort the array $$$b$$$ in non-descending order. You are given the resulting array $$$b$$$. For each index $$$i$$$, calculate what is the minimum and maximum possible value of $$$d_i$$$ you can choose in order to get the given array $$$b$$$.Note that the minimum (maximum) $$$d_i$$$-s are independent of each other, i. e. they can be obtained from different possible arrays $$$d$$$.","import bisect
 
for _ in range(int(input())):
	n=int(input())
	a=list(map(int,input().split()))
	b=list(map(int,input().split()))
	maxis=[]
	minis=[]
	for i in a:
		v=bisect.bisect_left(b,i)
		minis.append(max(0,b[v]-i))
	mx=[i for i in b]
	for i in range(n-2,-1,-1):
		v=bisect.bisect_left(b,a[i+1])
		if i+1!=v:
			mx[i]=mx[i+1]
		else:
			mx[i]=b[i]
	for i in range(n):
		maxis.append(mx[i]-a[i])
	print(*minis)
	print(*maxis)","['binary search', 'greedy', 'two pointers']"
"The robot is placed in the top left corner of a grid, consisting of $$$n$$$ rows and $$$m$$$ columns, in a cell $$$(1, 1)$$$.In one step, it can move into a cell, adjacent by a side to the current one:   $$$(x, y) \rightarrow (x, y + 1)$$$;  $$$(x, y) \rightarrow (x + 1, y)$$$;  $$$(x, y) \rightarrow (x, y - 1)$$$;  $$$(x, y) \rightarrow (x - 1, y)$$$. The robot can't move outside the grid.The cell $$$(s_x, s_y)$$$ contains a deadly laser. If the robot comes into some cell that has distance less than or equal to $$$d$$$ to the laser, it gets evaporated. The distance between two cells $$$(x_1, y_1)$$$ and $$$(x_2, y_2)$$$ is $$$|x_1 - x_2| + |y_1 - y_2|$$$.Print the smallest number of steps that the robot can take to reach the cell $$$(n, m)$$$ without getting evaporated or moving outside the grid. If it's not possible to reach the cell $$$(n, m)$$$, print -1.The laser is neither in the starting cell, nor in the ending cell. The starting cell always has distance greater than $$$d$$$ to the laser.","for i in range(int(input())):
    n,m,sx,sy,d=map(int,input().split())
    if n-sx<=d and sx-1<=d:
        print(-1)
    elif m-sy<=d and sy-1<=d:
        print(-1)
    elif sy-1<=d and sx-1<=d:
        print(-1)
    elif n-sx<=d and m-sy<=d:
        print(-1)
    else:
        print(n+m-2)",['implementation']
"Let's call a sequence of integers $$$x_1, x_2, \dots, x_k$$$ MEX-correct if for all $$$i$$$ ($$$1 \le i \le k$$$) $$$|x_i - \operatorname{MEX}(x_1, x_2, \dots, x_i)| \le 1$$$ holds. Where $$$\operatorname{MEX}(x_1, \dots, x_k)$$$ is the minimum non-negative integer that doesn't belong to the set $$$x_1, \dots, x_k$$$. For example, $$$\operatorname{MEX}(1, 0, 1, 3) = 2$$$ and $$$\operatorname{MEX}(2, 1, 5) = 0$$$.You are given an array $$$a$$$ consisting of $$$n$$$ non-negative integers. Calculate the number of non-empty MEX-correct subsequences of a given array. The number of subsequences can be very large, so print it modulo $$$998244353$$$. Note: a subsequence of an array $$$a$$$ is a sequence $$$[a_{i_1}, a_{i_2}, \dots, a_{i_m}]$$$ meeting the constraints $$$1 \le i_1 &lt; i_2 &lt; \dots &lt; i_m \le n$$$. If two different ways to choose the sequence of indices $$$[i_1, i_2, \dots, i_m]$$$ yield the same subsequence, the resulting subsequence should be counted twice (i. e. two subsequences are different if their sequences of indices $$$[i_1, i_2, \dots, i_m]$$$ are not the same).","import sys
import os
from io import BytesIO, IOBase

# region fastio
# BUFSIZE = 8192
#   
# class FastIO(IOBase):
#     newlines = 0
#   
#     def __init__(self, file):
#         self._fd = file.fileno()
#         self.buffer = BytesIO()
#         self.writable = ""x"" in file.mode or ""r"" not in file.mode
#         self.write = self.buffer.write if self.writable else None
#   
#     def read(self):
#         while True:
#             b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
#             if not b:
#                 break
#             ptr = self.buffer.tell()
#             self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
#         self.newlines = 0
#         return self.buffer.read()
#   
#     def readline(self):
#         while self.newlines == 0:
#             b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
#             self.newlines = b.count(b""\n"") + (not b)
#             ptr = self.buffer.tell()
#             self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
#         self.newlines -= 1
#         return self.buffer.readline()
#   
#     def flush(self):
#         if self.writable:
#             os.write(self._fd, self.buffer.getvalue())
#             self.buffer.truncate(0), self.buffer.seek(0)
#   
# class IOWrapper(IOBase):
#     def __init__(self, file):
#         self.buffer = FastIO(file)
#         self.flush = self.buffer.flush
#         self.writable = self.buffer.writable
#         self.write = lambda s: self.buffer.write(s.encode(""ascii""))
#         self.read = lambda: self.buffer.read().decode(""ascii"")
#         self.readline = lambda: self.buffer.readline().decode(""ascii"")
#  
# if sys.version_info[0] < 3:
#     sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
# else:
#     sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

f = sys.stdin
if os.environ.get('USER') == ""loic"":
    f = open(""data.in"")
    
line = lambda: f.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

def solve():
    
    ones = 0
    sz = N + 2
    dp = [0] * sz
    pref = [0] * sz
    
    for val in A:
        if val == 1:
            ones = (ones * 2 + 1) % M
        
        mex = val
        
        if mex >= 1:
            dp[mex] = (dp[mex] * 2) % M
            dp[mex] = (dp[mex] + pref[mex-1]) % M
            pref[mex] = (pref[mex] * 2) % M
            pref[mex] = (pref[mex] + pref[mex-1]) % M
        else:
            dp[0] = (dp[0] * 2 + 1) % M
            pref[0] = (pref[0] * 2 + 1) % M
         
        if val >= 2:
            mex = val - 2
            dp[mex] = (dp[mex] * 2) % M
    
    
    res = ones
    for i in range(sz):
        res = (res + dp[i]) % M
        
    res %= M
    
    return str(res)

Z = 5 * 10**5
M = 998244353
# POW = power_two(Z)
for test in range(1,ui()+1):
    N = ui()
    A = li()
    
    print(solve())
    
f.close()","['dp', 'math']"
"There is a grid, consisting of $$$n$$$ rows and $$$m$$$ columns. Each cell of the grid is either free or blocked. One of the free cells contains a lab. All the cells beyond the borders of the grid are also blocked.A crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: ""move right"", ""move down"", ""move left"" or ""move up"". Each command means moving to a neighbouring cell in the corresponding direction.However, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.We want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.","import sys
import os
from io import BytesIO, IOBase
from collections import deque

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

f = sys.stdin
if os.environ.get('USER') == ""loic"":
    f = open(""data.in"")
    
line = lambda: f.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

def neigh(i,j):
    res = []
    if i > 0:
        res.append((i-1,j))
    if i < N-1:
        res.append((i+1,j))
    if j > 0:
        res.append((i,j-1))
    if j < M-1:
        res.append((i,j+1))
    return res

def solve():
    
    start = (x,y)
    
    q = deque([start])

    while q:
        i,j = q.pop()
        
        chs = neigh(i, j)
        
        for i_n,j_n in chs:
            val = G[i_n][j_n]
            if val == '.':
                cnt = 0
                for i_ch,j_ch in neigh(i_n, j_n):
                    if G[i_ch][j_ch] == '.':
                        cnt += 1
                if cnt <= 1:
                    G[i_n][j_n] = '+'
                    q.append((i_n,j_n))
    
    
    res = ""\n"".join("""".join(v for v in l) for l in G)
    
    return str(res)

for test in range(1,ui()+1):
    N,M = ti()
    G = []
    x = -1
    y = -1
    
    G = [list(line()[0]) for i in range(N)]
    xLab = -1
    yLab = -1
    for i in range(N):
        for j in range(M):
            if G[i][j] == 'L':
                x = i
                y = j
                break
    
#     for i in range(N):
#         l = list(line()[0])
#         G.append(l)
#         if x == -1:
#             for j in range(M):
#                 if l[j] == 'L':
#                     x = i
#                     y = j
#                     break
    
    print(solve())
    
f.close()","['dfs and similar', 'graphs']"
"Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts $$$100^{500}$$$ seconds, during which Monocarp attacks the dragon with a poisoned dagger. The $$$i$$$-th attack is performed at the beginning of the $$$a_i$$$-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals $$$1$$$ damage during each of the next $$$k$$$ seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).For example, suppose $$$k = 4$$$, and Monocarp stabs the dragon during the seconds $$$2$$$, $$$4$$$ and $$$10$$$. Then the poison effect is applied at the start of the $$$2$$$-nd second and deals $$$1$$$ damage during the $$$2$$$-nd and $$$3$$$-rd seconds; then, at the beginning of the $$$4$$$-th second, the poison effect is reapplied, so it deals exactly $$$1$$$ damage during the seconds $$$4$$$, $$$5$$$, $$$6$$$ and $$$7$$$; then, during the $$$10$$$-th second, the poison effect is applied again, and it deals $$$1$$$ damage during the seconds $$$10$$$, $$$11$$$, $$$12$$$ and $$$13$$$. In total, the dragon receives $$$10$$$ damage.Monocarp knows that the dragon has $$$h$$$ hit points, and if he deals at least $$$h$$$ damage to the dragon during the battle — he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of $$$k$$$ (the number of seconds the poison effect lasts) that is enough to deal at least $$$h$$$ damage to the dragon.","import sys
input = sys.stdin.readline

for _ in range(int(input())):
    n, h = map(int, input().split())
    w = list(map(int, input().split())) + [10**20]
    d = [j-i for i, j in zip(w,w[1:])]
    lo, hi = 0, h
    while lo < hi:
        mid = (lo + hi)//2
        s = 0
        for i in range(n):
            s += min(d[i], mid)
        if s < h:
            lo = mid + 1
        else:
            hi = mid
    print(lo)",['binary search']
"You are given a rooted tree consisting of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$. The root of the tree is the vertex $$$1$$$.You have to color all vertices of the tree into $$$n$$$ colors (also numbered from $$$1$$$ to $$$n$$$) so that there is exactly one vertex for each color. Let $$$c_i$$$ be the color of vertex $$$i$$$, and $$$p_i$$$ be the parent of vertex $$$i$$$ in the rooted tree. The coloring is considered beautiful if there is no vertex $$$k$$$ ($$$k &gt; 1$$$) such that $$$c_k = c_{p_k} - 1$$$, i. e. no vertex such that its color is less than the color of its parent by exactly $$$1$$$.Calculate the number of beautiful colorings, and print it modulo $$$998244353$$$.","from collections import Counter
from heapq import heapify,heappush,heappop
import sys
raw_input=sys.stdin.readline

M=998244353
rv,rt=[],[0,1]
def dft(a):
	n=len(a)
	if len(rv) != n:
		k=(n.bit_length()-1)-1
		rv.extend([0]*(n-len(rv)))
		for i in range(n): rv[i]=(rv[i>>1]>>1)|((i&1)<<k)
	for i in range(n):
		if rv[i]<i: a[i],a[rv[i]]=a[rv[i]],a[i]
	if len(rt)<n:
		k=len(rt).bit_length()-1
		rt.extend([0]*(n-len(rt)))
		while ((1<<k)<n):
			e=pow(3,(M-1)>>(k+1),M)
			for i in range(1<<(k-1),1<<k):
				rt[2*i]=rt[i]
				rt[2*i+1]=(rt[i]*e)%M
			k+=1
	k=1
	while k<n:
		i=0
		while i<n:
			for j in range(k):
				u=a[i+j]
				v=(a[i+j+k]*rt[k+j])%M
				a[i+j]=(u+v)%M
				a[i+j+k]=(u-v)%M
			i+=2*k
		k *= 2

def idft(a):
	n=len(a)
	a[1:]=a[1:][::-1]
	dft(a)
	inv=pow(n,M-2,M)
	for i in range(n):
		a[i]=(a[i]*inv)%M

def convmod(a,b):
	sz,tot=1,len(a)+len(b)-1
	while sz<tot: sz *= 2
	a.extend([0]*(sz-len(a)))
	b.extend([0]*(sz-len(b)))
	dft(a), dft(b)
	for i in range(sz): a[i]=(a[i]*b[i])%M
	idft(a)
	return a[:tot]

def nCr(n,k):
    return (fact[n]*inv_fact[n-k]%M)*inv_fact[k]%M

n=int(input())
fact,inv,inv_fact=[[1]*2 for _ in range(3)]
while len(inv) <= n:
    fact.append(fact[-1]*len(inv)%M)
    inv.append(inv[M%len(inv)]*(M-M//len(inv))%M)
    inv_fact.append(inv_fact[-1]*inv[-1]%M)
adj=[[] for _ in range(n)]
for _ in range(n-1):
    x,y=list(map(int,input().strip().split()))
    x,y=x-1,y-1
    adj[x].append(y)
    adj[y].append(x)
cnt=Counter()
for i in range(n):
    if len(adj[i])-(i>0): cnt[len(adj[i])-(i>0)]+=1
min_heap=[(1,[1])]
for d,k in cnt.items():
    poly_d_k=[0]*(k+1)
    pw=1
    for i in range(k+1):
        poly_d_k[i]=(nCr(k,i)*pw)%M
        pw=(pw*d)%M
    min_heap.append((len(poly_d_k),poly_d_k))
heapify(min_heap)
while len(min_heap)>1:
    _,p1=heappop(min_heap)
    _,p2=heappop(min_heap)
    new_p=convmod(p1,p2)
    heappush(min_heap,(len(new_p),new_p))
p=min_heap[0][1]
result,sign=0,1
for i in range(len(p)):
    result=(result+sign*p[i]*fact[n-i])%M
    sign*=-1
print(result)","['combinatorics', 'divide and conquer', 'fft']"
"You are beta testing the new secret Terraria update. This update will add quests to the game!Simply, the world map can be represented as an array of length $$$n$$$, where the $$$i$$$-th column of the world has height $$$a_i$$$.There are $$$m$$$ quests you have to test. The $$$j$$$-th of them is represented by two integers $$$s_j$$$ and $$$t_j$$$. In this quest, you have to go from the column $$$s_j$$$ to the column $$$t_j$$$. At the start of the quest, you are appearing at the column $$$s_j$$$.In one move, you can go from the column $$$x$$$ to the column $$$x-1$$$ or to the column $$$x+1$$$. In this version, you have Spectre Boots, which allow you to fly. Since it is a beta version, they are bugged, so they only allow you to fly when you are going up and have infinite fly duration. When you are moving from the column with the height $$$p$$$ to the column with the height $$$q$$$, then you get some amount of fall damage. If the height $$$p$$$ is greater than the height $$$q$$$, you get $$$p - q$$$ fall damage, otherwise you fly up and get $$$0$$$ damage.For each of the given quests, determine the minimum amount of fall damage you can get during this quest.","n,m=(int(i) for i in (input().split()))
s=list(map(int,input().split()))
summa=[0]
minus=[0]
for i in range(n-1):
    summa.append(summa[i]+(max((s[i]-s[i+1]),0)))
    minus.append(minus[i]+(max((s[i+1]-s[i]),0)))
for q in range(m):
    a,b=(map(int,input().split()))
    if a>b:
        print(minus[a-1]-minus[b-1])
    else:
        print(summa[b-1]-summa[a-1])","['data structures', 'dp', 'implementation']"
"A bracket sequence is a string containing only characters ""("" and "")"". A regular bracket sequence (or, shortly, an RBS) is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example:  bracket sequences ""()()"" and ""(())"" are regular (the resulting expressions are: ""(1)+(1)"" and ""((1+1)+1)"");  bracket sequences "")("", ""("" and "")"" are not. There was an RBS. Some brackets have been replaced with question marks. Is it true that there is a unique way to replace question marks with brackets, so that the resulting sequence is an RBS?","#!/usr/bin/env python
from __future__ import division, print_function

import os
import sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip

def solve(s):
    from collections import Counter
    c = Counter(s)
    a = (c['?'] + c[')'] - c['(']) // 2
    b = c['?'] - a

    q = 0
    l = r = None
    for i, c in enumerate(s):
        if c == '?':
            if q < a:
                l = i
            elif r is None:
                r = i
            q += 1
    if l is None or r is None:
        return 'YES'

    check = 0
    for i, c in enumerate(s):
        if c == '(':
            check += 1
        elif c == ')':
            check -= 1
        elif i < l:
            check += 1
        elif i == l:
            check -= 1
        elif i == r:
            check += 1
        else:
            check -= 1
        if check < 0:
            return 'YES'
    if check != 0:
        return 'YES'
    return 'NO'

def main():
    t = int(input())
    for _ in range(t):
        s = input()
        print(solve(s))


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inputarr = lambda: [int(x) for x in input().split()]

# endregion

if __name__ == ""__main__"":
    main()","['constructive algorithms', 'greedy', 'implementation', 'strings']"
"Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.Monocarp has $$$n$$$ problems that none of his students have seen yet. The $$$i$$$-th problem has a topic $$$a_i$$$ (an integer from $$$1$$$ to $$$n$$$) and a difficulty $$$b_i$$$ (an integer from $$$1$$$ to $$$n$$$). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.Monocarp decided to select exactly $$$3$$$ problems from $$$n$$$ problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):  the topics of all three selected problems are different;  the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset.","import os
import sys
from io import BytesIO, IOBase
from collections import Counter, defaultdict
from sys import stdin, stdout
import io
import math
from math import *
import heapq
import bisect
import collections
def ceil(a, b):
    return (a + b - 1) // b
inf = float('inf')

def get():
    return stdin.readline().rstrip()
mod = 10 ** 5 + 7
# for _ in range(int(get())):
# n=int(get())
# l=list(map(int,get().split()))
# = map(int,get().split())
#######################################################
# combinations
def nCr(n, r):
    p = 1
    k = 1
    if (n - r < r):
        r = n - r

    if (r != 0):
        while (r):
            p *= n
            k *= r
            m = gcd(p, k)
            p //= m
            k //= m
            n -= 1
            r -= 1
    else:
        p = 1
    return p
for _ in range(int(get())):
    n=int(get())
    l1=defaultdict(int)
    l2=defaultdict(int)
    x=0
    y=0
    l3=[]
    for i in range(n):
        a,b = map(int,get().split())
        l3.append([a,b])
        l1[a]+=1
        l2[b]+=1
    ans=int(nCr(n,3))
    for i in range(len(l3)):
        ans-=(l1[l3[i][0]]-1)*(l2[l3[i][1]]-1)
    print(ans)","['combinatorics', 'data structures', 'geometry', 'implementation', 'math']"
"Let's call a number k-good if it contains all digits not exceeding k (0, ..., k). You've got a number k and an array a containing n numbers. Find out how many k-good numbers are in a (count each number every time it occurs in array a).","n,k=map(int,raw_input().split())
ans=chk=0
for i in range(n):
    w=list(raw_input())
    w=list(set(w))
    w.sort()
    if len(w)>k:
        for j in range(k+1):
            if w[j]!=str(j):
                break
            elif w[j]==str(k):
                ans+=1
                break
print ans",['implementation']
"Vitaly gave Maxim $$$n$$$ numbers $$$1, 2, \ldots, n$$$ for his $$$16$$$-th birthday. Maxim was tired of playing board games during the celebration, so he decided to play with these numbers. In one step Maxim can choose two numbers $$$x$$$ and $$$y$$$ from the numbers he has, throw them away, and add two numbers $$$x + y$$$ and $$$|x - y|$$$ instead. He wants all his numbers to be equal after several steps and the sum of the numbers to be minimal.Help Maxim to find a solution. Maxim's friends don't want to wait long, so the number of steps in the solution should not exceed $$$20n$$$. It is guaranteed that under the given constraints, if a solution exists, then there exists a solution that makes all numbers equal, minimizes their sum, and spends no more than $$$20n$$$ moves.","import sys
raw_input = iter(sys.stdin.read().splitlines()).next

def bfs(n):
    result, a = [], []
    q = [(n, 1)]
    while q:
        new_q = []
        for n, coeff in q:
            if n <= 2:
                for i in xrange(1, n+1):
                    a.append(i*coeff)
                continue
            pw = 1<<(n.bit_length()-1)
            if pw == n:
                a.append(n*coeff)
                n -= 1
                pw //= 2
            a.append(pw*coeff)
            for i in xrange(1, (n-pw)+1):
                result.append(((pw-i)*coeff, (pw+i)*coeff))
                a.append(2*pw*coeff)
            new_q.append((pw-(n-pw)-1, coeff))
            new_q.append((n-pw, 2*coeff))
        q = new_q
    return result, a

def solution():
    n = int(raw_input())
    if n == 2:
        return -1
    result, a = bfs(n)
    a.sort()
    expect_num = 1<<(n-1).bit_length()
    for i in xrange(len(a)-1):
        if a[i] != a[i+1]:
            continue
        result.append((a[i], a[i+1]))
        a[i+1] += a[i]
        a.remove(a[i])
        break
    for x in a:
        while x != expect_num:
            result.append((0, x))
            result.append((x, x))
            x *= 2
    result.append((0, expect_num))
    return ""%s\n%s"" % (len(result), ""\n"".join(map(lambda x: "" "".join(map(str, x)), result)))

for case in xrange(int(raw_input())):
    print '%s' % solution()","['constructive algorithms', 'greedy', 'math']"
"The enchanted forest got its name from the magical mushrooms growing here. They may cause illusions and generally should not be approached.—Perfect Memento in Strict SenseMarisa comes to pick mushrooms in the Enchanted Forest. The Enchanted forest can be represented by $$$n$$$ points on the $$$X$$$-axis numbered $$$1$$$ through $$$n$$$. Before Marisa started, her friend, Patchouli, used magic to detect the initial number of mushroom on each point, represented by $$$a_1,a_2,\ldots,a_n$$$.Marisa can start out at any point in the forest on minute $$$0$$$. Each minute, the followings happen in order:  She moves from point $$$x$$$ to $$$y$$$ ($$$|x-y|\le 1$$$, possibly $$$y=x$$$).  She collects all mushrooms on point $$$y$$$.  A new mushroom appears on each point in the forest. Note that she cannot collect mushrooms on minute $$$0$$$.Now, Marisa wants to know the maximum number of mushrooms she can pick after $$$k$$$ minutes.","import sys,math
input=sys.stdin.readline

for _ in range(int(input())):
    #n=int(input())
    n,k=map(int,input().split())
    l=list(map(int,input().split()))
    if n==1:
        print(l[0]+(k-1))
    elif k>=n:
        ans=sum(l)+((n*(n-1))//2)+n*(k-n)
        
        print(ans)
    else:
        s=0
        for i in range(k):
            s=s+l[i]
        x=s
        for i in range(k,n):
            x=x-l[i-k]+l[i]
            s=max(s,x)
        print(s+((k*(k-1))//2))","['greedy', 'implementation', 'math']"
"Highway 201 is the most busy street in Rockport. Traffic cars cause a lot of hindrances to races, especially when there are a lot of them. The track which passes through this highway can be divided into $$$n$$$ sub-tracks. You are given an array $$$a$$$ where $$$a_i$$$ represents the number of traffic cars in the $$$i$$$-th sub-track. You define the inconvenience of the track as $$$\sum\limits_{i=1}^{n} \sum\limits_{j=i+1}^{n} \lvert a_i-a_j\rvert$$$, where $$$|x|$$$ is the absolute value of $$$x$$$. You can perform the following operation any (possibly zero) number of times: choose a traffic car and move it from its current sub-track to any other sub-track.Find the minimum inconvenience you can achieve.","import sys

input = lambda: sys.stdin.buffer.readline().decode().strip()
print = sys.stdout.write

for _ in range(int(input())):
    n = int(input())
    nums = list(map(int, input().split()))
    total = sum(nums)
    reminder = total % n
    print(str((n - reminder) * reminder) + ""\n"")","['combinatorics', 'greedy', 'math']"
"This is the easy version of the problem. The only difference is that here $$$k=2$$$. You can make hacks only if both the versions of the problem are solved.This is an interactive problem.Every decimal number has a base $$$k$$$ equivalent. The individual digits of a base $$$k$$$ number are called $$$k$$$-its. Let's define the $$$k$$$-itwise XOR of two $$$k$$$-its $$$a$$$ and $$$b$$$ as $$$(a + b)\bmod k$$$.The $$$k$$$-itwise XOR of two base $$$k$$$ numbers is equal to the new number formed by taking the $$$k$$$-itwise XOR of their corresponding $$$k$$$-its. The $$$k$$$-itwise XOR of two decimal numbers $$$a$$$ and $$$b$$$ is denoted by $$$a\oplus_{k} b$$$ and is equal to the decimal representation of the $$$k$$$-itwise XOR of the base $$$k$$$ representations of $$$a$$$ and $$$b$$$. All further numbers used in the statement below are in decimal unless specified. When $$$k = 2$$$ (it is always true in this version), the $$$k$$$-itwise XOR is the same as the bitwise XOR.You have hacked the criminal database of Rockport Police Department (RPD), also known as the Rap Sheet. But in order to access it, you require a password. You don't know it, but you are quite sure that it lies between $$$0$$$ and $$$n-1$$$ inclusive. So, you have decided to guess it. Luckily, you can try at most $$$n$$$ times without being blocked by the system. But the system is adaptive. Each time you make an incorrect guess, it changes the password. Specifically, if the password before the guess was $$$x$$$, and you guess a different number $$$y$$$, then the system changes the password to a number $$$z$$$ such that $$$x\oplus_{k} z=y$$$. Guess the password and break into the system.","for _ in range(int(input())):
    n,k=map(int,input().split())
    for i in range(n):
        if(i==0):
            print(0)
        else:
            print(i^(i-1))
        if(int(input())==1):
            break","['bitmasks', 'constructive algorithms', 'interactive', 'math']"
"This is the hard version of the problem. The only difference is that here $$$2\leq k\leq 100$$$. You can make hacks only if both the versions of the problem are solved.This is an interactive problem!Every decimal number has a base $$$k$$$ equivalent. The individual digits of a base $$$k$$$ number are called $$$k$$$-its. Let's define the $$$k$$$-itwise XOR of two $$$k$$$-its $$$a$$$ and $$$b$$$ as $$$(a + b)\bmod k$$$.The $$$k$$$-itwise XOR of two base $$$k$$$ numbers is equal to the new number formed by taking the $$$k$$$-itwise XOR of their corresponding $$$k$$$-its. The $$$k$$$-itwise XOR of two decimal numbers $$$a$$$ and $$$b$$$ is denoted by $$$a\oplus_{k} b$$$ and is equal to the decimal representation of the $$$k$$$-itwise XOR of the base $$$k$$$ representations of $$$a$$$ and $$$b$$$. All further numbers used in the statement below are in decimal unless specified.You have hacked the criminal database of Rockport Police Department (RPD), also known as the Rap Sheet. But in order to access it, you require a password. You don't know it, but you are quite sure that it lies between $$$0$$$ and $$$n-1$$$ inclusive. So, you have decided to guess it. Luckily, you can try at most $$$n$$$ times without being blocked by the system. But the system is adaptive. Each time you make an incorrect guess, it changes the password. Specifically, if the password before the guess was $$$x$$$, and you guess a different number $$$y$$$, then the system changes the password to a number $$$z$$$ such that $$$x\oplus_{k} z=y$$$. Guess the password and break into the system.","from __future__ import division, print_function

import os,sys
from io import BytesIO, IOBase

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip

from bisect import bisect_left as lower_bound, bisect_right as upper_bound 
def so():  return int(input())
def st():  return input()
def mj():  return map(int, input().split())
def msj(): return map(str,input().strip().split("" ""))
def le():  return list(map(int,input().split()))
def rc():  return map(float,input().split())
def lebe():return list(map(int, input()))

def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
def joro(L):
    return(''.join(map(str, L)))


def decimalToBinary(n): return bin(n).replace(""0b"","""")


def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True
def npr(n, r):
    return factorial(n) // factorial(n - r) if n >= r else 0
 
 
def ncr(n, r):
    return factorial(n) // (factorial(r) * factorial(n - r)) if n >= r else 0
 
 
def lower_bound(li, num):
    answer = -1
    start = 0
    end = len(li) - 1
 
    while (start <= end):
        middle = (end + start) // 2
        if li[middle] >= num:
            answer = middle
            end = middle - 1
        else:
            start = middle + 1
    return answer  # min index where x is not less than num
 
 
def upper_bound(li, num):
    answer = -1
    start = 0
    end = len(li) - 1
 
    while (start <= end):
        middle = (end + start) // 2
 
        if li[middle] <= num:
            answer = middle
            start = middle + 1
 
        else:
            end = middle - 1
    return answer  # max index where x is not greater than num
def tir(a,b,c):
    if(0==c):
        return 1
    if(len(a)<=b):
        return 0
    
    if(c!=-1):
        return (tir(a,1+b,c+a[b]) or tir(a,b+1,c-a[b]) or tir(a,1+b,c)) 
        
        
    else:
        return (tir(a,1+b,a[b]) or tir(a,b+1,-a[b]) or tir(a,1+b,-1))
hoi=int(2**20)        
 
def abs(x):
    return x if x >= 0 else -x
 
 
def binary_search(li, val, lb, ub):
    # print(lb, ub, li)
    ans = -1
    while (lb <= ub):
        mid = (lb + ub) // 2
        # print('mid is',mid, li[mid])
        if li[mid] > val:
            ub = mid - 1
        elif val > li[mid]:
            lb = mid + 1
        else:
            ans = mid  # return index
            break
    return ans
 
 
def kadane(x):  # maximum sum contiguous subarray
    sum_so_far = 0
    current_sum = 0
    for i in x:
        current_sum += i
        if current_sum < 0:
            current_sum = 0
        else:
            sum_so_far = max(sum_so_far, current_sum)
    return sum_so_far
 
 
def pref(li):
    pref_sum = [0]
    for i in li:
        pref_sum.append(pref_sum[-1] + i)
    return pref_sum
 
 
def SieveOfEratosthenes(n):
    prime = [True for i in range(n + 1)]
    p = 2
    li = []
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
 
    for p in range(2, len(prime)):
        if prime[p]:
            li.append(p)
    return li
 
 
def primefactors(n):
    factors = []
    while (n % 2 == 0):
        factors.append(2)
        n //= 2
    for i in range(3, int(sqrt(n)) + 1, 2):  # only odd factors left
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:  # incase of prime
        factors.append(n)
    return factors

def read():
    sys.stdin  = open('input.txt', 'r')  
    sys.stdout = open('output.txt', 'w') 
def tr(n):
    return n*(n+1)//2
def hu(a,b,opp):
    d=1
    c=0
    while(0<b or 0<a):
        c=c+(((b%opp)+(a%opp))%opp)*d
        a=a//opp
        b=b//opp
        d=opp*d
    return c
def rw(u,opp):
    c=0
    d=1
    while(0<u):
        c=c+((-u%opp)%opp)*d
        u=u//opp
        d=opp*d
    return c
soi=int(1e9)
boi=int(1e9-7)
doi=int(1e9+7)


def main():
    import sys
    import math as my
    input=sys.stdin.readline
    y=""Yes""
    n=""No""
    for i in range(so()):
        #c=0
        op,opp=mj()
        c=0
        for i in range(op):
            if(not i%2):
                z=i
                
            else:
                
                z=rw(i,opp)
            uo=hu(z,c,opp)
            print(uo)
            sys.stdout.flush()
            oppp=so()
            if(1==oppp):
                break
            if(-1==oppp):
                return
            c=hu(rw(c,opp),uo,opp)
    

    
            
            
            
                
            
        
    
    
    
        
    
    
    
    
    
        
        
                        
            
    
        
    
            
    
            
        
    

            
        
    
    
    

    
    
    
    
        

        
    

    
    
    
    
    
    
    
    
    
    

    

    
        
        
            
    
    
                
            
                
                
                
                
            
    
            
            
    
    
    
    
        
            
    
           
            
            
        
    
        
    
    
        
        
        

            
                    
                
                    
                    
                    
                    
                    
                    
        
                
        
        
       
    
           
          
          
                
            
        
                
    
        
        
        
       
            
                
        




# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion


if __name__ == ""__main__"":
    #read()
    main()
    #dmain()

# Comment Read()","['brute force', 'constructive algorithms', 'interactive', 'math']"
"A binary string is a string that consists of characters $$$0$$$ and $$$1$$$. A bi-table is a table that has exactly two rows of equal length, each being a binary string.Let $$$\operatorname{MEX}$$$ of a bi-table be the smallest digit among $$$0$$$, $$$1$$$, or $$$2$$$ that does not occur in the bi-table. For example, $$$\operatorname{MEX}$$$ for $$$\begin{bmatrix} 0011\\ 1010 \end{bmatrix}$$$ is $$$2$$$, because $$$0$$$ and $$$1$$$ occur in the bi-table at least once. $$$\operatorname{MEX}$$$ for $$$\begin{bmatrix} 111\\ 111 \end{bmatrix}$$$ is $$$0$$$, because $$$0$$$ and $$$2$$$ do not occur in the bi-table, and $$$0 &lt; 2$$$.You are given a bi-table with $$$n$$$ columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table — the whole bi-table.What is the maximal sum of $$$\operatorname{MEX}$$$ of all resulting bi-tables can be?","def func():
    t = int(input())

    cases = []
    for i in range(t):
        bits = int(input())
        first = input()
        second = input()
        cases.append([bits, first, second])

    for case in cases:
        mex = 0
        first_bits = case[1]
        second_bits = case[2]
        checked = [False] * len(first_bits)

        for i in range(case[0]):
            if first_bits[i] != second_bits[i]:
                mex += 2
                checked[i] = True

        for i in range(case[0]-1):
            if not checked[i] and not checked[i+1]:
                if int(first_bits[i]) + int(first_bits[i+1]) == 1:
                    mex += 2
                    checked[i] = True
                    checked[i+1] = True
                if int(first_bits[i]) + int(first_bits[i+1]) == 0:
                    mex += 1
                    checked[i] = True
            elif checked[i]:
                continue
            elif checked[i+1]:
                if first_bits[i] == '0':
                    mex += 1
                    checked[i] = True

        if not checked[-1] and first_bits[-1] == '0':
            mex += 1
        print(mex)
        # DYNAMIC PROGRAMMING WITH MATRIX
        # matrix = [[0 for x in range(case[0])] for y in range(case[0])]
        #
        # # fill the diagonal
        # for i in range(case[0]):
        #     if first_bits[i] != second_bits[i]:
        #         matrix[i][i] = 2
        #     elif first_bits[i] == '1':
        #         matrix[i][i] = 0
        #     else:
        #         matrix[i][i] = 1
        #
        # for i in range(case[0]-1):
        #     if matrix[i][i] == 2:
        #         continue
        #     elif matrix[i][i] + matrix[i+1][i+1] == 1:
        #         matrix[i][i+1] = 2
        #         matrix[i][i] = 0
        #         matrix[i+1][i+1] = 0
        #
        # for line in matrix:
        #     mex += sum(line)
        #
        # print(mex)

if __name__ == ""__main__"":
    func()","['bitmasks', 'constructive algorithms', 'dp', 'greedy']"
George has recently entered the BSUCP (Berland State University for Cool Programmers). George has a friend Alex who has also entered the university. Now they are moving into a dormitory. George and Alex want to live in the same room. The dormitory has n rooms in total. At the moment the i-th room has pi people living in it and the room can accommodate qi people in total (pi ≤ qi). Your task is to count how many rooms has free place for both George and Alex.,"import sys

n = int(sys.stdin.readline().split()[0])

rooms = [[0 for x in range(2)] for y in range(n)]

row = 0

for line in sys.stdin:
    column = 0
    for word in line.split():
        rooms[row][column] = int(word)
        column += 1
    row += 1

rooms_acceptable = 0

for room in rooms:
    if room[0] + 2 <= room[1]:
        rooms_acceptable += 1

print(rooms_acceptable)",['implementation']
"It is the easy version of the problem. The only difference is that in this version $$$n = 1$$$.In the cinema seats can be represented as the table with $$$n$$$ rows and $$$m$$$ columns. The rows are numbered with integers from $$$1$$$ to $$$n$$$. The seats in each row are numbered with consecutive integers from left to right: in the $$$k$$$-th row from $$$m (k - 1) + 1$$$ to $$$m k$$$ for all rows $$$1 \le k \le n$$$. $$$1$$$$$$2$$$$$$\cdots$$$$$$m - 1$$$$$$m$$$$$$m + 1$$$$$$m + 2$$$$$$\cdots$$$$$$2 m - 1$$$$$$2 m$$$$$$2m + 1$$$$$$2m + 2$$$$$$\cdots$$$$$$3 m - 1$$$$$$3 m$$$$$$\vdots$$$$$$\vdots$$$$$$\ddots$$$$$$\vdots$$$$$$\vdots$$$$$$m (n - 1) + 1$$$$$$m (n - 1) + 2$$$$$$\cdots$$$$$$n m - 1$$$$$$n m$$$ The table with seats indices There are $$$nm$$$ people who want to go to the cinema to watch a new film. They are numbered with integers from $$$1$$$ to $$$nm$$$. You should give exactly one seat to each person.It is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. $$$i$$$-th person has the level of sight $$$a_i$$$. Let's define $$$s_i$$$ as the seat index, that will be given to $$$i$$$-th person. You want to give better places for people with lower sight levels, so for any two people $$$i$$$, $$$j$$$ such that $$$a_i &lt; a_j$$$ it should be satisfied that $$$s_i &lt; s_j$$$.After you will give seats to all people they will start coming to their seats. In the order from $$$1$$$ to $$$nm$$$, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.Let's consider an example: $$$m = 5$$$, the person has the seat $$$4$$$ in the first row, the seats $$$1$$$, $$$3$$$, $$$5$$$ in the first row are already occupied, the seats $$$2$$$ and $$$4$$$ are free. The inconvenience of this person will be $$$2$$$, because he will go through occupied seats $$$1$$$ and $$$3$$$.Find the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).","# cook your dish here
#!/usr/bin/env python
import bisect
from cmath import inf
from heapq import heapify, heappop, heappush
import os
from math import ceil, factorial, fmod,pi,sqrt,log,floor
import re
import sys
from collections import Counter
from io import BytesIO, IOBase, StringIO

def modFact(n, p):
    if n >= p:
        return 0   
 
    result = 1
    for i in range(1, n + 1):
        result = (result * i) % p
 
    return result
 
def calculate(p, q):
     
    mod = 998244353
    expo = 0
    expo = mod - 2
 
    # Loop to find the value
    # until the expo is not zero
    while (expo):
 
        # Multiply p with q
        # if expo is odd
        if (expo & 1):
            p = (p * q) % mod
        q = (q * q) % mod
 
        # Reduce the value of
        # expo by 2
        expo >>= 1
 
    return p
def compute_gcd(x, y):

   while(y):
       x, y = y, x % y
   return x

# This function computes LCM
def compute_lcm(x, y):
   lcm = (x*y)//compute_gcd(x,y)
   return lcm

def read_arr():
    return [int(x) for x in input().split()]

# def bin_search(num, arr):
#     start = 0
#     end = len(arr)-1
#     while start <= end:
#         mid=(start+end)//2
#         if arr[mid] == num:
#             return mid
#         elif arr[mid] > num:
#             end= mid-1
#         else:
#             start = mid + 1
#     return -1


def factors(n) :
     
    # Note that this loop runs till square root
    i = 1
    ans=[]
    while i <= sqrt(n):
         
        if (n % i == 0) :
             
            # If divisors are equal, print only one
            if (n / i == i) :
                ans.append(i)
            else :
                # Otherwise print both
                
                ans.append(i)
                ans.append(int(n/i))
        i = i + 1
    return ans

def is_palindrome(n):
    for j in range(len(n)//2):
        if n[j]!=n[len(n)-j-1]:
            return False
    return True

def is_sorted(arr,n,m):
    for j in range(n):
        for k in range(m-1):
            if arr[j][k] > arr[j][k+1]:
                return False 
    return True

MOD = 10**9 + 7    

def main():
    for i in range(int(input())):
        n, m = map(int, input().split())
        arr = [int(x) for x in input().split()]
        done = [False for j in range(m)]
        cnt=0
        tmp = arr.copy()
        tmp.sort()
        idx = {}
        for j in range(m):
            idx[tmp[j]] = j + 1
        for j in range(m):
            for k in range(idx[arr[j]]):
                if done[k]:
                    cnt += 1
            done[idx[arr[j]]-1] = True 
            idx[arr[j]] -= 1
        print(cnt)
            

        
                

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
if __name__ == ""__main__"":
    main()","['data structures', 'greedy', 'sortings']"
"There are $$$n$$$ points and $$$m$$$ segments on the coordinate line. The initial coordinate of the $$$i$$$-th point is $$$a_i$$$. The endpoints of the $$$j$$$-th segment are $$$l_j$$$ and $$$r_j$$$ — left and right endpoints, respectively.You can move the points. In one move you can move any point from its current coordinate $$$x$$$ to the coordinate $$$x - 1$$$ or the coordinate $$$x + 1$$$. The cost of this move is $$$1$$$.You should move the points in such a way that each segment is visited by at least one point. A point visits the segment $$$[l, r]$$$ if there is a moment when its coordinate was on the segment $$$[l, r]$$$ (including endpoints).You should find the minimal possible total cost of all moves such that all segments are visited.","import sys
import os
from io import BytesIO

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))

f = sys.stdin
if os.environ.get('USER') == ""loic"":
    f = open(""data.in"")

line = lambda: f.readline().strip('\r\n').split()

def write(w):
    sys.stdout.write(w)
    sys.stdout.write(""\n"")

def solve():
    tmp = sorted(R, key=lambda e: (e[1],-e[0]))
    pts = sorted(A)
    
    dist_l = [[] for _ in range(N)]
    dist_r = [[0] for _ in range(N)]
    
    j = 0
    ref_l = float('-inf')
    pts.append(float('inf'))
    for i in range(N+1):
        pt = pts[i]
        while j < len(tmp):
            l,r = tmp[j]
            if pt < l:
                break
            if l > ref_l and pt > r:
                if i < N:
                    dist_l[i].append(pt - r)
                if i > 0:
                    dist_r[i-1].append(l - pts[i-1])
                ref_l = l
            j += 1
        if i < N:
            dist_l[i].append(0)
    pts.pop()

    dp = [[float('inf') for _ in range(2)] for _ in range(N)]
    for j in range(len(dist_r[0])):
        dp[0][0] = min(dp[0][0], 2 * dist_l[0][0])
        dp[0][1] = min(dp[0][0], dist_l[0][0])
    
    for i in range(1,N):
        pt = pts[i]
        
        for j in range(len(dist_r[i-1])):
            r = dist_r[i-1][j]
            l = dist_l[i][j]
            left = dp[i-1][0] + r + 2*l
            right = dp[i-1][1] + 2*r + 2*l
            dp[i][0] = min(dp[i][0], min(left, right))
            left = dp[i-1][0] + r + l
            right = dp[i-1][1] + 2*r + l
            dp[i][1] = min(dp[i][1], min(left, right))
    
    res = float('inf')
    for j in range(len(dist_r[-1])):
        res = min(res, dp[N-1][0] + dist_r[-1][-1])
        res = min(res, dp[N-1][1] + 2 * dist_r[-1][-1])
    
    return str(res)


T = int(line()[0])
for test in range(1,T+1):
    N,M = map(int,line())
    A = list(map(int,line()))
    R = []
    for _ in range(M):
        a,b = map(int,line())
        R.append((a,b))
    
    write(solve())
    
f.close()","['data structures', 'dp', 'greedy', 'implementation', 'sortings']"
"A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. The parent of a vertex $$$v$$$ (different from root) is the previous to $$$v$$$ vertex on the shortest path from the root to the vertex $$$v$$$. Children of the vertex $$$v$$$ are all vertices for which $$$v$$$ is the parent.A vertex is a leaf if it has no children. We call a vertex a bud, if the following three conditions are satisfied:   it is not a root,  it has at least one child, and  all its children are leaves. You are given a rooted tree with $$$n$$$ vertices. The vertex $$$1$$$ is the root. In one operation you can choose any bud with all its children (they are leaves) and re-hang them to any other vertex of the tree. By doing that you delete the edge connecting the bud and its parent and add an edge between the bud and the chosen vertex of the tree. The chosen vertex cannot be the bud itself or any of its children. All children of the bud stay connected to the bud.What is the minimum number of leaves it is possible to get if you can make any number of the above-mentioned operations (possibly zero)?","from collections import deque
import heapq
from sys import *
input = stdin.readline

t = int(input())
for _ in range(t):
  n = int(input())

  graph = [set() for _ in range(n+1)]

  for i in range(n-1):
    c, d = map(int, input().split())
    graph[c].add(d)
    graph[d].add(c)

  dist = [-1] * (n+1)
  dist[0] = 0
  dist[1] = 0
  d = deque()
  d.append(1)

  parent = [0]*(n+1)

  while d:
    v = d.popleft()
    for i in graph[v]:
      if dist[i] != -1:
        continue
      dist[i] = dist[v] + 1
      d.append(i)
      parent[i] = v
  
  QUE = []
  for i in range(2,n+1):
    heapq.heappush(QUE, (-dist[i], i))

  budcnt = 0
  leafcnt = 0
  used = [0]*(n+1)
  while QUE:
    DIST, CHILD = heapq.heappop(QUE)
    if used[CHILD] == 0:
      used[CHILD] = 1
      PARENT = parent[CHILD]
      used[PARENT] = 1
      if PARENT != 1:
        leafcnt += len(graph[PARENT]) - 1
        budcnt += 1
        for x in graph[PARENT]:
          if dist[PARENT] < dist[x]:
            used[x]  = 1
        graph[parent[PARENT]].remove(PARENT)
  

  if len(graph[1]) == 0:
    print(leafcnt-(budcnt-1))
  else:
    print(len(graph[1])+leafcnt-budcnt)","['constructive algorithms', 'dfs and similar', 'dp', 'greedy', 'trees']"
"This is an interactive problem.Little Dormi was faced with an awkward problem at the carnival: he has to guess the edges of an unweighted tree of $$$n$$$ nodes! The nodes of the tree are numbered from $$$1$$$ to $$$n$$$.The game master only allows him to ask one type of question: Little Dormi picks a node $$$r$$$ ($$$1 \le r \le n$$$), and the game master will reply with an array $$$d_1, d_2, \ldots, d_n$$$, where $$$d_i$$$ is the length of the shortest path from node $$$r$$$ to $$$i$$$, for all $$$1 \le i \le n$$$.Additionally, to make the game unfair challenge Little Dormi the game master will allow at most $$$\lceil\frac{n}{2}\rceil$$$ questions, where $$$\lceil x \rceil$$$ denotes the smallest integer greater than or equal to $$$x$$$.Faced with the stomach-churning possibility of not being able to guess the tree, Little Dormi needs your help to devise a winning strategy!Note that the game master creates the tree before the game starts, and does not change it during the game.","import sys
from sys import stdout

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return map(int, s)


# t = getInt()
t = 1


def p(*args, **kwargs):
    print(*args, **kwargs)
    stdout.flush()


def solve():
    n = getInt()
    e = [[0] * (n+1) for _ in range(n+1)]

    def ask(i):
        p(""?"", i)
        return list(getList())
    level = ask(1)

    def assign(i, a):
        for j, x in enumerate(a, 1):
            if x == 1:
                e[i][j] = e[j][i] = 1

    assign(1, level)
    l = max(level)
    color = [0, 0]
    for j in level:
        color[j & 1] += 1

    # color tree black and white, only query the color with the small nodes
    # which is <= n /2
    # we can color the graph by block and white nodes, odd level is black, even level is white
    # we notice that min(black, white) <= n / 2
    # hence we just need to query level of the min color
    who = color[1] < color[0]
    w = [[] for _ in range(l+1)]
    for i, j in enumerate(level, 1):
        w[j].append(i)
    for i in range(1, l+1):
        if i & 1 == who:
            for j in w[i]:
                assign(j, ask(j))

    p(""!"")
    for i in range(1, n+1):
        for j in range(1, i):
            if e[i][j]:
                p(i, j)


for _ in range(t):
    solve()","['constructive algorithms', 'interactive', 'trees']"
"You are given an array $$$a_1, a_2, \ldots, a_n$$$ of positive integers. A good pair is a pair of indices $$$(i, j)$$$ with $$$1 \leq i, j \leq n$$$ such that, for all $$$1 \leq k \leq n$$$, the following equality holds:$$$$$$ |a_i - a_k| + |a_k - a_j| = |a_i - a_j|, $$$$$$ where $$$|x|$$$ denotes the absolute value of $$$x$$$.Find a good pair. Note that $$$i$$$ can be equal to $$$j$$$.","t = int(input())
for _ in range(t):
      n = int(input())
      li = list(map(int,input().split()))
      i = li.index(min(li)) + 1
      j = li.index(max(li)) + 1
      
      print(i,j)","['math', 'sortings']"
"We say that a positive integer $$$n$$$ is $$$k$$$-good for some positive integer $$$k$$$ if $$$n$$$ can be expressed as a sum of $$$k$$$ positive integers which give $$$k$$$ distinct remainders when divided by $$$k$$$.Given a positive integer $$$n$$$, find some $$$k \geq 2$$$ so that $$$n$$$ is $$$k$$$-good or tell that such a $$$k$$$ does not exist.","import array
import bisect
import heapq
import json
import math
import collections
import sys
import copy
from functools import reduce
import decimal
from io import BytesIO, IOBase
import os
import itertools
import functools
from types import GeneratorType
import fractions
from typing import Tuple, List, Union

# sys.setrecursionlimit(10 ** 9)
decimal.getcontext().rounding = decimal.ROUND_HALF_UP

graphDict = collections.defaultdict

queue = collections.deque


################## pypy deep recursion handling ##############
# Author = @pajenegod
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        to = f(*args, **kwargs)
        if stack:
            return to
        else:
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        return to
                    to = stack[-1].send(to)

    return wrappedfunc


################## Graphs ###################
class Graphs:
    def __init__(self):
        self.graph = graphDict(list)

    def add_edge(self, u, v, w, z):
        self.graph[u].append([v, w, z])
        self.graph[v].append([u, z, w])

    def dfs_utility(self, nodes, visited_nodes, colors, parity, level):
        global count
        if nodes == 1:
            colors[nodes] = -1
        else:
            if len(self.graph[nodes]) == 1 and parity % 2 == 0:
                if q == 1:
                    colors[nodes] = 1
                else:
                    colors[nodes] = -1
                    count += 1
            else:
                if parity % 2 == 0:
                    colors[nodes] = -1
                else:
                    colors[nodes] = 1
        visited_nodes.add(nodes)
        for neighbour in self.graph[nodes]:
            new_level = level + 1
            if neighbour not in visited_nodes:
                self.dfs_utility(neighbour, visited_nodes, colors, level - 1, new_level)

    def dfs(self, node):
        Visited = set()
        color = collections.defaultdict()
        self.dfs_utility(node, Visited, color, 0, 0)
        return color

    def bfs(self, node, f_node):
        count = float(""inf"")
        visited = set()
        level = 0
        if node not in visited:
            queue.append([node, level])
            visited.add(node)
        flag = 0
        while queue:
            parent = queue.popleft()
            if parent[0] == f_node:
                flag = 1
                count = min(count, parent[1])
            level = parent[1] + 1
            for item in self.graph[parent[0]]:
                if item not in visited:
                    queue.append([item, level])
                    visited.add(item)
        return count if flag else -1
        return False


################### Tree Implementaion ##############
class Tree:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None


def inorder(node, lis):
    if node:
        inorder(node.left, lis)
        lis.append(node.data)
        inorder(node.right, lis)
    return lis


def leaf_node_sum(root):
    if root is None:
        return 0
    if root.left is None and root.right is None:
        return root.data
    return leaf_node_sum(root.left) + leaf_node_sum(root.right)


def hight(root):
    if root is None:
        return -1
    if root.left is None and root.right is None:
        return 0
    return max(hight(root.left), hight(root.right)) + 1


################## Union Find #######################
class UnionFind():
    parents = []
    sizes = []
    count = 0

    def __init__(self, n):
        self.count = n
        self.parents = [i for i in range(n)]
        self.sizes = [1 for i in range(n)]

    def find(self, i):
        if self.parents[i] == i:
            return i
        else:
            self.parents[i] = self.find(self.parents[i])
            return self.parents[i]

    def unite(self, i, j):
        root_i = self.find(i)
        root_j = self.find(j)
        if root_i == root_j:
            return
        elif root_i < root_j:
            self.parents[root_j] = root_i
            self.sizes[root_i] += self.sizes[root_j]
        else:
            self.parents[root_i] = root_j
            self.sizes[root_j] += self.sizes[root_i]

    def same(self, i, j):
        return self.find(i) == self.find(j)

    def size(self, i):
        return self.sizes[self.find(i)]

    def group_count(self):
        return len(set(self.find(i) for i in range(self.count)))

    def answer(self, extra, p, q):
        dic = collections.Counter()
        for q in range(n):
            dic[self.find(q)] = self.size(q)
        hq = list(dic.values())
        heapq._heapify_max(hq)
        ans = -1
        for z in range(extra + 1):
            if hq:
                ans += heapq._heappop_max(hq)
            else:
                break
        return ans


#################################################

def rounding(n):
    return int(decimal.Decimal(f'{n}').to_integral_value())


def factors(n):
    return set(reduce(list.__add__,
                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0), [1]))


def p_sum(array):
    return list(itertools.accumulate(array))


def base_change(nn, bb):
    if nn == 0:
        return [0]
    digits = []
    while nn:
        digits.append(int(nn % bb))
        nn //= bb
    return digits[::-1]


def diophantine(a: int, b: int, c: int):
    d, x, y = extended_gcd(a, b)
    r = c // d
    return r * x, r * y


@bootstrap
def extended_gcd(a: int, b: int):
    if b == 0:
        d, x, y = a, 1, 0
    else:
        (d, p, q) = yield extended_gcd(b, a % b)
        x = q
        y = p - q * (a // b)

    yield d, x, y


######################################################################################

'''
Knowledge and awareness are vague, and perhaps better called illusions.
Everyone lives within their own subjective interpretation.
                                                            ~Uchiha Itachi
'''

################################ <fast I/O> ###########################################
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, **kwargs):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


#############################################<I/O Region >##############################################


def inp():
    return sys.stdin.readline().strip()


def map_inp(v_type):
    return map(v_type, inp().split())


def list_inp(v_type):
    return list(map_inp(v_type))


def interactive():
    return sys.stdout.flush()


######################################## Solution ####################################


def primes_sieve1(limit):
    limitn = limit + 1
    primes = dict()
    for i in range(2, limitn): primes[i] = True

    for i in primes:
        factors = range(i, limitn, i)
        for f in factors[1:]:
            primes[f] = False
    return [i for i in primes if primes[i] == True]


def c_sum(x):
    return (x * (x + 1)) // 2
def ans(a):
    print(a)
    return

for _ in range(int(inp())):
    n = int(inp())
    if n <= 2:
        ans(-1)
        continue
    if n % 2:
        ans(2)
        continue
    if n % 3 == 0:
        ans(3)
        continue
    if n % 4 == 2:
        ans(4)
        continue
    m = n
    while m % 2 == 0:
        m //= 2
    if m == 1:
        ans(-1)
        continue
    for k in (m, n // m * 2):
        a = n - k * (k + 1) // 2
        if a >= 0 and a % k == 0:
            ans(k)
            break","['constructive algorithms', 'math', 'number theory']"
"You are given $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$. For any real number $$$t$$$, consider the complete weighted graph on $$$n$$$ vertices $$$K_n(t)$$$ with weight of the edge between vertices $$$i$$$ and $$$j$$$ equal to $$$w_{ij}(t) = a_i \cdot a_j + t \cdot (a_i + a_j)$$$. Let $$$f(t)$$$ be the cost of the minimum spanning tree of $$$K_n(t)$$$. Determine whether $$$f(t)$$$ is bounded above and, if so, output the maximum value it attains.","h=10**9
for _ in range(int(input())):
	n=int(input());a=list(map(int,input().split()));a.sort();
	def f(t):
		c=a[0]*a[-1]+t*(a[0]+a[-1])
		for i in range(1,n-1):c+=min(a[0]*a[i]+t*(a[0]+a[i]),a[-1]*a[i]+t*(a[-1]+a[i]))
		return c
	if f(h)>0 or f(-h)>0:print(""INF"");
	else:
		l,r=-h,h
		while r-l>3:
			p,q=(l*2+r)//3,(l+2*r)//3;
			if f(p)>f(q):r=q;
			else:l=p;
		z=-h*h
		for i in range(l,r):z=max(z,f(i))
		print(z)","['binary search', 'constructive algorithms', 'graphs', 'greedy', 'math', 'sortings']"
"You are given two sets of positive integers $$$A$$$ and $$$B$$$. You have to find two non-empty subsets $$$S_A \subseteq A$$$, $$$S_B \subseteq B$$$ so that the least common multiple (LCM) of the elements of $$$S_A$$$ is equal to the least common multiple (LCM) of the elements of $$$S_B$$$.","import math
for _ in range(int(input())):
    n, m = [*map(int, input().split())]
    N, M = 1<<(len(bin(n-1))-2), 1<<(len(bin(m-1))-2)
    a = [*map(int, input().split())]
    b = [*map(int, input().split())]
    d = [[math.gcd(i,j) for i in b] for j in a]
    d1, d2 = [[0]*(M<<1) for i in range(n)], [[0]*(N<<1) for i in range(m)]
    def upd(d, i): 
        while i>1: d[i>>1]=math.gcd(d[i], d[i^1]); i>>=1
    s1, s2 = set(range(n)), set(range(m))
    def updr(s1, s2, d1, d2, t, i, now):
        s1.discard(i)
        for idx in list(s2):
            if idx > now: break
            x=d2[idx]
            if x[1] == 1:
                x[i+t]=0
                upd(x,i+t)
                if x[1] != 1: updr(s2, s1, d2, d1, M+N-t, idx, now)
    for i in range(max(m,n)):
        if i < n:
            for j in s2: d1[i][j+M] = a[i] // d[i][j]
            for j in range(M-1, 0, -1): d1[i][j] = math.gcd(d1[i][j<<1], d1[i][j<<1|1])
            if d1[i][1] != 1: updr(s1, s2, d1, d2, N, i, i)
        if i < m:
            for j in s1: d2[i][j+N] = b[i] // d[j][i]
            for j in range(N-1, 0, -1): d2[i][j] = math.gcd(d2[i][j<<1], d2[i][j<<1|1])
            if d2[i][1] != 1: updr(s2, s1, d2, d1, M, i, i)
        # print(i, len(s1), len(s2))
    if len(s1): print('YES'); print(len(s1), len(s2)); print(*[a[i] for i in s1]); print(*[b[i] for i in s2])
    else: print('NO')","['data structures', 'math', 'number theory']"
"You are given two arrays: an array $$$a$$$ consisting of $$$n$$$ zeros and an array $$$b$$$ consisting of $$$n$$$ integers.You can apply the following operation to the array $$$a$$$ an arbitrary number of times: choose some subsegment of $$$a$$$ of length $$$k$$$ and add the arithmetic progression $$$1, 2, \ldots, k$$$ to this subsegment — i. e. add $$$1$$$ to the first element of the subsegment, $$$2$$$ to the second element, and so on. The chosen subsegment should be inside the borders of the array $$$a$$$ (i.e., if the left border of the chosen subsegment is $$$l$$$, then the condition $$$1 \le l \le l + k - 1 \le n$$$ should be satisfied). Note that the progression added is always $$$1, 2, \ldots, k$$$ but not the $$$k, k - 1, \ldots, 1$$$ or anything else (i.e., the leftmost element of the subsegment always increases by $$$1$$$, the second element always increases by $$$2$$$ and so on).Your task is to find the minimum possible number of operations required to satisfy the condition $$$a_i \ge b_i$$$ for each $$$i$$$ from $$$1$$$ to $$$n$$$. Note that the condition $$$a_i \ge b_i$$$ should be satisfied for all elements at once.","import sys
input = sys.stdin.readline
n,k=map(int,input().split())
b=list(map(int,input().split()))
closed=[0]*n
tot=0
cnt=0
ans=0
for i in range(n-1,-1,-1):
  tot-=cnt
  cnt-=closed[i]
  b[i]-=tot
  if b[i]<=0:
    continue
  el=min(i+1,k)
  need=-(-b[i]//el)
  tot+=need*el
  cnt+=need
  ans+=need
  if i-el>=0:
    closed[i-el]+=need
print(ans)","['data structures', 'greedy']"
"There are $$$n+1$$$ teleporters on a straight line, located in points $$$0$$$, $$$a_1$$$, $$$a_2$$$, $$$a_3$$$, ..., $$$a_n$$$. It's possible to teleport from point $$$x$$$ to point $$$y$$$ if there are teleporters in both of those points, and it costs $$$(x-y)^2$$$ energy.You want to install some additional teleporters so that it is possible to get from the point $$$0$$$ to the point $$$a_n$$$ (possibly through some other teleporters) spending no more than $$$m$$$ energy in total. Each teleporter you install must be located in an integer point.What is the minimum number of teleporters you have to install?","def split_cost(total_len, k):
    bigger_interv = total_len % (k + 1) # number of intervals with len = total_len // (k + 1) + 1
    lesser_interv = k + 1 - bigger_interv # number of intervals with len = total_len // (k + 1)
    basic_cost = total_len // (k + 1)

    # sum of all the smaller intervals + sum of all the bigger intervals
    return basic_cost**2 * lesser_interv + (basic_cost + 1)**2 * bigger_interv


def get_segment_portals_and_cost(interv_len, min_change):
    l = 0; r = interv_len - 1 # bigger and smaller change reached in 'l' and 'r' respectively
    if split_cost(interv_len, r) - split_cost(interv_len, r + 1) >= min_change:
        return r, split_cost(interv_len, r)

    while l + 1 < r:
        mid = (l + r) >> 1
        # if change f(k-1) - f(k) >= min_change
        if split_cost(interv_len, mid -1) - split_cost(interv_len, mid) >= min_change:
            l = mid # we keep l in 'YES' part of the Predicate
        else:
            r = mid # we keep r in 'NO' part of the Predicate

    # We keep the last value that satisfies f(k-1) - f(k) >= min_change
    return l, split_cost(interv_len, l)


def put_portals(min_cost, intervals):
    h = 0 # number of portals used
    g = 0 # total cost
    for inter in intervals:
        portals, cost = get_segment_portals_and_cost(inter, min_cost)
        h += portals
        g += cost

    return h, g


def solve(n, m, intervals):
    # search for minimum cost change in all the intervals
    l = 0; r = m+10

    if put_portals(r, intervals)[1] <= m: # if the cost without portals is <= m
        return 0  # optimus is put 0 portals

    while l + 1 < r:
        mid = (l + r) // 2
        _, cost = put_portals(mid, intervals)
        if cost <= m:  # possible solution
            l = mid  # we keep l in 'YES' part of the Predicate
        else:
            r = mid  # we keep r in 'NO' part of the Predicate

    c_amount, c_cost = put_portals(l, intervals)  # last value that satisfies: cost <= m
    c_next_amount, c_next_cost = put_portals(r, intervals)  # first value that not satisfies: cost <= m

    change = (c_next_cost - c_cost) // (c_amount - c_next_amount)  # change that gave every new teleport
    # we subtract the just amount of teleports for pass cost restriction, slowly converting l to r
    return c_amount - (m - c_cost) // change


if __name__ == '__main__':
    n = int(input())
    list_telep = [int(x) for x in input().split()]
    m = int(input())
    # distance betwen list_telep[i] and [i+1]
    list_intervals = [list_telep[0]]
    list_intervals += [list_telep[i+1] - list_telep[i] for i in range(n-1)]

    res = solve(n, m, list_intervals)
    print(res)","['binary search', 'greedy']"
"Frog Gorf is traveling through Swamp kingdom. Unfortunately, after a poor jump, he fell into a well of $$$n$$$ meters depth. Now Gorf is on the bottom of the well and has a long way up.The surface of the well's walls vary in quality: somewhere they are slippery, but somewhere have convenient ledges. In other words, if Gorf is on $$$x$$$ meters below ground level, then in one jump he can go up on any integer distance from $$$0$$$ to $$$a_x$$$ meters inclusive. (Note that Gorf can't jump down, only up).Unfortunately, Gorf has to take a break after each jump (including jump on $$$0$$$ meters). And after jumping up to position $$$x$$$ meters below ground level, he'll slip exactly $$$b_x$$$ meters down while resting.Calculate the minimum number of jumps Gorf needs to reach ground level.","from sys import stdin, stdout
import sys
import heapq
from collections import defaultdict
import math
import bisect
import io, os
# from cffi import FFI
import copy
import itertools

# for interactive problem
# n = int(stdin.readline())
# print(x, flush=True)

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def ncr(n, r, p):
    # initialize numerator
    # and denominator
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p

#input = sys.stdin.buffer.readline

# ffi = FFI()
# ffi.cdef(
#     """"""
#     typedef struct {
#         long long suf;
#         long long pre;
#         long long maxi;
#         bool is_plus;
#         long long lowest;
#         long long sum;
#         int length;
#     } node_t;
#     """"""
# )
#
# MX = 2 << ((2 * 10 ** 5) - 1).bit_length()
# data = ffi.new(""node_t[]"", MX + 3)
# data[MX] = (0, 0, 0, True, 0, 0, 0)
# id_node = data[MX]
# res_left = MX + 1
# res_right = MX + 2
#
# def combine(a, b):
#     if a.length == 0:
#         return b
#     if b.length == 0:
#         return a
#
#     length = a.length + b.length
#     if a.is_plus:
#         pre = a.sum + b.pre
#     else:
#         pre = a.pre
#     if b.is_plus:
#         suf = a.suf + b.sum
#     else:
#         suf = b.suf
#     is_plus = a.is_plus and b.is_plus
#     sum = a.sum + b.sum
#     maxi = max(a.maxi, b.maxi, a.suf + b.pre)
#     lowest = min(a.lowest, a.sum + b.lowest)
#     return (suf, pre, maxi, is_plus, lowest, sum, length)
#
# def mapValue(x):
#     return (max(x, 0), max(x, 0), max(x, 0), (x >= 0), x, x, 1)
#
# class SegmentTree:
#     def __init__(self, N, A):
#         self._len = N
#         self._size = _size = 1 << (self._len - 1).bit_length()
#         for i in range(2 * _size):
#             data[i] = id_node
#         for i, x in enumerate(A):
#             data[_size + i] = mapValue(x)
#         for i in reversed(range(_size)):
#             data[i] = combine(data[i + i], data[i + i + 1])
#
#     def __delitem__(self, idx):
#         self[idx] = id_node
#
#     def __getitem__(self, idx):
#         return data[idx + self._size]
#
#     def __setitem__(self, idx, value):
#         idx += self._size
#         data[idx] = value
#         idx >>= 1
#         while idx:
#             data[idx] = combine(data[2 * idx], data[2 * idx + 1])
#             idx >>= 1
#
#     def __len__(self):
#         return self._len
#
#     def query(self, start, stop):
#         """"""func of data[start, stop)""""""
#         start += self._size
#         stop += self._size
#         data[res_left] = id_node
#         data[res_right] = id_node
#         while start < stop:
#             if start & 1:
#                 data[res_left] = combine(data[res_left], data[start])
#                 start += 1
#             if stop & 1:
#                 stop -= 1
#                 data[res_right] = combine(data[stop], data[res_right])
#             start >>= 1
#             stop >>= 1
#         data[res_left] = combine(data[res_left], data[res_right])
#         return data[res_left]

# def main():
#     n, q = map(int, stdin.readline().split())
#     segtree = SegmentTree(n, map(int, stdin.readline().split()))
#     ans = []
#     for _ in range(q):
#         t, l, r = map(int, stdin.readline().split())
#         l -= 1
#         if t == 1:
#             segtree[l] = mapValue(r)
#         else:
#             ans.append(int(segtree.query(l, r).ans))
#     print(""\n"".join(map(str, ans)))

def kbits(n, k):
    result = []
    for bits in itertools.combinations(range(n), k):
        s = ['0'] * n
        for bit in bits:
            s[bit] = '1'
        result.append(''.join(s))
    return result


def main():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    dp = [math.inf] * n
    dp[-1] = 0
    prev = [math.inf] * n
    prev_p = [math.inf] * n
    ans = math.inf
    prev_ans = -1
    sched = n-1
    stack = [n-1]
    while stack:
        temp = []
        for i in stack:
            x = max(i - a[i], 0)
            if i - a[i] < 0:
                if ans > dp[i]+1:
                    ans = dp[i]+1
                    prev_ans = i
                ans = min(dp[i]+1, ans)
            for j in range(x, sched):
                pos = j + b[j]
                if dp[pos] > dp[i] + 1:
                    dp[pos] = dp[i] + 1
                    prev[pos] = i
                    prev_p[pos] = j
                    temp.append(pos)
            sched =min(x, sched)
        stack =temp
    if ans == math.inf:
        ans = -1
    stdout.write(str(ans)+""\n"")
    if ans != -1:
        arr = [-1]
        while prev_ans != math.inf:
            if prev_ans != -1:
                arr.append(prev_p[prev_ans])
            prev_ans = prev[prev_ans]
        stdout.write("" "".join([str(x+1) for x in reversed(arr[:-1])]) + ""\n"")


main()","['data structures', 'dp', 'graphs', 'greedy', 'shortest paths']"
"A group of $$$n$$$ alpinists has just reached the foot of the mountain. The initial difficulty of climbing this mountain can be described as an integer $$$d$$$.Each alpinist can be described by two integers $$$s$$$ and $$$a$$$, where $$$s$$$ is his skill of climbing mountains and $$$a$$$ is his neatness.An alpinist of skill level $$$s$$$ is able to climb a mountain of difficulty $$$p$$$ only if $$$p \leq s$$$. As an alpinist climbs a mountain, they affect the path and thus may change mountain difficulty. Specifically, if an alpinist of neatness $$$a$$$ climbs a mountain of difficulty $$$p$$$ the difficulty of this mountain becomes $$$\max(p, a)$$$. Alpinists will climb the mountain one by one. And before the start, they wonder, what is the maximum number of alpinists who will be able to climb the mountain if they choose the right order. As you are the only person in the group who does programming, you are to answer the question.Note that after the order is chosen, each alpinist who can climb the mountain, must climb the mountain at that time.","import os,sys
from random import randint
from io import BytesIO, IOBase

from collections import defaultdict,deque,Counter
from bisect import bisect_left,bisect_right
from heapq import heappush,heappop
from functools import lru_cache
from itertools import accumulate
import math

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split(' ')))

# for _ in range(int(input())):
#     s = input()
#     mn = 'z'
#     for i in range(len(s)):
#         if s[i] < mn:
#             mn = s[i]
#     idx = s.index(mn)
#     ans = []
#     for i in range(len(s)):
#         if i != idx:
#             ans.append(s[i])
#     print(mn, ''.join(ans))

# def f(a):
#     n = len(a)
#     cnt = [0] * (n + 1)
#     for i in range(n):
#         cnt[a[i]] += 1
#     for i in range(n):
#         a[i] = cnt[a[i]]

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split(' ')))
#     tot = [a[:]]
#     b = [0] * n
#     while b != a:
#         b = a[:]
#         f(a)
#         tot.append(a[:])
#     for _ in range(int(input())):
#         x, k = list(map(int, input().split(' ')))
#         k = min(k, len(tot) - 1)
#         x -= 1
#         print(tot[k][x])

# N = int(pow(10 ** 9, 0.5)) + 5
# def get_prime_linear(n):
#     global cnt
#     for i in range(2, n + 1):
#         if not st[i]:
#             primes[cnt] = i
#             cnt += 1
#         for j in range(n):
#             if primes[j] > n / i: break
#             st[primes[j] * i] = True
#             if i % primes[j] == 0: break 
# primes, cnt, st = [0] * (N + 5), 0, [False] * (N + 5)
# get_prime_linear(N)
# prime1e3 = primes[:cnt]

# @lru_cache(None)
# def get_factor(n):
#     res = []
#     for i in prime1e3:
#         if i * i > n:
#             break
#         while n % i == 0:
#             n //= i
#             res.append(i)
#     if n > 1:
#         res.append(n)
#     s = set([1])
#     for i in res:
#         news = set()
#         for j in s:
#             news.add(j)
#             news.add(j * i)
#         s = news
#     return sorted(s)

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split(' ')))
#     b = []
#     for j in range(32):
#         cnt = 0
#         for i in range(n):
#             if a[i] >> j & 1:
#                 cnt += 1
#         if cnt > 0:
#             b.append(cnt)
#     if not b:
#         print(*list(range(1, n + 1)))
#     else:
#         ans = b[0]
#         for i in range(1, len(b)):
#             ans = math.gcd(ans, b[i])
#         print(*get_factor(ans))

class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True
 
    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False
 
    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1
 
    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x
 
    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k
 
    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1
 
        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True
 
    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi
 
        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True
 
    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)
 
    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))
 
    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value
 
    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx
 
    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx
 
    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)
 
    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len
 
    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]
 
    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)
 
    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False
 
    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)
 
    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))
 
    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))

# def solve():
#     n = int(input())
#     a = [0] + list(map(int, input().split(' ')))
#     b = [0] + list(map(int, input().split(' ')))
#     q = deque()
#     q.append((n, n, 0))
#     st = SortedList(list(range(n)))
#     pre = [-1] * (n + 1)
#     while q:
#         x, y, d = q.popleft()
#         for i in range(len(st) -1, -1, -1):
#             if st[i] < x - a[x]:
#                 break
#             else:
#                 if st[i] == 0:
#                     print(d + 1)
#                     ans = [0, y]
#                     t = y
#                     while t != n:
#                         ans.append(pre[t])
#                         t = pre[t]
#                     ans.pop()
#                     ans = ans[::-1]
#                     print(*ans)
#                     return
#                 q.append((st[i] + b[st[i]], st[i], d + 1))
#                 pre[st[i]] = y
#                 st.pop(i)
#     print(-1)
# solve()

N = 10 ** 9
n, d = list(map(int, input().split(' ')))
b = []
c = []
for _ in range(n):
    s, a = list(map(int, input().split(' ')))
    if s >= d:
        b.append(s)
        c.append(a)
if not b:
    print(0)
else:
    id = [i for i in range(len(b))] 
    id.sort(key=lambda x:max(b[x], c[x]) * N + b[x])
    ans = 0
    for i in range(len(b)):
        if b[id[i]] >= d:
            d = max(d, c[id[i]])
            ans += 1
    print(ans)","['data structures', 'dp', 'greedy', 'sortings']"
"You have an $$$n \times n$$$ chessboard and $$$k$$$ rooks. Rows of this chessboard are numbered by integers from $$$1$$$ to $$$n$$$ from top to bottom and columns of this chessboard are numbered by integers from $$$1$$$ to $$$n$$$ from left to right. The cell $$$(x, y)$$$ is the cell on the intersection of row $$$x$$$ and collumn $$$y$$$ for $$$1 \leq x \leq n$$$ and $$$1 \leq y \leq n$$$.The arrangement of rooks on this board is called good, if no rook is beaten by another rook.A rook beats all the rooks that shares the same row or collumn with it.The good arrangement of rooks on this board is called not stable, if it is possible to move one rook to the adjacent cell so arrangement becomes not good. Otherwise, the good arrangement is stable. Here, adjacent cells are the cells that share a side.  Such arrangement of $$$3$$$ rooks on the $$$4 \times 4$$$ chessboard is good, but it is not stable: the rook from $$$(1, 1)$$$ can be moved to the adjacent cell $$$(2, 1)$$$ and rooks on cells $$$(2, 1)$$$ and $$$(2, 4)$$$ will beat each other. Please, find any stable arrangement of $$$k$$$ rooks on the $$$n \times n$$$ chessboard or report that there is no such arrangement.","for _ in range(int(input())):
  n,k = [int(x) for x in input().split()]
  if (2*k-1 <=n):
    a = [list("".""*n) for _ in range(n)]
    for i in range(0,2*k,2):
      a[i][i]='R'
    for i in a:
      print("""".join(i))
  else:
    print(-1)",['constructive algorithms']
"You have decided to open a new school. You have already found $$$n$$$ teachers and $$$m$$$ groups of students. The $$$i$$$-th group of students consists of $$$k_i \geq 2$$$ students. You know age of each teacher and each student. The ages of teachers are $$$a_1, a_2, \ldots, a_n$$$ and the ages of students of the $$$i$$$-th group are $$$b_{i, 1}, b_{i, 2}, \ldots, b_{i, k_i}$$$.To start lessons you should assign the teacher to each group of students. Such assignment should satisfy the following requirements:  To each group exactly one teacher assigned.  To each teacher at most $$$1$$$ group of students assigned.  The average of students' ages in each group doesn't exceed the age of the teacher assigned to this group. The average of set $$$x_1, x_2, \ldots, x_k$$$ of $$$k$$$ integers is $$$\frac{x_1 + x_2 + \ldots + x_k}{k}$$$.Recently you have heard that one of the students will refuse to study in your school. After this, the size of one group will decrease by $$$1$$$ while all other groups will remain unchanged.You don't know who will refuse to study. For each student determine if you can start lessons in case of his refusal.Note, that it is not guaranteed that it is possible to start lessons before any refusal.","import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


class SegmentTree:
    def __init__(self, size):
        count = 1
        while count < size:
            count *= 2

        self.size = size
        self.count = count

        self.T = [0] * (count)
        self.V = [0] * (2*count)

    def __apply(self, e, v):
        if e < self.count:
            self.T[e] += v

        self.V[e] += v

    def __merge(vl, vr):
        return min(vl, vr)

    def __push(self, e):
        t = self.T[e]
        if t == 0:
            return
        
        self.__apply(2*e, t)
        self.__apply(2*e + 1, t)

        self.T[e] = 0

    def __updateCore(self, e, tl, tr, l, r, v):
        if r <= tl or tr <= l or l >= r:
            return

        if l <= tl and tr <= r:
            self.__apply(e, v)
        else:
            self.__push(e)

            tm = (tl + tr)//2
            self.__updateCore(2*e,     tl, tm,         l, min(tm, r), v)
            self.__updateCore(2*e + 1, tm, tr, max(l, tm),         r, v)

            self.V[e] = SegmentTree.__merge(self.V[2*e], self.V[2*e + 1])

    def update(self, l, r, v):
        self.__updateCore(1, 0, self.size, l, r + 1, v)

    def __queryCore(self, e, tl, tr, l, r):
        if r <= tl or tr <= l or l >= r:
            return 10**10

        if l <= tl and tr <= r:
            return self.V[e]
        else:
            self.__push(e)
     
            tm = (tl + tr)//2
            lv = self.__queryCore(2*e,     tl, tm,          l, min(tm, r))
            rv = self.__queryCore(2*e + 1, tm, tr, max(l, tm),         r)

            return SegmentTree.__merge(lv, rv)
        
    def query(self, l, r):
        return self.__queryCore(1, 0, self.size, l, r + 1)

    def clear(self, new = False):
        if new:
            self.T = [0] * self.count
            self.V = [0] * (2*self.count)
        else:
            for i in range(self.count):
                self.T[i] = self.V[i] = 0

            for i in range(self.count + 1, 2*self.count):
                self.V[i] = 0


Limit = 10**5
ST = SegmentTree(Limit + 1)

Q = int(input())
for _ in range(Q):
    n, m = map(int, input().split(' '))
    A = list(map(int, input().split(' ')))
    A.sort()

    K = []
    for i in range(m):
        input()
        K.append(list(map(int, input().split(' '))))

    for a in A[-m:]:
        ST.update(0, a, 1)

    SK, LK = [], []
    for k in K:
        sk = sum(k)
        SK.append(sk)

        lk = len(k)
        LK.append(lk)

        ST.update(0, (sk + lk - 1)//lk, -1)

    if ST.query(0, Limit) >= 1:
        print("""".join(""1"" * lk for lk in LK))
    else:
        initial = ST.query(0, Limit) >= 0

        for i in range(len(K)):
            sk = SK[i]
            lk = LK[i]
            mk = (sk + lk - 1)//lk
            ST.update(0, mk, 1)
        
            for h in K[i]:
                if initial and h <= mk or not initial and h >= mk:
                    mk1 = (sk - h + lk - 2)//(lk - 1)
                    ST.update(0, mk1, -1)
                    print('1' if ST.query(0, Limit) >= 0 else '0', end = '')
                    ST.update(0, mk1, 1)
                else:
                    print('1' if initial else '0', end = '')

            ST.update(0, mk, -1)
        print()

    for a in A[-m:]:
        ST.update(0, a, -1)
 
    for i in range(len(K)):
        sk = SK[i]
        lk = LK[i]
        ST.update(0, (sk + lk - 1)//lk, 1)","['binary search', 'data structures', 'dp', 'greedy', 'implementation', 'sortings']"
"Polycarp bought a new expensive painting and decided to show it to his $$$n$$$ friends. He hung it in his room. $$$n$$$ of his friends entered and exited there one by one. At one moment there was no more than one person in the room. In other words, the first friend entered and left first, then the second, and so on.It is known that at the beginning (before visiting friends) a picture hung in the room. At the end (after the $$$n$$$-th friend) it turned out that it disappeared. At what exact moment it disappeared — there is no information.Polycarp asked his friends one by one. He asked each one if there was a picture when he entered the room. Each friend answered one of three:  no (response encoded with 0);  yes (response encoded as 1);  can't remember (response is encoded with ?). Everyone except the thief either doesn't remember or told the truth. The thief can say anything (any of the three options).Polycarp cannot understand who the thief is. He asks you to find out the number of those who can be considered a thief according to the answers.","for _ in range(int(input())):
    s = input()
    ans = 0
    ll, rr = 0, len(s)
    k = 0
    if '0' in s:
        rr = s.index('0') + 1
        k += 1
    if '1' in s:
        ll = len(s) - s[::-1].index('1') - 1
        k += 2
    if k == 3:
        print(rr - ll)
    elif k == 1:
        print(rr)
    elif k == 2:
        print(rr - ll)
    else:
        print(len(s))",['implementation']
"You are given a rooted tree consisting of $$$n$$$ vertices. Vertices are numbered from $$$1$$$ to $$$n$$$. Any vertex can be the root of a tree.A tree is a connected undirected graph without cycles. A rooted tree is a tree with a selected vertex, which is called the root.The tree is specified by an array of parents $$$p$$$ containing $$$n$$$ numbers: $$$p_i$$$ is a parent of the vertex with the index $$$i$$$. The parent of a vertex $$$u$$$ is a vertex that is the next vertex on the shortest path from $$$u$$$ to the root. For example, on the simple path from $$$5$$$ to $$$3$$$ (the root), the next vertex would be $$$1$$$, so the parent of $$$5$$$ is $$$1$$$.The root has no parent, so for it, the value of $$$p_i$$$ is $$$i$$$ (the root is the only vertex for which $$$p_i=i$$$).Find such a set of paths that:  each vertex belongs to exactly one path, each path can contain one or more vertices;  in each path each next vertex — is a son of the current vertex (that is, paths always lead down — from parent to son);  number of paths is minimal. For example, if $$$n=5$$$ and $$$p=[3, 1, 3, 3, 1]$$$, then the tree can be divided into three paths:   $$$3 \rightarrow 1 \rightarrow 5$$$ (path of $$$3$$$ vertices),  $$$4$$$ (path of $$$1$$$ vertices).  $$$2$$$ (path of $$$1$$$ vertices).     Example of splitting a root tree into three paths for $$$n=5$$$, the root of the tree — node $$$3$$$.","# cook your dish here
#!/usr/bin/env python
from bisect import bisect_left
import os
from math import ceil, factorial, fmod,pi,sqrt,log
import sys
from collections import Counter
from io import BytesIO, IOBase, StringIO
def modFact(n, p):
    if n >= p:
        return 0   
 
    result = 1
    for i in range(1, n + 1):
        result = (result * i) % p
 
    return result
 
def calculate(p, q):
     
    mod = 998244353
    expo = 0
    expo = mod - 2
 
    # Loop to find the value
    # until the expo is not zero
    while (expo):
 
        # Multiply p with q
        # if expo is odd
        if (expo & 1):
            p = (p * q) % mod
        q = (q * q) % mod
 
        # Reduce the value of
        # expo by 2
        expo >>= 1
 
    return p
def compute_gcd(x, y):

   while(y):
       x, y = y, x % y
   return x

# This function computes LCM
def compute_lcm(x, y):
   lcm = (x*y)//compute_gcd(x,y)
   return lcm

def read_arr():
    return [int(x) for x in input().split()]

def bin_search(num, arr):
    start = 0
    end = len(arr)-1
    while start <= end:
        mid=(start+end)//2
        if arr[mid] == num:
            return mid
        elif arr[mid] > num:
            end= mid-1
        else:
            start = mid + 1
    return -1


def factors(n) :
     
    # Note that this loop runs till square root
    i = 1
    ans=[]
    while i <= sqrt(n):
         
        if (n % i == 0) :
             
            # If divisors are equal, print only one
            if (n / i == i) :
                ans.append(i)
            else :
                # Otherwise print both
                
                ans.append(i)
                ans.append(int(n/i))
        i = i + 1
    return ans

def is_palindrome(n):
    for j in range(len(n)//2):
        if n[j]!=n[len(n)-j-1]:
            return False
    return True

def main():
    t=int(input())
    for i in range(t):
        n = int(input())
        arr = [int(x) for x in input().split()]
        leaves = [True for j in range(n+1)]
        leaves[0]=False
        for j in range(n):
            leaves[arr[j]]=False 
        paths = []
        if n == 1:
            print(1)
            print(1)
            print(1)
            print()
            continue
        vis = [False for j in range(n+1)]
        for j in range(n+1):
            if leaves[j]:
                new = []
                start = j
                while not vis[start]:
                    new.append(start)
                    vis[start] = True 
                    if start == arr[start-1]:
                        break
                    start = arr[start-1]
                paths.append(new)
        print(len(paths))
        for j in paths:
            print(len(j))
            for k in range(len(j)-1, -1, -1):
                print(j[k],end="" "")
            print()
        if i != t-1:
            print()





BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
if __name__ == ""__main__"":
    main()","['graphs', 'implementation', 'trees']"
"Summer holidays! Someone is going on trips, someone is visiting grandparents, but someone is trying to get a part-time job. This summer Noora decided that she wants to earn some money, and took a job in a shop as an assistant.Shop, where Noora is working, has a plan on the following n days. For each day sales manager knows exactly, that in i-th day ki products will be put up for sale and exactly li clients will come to the shop that day. Also, the manager is sure, that everyone, who comes to the shop, buys exactly one product or, if there aren't any left, leaves the shop without buying anything. Moreover, due to the short shelf-life of the products, manager established the following rule: if some part of the products left on the shelves at the end of the day, that products aren't kept on the next day and are sent to the dump.For advertising purposes manager offered to start a sell-out in the shop. He asked Noora to choose any f days from n next for sell-outs. On each of f chosen days the number of products were put up for sale would be doubled. Thus, if on i-th day shop planned to put up for sale ki products and Noora has chosen this day for sell-out, shelves of the shop would keep 2·ki products. Consequently, there is an opportunity to sell two times more products on days of sell-out.Noora's task is to choose f days to maximize total number of sold products. She asks you to help her with such a difficult problem.","def sell(k, l):
    return (l if l <= k else k)

n, f = map(int, input().split())
kl = [[int(i) for i in input().split()] for _ in range(n)]

totel = 0
d = []

if f == 0:
    for i in kl:
        totel += sell(i[0], i[1])
    print (totel)
else:

    for i in kl:
        gain = (sell(i[0] * 2, i[1]) - sell(i[0], i[1]))
        totel += sell(i[0], i[1])
        d.append(gain)
        
    d.sort()
    totel += sum(d[0-f:])

    print (totel)","['sortings', 'greedy']"
"Olya has an array of integers $$$a_1, a_2, \ldots, a_n$$$. She wants to split it into tandem repeats. Since it's rarely possible, before that she wants to perform the following operation several (possibly, zero) number of times: insert a pair of equal numbers into an arbitrary position. Help her!More formally:  A tandem repeat is a sequence $$$x$$$ of even length $$$2k$$$ such that for each $$$1 \le i \le k$$$ the condition $$$x_i = x_{i + k}$$$ is satisfied.  An array $$$a$$$ could be split into tandem repeats if you can split it into several parts, each being a subsegment of the array, such that each part is a tandem repeat.  In one operation you can choose an arbitrary letter $$$c$$$ and insert $$$[c, c]$$$ to any position in the array (at the beginning, between any two integers, or at the end).  You are to perform several operations and split the array into tandem repeats or determine that it is impossible. Please note that you do not have to minimize the number of operations.","import collections as _collections
import io as _io
import sys as _sys


def f(sequence):
    sequence = list(sequence)
    elements_counter = _collections.Counter(sequence)
    if any(count % 2 != 0 for count in elements_counter.values()):
        raise ValueError

    target_sequence = sorted(sequence)

    result = []
    lengths = []
    acc_offset = 0
    while not _is_sorted(sequence):
        x_to_move = target_sequence.pop()
        i = len(sequence) - 1
        while i > 0 and sequence[i] != x_to_move:
            i -= 1
        acc_offset = _rev_prefix(sequence, i, acc_offset, result, lengths)
        acc_offset = _rev_prefix(sequence, i + 1, acc_offset, result, lengths)

    assert len(sequence) % 2 == 0
    lengths.extend([2] * (len(sequence) // 2))

    return result, lengths


def _is_sorted(sequence):
    return all(sequence[i - 1] <= sequence[i] for i in range(1, len(sequence)))


def _rev_prefix(sequence, length, acc_offset, result, lengths):
    if length < 1:
        return acc_offset
    for i, x in enumerate(sequence[:length]):
        result.append((acc_offset + length + i, x))
    sequence[:] = sequence[:length][::-1] + sequence[length:]
    acc_offset += 2 * length
    lengths.append(2 * length)
    return acc_offset


def _main():
    [tests_n] = _read_ints()

    for i_test in range(tests_n):

        [n] = _read_ints()
        a_seq = tuple(_read_ints())
        assert len(a_seq) == n

        try:
            result = f(a_seq)
        except ValueError:
            _print(-1)
        else:
            queries, subsegs_lengths = result
            _print(len(queries))
            _print('\n'.join(['%d %d' % query for query in queries]))
            _print(len(subsegs_lengths))
            _print(*subsegs_lengths)


def _read_ints(file=_sys.stdin):
    return map(int, file.readline().split())


def _print(*objects, sep=' ', end='\n', file=_sys.stdout):
    file.write(sep.join([str(x) for x in objects]) + end)


if __name__ == '__main__':
    _main()","['constructive algorithms', 'sortings']"
"Sam lives in Awesomeburg, its downtown has a triangular shape. Also, the following is true about the triangle:  its vertices have integer coordinates,  the coordinates of vertices are non-negative, and  its vertices are not on a single line. He calls a point on the downtown's border (that is the border of the triangle) safe if he can reach this point from at least one point of the line $$$y = 0$$$ walking along some straight line, without crossing the interior of the triangle.  In the picture the downtown is marked with grey color. The first path is invalid because it does not go along a straight line. The second path is invalid because it intersects with the interior of the downtown. The third and fourth paths are correct. Find the total length of the unsafe parts of the downtown border. It can be proven that these parts are segments and their number is finite.","n=int(input(""""))

k=0
ne=[]
for i in range(n):
    d=0
    a=input("""")
    
    b=input("""")
    c=input("""")
    a=a.split()
    b=b.split()
    c=c.split()
    l=[a,b,c]
    if int(a[1])==int(b[1]) and int(c[1])<int(a[1]):
        d=d+int(a[0])-int(b[0])
    if int(b[1])==int(c[1]) and int(a[1])<int(c[1]):
        d=d+int(b[0])-int(c[0])
    if int(a[1])==int(c[1]) and int(b[1])<int(a[1]):
        d=d+int(a[0])-int(c[0])
    ne.append((d**2)**(1/2))
for j in ne:
    print(j)",['geometry']
"A sequence of positive integers is called great for a positive integer $$$x$$$, if we can split it into pairs in such a way that in each pair the first number multiplied by $$$x$$$ is equal to the second number. More formally, a sequence $$$a$$$ of size $$$n$$$ is great for a positive integer $$$x$$$, if $$$n$$$ is even and there exists a permutation $$$p$$$ of size $$$n$$$, such that for each $$$i$$$ ($$$1 \le i \le \frac{n}{2}$$$) $$$a_{p_{2i-1}} \cdot x = a_{p_{2i}}$$$. Sam has a sequence $$$a$$$ and a positive integer $$$x$$$. Help him to make the sequence great: find the minimum possible number of positive integers that should be added to the sequence $$$a$$$ to make it great for the number $$$x$$$.","import collections
import os, sys
from io import BytesIO, IOBase

inf = sys.maxsize


def get_ints():
    return map(int, input().split())


def get_array():
    return list(map(int, input().split()))


mod = 1000000007
MOD = 998244353


def main():
    for _ in range(int(input())):
        n,x=get_ints()
        A=get_array()
        d=collections.Counter(A)
        A.sort()
        ans=0
        for ele in A:
            if d[ele] and d[ele*x]:
                d[ele]-=1
                d[ele*x]-=1
        print(sum(d.values()))






# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()","['greedy', 'sortings']"
"Masha wants to open her own bakery and bake muffins in one of the n cities numbered from 1 to n. There are m bidirectional roads, each of whose connects some pair of cities.To bake muffins in her bakery, Masha needs to establish flour supply from some storage. There are only k storages, located in different cities numbered a1, a2, ..., ak.Unforunately the law of the country Masha lives in prohibits opening bakery in any of the cities which has storage located in it. She can open it only in one of another n - k cities, and, of course, flour delivery should be paid — for every kilometer of path between storage and bakery Masha should pay 1 ruble.Formally, Masha will pay x roubles, if she will open the bakery in some city b (ai ≠ b for every 1 ≤ i ≤ k) and choose a storage in some city s (s = aj for some 1 ≤ j ≤ k) and b and s are connected by some path of roads of summary length x (if there are more than one path, Masha is able to choose which of them should be used).Masha is very thrifty and rational. She is interested in a city, where she can open her bakery (and choose one of k storages and one of the paths between city with bakery and city with storage) and pay minimum possible amount of rubles for flour delivery. Please help Masha find this amount.","'''input
3 1 1
1 2 3
3
'''
n, m, k = map(int, raw_input().split())

if k == 0:
	print -1
else:
	A = [map(int, raw_input().split()) for _ in xrange(m)]
	storages = map(int, raw_input().split())
	
	mark = [True] * (n + 1)
	for i in storages: mark[i] = False

	res = 10000000000
	for u, v, l in A:
		if mark[u] != mark[v]:
			res = min(res, l)

	print res if res != 10000000000 else -1",['graphs']
"Qpwoeirut has taken up architecture and ambitiously decided to remodel his city.Qpwoeirut's city can be described as a row of $$$n$$$ buildings, the $$$i$$$-th ($$$1 \le i \le n$$$) of which is $$$h_i$$$ floors high. You can assume that the height of every floor in this problem is equal. Therefore, building $$$i$$$ is taller than the building $$$j$$$ if and only if the number of floors $$$h_i$$$ in building $$$i$$$ is larger than the number of floors $$$h_j$$$ in building $$$j$$$.Building $$$i$$$ is cool if it is taller than both building $$$i-1$$$ and building $$$i+1$$$ (and both of them exist). Note that neither the $$$1$$$-st nor the $$$n$$$-th building can be cool.To remodel the city, Qpwoeirut needs to maximize the number of cool buildings. To do this, Qpwoeirut can build additional floors on top of any of the buildings to make them taller. Note that he cannot remove already existing floors.Since building new floors is expensive, Qpwoeirut wants to minimize the number of floors he builds. Find the minimum number of floors Qpwoeirut needs to build in order to maximize the number of cool buildings.","def ss(a,n):
    count = 0
    for i in range(1,n-1,2):
        x = max(a[i-1],a[i+1])
        
        if a[i]<=x:
            count+=x-a[i]+1
    return count 


def ff(s,n):
    lst1 = []
    lst2 = []
    for i in range(1,n-1):
        x = max(a[i-1],a[i+1])
        cost = 0
        if a[i]<=x:
            cost = x-a[i]+1
            
        if i%2==1:
            lst1.append(cost)
        else:
            lst2.append(cost)
    
    x = sum(lst2)
    z = x
    y = x
    x = 0
    mx = z
    for i in range(len(lst1)):
        x+=lst1[i]
        y-=lst2[i]
        mx = min(mx,x+y)
    return mx
    
for _ in range(int(input())):
    n = int(input())
    a = list(map(int,input().split()))
    if n%2==1:
        print(ss(a,n))
    else:
        print(ff(a,n))","['dp', 'flows', 'greedy', 'implementation']"
"This is the easy version of the problem. The only difference between the versions is the constraints on $$$n$$$, $$$k$$$, $$$a_i$$$, and the sum of $$$n$$$ over all test cases. You can make hacks only if both versions of the problem are solved.Note the unusual memory limit.You are given an array of integers $$$a_1, a_2, \ldots, a_n$$$ of length $$$n$$$, and an integer $$$k$$$.The cost of an array of integers $$$p_1, p_2, \ldots, p_n$$$ of length $$$n$$$ is $$$$$$\max\limits_{1 \le i \le n}\left(\left \lfloor \frac{a_i}{p_i} \right \rfloor \right) - \min\limits_{1 \le i \le n}\left(\left \lfloor \frac{a_i}{p_i} \right \rfloor \right).$$$$$$Here, $$$\lfloor \frac{x}{y} \rfloor$$$ denotes the integer part of the division of $$$x$$$ by $$$y$$$. Find the minimum cost of an array $$$p$$$ such that $$$1 \le p_i \le k$$$ for all $$$1 \le i \le n$$$.","import os
import sys
from io import BytesIO, IOBase

import sys
import threading

threading.stack_size(250 * 1024 * 1024)
sys.setrecursionlimit(5000)


BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    A = list(set(map(int, input().split())))

    n = len(A)

    a0 = min(A)

    M = [-1] * (10**5 + 1)
    for a in A:
        p = k
        start = 0
        while p >= 1:
            s = a//p
            M[start] = max(M[start], s)
            start = s + 1

            r = a % p
            p = p - ((p - r) + s)//(s + 1)

    r = 10**20
    m = -10**20
    for i in range(a0 + 1):
#        if M[i] >= 0:
        m = max(m, M[i])
        r = min(r, m - i)

    print(r)","['binary search', 'brute force', 'constructive algorithms', 'greedy', 'number theory']"
"You have a sequence of $$$n$$$ colored blocks. The color of the $$$i$$$-th block is $$$c_i$$$, an integer between $$$1$$$ and $$$n$$$.You will place the blocks down in sequence on an infinite coordinate grid in the following way.   Initially, you place block $$$1$$$ at $$$(0, 0)$$$.  For $$$2 \le i \le n$$$, if the $$$(i - 1)$$$-th block is placed at position $$$(x, y)$$$, then the $$$i$$$-th block can be placed at one of positions $$$(x + 1, y)$$$, $$$(x - 1, y)$$$, $$$(x, y + 1)$$$ (but not at position $$$(x, y - 1)$$$), as long no previous block was placed at that position. A tower is formed by $$$s$$$ blocks such that they are placed at positions $$$(x, y), (x, y + 1), \ldots, (x, y + s - 1)$$$ for some position $$$(x, y)$$$ and integer $$$s$$$. The size of the tower is $$$s$$$, the number of blocks in it. A tower of color $$$r$$$ is a tower such that all blocks in it have the color $$$r$$$.For each color $$$r$$$ from $$$1$$$ to $$$n$$$, solve the following problem independently:   Find the maximum size of a tower of color $$$r$$$ that you can form by placing down the blocks according to the rules.","def solveonecolor(array):

    m = len(array)
    if m==0:
        return 0
    elif m==1:
        return 1
    else:
        maxi = 1
        for i in range(m-1):
            if (array[i+1]-array[i])%2==1:
                maxi+=1

    return maxi


def solve(n, array):
    allans = []
    subarrays = [[] for _ in range(n)]
    for i in range(n):
        color = array[i]-1
        subarrays[color].append(i)

    for color in range(n):
        allans.append(solveonecolor(subarrays[color]))
    print("" "".join(str(i) for i in allans))


tests = int(input())
for _ in range(tests):
    n = int(input())
    array = list(map(int, input().split()))
    solve(n, array)","['dp', 'greedy', 'math']"
"Tanya is learning how to add numbers, but so far she is not doing it correctly. She is adding two numbers $$$a$$$ and $$$b$$$ using the following algorithm:  If one of the numbers is shorter than the other, Tanya adds leading zeros so that the numbers are the same length.  The numbers are processed from right to left (that is, from the least significant digits to the most significant).  In the first step, she adds the last digit of $$$a$$$ to the last digit of $$$b$$$ and writes their sum in the answer.  At each next step, she performs the same operation on each pair of digits in the same place and writes the result to the left side of the answer.  For example, the numbers $$$a = 17236$$$ and $$$b = 3465$$$ Tanya adds up as follows:$$$$$$ \large{ \begin{array}{r} + \begin{array}{r} 17236\\ 03465\\ \end{array} \\ \hline \begin{array}{r} 1106911 \end{array} \end{array}} $$$$$$  calculates the sum of $$$6 + 5 = 11$$$ and writes $$$11$$$ in the answer.  calculates the sum of $$$3 + 6 = 9$$$ and writes the result to the left side of the answer to get $$$911$$$.  calculates the sum of $$$2 + 4 = 6$$$ and writes the result to the left side of the answer to get $$$6911$$$.  calculates the sum of $$$7 + 3 = 10$$$, and writes the result to the left side of the answer to get $$$106911$$$.  calculates the sum of $$$1 + 0 = 1$$$ and writes the result to the left side of the answer and get $$$1106911$$$. As a result, she gets $$$1106911$$$.You are given two positive integers $$$a$$$ and $$$s$$$. Find the number $$$b$$$ such that by adding $$$a$$$ and $$$b$$$ as described above, Tanya will get $$$s$$$. Or determine that no suitable $$$b$$$ exists.","for s in[*open(0)][1:]:
 a,s=map(int,s.split());b=0;k=1
 while s>0<=(d:=s%(m:=10)-a%m)or-1<(d:=s%(m:=100)-a%10)<=9<s:a//=10;s//=m;b+=k*d;k*=10
 print((b,-1)[a>0])",['implementation']
"You are given a permutation $$$p$$$ of $$$n$$$ elements. A permutation of $$$n$$$ elements is an array of length $$$n$$$ containing each integer from $$$1$$$ to $$$n$$$ exactly once. For example, $$$[1, 2, 3]$$$ and $$$[4, 3, 5, 1, 2]$$$ are permutations, but $$$[1, 2, 4]$$$ and $$$[4, 3, 2, 1, 2]$$$ are not permutations. You should perform $$$q$$$ queries.There are two types of queries:  $$$1$$$ $$$x$$$ $$$y$$$ — swap $$$p_x$$$ and $$$p_y$$$.  $$$2$$$ $$$i$$$ $$$k$$$ — print the number that $$$i$$$ will become if we assign $$$i = p_i$$$ $$$k$$$ times.","import sys
import random
 
inp = [int(x) for x in sys.stdin.buffer.read().split()]; ii = 0
 
n = inp[ii]; ii += 1
q = inp[ii]; ii += 1
 
P = inp[ii: ii + n]; ii += n
P = [i - 1 for i in P]
 
special = [+(not random.randrange(400)) for _ in range(n)]
dist = [-1] * n
nesta = [-1] * n
memory = [-2] * n
version = [-1] * (n + 1)
 
def forget(x):
    if not special[x]:
        xx = x
        special[xx] = 1
        
        x = P[x]
        while not special[x]:
            x = P[x]
        
        special[xx] = 0
        if xx == x:
            return
    version[x] += 1
 
def update(node):
    if memory[node] < version[nesta[node]]:
        d = 1
        i = P[node]
        while not special[i]:
            i = P[i]
            d += 1
        
        memory[node] = version[i]
        nesta[node] = i
        dist[node] = d
 
def walk(i, k):
    while k and not special[i]:
        k -= 1
        i = P[i]
    
    if k:
        while update(i) or dist[i] <= k:
            k -= dist[i]
            i = nesta[i]
 
    while k:
        k -= 1
        i = P[i]
    
    return i
 
for _ in range(q):
    qtype = inp[ii]; ii += 1
    if qtype == 1:
        x = inp[ii] - 1; ii += 1
        y = inp[ii] - 1; ii += 1
 
        P[x], P[y] = P[y], P[x]
 
        forget(P[x])
        forget(P[y])
    else:
        i = inp[ii] - 1; ii += 1
        k = inp[ii]; ii += 1
 
        print(walk(i, k) + 1)","['brute force', 'data structures', 'divide and conquer', 'two pointers']"
"Vladik is a competitive programmer. This year he is going to win the International Olympiad in Informatics. But it is not as easy as it sounds: the question Vladik face now is to find the cheapest way to get to the olympiad.Vladik knows n airports. All the airports are located on a straight line. Each airport has unique id from 1 to n, Vladik's house is situated next to the airport with id a, and the place of the olympiad is situated next to the airport with id b. It is possible that Vladik's house and the place of the olympiad are located near the same airport. To get to the olympiad, Vladik can fly between any pair of airports any number of times, but he has to start his route at the airport a and finish it at the airport b.Each airport belongs to one of two companies. The cost of flight from the airport i to the airport j is zero if both airports belong to the same company, and |i - j| if they belong to different companies.Print the minimum cost Vladik has to pay to get to the olympiad.","n,a,b = map(int,input().split())
s = input()
a-=1
b-=1
if(s[a]=='0'):
	if(s[b]=='0'):
		print(0)
	else:
		print(1)
	
else:
	if(s[b]=='1'):
		print(0)
	else:
		print(1)","['constructive algorithms', 'implementation', 'greedy']"
"Note: The XOR-sum of set $$$\{s_1,s_2,\ldots,s_m\}$$$ is defined as $$$s_1 \oplus s_2 \oplus \ldots \oplus s_m$$$, where $$$\oplus$$$ denotes the bitwise XOR operation.After almost winning IOI, Victor bought himself an $$$n\times n$$$ grid containing integers in each cell. $$$n$$$ is an even integer. The integer in the cell in the $$$i$$$-th row and $$$j$$$-th column is $$$a_{i,j}$$$.Sadly, Mihai stole the grid from Victor and told him he would return it with only one condition: Victor has to tell Mihai the XOR-sum of all the integers in the whole grid.Victor doesn't remember all the elements of the grid, but he remembers some information about it: For each cell, Victor remembers the XOR-sum of all its neighboring cells.Two cells are considered neighbors if they share an edge — in other words, for some integers $$$1 \le i, j, k, l \le n$$$, the cell in the $$$i$$$-th row and $$$j$$$-th column is a neighbor of the cell in the $$$k$$$-th row and $$$l$$$-th column if $$$|i - k| = 1$$$ and $$$j = l$$$, or if $$$i = k$$$ and $$$|j - l| = 1$$$.To get his grid back, Victor is asking you for your help. Can you use the information Victor remembers to find the XOR-sum of the whole grid?It can be proven that the answer is unique.","''' E. Grid Xor
https://codeforces.com/contest/1629/problem/E
'''

import io, os, sys
input = sys.stdin.readline 
output = sys.stdout.write

DEBUG = os.environ.get('debug') not in [None, '0']

if DEBUG:
    from inspect import currentframe, getframeinfo
    from re import search

def debug(*args):
    if not DEBUG: return
    frame = currentframe().f_back
    s = getframeinfo(frame).code_context[0]
    r = search(r""\((.*)\)"", s).group(1)
    vnames = r.split(', ')
    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]
    prefix = f'{currentframe().f_back.f_lineno:02d}: '
    print(f'{prefix}{"", "".join(var_and_vals)}')


INF = float('inf')

# -----------------------------------------

# https://codeforces.com/blog/entry/99276?#comment-880317
# each cell should have odd number of chosen neighbors
# fix row 1 to all 0
# then choose (r, c) if (r-1, c) has even number of 1 neighbors

# but why is last row valid?

def solve(N, grid):
    res = 0
    chosen = [[0]*N for _ in range(N)]
    for r in range(1, N):
        for c in range(N):
            cnt = 0
            if r > 1: cnt += chosen[r-2][c]
            if c > 0: cnt += chosen[r-1][c-1]
            if c < N-1: cnt += chosen[r-1][c+1]
            if cnt % 2 == 0:
                chosen[r][c] = 1
                res ^= grid[r][c]
    
    return res


def main():
    T = int(input())
    for _ in range(T):
        N = int(input())
        grid = [list(map(int, input().split())) for _ in range(N)]
        out = solve(N, grid)
        print(out)


if __name__ == '__main__':
    main()","['constructive algorithms', 'greedy', 'interactive', 'math']"
"This is the hard version of the problem. The difference is the constraints on $$$n$$$, $$$m$$$ and $$$t$$$. You can make hacks only if all versions of the problem are solved.Alice and Bob are given the numbers $$$n$$$, $$$m$$$ and $$$k$$$, and play a game as follows:The game has a score that Alice tries to maximize, and Bob tries to minimize. The score is initially $$$0$$$. The game consists of $$$n$$$ turns. Each turn, Alice picks a real number from $$$0$$$ to $$$k$$$ (inclusive) which Bob either adds to or subtracts from the score of the game. But throughout the game, Bob has to choose to add at least $$$m$$$ out of the $$$n$$$ turns.Bob gets to know which number Alice picked before deciding whether to add or subtract the number from the score, and Alice gets to know whether Bob added or subtracted the number for the previous turn before picking the number for the current turn (except on the first turn since there was no previous turn).If Alice and Bob play optimally, what will the final score of the game be?","import sys
import os
from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
MOD=10**9+7
facts=[1 for _ in range(10**6+1)]
for i in range(1,10**6+1):
    facts[i]=(facts[i-1]*i)%MOD
factinvs=[1 for _ in range(10**6+1)]
factinvs[-1]=pow(facts[-1],MOD-2,MOD)
temp=factinvs[-1]
for i in range(10**6,1,-1):
    factinvs[i-1]=(factinvs[i]*i)%MOD
powinvs=[1 for _ in range(10**6+1)]
inv_2=pow(2,MOD-2,MOD)
for i in range(1,10**6+1):
    powinvs[i]=powinvs[i-1]*inv_2%MOD
def binom(n,m):
    return facts[n]*factinvs[m]*factinvs[n-m]%MOD
def solve():
    n,m,k=map(int,input().split())
    if n==m:
        print((m*k)%MOD)
        return
    res=0
    for i in range(1,m+1):
        c=binom(n-i-1,m-i)
        p=powinvs[n-i]
        res+=(c*p*i*k)%MOD
        res%=MOD
    print(res)
 
for _ in range(int(input())):solve()","['combinatorics', 'dp', 'games']"
"This is the easy version of the problem. The difference is the constraints on $$$n$$$, $$$m$$$ and $$$t$$$. You can make hacks only if all versions of the problem are solved.Alice and Bob are given the numbers $$$n$$$, $$$m$$$ and $$$k$$$, and play a game as follows:The game has a score that Alice tries to maximize, and Bob tries to minimize. The score is initially $$$0$$$. The game consists of $$$n$$$ turns. Each turn, Alice picks a real number from $$$0$$$ to $$$k$$$ (inclusive) which Bob either adds to or subtracts from the score of the game. But throughout the game, Bob has to choose to add at least $$$m$$$ out of the $$$n$$$ turns.Bob gets to know which number Alice picked before deciding whether to add or subtract the number from the score, and Alice gets to know whether Bob added or subtracted the number for the previous turn before picking the number for the current turn (except on the first turn since there was no previous turn).If Alice and Bob play optimally, what will the final score of the game be?","mxn=10**9 + 7

def modI(a, m):

    m0=m
    y=0
    x=1;
    if(m==1): return 0;
    while(a>1):
    
        q=a//m;
        t=m;
        m=a%m;
        a=t;
        t=y;
        y=x-q*y;
        x=t;
    
    if(x<0):x+=m0;
    return x;

def fastfrac(a,b,M):
    numb = modI(b,M)
    return ((a%M)*(numb%M))%M
    

for _ in range(int(input())):
    n,m,k=map(int,input().split())
    dp=[[0 for i in range(m+1)] for j in range(n+1)]
    for i in range(1,n+1):
        for j in range(1,m+1):
            if i==j:
                dp[i][j]=(k*i)%mxn
            else:
                dp[i][j]=fastfrac((dp[i-1][j]+dp[i-1][j-1])%mxn,2,mxn)
    print(dp[n][m])","['combinatorics', 'dp', 'games']"
"Pak Chanek is playing one of his favourite board games. In the game, there is a directed graph with $$$N$$$ vertices and $$$M$$$ edges. In the graph, edge $$$i$$$ connects two different vertices $$$U_i$$$ and $$$V_i$$$ with a length of $$$W_i$$$. By using the $$$i$$$-th edge, something can move from $$$U_i$$$ to $$$V_i$$$, but not from $$$V_i$$$ to $$$U_i$$$.To play this game, initially Pak Chanek must place both of his hands onto two different vertices. In one move, he can move one of his hands to another vertex using an edge. To move a hand from vertex $$$U_i$$$ to vertex $$$V_i$$$, Pak Chanek needs a time of $$$W_i$$$ seconds. Note that Pak Chanek can only move one hand at a time. This game ends when both of Pak Chanek's hands are on the same vertex.Pak Chanek has several questions. For each $$$p$$$ satisfying $$$2 \leq p \leq N$$$, you need to find the minimum time in seconds needed for Pak Chanek to end the game if initially Pak Chanek's left hand and right hand are placed on vertex $$$1$$$ and vertex $$$p$$$, or report if it is impossible.","import sys
from array import array
from heapq import *


class graph:
    def __init__(self, n):
        self.n = n
        self.gdict = [array('i') for _ in range(n + 1)]
        self.weight = [array('i') for _ in range(n + 1)]
        self.dir = [array('b') for _ in range(n + 1)]

    def add_edge(self, node1, node2):
        self.gdict[node1].append(node2)
        self.gdict[node2].append(node1)
        self.dir[node1].append(1)
        self.dir[node2].append(0)

    def add_wedge(self, node1, node2, w):
        self.weight[node1].append(w)
        self.weight[node2].append(w)

    def dijkstra(self, root):
        # initial distances
        self.dist = [10 ** 18] * (self.n + 1)
        vis = array('b', [0] * (self.n + 1))
        self.dist[root], que = 0, [(0, root)]

        # traverse all nodes
        while que:
            d, u = heappop(que)

            # traverse all adjacent nodes and update distances
            if not vis[u]:
                for i in range(len(self.gdict[u])):
                    v, d2, dir = self.gdict[u][i], self.weight[u][i], self.dir[u][i]
                    cost = d2 + self.dist[u]

                    if not vis[v] and dir and cost < self.dist[v]:
                        self.dist[v] = cost
                        heappush(que, (self.dist[v], v))
                vis[u] = 1

        vis = array('b', [0] * (self.n + 1))
        que = [(self.dist[i], i) for i in range(1, self.n + 1)]
        heapify(que)
        while que:
            d, u = heappop(que)

            # traverse all adjacent nodes and update distances
            if not vis[u]:
                for i in range(len(self.gdict[u])):
                    v, d2, dir = self.gdict[u][i], self.weight[u][i], self.dir[u][i]
                    cost = d2 + self.dist[u]

                    if not vis[v] and not dir and cost < self.dist[v]:
                        self.dist[v] = cost
                        heappush(que, (self.dist[v], v))

                vis[u] = 1

        for i in range(1, self.n + 1):
            if self.dist[i] == 10 ** 18:
                self.dist[i] = -1
        print(' '.join(map(str, self.dist[2:])))

input = lambda: sys.stdin.buffer.readline().decode().strip()
n, m = map(int, input().split())
g = graph(n)
for _ in range(m):
    u, v, w = map(int, input().split())
    g.add_edge(u, v)
    g.add_wedge(u, v, w)
g.dijkstra(1)","['dp', 'graphs', 'shortest paths']"
"There are one cat, $$$k$$$ mice, and one hole on a coordinate line. The cat is located at the point $$$0$$$, the hole is located at the point $$$n$$$. All mice are located between the cat and the hole: the $$$i$$$-th mouse is located at the point $$$x_i$$$ ($$$0 &lt; x_i &lt; n$$$). At each point, many mice can be located.In one second, the following happens. First, exactly one mouse moves to the right by $$$1$$$. If the mouse reaches the hole, it hides (i.e. the mouse will not any more move to any point and will not be eaten by the cat). Then (after that the mouse has finished its move) the cat moves to the right by $$$1$$$. If at the new cat's position, some mice are located, the cat eats them (they will not be able to move after that). The actions are performed until any mouse hasn't been hidden or isn't eaten.In other words, the first move is made by a mouse. If the mouse has reached the hole, it's saved. Then the cat makes a move. The cat eats the mice located at the pointed the cat has reached (if the cat has reached the hole, it eats nobody).Each second, you can select a mouse that will make a move. What is the maximum number of mice that can reach the hole without being eaten?","t=int(input())
for i in range(t):
    n,k=map(int,input().split())
    mouse=list(map(int,input().strip().split()))
    mouse.sort(reverse=True)
    cat=0
    count=0
    while (count < len(mouse) and cat +n-mouse[count] < n):
        cat=cat+n-mouse[count]
        count+=1
    print(count)","['binary search', 'greedy', 'greedy']"
"It is given a non-negative integer $$$x$$$, the decimal representation of which contains $$$n$$$ digits. You need to color each its digit in red or black, so that the number formed by the red digits is divisible by $$$A$$$, and the number formed by the black digits is divisible by $$$B$$$.At least one digit must be colored in each of two colors. Consider, the count of digits colored in red is $$$r$$$ and the count of digits colored in black is $$$b$$$. Among all possible colorings of the given number $$$x$$$, you need to output any such that the value of $$$|r - b|$$$ is the minimum possible.Note that the number $$$x$$$ and the numbers formed by digits of each color, may contain leading zeros.  Example of painting a number for $$$A = 3$$$ and $$$B = 13$$$ The figure above shows an example of painting the number $$$x = 02165$$$ of $$$n = 5$$$ digits for $$$A = 3$$$ and $$$B = 13$$$. The red digits form the number $$$015$$$, which is divisible by $$$3$$$, and the black ones — $$$26$$$, which is divisible by $$$13$$$. Note that the absolute value of the difference between the counts of red and black digits is $$$1$$$, it is impossible to achieve a smaller value.","import sys
import io, os
input = sys.stdin.readline

from collections import defaultdict

def main():

    t = int(input())
    for _ in range(t):
        n, a, b = map(int, input().split())
        s = list(str(input().rstrip()))
        s = [int(c) for c in s]
        dp = [-1]*(a*b*(n+1)*(n+1))
        dp[0] = 0

        def getindex(i, j, ra, rb):
            return i*(n+1)*a*b+j*a*b+ra*b+rb

        for i, c in enumerate(s):
            for j in range(i+1):
                for ra in range(a):
                    for rb in range(b):
                        idx = getindex(i, j, ra, rb)
                        if dp[idx] == -1:
                            continue
                        #red
                        nra = (ra*10+c)%a
                        nidx =getindex(i+1, j+1, nra, rb)
                        dp[nidx] = idx
                        #black
                        nrb = (rb*10+c)%b
                        nidx =getindex(i+1, j, ra, nrb)
                        dp[nidx] = idx
        bestj = 0
        for j in range(1, n+1):
            idx = getindex(n, j, 0, 0)
            if dp[idx] != -1 and abs(j-(n-j)) < abs(bestj-(n-bestj)):
                bestj = j
        if bestj == 0:
            print(-1)
            continue
        cur = n
        j = bestj
        ra = 0
        rb = 0
        ans = []
        while cur > 0:
            idx = getindex(cur, j, ra, rb)
            pidx = dp[idx]
            cur, r = divmod(pidx, (n+1)*a*b)
            pj, r =  divmod(r, a*b)
            ra, rb = divmod(r, b)
            if pj == j-1:
                ans.append('R')
            else:
                ans.append('B')
            j = pj
        ans.reverse()
        print(''.join(ans))

if __name__ == '__main__':
    main()","['dfs and similar', 'dp', 'implementation', 'math', 'meet-in-the-middle']"
"Omkar and Akmar are playing a game on a circular board with $$$n$$$ ($$$2 \leq n \leq 10^6$$$) cells. The cells are numbered from $$$1$$$ to $$$n$$$ so that for each $$$i$$$ ($$$1 \leq i \leq n-1$$$) cell $$$i$$$ is adjacent to cell $$$i+1$$$ and cell $$$1$$$ is adjacent to cell $$$n$$$. Initially, each cell is empty.Omkar and Akmar take turns placing either an A or a B on the board, with Akmar going first. The letter must be placed on an empty cell. In addition, the letter cannot be placed adjacent to a cell containing the same letter. A player loses when it is their turn and there are no more valid moves.Output the number of possible distinct games where both players play optimally modulo $$$10^9+7$$$. Note that we only consider games where some player has lost and there are no more valid moves.Two games are considered distinct if the number of turns is different or for some turn, the letter or cell number that the letter is placed on were different.A move is considered optimal if the move maximizes the player's chance of winning, assuming the other player plays optimally as well. More formally, if the player who has to move has a winning strategy, they have to make a move after which they will still have a winning strategy. If they do not, they can make any move.","from math import factorial
def win(a):
	bw = None;bc = 0
	for i in range(len(a)):
		if a[i] is None:
			for j in range(2):
				if a[i-1] == j or a[(i+1)%len(a)] == j:continue
				a[i] = j;w, c = win(a);a[i] = None
				if bw != False:
					bw = w
					if w == False:bc = c
					else:bc += c
				else:bc += c
	if bw is None:return False, 1
	else:return ((not bw), bc)
F = dict()
def win1(left, d):
	global F;a = []
	if left == 0:return 0
	if (left, d) in F:return F[(left, d)]	
	if left == 1:
		if d == 0:a.append(0)
		else:F[(left, d)] = 0;return 0
	else:
		if d == 1:
			a.append(win1(0,1) ^ win1(left-1,0))
			for i in range(1,left-1):a.append(win1(i,1) ^ win1(left-i-1,0));a.append(win1(i,0) ^ win1(left-i-1,1))
		else:
			a.append(win1(0,1) ^ win1(left-1,1))
			for i in range(1,left-1):a.append(win1(i,1) ^ win1(left-i-1,1));a.append(win1(i,0) ^ win1(left-i-1,0))
	s = set(a)
	for i in range(100000):
		if i not in s:F[(left, d)] = i;return i
def rec(a, i):
	if i == len(a):
		for i in range(len(a)):
			if a[i] == 1 and (a[i-1] == 1 or a[(i+1)%len(a)] == 1):return 0
		print(a);return 1
	r = 0
	for j in range(2):a[i] = j;r += rec(a, i+1)
	return r
MOD = 10**9+7;F = [0]*(10**6+3);F[0] = 1
for i in range(1,len(F)):F[i] = (F[i-1]*i)%MOD
FI = [0]*len(F);FI[-1] = pow(F[-1], MOD-2, MOD)
for i in range(len(F)-2,-1,-1):FI[i] = (FI[i+1]*(i+1))%MOD
def C(n, k):return (F[n]*FI[n-k]*FI[k]) % MOD
def H(n, k):
	if k == 0:return 1
	return C(n-k,k)+C(n-k-1,k-1)
def solve():
	n = int(input());r = 0
	for i in range(n):
		if i*2 > n:break
		if (n - i) % 2 == 0:r = (r + H(n, i) * F[n-i]) % MOD
	print((2*r)%MOD)
solve()","['chinese remainder theorem', 'combinatorics', 'constructive algorithms', 'fft', 'games', 'geometry', 'math', 'meet-in-the-middle', 'string suffix structures']"
"You are given a sequence $$$a$$$ of length $$$n$$$ consisting of $$$0$$$s and $$$1$$$s.You can perform the following operation on this sequence:   Pick an index $$$i$$$ from $$$1$$$ to $$$n-2$$$ (inclusive).  Change all of $$$a_{i}$$$, $$$a_{i+1}$$$, $$$a_{i+2}$$$ to $$$a_{i} \oplus a_{i+1} \oplus a_{i+2}$$$ simultaneously, where $$$\oplus$$$ denotes the bitwise XOR operation  Find a sequence of at most $$$n$$$ operations that changes all elements of $$$a$$$ to $$$0$$$s or report that it's impossible.We can prove that if there exists a sequence of operations of any length that changes all elements of $$$a$$$ to $$$0$$$s, then there is also such a sequence of length not greater than $$$n$$$.","try:
        import sys
        from functools import lru_cache, cmp_to_key
        from heapq import merge, heapify, heappop, heappush
        # from math import *
        from collections import defaultdict as dd, deque, Counter as C
        from itertools import combinations as comb, permutations as perm
        from bisect import bisect_left as bl, bisect_right as br, bisect, insort
        from time import perf_counter
        from fractions import Fraction
        import copy
        from copy import deepcopy
        import time
        starttime = time.time()
        mod = int(pow(10, 9) + 7)
        mod2 = 998244353

        def data(): return sys.stdin.readline().strip()
        def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
        def L(): return list(sp())
        def sl(): return list(ssp())
        def sp(): return map(int, data().split())
        def ssp(): return map(str, data().split())
        def l1d(n, val=0): return [val for i in range(n)]
        def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
        def A2(n,m): return [[0]*m for i in range(n)]
        def A(n):return [0]*n
        # sys.setrecursionlimit(int(pow(10,6)))
        # from sys import stdin
        # input = stdin.buffer.readline
        # I = lambda : list(map(int,input().split()))
        # import sys
        # input=sys.stdin.readline
        

        sys.stdin = open(""input.txt"", ""r"")
        sys.stdout = open(""output.txt"", ""w"")
except:
        pass

for _ in range(L()[0]):
        n = L()[0]
        A = L()

        x = 0 
        for ele in A:
                x^=ele 
        if x:
                print(""NO"")
                continue


        if n%2:
                print(""YES"")
                ans = []
                for i in range(1,n,2):
                        ans.append(i)
                for i in range(n-4,0,-2):
                        ans.append(i)
                print(len(ans))
                print(*ans)
        else:
                x = 0
                
                for i,ele in enumerate(A):
                        x^=ele 
                        if i%2==0 and x==0:
                                print(""YES"")
                                ans = []
                                for j in range(1,i+1,2):
                                        ans.append(j)
                                for j in range(i+1-4,0,-2):
                                        ans.append(j)
                                for j in range(i+2,n,2):
                                        ans.append(j)
                                for j in range(n-4,i+1,-2):
                                        ans.append(j)
                                print(len(ans))
                                print(*ans)
                                break
                else:
                        print(""NO"")",['constructive algorithms']
"Ela likes to go hiking a lot. She loves nature and exploring the various creatures it offers. One day, she saw a strange type of ant, with a cannibalistic feature. More specifically, an ant would eat any ants that it sees which is smaller than it.Curious about this feature from a new creature, Ela ain't furious. She conducts a long, non-dubious, sentimental experiment.She puts $$$n$$$ cannibalistic ants in a line on a long wooden stick. Initially, the ants have the same weight of $$$1$$$. The distance between any two consecutive ants is the same. The distance between the first ant in the line to the left end and the last ant in the line to the right end is also the same as the distance between the ants. Each ant starts moving towards the left-end or the right-end randomly and equiprobably, at the same constant pace throughout the experiment. Two ants will crash if they are standing next to each other in the line and moving in opposite directions, and ants will change direction immediately when they reach the end of the stick. Ela can't determine the moving direction of each ant, but she understands very well their behavior when crashes happen.  If a crash happens between two ants of different weights, the heavier one will eat the lighter one, and gain the weight of the lighter one. After that, the heavier and will continue walking in the same direction. In other words, if the heavier one has weight $$$x$$$ and walking to the right, the lighter one has weight $$$y$$$ and walking to the left ($$$x &gt; y$$$), then after the crash, the lighter one will diminish, and the heavier one will have weight $$$x + y$$$ and continue walking to the right.  If a crash happens between two ants with the same weight, the one walking to the left end of the stick will eat the one walking to the right, and then continue walking in the same direction. In other words, if one ant of weight $$$x$$$ walking to the left, crashes with another ant of weight $$$x$$$ walking to the right, the one walking to the right will disappear, and the one walking to the left will have to weight $$$2x$$$ and continue walking to the left. Please, check the example in the ""Note"" section, which will demonstrate the ants' behavior as above.We can prove that after a definite amount of time, there will be only one last ant standing. Initially, each ant can randomly and equiprobably move to the left or the right, which generates $$$2^n$$$ different cases of initial movements for the whole pack. For each position in the line, calculate the probability that the ant begins in that position and survives. Output it modulo $$$10^9 + 7$$$.Formally, let $$$M = 10^9 + 7$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \not \equiv 0 \pmod{M}$$$. Output the integer equal to $$$p \cdot q^{-1} \bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \le x &lt; M$$$ and $$$x \cdot q \equiv p \pmod{M}$$$.","import sys
import math
import heapq
import itertools
import bisect
import random
import time
from collections import deque
input=sys.stdin.readline

mod=10**9+7
def power(a,n):
    if n==0:
        return 1
    x=power(a,n//2)
    if n%2==0:
        return x*x%mod
    else:
        return x*x*a%mod

def d(a):
    return power(a,mod-2)

d2=d(2)
pp=[d(power(2,0))]
for i in range(1000005):
    pp.append((pp[-1]*d2)%mod)
t=int(input())
for _ in range(t):
    n=int(input())

    ans=[1 for _ in range(n+1)]
    dp=[0 for _ in range(n+1)]
    for i in range(n//2+1,n+1):
        dp[i]=1

    dp[n//2]=(1-d(pow(2,n//2-1)))%mod
    
    for i in range(n//2-1,0,-1):
        dp[i]=(dp[i+1]-dp[i*2]*pp[i]-dp[i*2+1]*pp[i+1])%mod
    
    for i in range(1,n+1):
        p=max(0,(i-1)//2)
   
        ans[i]=(dp[i]*pp[p])%mod
        if i!=n:
            ans[i]=(ans[i]*d2)%mod

    for i in range(1,n+1):
        print(ans[i])","['combinatorics', 'dp', 'math', 'probabilities']"
"While working at DTL, Ela is very aware of her physical and mental health. She started to practice various sports, such as Archery, Yoga, and Football.Since she started engaging in sports activities, Ela switches to trying a new sport on days she considers being ""Luxury"" days. She counts the days since she started these activities, in which the day she starts is numbered as day $$$1$$$. A ""Luxury"" day is the day in which the number of this day is a luxurious number. An integer $$$x$$$ is called a luxurious number if it is divisible by $$${\lfloor \sqrt{x} \rfloor}$$$.Here $$$\lfloor r \rfloor$$$ denotes the ""floor"" of a real number $$$r$$$. In other words, it's the largest integer not greater than $$$r$$$.For example: $$$8$$$, $$$56$$$, $$$100$$$ are luxurious numbers, since $$$8$$$ is divisible by $$$\lfloor \sqrt{8} \rfloor = \lfloor 2.8284 \rfloor = 2$$$, $$$56$$$ is divisible $$$\lfloor \sqrt{56} \rfloor = \lfloor 7.4833 \rfloor = 7$$$, and $$$100$$$ is divisible by $$$\lfloor \sqrt{100} \rfloor = \lfloor 10 \rfloor = 10$$$, respectively. On the other hand $$$5$$$, $$$40$$$ are not, since $$$5$$$ are not divisible by $$$\lfloor \sqrt{5} \rfloor = \lfloor 2.2361 \rfloor = 2$$$, and $$$40$$$ are not divisible by $$$\lfloor \sqrt{40} \rfloor = \lfloor 6.3246 \rfloor = 6$$$.Being a friend of Ela, you want to engage in these fitness activities with her to keep her and yourself accompanied (and have fun together, of course). Between day $$$l$$$ and day $$$r$$$, you want to know how many times she changes the activities.","import sys,math
input=sys.stdin.readline
for  _ in range(int(input())):
    #n=int(input())
    l,r=map(int,input().split())
    #a=list(map(int,input().split()))
    a=math.isqrt(l)
    b=math.isqrt(r)
    ans=0
    if a==b:
        if r>=a**2>=l:
            ans+=1  
        if r>=(a**2)+2*a>=l:
            ans+=1
        if r>=(a**2)+a>=l:
            ans+=1
    else:
        if a+1<=b-1:
            ans+=3*(b-1-a)
        if a**2>=l:
            ans+=1  
        if (a**2)+2*a>=l:
            ans+=1
        if (a**2)+a>=l:
            ans+=1
        if b**2<=r:
            ans+=1  
        if (b**2)+2*b<=r:
            ans+=1
        if (b**2)+b<=r:
            ans+=1
    print(ans)","['binary search', 'implementation', 'math']"
"Ela likes Chess a lot. During breaks, she usually challenges her co-worker in DTL to some chess games. She's not an expert at classic chess, but she's very interested in Chess variants, where she has to adapt to new rules and test her tactical mindset to win the game.The problem, which involves a non-standard chess pieces type that is described below, reads: given $$$3$$$ white crickets on a $$$n \cdot n$$$ board, arranged in an ""L"" shape next to each other, there are no other pieces on the board. Ela wants to know with a finite number of moves, can she put any white cricket on the square on row $$$x$$$, column $$$y$$$?An ""L""-shape piece arrangement can only be one of the below:    For simplicity, we describe the rules for crickets on the board where only three white crickets are. It can move horizontally, vertically, or diagonally, but only to a square in some direction that is immediately after another cricket piece (so that it must jump over it). If the square immediately behind the piece is unoccupied, the cricket will occupy the square. Otherwise (when the square is occupied by another cricket, or does not exist), the cricket isn't allowed to make such a move.See an example of valid crickets' moves on the pictures in the Note section.","import math
import collections
import bisect
import heapq

from collections import deque
from math import sqrt,ceil, floor

def inp_arr():
    return list(map(int, input().strip().split("" "")))
    
def inp_int():
    return int(input())
    
def inp_str():
    return input()
    
'''................................................................................'''

def solve():
    # cook your dish here
    n, = inp_arr()
    
    r1,c1,r2,c2,r3,c3 = inp_arr()
    x,y = inp_arr()
    
    r0 = (r1+r2+r3 - (r1^r2^r3))//2
    c0 = (c1+c2+c3 - (c1^c2^c3))//2
    
    corners = [[1,1], [1,n], [n,n], [n,1]]
    
    if([r0, c0] in corners):
        if(x == r0 or y==c0):
            print(""YES"")
        else:
            print(""NO"")
        return
    
    def check(x1,y1,x2,y2):
        diff1 = abs(x1-x2)
        diff2 = abs(y1-y2)
        
        if(diff1%2==0 and diff2%2==0):
            return True
        
        return False
        
    if(check(r1,c1,x,y) or check(r2,c2,x,y) or check(r3,c3,x,y)):
        print(""YES"")
        return
    
    print(""NO"")







tt = inp_int()
# tt = 1
for t in range(tt):
    solve()","['constructive algorithms', 'games', 'implementation', 'math']"
"You are given a string $$$a$$$, consisting of $$$n$$$ characters, $$$n$$$ is even. For each $$$i$$$ from $$$1$$$ to $$$n$$$ $$$a_i$$$ is one of 'A', 'B' or 'C'.A bracket sequence is a string containing only characters ""("" and "")"". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example, bracket sequences ""()()"" and ""(())"" are regular (the resulting expressions are: ""(1)+(1)"" and ""((1+1)+1)""), and "")("", ""("" and "")"" are not.You want to find a string $$$b$$$ that consists of $$$n$$$ characters such that:   $$$b$$$ is a regular bracket sequence;  if for some $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$) $$$a_i=a_j$$$, then $$$b_i=b_j$$$. In other words, you want to replace all occurrences of 'A' with the same type of bracket, then all occurrences of 'B' with the same type of bracket and all occurrences of 'C' with the same type of bracket.Your task is to determine if such a string $$$b$$$ exists.","f=int(input())
for i in range(f):
    li=input()
    if li[0] == li[-1]:
        print(""NO"")
        continue
    x=0
    y=0
    z=0
    a1=li[0]
    a2=li[-1]
    open1=0
    close1=0
    summ=0
    for i in range(len(li)):
        if li[i]==a1:
            open1+=1
        elif li[i]==a2:
            close1+=1
        else:
            summ+=1
    c1=0
    c2=0;
    if open1+summ==close1:
        for i in range(len(li)):
            if li[i]==a2:
                c2+=1
            else:
                c1+=1
            if c2>c1:
                break
    elif open1==summ+close1:
        for i in range(len(li)):
            if li[i]==a1:
                c1+=1
            else:
                c2+=1
            if c2>c1:
                break
    else:
        print(""NO"")
        continue
    if c2>c1:
        print(""NO"")
    else:
        print(""YES"")","['bitmasks', 'brute force', 'implementation']"
"You are given a permutation $$$p_1, p_2, \ldots, p_n$$$ of length $$$n$$$ of numbers $$$0, \ldots, n - 1$$$. Count the number of subsegments $$$1 \leq l \leq r \leq n$$$ of this permutation such that $$$mex(p_l, p_{l+1}, \ldots, p_r) &gt; med(p_l, p_{l+1}, \ldots, p_r)$$$.$$$mex$$$ of $$$S$$$ is the smallest non-negative integer that does not occur in $$$S$$$. For example: $$$mex({0, 1, 2, 3}) = 4$$$ $$$mex({0, 4, 1, 3}) = 2$$$ $$$mex({5, 4, 0, 1, 2}) = 3$$$$$$med$$$ of the set $$$S$$$ is the median of the set, i.e. the element that, after sorting the elements in non-decreasing order, will be at position number $$$\left \lfloor{ \frac{|S| + 1}{2} } \right \rfloor$$$ (array elements are numbered starting from $$$1$$$ and here $$$\left \lfloor{v} \right \rfloor$$$ denotes rounding $$$v$$$ down.). For example: $$$med({0, 1, 2, 3}) = 1$$$ $$$med({0, 4, 1, 3}) = 1$$$ $$$med({5, 4, 0, 1, 2}) = 2$$$A sequence of $$$n$$$ numbers is called a permutation if it contains all the numbers from $$$0$$$ to $$$n - 1$$$ exactly once.","m=int(input())
for _ in range(m):
    n=int(input())
    s=dict(zip(map(int,input().split()),range(n)))
    mi=s[0]
    ma=mi
    lists=0
    n0=int(n/2)+n%2
    for i in range(n0):
        si=s[i]
        mi=min(mi,si)
        ma=max(ma,si)
        b1=2*i+1
        b2=b1+1
        a1=min(b1-ma+mi,mi+1,n-ma,n-b1+1)
        a2=min(b2-ma+mi,mi+1,n-ma,n-b2+1)
        if b2<=n and a2>0:
            lists=lists+a2
        if a1>0:
            lists=lists+a1
    print(lists)","['math', 'two pointers']"
"You are given an array of positive integers $$$a_1, a_2, \ldots, a_n$$$.Make the product of all the numbers in the array (that is, $$$a_1 \cdot a_2 \cdot \ldots \cdot a_n$$$) divisible by $$$2^n$$$.You can perform the following operation as many times as you like:  select an arbitrary index $$$i$$$ ($$$1 \leq i \leq n$$$) and replace the value $$$a_i$$$ with $$$a_i=a_i \cdot i$$$. You cannot apply the operation repeatedly to a single index. In other words, all selected values of $$$i$$$ must be different.Find the smallest number of operations you need to perform to make the product of all the elements in the array divisible by $$$2^n$$$. Note that such a set of operations does not always exist.","def countPow2(k):
    count = 0
    while k % 2 == 0:
        count += 1
        k //= 2

    return count


for _ in [0] * int(input()):
    n = int(input())
    nums = list(map(int, input().rstrip().split()))

    total = extra = 0
    extArr = []
    for num in nums:
        total += countPow2(num)

    for i in range(2, n+1):
        temp = countPow2(i)
        extra += temp
        extArr += [temp]

    extArr.sort(reverse=True)

    if total >= n:
        print(0)
    elif total + extra < n:
        print(-1)

    else:
        ans = 0
        for i in range(len(extArr)):
            ans += 1

            if total + extArr[i] >= n:
                break

            total += extArr[i]

        print(ans)","['greedy', 'math', 'sortings']"
"You find yourself on an unusual crossroad with a weird traffic light. That traffic light has three possible colors: red (r), yellow (y), green (g). It is known that the traffic light repeats its colors every $$$n$$$ seconds and at the $$$i$$$-th second the color $$$s_i$$$ is on.That way, the order of the colors is described by a string. For example, if $$$s=$$$""rggry"", then the traffic light works as the following: red-green-green-red-yellow-red-green-green-red-yellow- ... and so on.More formally, you are given a string $$$s_1, s_2, \ldots, s_n$$$ of length $$$n$$$. At the first second the color $$$s_1$$$ is on, at the second — $$$s_2$$$, ..., at the $$$n$$$-th second the color $$$s_n$$$ is on, at the $$$n + 1$$$-st second the color $$$s_1$$$ is on and so on.You need to cross the road and that can only be done when the green color is on. You know which color is on the traffic light at the moment, but you don't know the current moment of time. You need to find the minimum amount of time in which you are guaranteed to cross the road.You can assume that you cross the road immediately. For example, with $$$s=$$$""rggry"" and the current color r there are two options: either the green color will be on after $$$1$$$ second, or after $$$3$$$. That way, the answer is equal to $$$3$$$ — that is the number of seconds that we are guaranteed to cross the road, if the current color is r.","def func(letter, sequence):

    if letter == ""g"":
        return 0


    maxs = 0
    count = -1
    letter_found = False
    flag = True
    currentl = 0
    currentg = 0
    nextpos = True




    for index, value in enumerate(sequence):
        if value == ""g"":
            nextpos = True
            # print(""nextpos:True"")
            currentg = index
            first_g = True
            if first_g and flag:
                g_1 = index
                flag = False

            count += 1
            maxs = max(count, maxs)
            count = -1
            letter_found = False


            continue
        if value == letter:
            letter_found = True

            if nextpos:
                currentl = index
                nextpos = False
        if letter_found:
            count += 1


    end = 0

    if sequence[-1] != ""g"" and currentl > currentg:
        end = int(length) - currentl + g_1


    maxs = max(end, maxs)
    return maxs



tests = int(input())
for i in range(tests):
    inp = input().split()
    length = inp[0]
    l = inp[1]
    seq = input()
    print(func(l, seq))","['binary search', 'implementation', 'two pointers']"
"Little Leon lives in the forest. He has recently noticed that some trees near his favourite path are withering, while the other ones are overhydrated so he decided to learn how to control the level of the soil moisture to save the trees.There are $$$n$$$ trees growing near the path, the current levels of moisture of each tree are denoted by the array $$$a_1, a_2, \dots, a_n$$$. Leon has learned three abilities which will help him to dry and water the soil.  Choose a position $$$i$$$ and decrease the level of moisture of the trees $$$1, 2, \dots, i$$$ by $$$1$$$.  Choose a position $$$i$$$ and decrease the level of moisture of the trees $$$i, i + 1, \dots, n$$$ by $$$1$$$.  Increase the level of moisture of all trees by $$$1$$$. Leon wants to know the minimum number of actions he needs to perform to make the moisture of each tree equal to $$$0$$$.","from sys import stdin, stdout; read = stdin.readline; write = stdout.write

for _ in range(int(read())):
    
    n = int(read()); arr = list(map(int, read().split()))

    total = 0; carry = 0

    for i in range(1,n):
        arr[i] -= carry
        total += abs(arr[i] - arr[i-1])

        if arr[i-1] < arr[i]:
            carry += abs(arr[i-1] - arr[i])
            arr[i] = arr[i-1]
            
    
    write(f""{total+abs(arr[-1])} \n"")","['constructive algorithms', 'data structures', 'greedy']"
"Alice and Bob play a game. They have a binary string $$$s$$$ (a string such that each character in it is either $$$0$$$ or $$$1$$$). Alice moves first, then Bob, then Alice again, and so on.During their move, the player can choose any number (not less than one) of consecutive equal characters in $$$s$$$ and delete them.For example, if the string is $$$10110$$$, there are $$$6$$$ possible moves (deleted characters are bold):  $$$\textbf{1}0110 \to 0110$$$;  $$$1\textbf{0}110 \to 1110$$$;  $$$10\textbf{1}10 \to 1010$$$;  $$$101\textbf{1}0 \to 1010$$$;  $$$10\textbf{11}0 \to 100$$$;  $$$1011\textbf{0} \to 1011$$$. After the characters are removed, the characters to the left and to the right of the removed block become adjacent. I. e. the following sequence of moves is valid: $$$10\textbf{11}0 \to 1\textbf{00} \to 1$$$.The game ends when the string becomes empty, and the score of each player is the number of $$$1$$$-characters deleted by them.Each player wants to maximize their score. Calculate the resulting score of Alice.","t = int(input())

for _ in range(t):
    s = sorted(input().split('0'), reverse=True)[::2]
    res = sum(list(map(len, s)))
    print(res)","['greedy', 'sortings', 'games']"
"Marin feels exhausted after a long day of cosplay, so Gojou invites her to play a game!Marin and Gojou take turns to place one of their tokens on an $$$n \times n$$$ grid with Marin starting first. There are some restrictions and allowances on where to place tokens:   Apart from the first move, the token placed by a player must be more than Manhattan distance $$$k$$$ away from the previous token placed on the matrix. In other words, if a player places a token at $$$(x_1, y_1)$$$, then the token placed by the other player in the next move must be in a cell $$$(x_2, y_2)$$$ satisfying $$$|x_2 - x_1| + |y_2 - y_1| &gt; k$$$.  Apart from the previous restriction, a token can be placed anywhere on the matrix, including cells where tokens were previously placed by any player. Whenever a player places a token on cell $$$(x, y)$$$, that player gets $$$v_{x,\ y}$$$ points. All values of $$$v$$$ on the grid are distinct. You still get points from a cell even if tokens were already placed onto the cell. The game finishes when each player makes $$$10^{100}$$$ moves.Marin and Gojou will play $$$n^2$$$ games. For each cell of the grid, there will be exactly one game where Marin places a token on that cell on her first move. Please answer for each game, if Marin and Gojou play optimally (after Marin's first move), who will have more points at the end? Or will the game end in a draw (both players have the same points at the end)?","import heapq

import os
import sys
from io import BytesIO, IOBase

_str = str
str = lambda x=b"""": x if type(x) is bytes else _str(x).encode()

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def f(x, y, x1, y1, x2, y2):
    return x1 + y1 <= x + y <= x2 + y2 and x1 - y1 <= x - y <= x2 - y2

def out(x, y, x1, y1, x2, y2):
    return not (x1 + y1 <= x + y <= x2 + y2) and not (x1 - y1 <= x - y <= x2 - y2)

def merge(x1, y1, x2, y2, x3, y3, x4, y4):
    new = [0] * 4
    if f(x1, y1, x3, y3, x4, y4):
        new[0], new[1] = x1, y1
    elif out(x1, y1, x3, y3, x4, y4):
        new[0], new[1] = x3, y4
    else:
        if x3 - y3 <= x1 - y1 <= x4 - y4:
            num = ((x1 - y1) - (x3 - y3)) / 2
            new[0], new[1] = x3 + num, y3 - num
        else:
            num = ((x1 + y1) - (x3 + y3)) / 2
            new[0], new[1] = x3 + num, y3 + num
    if f(x2, y2, x3, y3, x4, y4):
        new[2], new[3] = x2, y2
    elif out(x2, y2, x3, y3, x4, y4):
        new[2], new[3] = x4, y4
    else:
        if x3 + y3 <= x2 + y2 <= x4 + y4:
            num = (x4 + y4 - (x2 + y2)) / 2
            new[2], new[3] = x4 - num, y4 - num
        else:
            num = ((x4 - y4) - (x2 - y2)) / 2
            new[2], new[3] = x4 - num, y4 + num
    return new


def main():
    n, k = list(map(int, input().split(' ')))
    v = [list(map(int, input().split(' '))) for _ in range(n)]
    max_id = None
    d = [0] *(n * n + 1)
    for i in range(n):
        for j in range(n):
            d[v[i][j]] = i * (n + 1) + j
            if v[i][j] == n * n:
                max_id = [i, j]
    valid = [(max_id[0] - k), max_id[1], (max_id[0] + k), max_id[1]]
    
    for vnow in range(n * n, 0, -1):
        x, y = d[vnow] // (n + 1), d[vnow] % (n + 1)
        #print(valid, vnow, x, y)
        if not f(x, y, valid[0], valid[1], valid[2], valid[3]):
            continue
        if f(valid[0], valid[1], x - k, y, x + k, y) and f(valid[2], valid[3], x - k, y, x + k, y):
            continue
        new = merge(valid[0], valid[1], valid[2], valid[3], x - k, y, x + k, y)
        valid.clear()
        valid = new
    
    #print(valid)
    for i in range(n):
        res = ['G'] * n
        for j in range(n):
            if f(i, j, valid[0], valid[1], valid[2], valid[3]):
                res[j] = 'M'
        print(''.join(res))
            
    return

main()","['data structures', 'dp', 'games', 'hashing', 'implementation', 'math', 'number theory', 'sortings']"
"Shinju loves permutations very much! Today, she has borrowed a permutation $$$p$$$ from Juju to play with.The $$$i$$$-th cyclic shift of a permutation $$$p$$$ is a transformation on the permutation such that $$$p = [p_1, p_2, \ldots, p_n] $$$ will now become $$$ p = [p_{n-i+1}, \ldots, p_n, p_1,p_2, \ldots, p_{n-i}]$$$.Let's define the power of permutation $$$p$$$ as the number of distinct elements in the prefix maximums array $$$b$$$ of the permutation. The prefix maximums array $$$b$$$ is the array of length $$$n$$$ such that $$$b_i = \max(p_1, p_2, \ldots, p_i)$$$. For example, the power of $$$[1, 2, 5, 4, 6, 3]$$$ is $$$4$$$ since $$$b=[1,2,5,5,6,6]$$$ and there are $$$4$$$ distinct elements in $$$b$$$.Unfortunately, Shinju has lost the permutation $$$p$$$! The only information she remembers is an array $$$c$$$, where $$$c_i$$$ is the power of the $$$(i-1)$$$-th cyclic shift of the permutation $$$p$$$. She's also not confident that she remembers it correctly, so she wants to know if her memory is good enough.Given the array $$$c$$$, determine if there exists a permutation $$$p$$$ that is consistent with $$$c$$$. You do not have to construct the permutation $$$p$$$.A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3, 4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).","a,b,c=input,int,range
for _ in c(b(a())):n=b(a());m=list(map(b,a().split()));print(""YNEOS""[m.count(1)!= 1 or m[0]>m[-1]+1 or any(m[i+1]-m[i]>1 for i in range(n-1))::2])","['constructive algorithms', 'math']"
"There is a new attraction in Singapore Zoo: The Infinite Zoo.The Infinite Zoo can be represented by a graph with an infinite number of vertices labeled $$$1,2,3,\ldots$$$. There is a directed edge from vertex $$$u$$$ to vertex $$$u+v$$$ if and only if $$$u\&amp;v=v$$$, where $$$\&amp;$$$ denotes the bitwise AND operation. There are no other edges in the graph.Zookeeper has $$$q$$$ queries. In the $$$i$$$-th query she will ask you if she can travel from vertex $$$u_i$$$ to vertex $$$v_i$$$ by going through directed edges.","import math
from collections import deque
from sys import stdin, stdout, setrecursionlimit
from string import ascii_letters
from decimal import *
letters = ascii_letters[:26]
from collections import defaultdict
#from functools import reduce
input = stdin.readline
#print = stdout.write
 
 
for _ in range(int(input())):
    a, b = map(lambda x : (list(str(bin(int(x)))[2:])[::-1], int(x)), input().split())
    cnt = 0
    can = True
    if a[1] > b[1]:
        can = False
    a = a[0]
    b = b[0]
    la = len(a)
    lb = len(b)
    for i in range(lb):
        if i < la and a[i] == '1':
            cnt += 1
        if i < lb and b[i] == '1':
            if cnt == 0:
                can = False
            else:
                cnt -= 1
    for i in range(lb, la):
        if a[i] == '1':
            can = False
    print('YES' if can else 'NO')","['bitmasks', 'constructive algorithms', 'dp', 'greedy', 'math']"
"It was the third month of remote learning, Nastya got sick of staying at dormitory, so she decided to return to her hometown. In order to make her trip more entertaining, one of Nastya's friend presented her an integer array $$$a$$$. Several hours after starting her journey home Nastya remembered about the present. To entertain herself she decided to check, are there four different indices $$$x, y, z, w$$$ such that $$$a_x + a_y = a_z + a_w$$$.Her train has already arrived the destination, but she still hasn't found the answer. Can you help her unravel the mystery?","#!/usr/bin/env python3
import sys
 
sys.stdin.readline()
l = list(map(int, sys.stdin.readline().split()))
#l = sorted(l)
 
cand = {}
 
for i, v1 in enumerate(l):
    for j in range(i):
        s = v1 + l[j]
        if s in cand:
            if i not in cand[s] and j not in cand[s]:
                print('YES')
                print(i + 1, j + 1, cand[s][0] + 1, cand[s][1] + 1)
                exit(0)
        else:
            cand[s] = (i, j)
 
print('NO')","['brute force', 'hashing', 'implementation', 'math']"
"The new generation external memory contains an array of integers $$$a[1 \ldots n] = [a_1, a_2, \ldots, a_n]$$$.This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.Technically, each cyclic shift consists of two consecutive actions:   You may select arbitrary indices $$$l$$$ and $$$r$$$ ($$$1 \le l &lt; r \le n$$$) as the boundaries of the segment.  Then you replace the segment $$$a[l \ldots r]$$$ with it's cyclic shift to the left by an arbitrary offset $$$d$$$. The concept of a cyclic shift can be also explained by following relations: the sequence $$$[1, 4, 1, 3]$$$ is a cyclic shift of the sequence $$$[3, 1, 4, 1]$$$ to the left by the offset $$$1$$$ and the sequence $$$[4, 1, 3, 1]$$$ is a cyclic shift of the sequence $$$[3, 1, 4, 1]$$$ to the left by the offset $$$2$$$. For example, if $$$a = [1, \color{blue}{3, 2, 8}, 5]$$$, then choosing $$$l = 2$$$, $$$r = 4$$$ and $$$d = 2$$$ yields a segment $$$a[2 \ldots 4] = [3, 2, 8]$$$. This segment is then shifted by the offset $$$d = 2$$$ to the left, and you get a segment $$$[8, 3, 2]$$$ which then takes the place of of the original elements of the segment. In the end you get $$$a = [1, \color{blue}{8, 3, 2}, 5]$$$.Sort the given array $$$a$$$ using no more than $$$n$$$ cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires $$$n$$$ or less cyclic shifts will be accepted.","import copy
import math
from sys import stdin


def A():
    t = stdin.readline()
    t = int(t)
    while t:
        t-=1
        s =input()
        cnt = 0
        cnt1 = 0
        cnt2 = 0
        for i in s:
            if i == 'A':
                cnt += 1
            if i =='B':
                cnt1 += 1
            if i == 'C':
                cnt2+= 1
        if cnt + cnt2 == cnt1:
            print(""yes"")
        elif cnt == cnt1 and 0 == cnt2:
            print(""yes"")
        elif cnt2 == cnt1 and cnt == 0:
            print(""yes"")
        else:
            print(""NO"")

def B():
    t = int(input())
    while t:
        t -= 1
        n = int(input())
        a = [int(x) for x in stdin.readline().split()]
        c = copy.deepcopy(a)
        c.sort()

        r = n + 1
        res = []

        for i in c:
            r -= 1

            for j in range(0, r):
                if a[j] == c[r-1]:
                    if min(n,j+1) == min(n,r) :
                        continue
                    res.append([ min(n, j + 1), min(n, r),1])

                    a.pop(j)

                    a.insert(r-1,c[r-1])
                    break

            if a == c:
                break
            if a[::-1] == c:
                break

        if a == c:
            print(len(res))
            for i in res:
                print(""{} {} {}"".format(i[0], i[1],i[2]))
        else:
            res.append([1,n,1])
            print(len(res))
            for i in res:
                print(""{} {} {}"".format(i[0], i[1],i[2]))

B()","['implementation', 'sortings']"
"Kuznecov likes art, poetry, and music. And strings consisting of lowercase English letters.Recently, Kuznecov has found two strings, $$$a$$$ and $$$b$$$, of lengths $$$n$$$ and $$$m$$$ respectively. They consist of lowercase English letters and no character is contained in both strings. Let another string $$$c$$$ be initially empty. Kuznecov can do the following two types of operations:  Choose any character from the string $$$a$$$, remove it from $$$a$$$, and add it to the end of $$$c$$$.  Choose any character from the string $$$b$$$, remove it from $$$b$$$, and add it to the end of $$$c$$$. But, he can not do more than $$$k$$$ operations of the same type in a row. He must perform operations until either $$$a$$$ or $$$b$$$ becomes empty. What is the lexicographically smallest possible value of $$$c$$$ after he finishes?A string $$$x$$$ is lexicographically smaller than a string $$$y$$$ if and only if one of the following holds: $$$x$$$ is a prefix of $$$y$$$, but $$$x \neq y$$$;  in the first position where $$$x$$$ and $$$y$$$ differ, the string $$$x$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$y$$$.","t = int(input())

for c in range(t):
    n, m, k = [int(i) for i in input().split()]
    s = []
    ans = ''
    s1 = input()
    s.append(''.join(sorted(s1)))
    s2 = input()
    s.append(''.join(sorted(s2)))
    canSelect = True
    selected = 0
    d = k
    while(s[0]!='' and s[1]!=''):
        if (canSelect):
            lastSelected = selected
            if (s[1-selected][0]<s[selected][0]):
                selected = 1-selected
            if (lastSelected != selected):
                d = k
        else:
            selected = 1-selected
            canSelect = True
        if (s[selected][0]<s[1-selected][0]):
            l = min(d,s[selected].count(s[selected][0]))
        else:
            l = 1
        ans+=l*s[selected][0]
        s[selected]=s[selected][l:]
        d -= l
        if (d<=0):
            d = k
            canSelect = False
    print(ans)","['brute force', 'greedy', 'implementation', 'sortings', 'two pointers']"
"Lena is a beautiful girl who likes logical puzzles.As a gift for her birthday, Lena got a matrix puzzle!The matrix consists of $$$n$$$ rows and $$$m$$$ columns, and each cell is either black or white. The coordinates $$$(i,j)$$$ denote the cell which belongs to the $$$i$$$-th row and $$$j$$$-th column for every $$$1\leq i \leq n$$$ and $$$1\leq j \leq m$$$. To solve the puzzle, Lena has to choose a cell that minimizes the Manhattan distance to the farthest black cell from the chosen cell.More formally, let there be $$$k \ge 1$$$ black cells in the matrix with coordinates $$$(x_i,y_i)$$$ for every $$$1\leq i \leq k$$$. Lena should choose a cell $$$(a,b)$$$ that minimizes $$$$$$\max_{i=1}^{k}(|a-x_i|+|b-y_i|).$$$$$$As Lena has no skill, she asked you for help. Will you tell her the optimal cell to choose?","from __future__ import division, print_function
import math
import sys
import os
from io import BytesIO, IOBase
from collections import deque, Counter, OrderedDict, defaultdict
import heapq
# ceil,floor,log,sqrt,factorial,pow,pi,gcd
# import bisect
from bisect import bisect_left,bisect_right

BUFSIZE = 8192


class FastIO(IOBase):
	newlines = 0

	def __init__(self, file):
		self._fd = file.fileno()
		self.buffer = BytesIO()
		self.writable = ""x"" in file.mode or ""r"" not in file.mode
		self.write = self.buffer.write if self.writable else None

	def read(self):
		while True:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			if not b:
				break
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines = 0
		return self.buffer.read()

	def readline(self):
		while self.newlines == 0:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			self.newlines = b.count(b""\n"") + (not b)
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines -= 1
		return self.buffer.readline()

	def flush(self):
		if self.writable:
			os.write(self._fd, self.buffer.getvalue())
			self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
	def __init__(self, file):
		self.buffer = FastIO(file)
		self.flush = self.buffer.flush
		self.writable = self.buffer.writable
		self.write = lambda s: self.buffer.write(s.encode(""ascii""))
		self.read = lambda: self.buffer.read().decode(""ascii"")
		self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
	""""""Prints the values to a stream, or to sys.stdout by default.""""""
	sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
	at_start = True
	for x in args:
		if not at_start:
			file.write(sep)
		file.write(str(x))
		at_start = False
	file.write(kwargs.pop(""end"", ""\n""))
	if kwargs.pop(""flush"", False):
		file.flush()


if sys.version_info[0] < 3:
	sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
	sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def inp():
    return(int(input()))
def inps():
    return input().strip()
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input().strip()
    return(list(s[:len(s)]))
def invr():
    return(map(int,input().split()))

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
 
    return wrappedfunc

def check(x,y):
    if x<=0 or x>n or y<0 or y>m:
        return sys.maxsize
    else:
        val=0
        # print(x,y)
        for a,b in blck:
            val=max(val,abs(a-x)+abs(b-y))
        # print(val,x,y,blck)
        return val

for _ in range(inp()):
    n,m=invr()
    l=[]
    for i in range(n):
        l.append(insr())
    mnx,mxx,mny,mxy=sys.maxsize,-sys.maxsize,sys.maxsize,-sys.maxsize
    for i in range(n):
        for j in range(m):
            if l[i][j]=='B':
                x=i+j
                y=i-j
                mnx=min(x,mnx)
                mxx=max(x,mxx)
                mny=min(y,mny)
                mxy=max(y,mxy)
    val=sys.maxsize
    ax,ay=sys.maxsize,sys.maxsize
    for i in range(n):
        for j in range(m):
            a=i+j
            b=i-j
            v=max(abs(mxx-a),abs(mnx-a),abs(mny-b),abs(mxy-b))
            # print(a,b,v,val)
            if v<val:
                val=v
                ax,ay=i+1,j+1
    print(ax,ay)","['data structures', 'dp', 'geometry', 'shortest paths']"
"You are given a string $$$s$$$ consisting of $$$n$$$ lowercase Latin letters. Polycarp wants to remove exactly $$$k$$$ characters ($$$k \le n$$$) from the string $$$s$$$. Polycarp uses the following algorithm $$$k$$$ times:  if there is at least one letter 'a', remove the leftmost occurrence and stop the algorithm, otherwise go to next item;  if there is at least one letter 'b', remove the leftmost occurrence and stop the algorithm, otherwise go to next item;  ...  remove the leftmost occurrence of the letter 'z' and stop the algorithm. This algorithm removes a single letter from the string. Polycarp performs this algorithm exactly $$$k$$$ times, thus removing exactly $$$k$$$ characters.Help Polycarp find the resulting string.","if __name__=='__main__':
    n, k = input().split()
    n = int(n)
    k = int(k)
    s = input()
    chars = list(s)
    appearances = {}
    for i in range(27):
        appearances[chr(97+i)] = 0

    for letter in s:
        appearances[letter] += 1

    # for i in range(27):
    #     letter = chr(97+i)
    #     if appearances[letter] <= k:
    #         k -= appearances[letter]
    #         s = s.replace(letter, """")
    #     else:
    #         while k > 0:
    #             ind = s.index(letter)
    #             part1 = s[:ind]
    #             part2 = s[ind + 1:]
    #             s = part1 + part2
    #             k -= 1
    last_remove = """"
    for i in range(27):
        letter = chr(97+i)
        if appearances[letter] <= k:
            k -= appearances[letter]
            appearances[letter] = 0
            if k == 0:
                break
        else:
            last_remove = letter
            k = appearances[letter] - k
            break

    # for ch in s:
    #     if appearances[ch] == 0:
    #         chars.remove(ch)
    #     elif ch == last_remove:
    #         if appearances[ch] > k:
    #             chars.remove(ch)
    #             appearances[ch] -= 1

    new_s = []
    for ch in s:
        # if (k == 0 and ch != last_remove) or appearances[ch] <= k:
        #     new_s.append(ch)
        # else:
        #     appearances[ch] -= 1
        if ch == last_remove and appearances[ch] > k:
            appearances[ch] -= 1
        elif appearances[ch] != 0:
            new_s.append(ch)

    s = """".join(new_s)
    print(s)",['implementation']
You are given an array $$$a$$$ of $$$n$$$ integers. Initially there is only one copy of the given array.You can do operations of two types:  Choose any array and clone it. After that there is one more copy of the chosen array.  Swap two elements from any two copies (maybe in the same copy) on any positions. You need to find the minimal number of operations needed to obtain a copy where all elements are equal.,"for i in range(int(input())):
	n=int(input())
	a=input().split()
	from collections import Counter

	e,bb=Counter(a).most_common(1)[0]
	c=n-bb
	while bb<n:
		c+=1
		bb*=2
	print(c)","['constructive algorithms', 'greedy', 'sortings']"
"You are given an undirected graph that consists of n vertices and m edges. Initially, each edge is colored either red or blue. Each turn a player picks a single vertex and switches the color of all edges incident to it. That is, all red edges with an endpoint in this vertex change the color to blue, while all blue edges with an endpoint in this vertex change the color to red.Find the minimum possible number of moves required to make the colors of all edges equal.","from collections import deque
 
n, m = map(int, input().split())
adj = [[] for i in range(n)]
for i in range(m):
    u, v, c = input().split()
    u, v = int(u)-1, int(v)-1
    adj[u].append((v, c))
    adj[v].append((u, c))
 
visited = S = T = None
 
def bfs(i, k):
    q = deque([(i, 0)])
    while q:
        u, p = q.pop()
 
        if visited[u] >= 0:
            if visited[u] == p: continue
            else: return False
 
        visited[u] = p
        if p: S.append(u)
        else: T.append(u)
 
        for v, c in adj[u]:
            nxt = p if c == k else p^1
            q.appendleft((v, nxt))
 
    return True
 
def solve(k):
    global visited, S, T
    visited = [-1]*n
    res = []
    for i in range(n):
        if visited[i] < 0:
            S, T = [], []
            if not bfs(i, k):
                return [0]*(n+1)
            else:
                res.extend(S if len(S) < len(T) else T)
    return res
 
res1 = solve(""R"")
res2 = solve(""B"")
 
if min(len(res1), len(res2)) > n:
    print (-1)
else:
    print (min(len(res1), len(res2)))
    print ("" "".join(map(lambda x: str(x+1), res1 if len(res1) < len(res2) else res2)))","['dfs and similar', 'graphs']"
"Mihai has an $$$8 \times 8$$$ chessboard whose rows are numbered from $$$1$$$ to $$$8$$$ from top to bottom and whose columns are numbered from $$$1$$$ to $$$8$$$ from left to right.Mihai has placed exactly one bishop on the chessboard. The bishop is not placed on the edges of the board. (In other words, the row and column of the bishop are between $$$2$$$ and $$$7$$$, inclusive.)The bishop attacks in all directions diagonally, and there is no limit to the distance which the bishop can attack. Note that the cell on which the bishop is placed is also considered attacked.     An example of a bishop on a chessboard. The squares it attacks are marked in red. Mihai has marked all squares the bishop attacks, but forgot where the bishop was! Help Mihai find the position of the bishop.","t=int(input())
for i in range(t):
    l=input()
    res=[]
    for j in range(8):
     q=list(input())
     res.append(q)
    ind=[]
    for k in range(len(res)):
        if res[k].count('#')==1 or res[k].count(""#"")==0:
            ind.append(k+1)
    for i in range(len(ind)-1):
        for x in range(len(ind)-1,i,-1):
            try:
             if ind[i:x+1]==list(range(ind[i],ind[x]+1)):
                ind=ind[0:i]+ind[x+1:len(ind)]
            except IndexError:
                continue
    try:
        ind.pop(ind.index(1))
    except ValueError:
        pass
    try:
        ind.pop(ind.index(8))
    except ValueError:
        pass
    print(str(ind[-1])+"" ""+str(res[ind[-1]-1].index(""#"")+1))",['implementation']
"Omkar is creating a mosaic using colored square tiles, which he places in an $$$n \times n$$$ grid. When the mosaic is complete, each cell in the grid will have either a glaucous or sinoper tile. However, currently he has only placed tiles in some cells. A completed mosaic will be a mastapeece if and only if each tile is adjacent to exactly $$$2$$$ tiles of the same color ($$$2$$$ tiles are adjacent if they share a side.) Omkar wants to fill the rest of the tiles so that the mosaic becomes a mastapeece. Now he is wondering, is the way to do this unique, and if it is, what is it?","import sys
o = {'G':'S', 'S':'G'}
n = int(sys.stdin.readline())
d = [list(sys.stdin.readline()[:n]) for _ in range(n)]
f = [1]*(n*n)
finished = 1
def none(): print('NONE'); sys.exit()
def printd(): print('\n'.join(''.join(d[i]) for i in range(n)))
if n % 2: none()
x = ['']*(n//2)
def findt(i,j): return abs(j-i)//2 if (j - i) % 2 else min(i+j, 2*(n-1)-j-i) // 2
def findr(i,j,t):
    if (j-i) % 2: return o[t] if min(i,j) % 2 else t
    else:
        if i+j < n: return o[t] if i % 2 else t
        else: return t if i % 2 else o[t]
for i in range(n):
    for j in range(n):
        if d[i][j] != '.':
            t = findt(i,j)
            r = findr(i,j,d[i][j])
            if x[t] == o[r]: none()
            else: x[t] = r
for i in range(n//2):
    if not x[i]: print('MULTIPLE'); sys.exit()
for i in range(n):    
    for j in range(n):
        d[i][j] = findr(i,j,x[findt(i,j)])
print('UNIQUE')
printd()","['combinatorics', 'constructive algorithms', 'math']"
"Pak Chanek, a renowned scholar, invented a card puzzle using his knowledge. In the puzzle, you are given a board with $$$n$$$ rows and $$$m$$$ columns. Let $$$(r, c)$$$ represent the cell in the $$$r$$$-th row and the $$$c$$$-th column.Initially, there are $$$k$$$ cards stacked in cell $$$(1, 1)$$$. Each card has an integer from $$$1$$$ to $$$k$$$ written on it. More specifically, the $$$i$$$-th card from the top of the stack in cell $$$(1, 1)$$$ has the number $$$a_i$$$ written on it. It is known that no two cards have the same number written on them. In other words, the numbers written on the cards are a permutation of integers from $$$1$$$ to $$$k$$$. All other cells are empty.You need to move the $$$k$$$ cards to cell $$$(n, m)$$$ to create another stack of cards. Let $$$b_i$$$ be the number written on the $$$i$$$-th card from the top of the stack in cell $$$(n, m)$$$. You should create the stack in cell $$$(n, m)$$$ in such a way so that $$$b_i = i$$$ for all $$$1 \leq i \leq k$$$.In one move, you can remove the top card from a cell and place it onto an adjacent cell (a cell that shares a common side). If the target cell already contains one or more cards, you place your card on the top of the stack. You must do each operation while satisfying the following restrictions:   Each cell other than $$$(1,1)$$$ and $$$(n,m)$$$ must not have more than one card on it.  You cannot move a card onto cell $$$(1,1)$$$.  You cannot move a card from cell $$$(n,m)$$$. Given the values of $$$n$$$, $$$m$$$, $$$k$$$ and the array $$$a$$$, determine if the puzzle is solvable.","import bisect
from collections import defaultdict
from collections import deque
from functools import lru_cache
import heapq
from locale import resetlocale
from pickle import FALSE
import random
import math
from collections import Counter
import sys
 
#parse a single integer
mod = 10**9+7
def inp():
    return(int(sys.stdin.readline()))
#parse a list of integers
def inlt():
    return(list(map(int,sys.stdin.readline().split())))
#parse a string (can be modified to parse a list of characters)
def insr():
    s = sys.stdin.readline()[:-1]
    return(s)
#no idea what this does
def invr():
    return(map(int,input().split()))
def gcd(a,b):
    if b == 0:
        return a
    return gcd(b, a % b)
class UF:
    def __init__(self, size):
        self.parent = list(range(size))
        self.rank = [0] * size
        
    def find(self, x):
        if self.parent[x] == x:
            return x
        return self.find(self.parent[x])
    
    def union(self, x, y):
        px = self.find(x)
        py = self.find(y)
        if px == py:
            return
        if self.rank[px] > self.rank[py]:
            self.parent[py] = px
        elif self.rank[px] < self.rank[py]:
            self.parent[px] = py
        else:
            self.parent[px] = py
            self.rank[py] += 1

class BIT:
    def __init__(self, n):
        self.sums = [0] * (n+1)
    
    def update(self, i, delta):
        while i < len(self.sums):
            self.sums[i] += delta
            i += i & (-i)
    
    def query(self, i):
        res = 0
        while i > 0:
            res += self.sums[i]
            i -= i & (-i)
        return res

class NumArray:
    def __init__(self, nums):
        self.bit = BIT(len(nums))
        for i, num in enumerate(nums):
            self.bit.update(i+1, num)
        self.nums = [0] + nums

    def update(self, i, val):
        self.bit.update(i+1, val - self.nums[i+1])
        self.nums[i+1] = val

    def sumRange(self, i, j):
        return self.bit.query(j+1) - self.bit.query(i)

z = inp()
 
for v in range(z):
    [n,m,k] = inlt()
    l = inlt()
    seg = NumArray([0] * (k+1))
    a = []
    d = defaultdict(int)
    for x in l:
        idx = seg.sumRange(0,x)
        d[x] = idx 
        seg.update(x, 1)
    ok = True
    # print(d)
    for i in range(1,k+1):
        if n == 2 and m == 2:
            if d[i] > 1:
                ok = False
        elif d[i] > n*m - 4:
            ok = False 
    if ok:
        print(""YA"")
    else:
        print(""TIDAK"")","['constructive algorithms', 'data structures']"
"This is an interactive problem.A city has $$$n^2$$$ buildings divided into a grid of $$$n$$$ rows and $$$n$$$ columns. You need to build a road of some length $$$D(A,B)$$$ of your choice between each pair of adjacent by side buildings $$$A$$$ and $$$B$$$. Due to budget limitations and legal restrictions, the length of each road must be a positive integer and the total length of all roads should not exceed $$$48\,000$$$.There is a thief in the city who will start from the topmost, leftmost building (in the first row and the first column) and roam around the city, occasionally stealing artifacts from some of the buildings. He can move from one building to another adjacent building by travelling through the road which connects them.You are unable to track down what buildings he visits and what path he follows to reach them. But there is one tracking mechanism in the city. The tracker is capable of storing a single integer $$$x$$$ which is initially $$$0$$$. Each time the thief travels from a building $$$A$$$ to another adjacent building $$$B$$$ through a road of length $$$D(A,B)$$$, the tracker changes $$$x$$$ to $$$x\oplus D(A,B)$$$. Each time the thief steals from a building, the tracker reports the value $$$x$$$ stored in it and resets it back to $$$0$$$.It is known beforehand that the thief will steal in exactly $$$k$$$ buildings but you will know the values returned by the tracker only after the thefts actually happen. Your task is to choose the lengths of roads in such a way that no matter what strategy or routes the thief follows, you will be able to exactly tell the location of all the buildings where the thefts occurred from the values returned by the tracker.","def gray(k):
    if k==1:return [0,1]
    res=gray(k-1)
    res2=res[::-1]
    for i in range(len(res2)):
        res2[i]+=2**(k-1)
    return res+res2

g=gray(5)




memo=dict()
def ps(i,j):
    return memo[i,j]

memo2=dict()
def inv(x):
    return memo2[x]


for i in range(32):
    for j in range(32):
        nodi,nodj=g[i],g[j]
        res=0
        resi=[]
        resj=[]
        for _ in range(5):
            resi.append(nodi%2)
            nodi//=2
            resj.append(nodj%2)
            nodj//=2

        for _ in range(5):
            res*=2
            res+=resi.pop()
            res*=2
            res+=resj.pop()
        memo[i,j]=res
        memo2[memo[i,j]]=(i,j)



n,k=map(int,input().split())
s=0
for i in range(n):
    res=[]
    for j in range(n-1):
        res.append(ps(i,j)^ps(i,j+1))
    print(*res)
    s+=sum(res)


for i in range(n-1):
    res=[]
    for j in range(n):
        res.append(ps(i,j)^ps(i+1,j))
    print(*res)
    s+=sum(res)



i,j=0,0
now=0
import sys
for _ in range(k):
    x=int(input())
    sys.stdout.flush()
    now^=x
    ni,nj=inv(now)
    print(ni+1,nj+1)","['bitmasks', 'constructive algorithms', 'divide and conquer', 'greedy', 'interactive', 'math']"
"The symbol $$$\wedge$$$ is quite ambiguous, especially when used without context. Sometimes it is used to denote a power ($$$a\wedge b = a^b$$$) and sometimes it is used to denote the XOR operation ($$$a\wedge b=a\oplus b$$$). You have an ambiguous expression $$$E=A_1\wedge A_2\wedge A_3\wedge\ldots\wedge A_n$$$. You can replace each $$$\wedge$$$ symbol with either a $$$\texttt{Power}$$$ operation or a $$$\texttt{XOR}$$$ operation to get an unambiguous expression $$$E'$$$.The value of this expression $$$E'$$$ is determined according to the following rules:   All $$$\texttt{Power}$$$ operations are performed before any $$$\texttt{XOR}$$$ operation. In other words, the $$$\texttt{Power}$$$ operation takes precedence over $$$\texttt{XOR}$$$ operation. For example, $$$4\;\texttt{XOR}\;6\;\texttt{Power}\;2=4\oplus (6^2)=4\oplus 36=32$$$.  Consecutive powers are calculated from left to right. For example, $$$2\;\texttt{Power}\;3 \;\texttt{Power}\;4 = (2^3)^4 = 8^4 = 4096$$$. You are given an array $$$B$$$ of length $$$n$$$ and an integer $$$k$$$. The array $$$A$$$ is given by $$$A_i=2^{B_i}$$$ and the expression $$$E$$$ is given by $$$E=A_1\wedge A_2\wedge A_3\wedge\ldots\wedge A_n$$$. You need to find the XOR of the values of all possible unambiguous expressions $$$E'$$$ which can be obtained from $$$E$$$ and has at least $$$k$$$ $$$\wedge$$$ symbols used as $$$\texttt{XOR}$$$ operation. Since the answer can be very large, you need to find it modulo $$$2^{2^{20}}$$$. Since this number can also be very large, you need to print its binary representation without leading zeroes. If the answer is equal to $$$0$$$, print $$$0$$$.","import sys, os, io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def f(u, v):
    m = u.bit_length()
    dp0, dp1 = [0] * 2, [0] * 2
    dp0[0] = 1
    for i in range(m - 1, -1, -1):
        ndp0, ndp1 = [0] * 2, [0] * 2
        c = u & pow2[i]
        d = v & pow2[i]
        if c and d:
            ndp0[0] = dp0[0]
            ndp0[1] = dp0[1]
            ndp1[0] = dp0[0] + 2 * dp1[0] 
            ndp1[1] = dp0[1] + 2 * dp1[1]
        elif c:
            ndp0[0] = dp0[0]
            ndp0[1] = dp0[1]
            ndp1[0] = 2 * dp1[0]
            ndp1[1] = 2 * dp1[1]
        elif d:
            ndp0[1] = dp0[0] + dp0[1]
            ndp1[0] = dp0[0] + dp1[0]
            ndp1[1] = dp0[1] + dp1[0] + 2 * dp1[1]
        else:
            ndp0[0] = dp0[0]
            ndp0[1] = dp0[1]
            ndp1[0] = dp1[0]
            ndp1[1] = dp1[0] + 2 * dp1[1]
        dp0, dp1 = ndp0, ndp1
    return v + 3 - (dp0[1] + dp1[1])

n, k = map(int, input().split())
b = list(map(int, input().split()))
if n == 1:
    ans = ""1"" + ""0"" * b[0]
    sys.stdout.write(ans)
    exit()
pow2 = [1]
for _ in range(20):
    pow2.append(2 * pow2[-1])
l = pow2[20]
ans = [0] * l
y = []
u, c = n - 2, 2
for _ in range(25):
    u -= 1
    v = u - max(k - c, 0)
    y.append(f(u, v) % 2)
for i in range(n):
    u, c = n - 2, 2
    for j in range(i, min(i + 25, n)):
        u -= 1
        if j == 0 or j == n - 1:
            u += 1
            c -= 1
        if i == j:
            x = b[j]
        elif b[j] > 20:
            break
        else:
            x *= pow2[b[j]]
        if x >= l or u < k - c:
            break
        if 0 < i <= n - 25:
            ans[x] ^= y[j - i]
        else:
            v = u - max(k - c, 0)
            ans[x] ^= f(u, v) % 2
while len(ans) > 1 and not ans[-1]:
    ans.pop()
ans.reverse()
sys.stdout.write("""".join(map(str, ans)))","['bitmasks', 'combinatorics', 'math', 'number theory']"
"There are $$$n$$$ students numerated from $$$1$$$ to $$$n$$$. The level of the $$$i$$$-th student is $$$a_i$$$. You need to split the students into stable groups. A group of students is called stable, if in the sorted array of their levels no two neighboring elements differ by more than $$$x$$$.For example, if $$$x = 4$$$, then the group with levels $$$[1, 10, 8, 4, 4]$$$ is stable (because $$$4 - 1 \le x$$$, $$$4 - 4 \le x$$$, $$$8 - 4 \le x$$$, $$$10 - 8 \le x$$$), while the group with levels $$$[2, 10, 10, 7]$$$ is not stable ($$$7 - 2 = 5 &gt; x$$$).Apart from the $$$n$$$ given students, teachers can invite at most $$$k$$$ additional students with arbitrary levels (at teachers' choice). Find the minimum number of stable groups teachers can form from all students (including the newly invited).For example, if there are two students with levels $$$1$$$ and $$$5$$$; $$$x = 2$$$; and $$$k \ge 1$$$, then you can invite a new student with level $$$3$$$ and put all the students in one stable group.","# python
import os
import sys; import math
from io import BytesIO, IOBase
from operator import itemgetter

def solve():
    n,k,x = [int(x) for x in input().split()]
    a = sorted([int(x) for x in input().split()])
    diff = []
    for i in range(n-1):
        temp = abs(a[i]-a[i+1])
        if temp > x:
            diff.append(temp) 
    diff.sort(); #print(diff)
    ans = len(diff) + 1
    for i in range(len(diff)):
        k -= (diff[i] - 1)//x
        if kc(k) == False:
            break
        else:
            ans -= 1
    print(ans) 

def kc(k):
    if k < 0: return False
    else: return True


def upperbound(arr,val):
    start = 0; end = len(arr) - 1; ans = -1
    while (start <= end):
        mid = (start + end) // 2
        if (arr[mid] <= val):
            start = mid + 1
        else:
            ans = mid
            end = mid - 1
    return ans
def lowerbound(arr,val):
    length = len(arr); answer = -1; start = 0; end = length - 1    
    while start <= end:
        middle = (start + end)//2    
        if arr[middle] == val:
            answer = middle
            end = middle - 1
        elif arr[middle] > val:
            end = middle - 1    
        else:
            start = middle + 1
    return answer
def D2B(n):
    arr = []
    while (n > 0):
        temp = n; m = 0; p = 1
        while (temp):
            rem = temp % 10; temp = int(temp/10)
            if (rem != 0):
                m += p;
            p *= 10;
        arr.append(m); n = n - m;
    return arr
def sort2D(arr,axis):
    arr = sorted(arr, key = itemgetter(axis)); return arr
def DD(rows,cols):
    arr = [[0 for i in range(cols)] for j in range(rows)]; return arr
# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion
if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")

f = 0

if __name__ == ""__main__"":
    if f == 1:
        t = int(input())
        while(t):
            solve(); t -= 1
    else: solve()","['greedy', 'sortings']"
"Phoenix has collected $$$n$$$ pieces of gold, and he wants to weigh them together so he can feel rich. The $$$i$$$-th piece of gold has weight $$$w_i$$$. All weights are distinct. He will put his $$$n$$$ pieces of gold on a weight scale, one piece at a time. The scale has an unusual defect: if the total weight on it is exactly $$$x$$$, it will explode. Can he put all $$$n$$$ gold pieces onto the scale in some order, without the scale exploding during the process? If so, help him find some possible order. Formally, rearrange the array $$$w$$$ so that for each $$$i$$$ $$$(1 \le i \le n)$$$, $$$\sum\limits_{j = 1}^{i}w_j \ne x$$$.","for _ in range(int(input())):
  n,x = [int(x) for x in input().split()]
  lis = list(map(int,input().split()))
  if sum(lis) ==x:
    print('NO')
    continue 
  lis = sorted(lis,reverse = True)
  value =0
  for i in range(n):
    value+=lis[i]
    if value == x:
      lis[i],lis[i+1] = lis[i+1],lis[i]
      break
  print('YES')
  print(*lis)","['constructive algorithms', 'greedy', 'math']"
"In Fire City, there are $$$n$$$ intersections and $$$m$$$ one-way roads. The $$$i$$$-th road goes from intersection $$$a_i$$$ to $$$b_i$$$ and has length $$$l_i$$$ miles. There are $$$q$$$ cars that may only drive along those roads. The $$$i$$$-th car starts at intersection $$$v_i$$$ and has an odometer that begins at $$$s_i$$$, increments for each mile driven, and resets to $$$0$$$ whenever it reaches $$$t_i$$$. Phoenix has been tasked to drive cars along some roads (possibly none) and return them to their initial intersection with the odometer showing $$$0$$$.For each car, please find if this is possible. A car may visit the same road or intersection an arbitrary number of times. The odometers don't stop counting the distance after resetting, so odometers may also be reset an arbitrary number of times.","def find_SCC(graph):
    SCC, S, P = [], [], []
    depth = [0] * len(graph)
 
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            d = depth[~node] - 1
            if P[-1] > d:
                SCC.append(S[d:])
                del S[d:], P[-1]
                for node in SCC[-1]:
                    depth[node] = -1
        elif depth[node] > 0:
            while P[-1] > depth[node]:
                P.pop()
        elif depth[node] == 0:
            S.append(node)
            P.append(len(S))
            depth[node] = len(S)
            stack.append(~node)
            stack += graph[node]
    return SCC[::-1]

import sys
input = sys.stdin.readline

n,m = map(int, input().split())
adj = [[] for _ in range(n)]
a2 = [[] for _ in range(n)]

edges = []
for _ in range(m):
    a,b,l = map(int, input().split());a-=1;b-=1
    edges.append((a,b,l))
    adj[a].append(b)
    a2[a].append((b,l))

SCCs = find_SCC(adj)
SCC_ind = [-1] * n
for i in range(len(SCCs)):
    for v in SCCs[i]:
        SCC_ind[v] = i

from math import gcd

dist = [-1] * n
SCC_gcd = []
for l in SCCs:
    root = l[0]
    ind = SCC_ind[root]
    dist[root] = 0
    g = 0
    stack = [root]
    while stack:
        u = stack.pop()
        for v, l in a2[u]:
            if SCC_ind[v] == ind:
                if dist[v] == -1:
                    stack.append(v)
                    dist[v] = dist[u] + l
                else:
                    d1 = dist[u] + l
                    diff = (dist[v] - d1)
                    g = gcd(g, diff)
    SCC_gcd.append(g)

q = int(input())
out = []
for _ in range(q):
    v,s,t = map(int, input().split());v-=1
    g = gcd(SCC_gcd[SCC_ind[v]], t)
    if s % g == 0:
        out.append('YES')
    else:
        out.append('NO')
print('\n'.join(out))","['dfs and similar', 'graphs', 'math', 'number theory']"
"This is the hard version of the problem. The only difference is that in this version $$$q = n$$$.You are given an array of integers $$$a_1, a_2, \ldots, a_n$$$.The cost of a subsegment of the array $$$[l, r]$$$, $$$1 \leq l \leq r \leq n$$$, is the value $$$f(l, r) = \operatorname{sum}(l, r) - \operatorname{xor}(l, r)$$$, where $$$\operatorname{sum}(l, r) = a_l + a_{l+1} + \ldots + a_r$$$, and $$$\operatorname{xor}(l, r) = a_l \oplus a_{l+1} \oplus \ldots \oplus a_r$$$ ($$$\oplus$$$ stands for bitwise XOR).You will have $$$q$$$ queries. Each query is given by a pair of numbers $$$L_i$$$, $$$R_i$$$, where $$$1 \leq L_i \leq R_i \leq n$$$. You need to find the subsegment $$$[l, r]$$$, $$$L_i \leq l \leq r \leq R_i$$$, with maximum value $$$f(l, r)$$$. If there are several answers, then among them you need to find a subsegment with the minimum length, that is, the minimum value of $$$r - l + 1$$$.","from bisect import bisect_left, bisect_right
import sys
import io
import os


# region IO
BUFSIZE = 8192


class FastIO(io.IOBase):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.buffer = io.BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(io.IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def input(): return sys.stdin.readline().rstrip('\r\n')


def read_int_list():
    return list(map(int, input().split()))


def read_int_tuple():
    return tuple(map(int, input().split()))


def read_int():
    return int(input())


# endregion

# region local test
# if 'AW' in os.environ.get('COMPUTERNAME', ''):
#     test_no = 1
#     f = open(os.path.dirname(__file__) + f'\\in{test_no}.txt', 'r')

#     def input():
#         return f.readline().rstrip(""\r\n"")
# endregion

def solve():
    n, q = read_int_tuple()
    A = read_int_list()

    pre = [0] * (n + 1)
    pxr = [0] * (n + 1)
    for i, x in enumerate(A, 1):
        pre[i] = x + pre[i - 1]
        pxr[i] = x ^ pxr[i - 1]
    idx = [i for i, x in enumerate(A) if x]

    for _ in range(q):
        L, R = read_int_tuple()
        li, ri = bisect_left(idx, L - 1), bisect_right(idx, R - 1) - 1
        if not (0 <= li <= ri < len(idx)):
            print(L, L)
            continue

        L, R = idx[li], idx[ri]
        tx = pxr[R + 1] ^ pxr[L]
        hi = pre[R + 1] - pre[L] - tx
        if hi == 0:
            print(L + 1, L + 1)
            continue

        tl, tr = L, R
        
        for dd in range(1, min(bin(tx).count('1') + 1, ri - li + 1)):
            for dl in range(dd + 1):
                dr = dd - dl
                i, j = idx[li + dl], idx[ri - dr]
                cur = pre[j + 1] - pre[i] - (pxr[j + 1] ^ pxr[i])
                if cur == hi and tr - tl > j - i:
                    tl, tr = i, j


        print(tl + 1, tr + 1)


T = read_int()  # 1
for t in range(T):
    solve()","['binary search', 'bitmasks', 'brute force', 'greedy', 'implementation', 'two pointers']"
"This is the easy version of the problem. The only difference is that in this version $$$q = 1$$$.You are given an array of integers $$$a_1, a_2, \ldots, a_n$$$.The cost of a subsegment of the array $$$[l, r]$$$, $$$1 \leq l \leq r \leq n$$$, is the value $$$f(l, r) = \operatorname{sum}(l, r) - \operatorname{xor}(l, r)$$$, where $$$\operatorname{sum}(l, r) = a_l + a_{l+1} + \ldots + a_r$$$, and $$$\operatorname{xor}(l, r) = a_l \oplus a_{l+1} \oplus \ldots \oplus a_r$$$ ($$$\oplus$$$ stands for bitwise XOR).You will have $$$q = 1$$$ query. Each query is given by a pair of numbers $$$L_i$$$, $$$R_i$$$, where $$$1 \leq L_i \leq R_i \leq n$$$. You need to find the subsegment $$$[l, r]$$$, $$$L_i \leq l \leq r \leq R_i$$$, with maximum value $$$f(l, r)$$$. If there are several answers, then among them you need to find a subsegment with the minimum length, that is, the minimum value of $$$r - l + 1$$$.","#from math import ceil, floor #, gcd, log, factorial, comb, perm,
#log10, log2, log, sin, asin, tan, atan, radians
#from heapq import heappop,heappush,heapify #heappop(hq), heapify(list)
#from collections import defaultdict as dd
#mydd=dd(list) for .append
#from collections import deque as dq #deque  e.g. myqueue=dq(list)
#append/appendleft/appendright/pop/popleft
#from bisect import bisect as bis #a=[1,3,4,6,7,8] #bis(a,5)-->3
#import bisect #bisect.bisect_left(a,4)-->2 #bisect.bisect(a,4)-->3
#import statistics as stat  # stat.median(a), mode, mean
#from itertools import permutations(p,r)#combinations(p,r)
#combinations_with_replacement#combinations(p,r) gives r-length tuples,
#in sorted order, with repeated elements#product gives outer product combos
import sys
input = sys.stdin.readline
#print = sys.stdout.write
#sys.setrecursionlimit(100000) #default is 1000 
############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))   #.split(','), default is space
#list([0,*map(int,input().split("" ""))]) # pad a zero to avoid zero indexing
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
####################################################
#t=1
t = int(input())
for tc in range(t):
    n,q=map(int, input().split())
    a=inlt()
    psa=[0]
    pxa=[0]
    for i in a:
        psa.append(psa[-1]+i)
        pxa.append(pxa[-1]^i)
    for qc in range(q):
        L,R=map(int, input().split())
        val=psa[R]-psa[L-1]-pxa[R]^pxa[L-1]
        if val==0:print(L,L);continue
        ans=[L,R]
        i=L
        for j in range(L+1,R+1):
            tmp=psa[j]-psa[i-1]-(pxa[j]^pxa[i-1])
            while tmp==val:
                if j-i<ans[1]-ans[0]:ans=[i,j]
                i+=1
                tmp=psa[j]-psa[i-1]-(pxa[j]^pxa[i-1])
            if ans[1]-ans[0]==1:break
        print(*ans)
    
#print(*ans,sep=' ')##print(""{:.3f}"".format(ans)+""%"")
#:b binary :% eg print(""{:6.2%}"".format(ans))
#print("" "".join(str(i) for i in ans))
#print("" "".join(map(str,ans))) #seems faster
#print(a[0] if a else 0)
#prefixsum a=[a1...an] #psa=[0]*(n+1)
#for i in range(n): psa[i+1]=psa[i]+a[i]
#sum[:ax]=psa[x+1] e.g. sum 1st 5 items in psa[5]
#ASCII<->number ord('f')=102 chr(102)='f'
#def binary_search(li, val, lb, ub):
#    while ((ub-lb)>1):
#        mid = (lb + ub) // 2
#        if li[mid] >= val:
#            ub = mid
#        else:
#            lb = mid
#    return lb+1 #return index of elements <val in li
#def binary_search(li, val, lb, ub):
#    ans = -1
#    while (lb <= ub):
#        mid = (lb + ub) // 2
#        if li[mid] > val:
#            ub = mid - 1
#        elif val > li[mid]:
#            lb = mid + 1
#        else:
#            ans = mid  # return index
#            break
#    return ans
##########
#def pref(li):
#    pref_sum = [0]
#    for i in li:
#        pref_sum.append(pref_sum[-1] + i)
#    return pref_sum
##########
#def suff(li):
#    suff_sum = [0]
#    for i in range(len(li)-1,-1,-1):
#        suff_sum.insert(0,suff_sum[0] + li[i])
#    return suff_sum
#############
#def maxSubArraySumI(arr): #Kadane's algorithm with index
#    max_till_now=arr[0];max_ending=0;size=len(arr)
#    start=0;end=0;s=0
#    for i in range(0, size):
#        max_ending = max_ending + arr[i]
#        if max_till_now < max_ending:
#            max_till_now=max_ending
#            start=s;end=i
#        if max_ending<0:
#            max_ending=0
#            s=i+1
#    return max_till_now,start,end
############# avoid max for 2 elements - slower than direct if
#def maxSubArraySum(arr): #Kadane's algorithm
#    max_till_now=arr[0];max_ending=0;size=len(arr)
#    for i in range(0, size):
#        max_ending = max_ending + arr[i]
#        if max_till_now < max_ending:max_till_now=max_ending
#        if max_ending<0:max_ending=0
#    return max_till_now
#############
#def findbits(x):
#    tmp=[]
#    while x>0:tmp.append(x%2);x//=2
#    tmp.reverse()
#    return tmp
##############Dijkstra algorithm example
#dg=[999999]*(n+1);dg[n]=0;todo=[(0,n)];chkd=[0]*(n+1)
#while todo:#### find x with min dg in todo
#    _,x=hq.heappop(todo)
#    if chkd[x]:continue
#    for i in coming[x]:going[i]-=1
#    for i in coming[x]:
#        tmp=1+dg[x]+going[i]
#        if tmp<dg[i]:dg[i]=tmp;hq.heappush(todo,(dg[i],i))   
#    chkd[x]=1
################ 
# adj swaps to match 2 binary strings: sum_{i=1}^n(abs(diff in i-th prefix sums))
###############
##s=[2, 3, 1, 4, 5, 3]
##sorted(range(len(s)), key=lambda k: s[k])
##gives sorted indices [2, 0, 1, 5, 3, 4]
##m= [[3, 4, 6], [2, 4, 8], [2, 3, 4], [1, 2, 3], [7, 6, 7], [1, 8, 2]]
##m.sort(reverse=True,key=lambda k:k[2]) #sorts m according to 3rd elements
#import bisect  #li = [1, 3, 4, 4, 4, 6, 7]#sorted li, use b search, so log(n)
#bisect.bisect(li,4)-->5 #bisect.bisect_left(li,4)-->2
###############
##def chkprime(x):
##    if x==2 or x==3:return True
##    if x%2==0 or x<2:return False
##    for i in range(3,int(x**0.5)+1,2):
##        if x%i==0:return False
##    return True
############### prime factoring functions
##def pfactors(n):
##    f=[];d=3
##    while n%2==0:f.append(2);n//=2
##    while d*d<=n:
##        while n%d==0:f.append(d);n//=d
##        d+=2
##    if n>1:f.append(n)
##    return f
############################## check equivalence under rotation
##def cyclic_equiv(u,v):
##    n,i,j=len(u),0,0
##    if n!=len(v):return False
##    while i<n and j<n:
##        k=1
##        while k<=n and u[(i+k)%n]==v[(j+k)%n]:k+=1
##        if k>n:return True
##        if u[(i+k)%n]>v[(j+k)%n]:
##            i+=k
##        else:
##            j+=k
##    return False","['binary search', 'bitmasks', 'greedy', 'two pointers']"
"You are playing a game called Slime Escape. The game takes place on a number line. Initially, there are $$$n$$$ slimes. For all positive integers $$$i$$$ where $$$1 \le i \le n$$$, the $$$i$$$-th slime is located at position $$$i$$$ and has health $$$a_i$$$. You are controlling the slime at position $$$k$$$. There are two escapes located at positions $$$0$$$ and $$$n+1$$$. Your goal is to reach any one of the two escapes by performing any number of game moves.In one game move, you move your slime to the left or right by one position. However, if there is another slime in the new position, you must absorb it. When absorbing a slime, the health of your slime would be increased by the health of the absorbed slime, then the absorbed slime would be removed from the game.Note that some slimes might have negative health, so your health would decrease when absorbing such slimes. You lose the game immediately if your slime has negative health at any moment during the game.Can you reach one of two escapes by performing any number of game moves, without ever losing the game?","import sys
input = sys.stdin.readline

def solve():
    n, k = list(map(int, input().split()))
    a = list(map(int, input().split()))
    k -= 1
    ls, rs = a[:k][::-1], a[k + 1:]
    # 把连续的合并，变成[最大代价，最终收益]的形式
    ls2, rs2 = [], []

    # left
    score, minScore = 0, 0
    for aa in ls:
        if score + aa >= 0:
            score += aa
            ls2.append([minScore, score])
            # init
            score, minScore = 0, 0
        else:
            score += aa
            minScore = min(minScore, score)
    if score != 0 or minScore != 0:
        ls2.append([minScore, score])

    # right
    score, minScore = 0, 0
    for aa in rs:
        if score + aa >= 0:
            score += aa
            rs2.append([minScore, score])
            # init
            score, minScore = 0, 0
        else:
            score += aa
            minScore = min(minScore, score)
    if score != 0 or minScore != 0:
        rs2.append([minScore, score])


    # 根据rs2和ls2左右弹跳
    #print(ls2)
    #print(rs2)
    ml, mr = len(ls2), len(rs2)
    i, j = 0, 0
    curr = a[k]
    while i < ml and j < mr:
        if curr + ls2[i][0] >= 0:
            curr += ls2[i][1]
            i += 1
        elif curr + rs2[j][0] >= 0:
            curr += rs2[j][1]
            j += 1
        else:
            break

    if i == ml or j == mr:
        print('YES')
    else:
        print('NO')







if __name__ == '__main__':
    for _ in range(int(input())):
        solve()","['data structures', 'dp', 'greedy', 'two pointers']"
"You are given $$$n$$$ sticks with positive integral length $$$a_1, a_2, \ldots, a_n$$$.You can perform the following operation any number of times (possibly zero):   choose one stick, then either increase or decrease its length by $$$1$$$. After each operation, all sticks should have positive lengths. What is the minimum number of operations that you have to perform such that it is possible to select three of the $$$n$$$ sticks and use them without breaking to form an equilateral triangle?An equilateral triangle is a triangle where all of its three sides have the same length.","# Coded By Block_Cipher
 
import math
import os
import random
import re
import sys
from math import gcd
from math import sqrt
# from collections import Counter
 

# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

for _ in range(int(input())):
	n = int(input())
	arr = list(map(int,input().split()))


	arr.sort()

	ans = 900000000000
	for i in range(n-2):
		ans = min(ans,arr[i+2]- arr[i])
	print(ans)","['brute force', 'greedy', 'sortings']"
"You are given a prime number $$$n$$$, and an array of $$$n$$$ integers $$$b_1,b_2,\ldots, b_n$$$, where $$$0 \leq b_i &lt; n$$$ for each $$$1 \le i \leq n$$$.You have to find a matrix $$$a$$$ of size $$$n \times n$$$ such that all of the following requirements hold:  $$$0 \le a_{i,j} &lt; n$$$ for all $$$1 \le i, j \le n$$$.  $$$a_{r_1, c_1} + a_{r_2, c_2} \not\equiv a_{r_1, c_2} + a_{r_2, c_1} \pmod n$$$ for all positive integers $$$r_1$$$, $$$r_2$$$, $$$c_1$$$, and $$$c_2$$$ such that $$$1 \le r_1 &lt; r_2 \le n$$$ and $$$1 \le c_1 &lt; c_2 \le n$$$. $$$a_{i,i} = b_i$$$ for all $$$1 \le i \leq n$$$. Here $$$x \not \equiv y \pmod m$$$ denotes that $$$x$$$ and $$$y$$$ give different remainders when divided by $$$m$$$.If there are multiple solutions, output any. It can be shown that such a matrix always exists under the given constraints.","from sys import stdin

# import tracemalloc
# from sys import setrecursionlimit
# import resource
input = stdin.readline


# setrecursionlimit(int(1e9))
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))

def ii():
    return int(input())


def li():
    return list(map(int, input().split()))


from math import sqrt


def perfect_sq(n):
    x = int(sqrt(n))

    while x * x < n:
        x += 1

    while x * x > n:
        x -= 1

    return (x * x == n)

n=ii()
a=li()
for i in range(n):
    for j in range(n):
        tmp = j*i - i*i
        print(((tmp + a[i] )%n + n)%n , end=' ')
    print()","['constructive algorithms', 'number theory']"
"You are given an array $$$a$$$ of $$$n$$$ integers. Find the number of pairs $$$(i, j)$$$ ($$$1 \le i &lt; j \le n$$$) where the sum of $$$a_i + a_j$$$ is greater than or equal to $$$l$$$ and less than or equal to $$$r$$$ (that is, $$$l \le a_i + a_j \le r$$$).For example, if $$$n = 3$$$, $$$a = [5, 1, 2]$$$, $$$l = 4$$$ and $$$r = 7$$$, then two pairs are suitable:   $$$i=1$$$ and $$$j=2$$$ ($$$4 \le 5 + 1 \le 7$$$);  $$$i=1$$$ and $$$j=3$$$ ($$$4 \le 5 + 2 \le 7$$$).","# _
#####################################################################################################################

def nPairs(lengthOfArray, l, r, array):
    iFinal = lengthOfArray - 1
    array.sort()
    total = 0
    for i in range(iFinal):
        curr_l, curr_r = l - array[i], r - array[i]
        if curr_r < array[i+1]:
            break
        elif curr_l > array[-1]:
            continue
        if curr_l <= array[i]:
            iFirst = i + 1
        else:
            iFirst = binSearchLowBound(curr_l, i+1, lengthOfArray, array)
        if curr_r >= array[-1]:
            iLast = iFinal
        else:
            iLast = binSearchUpBound(curr_r, i+1, lengthOfArray, array)
        # print(curr_l, curr_r, iFirst, iLast)
        total += iLast - iFirst + 1

    return total


def binSearchLowBound(value, iLow, iHigh, array):
    iEstimated = (iLow + iHigh)//2
    if array[iEstimated] < value:
        return binSearchLowBound(value, iEstimated+1, iHigh, array)

    elif array[iEstimated - 1] >= value:
        return binSearchLowBound(value, iLow, iEstimated, array)

    return iEstimated


def binSearchUpBound(value, iLow, iHigh, array):
    iEstimated = (iLow + iHigh)//2
    if array[iEstimated] > value:
        return binSearchUpBound(value, iLow, iEstimated, array)

    elif array[iEstimated+1] <= value:
        return binSearchUpBound(value, iEstimated+1, iHigh, array)

    return iEstimated


def testCase_1538c():
    return map(int, input().split(' ')), list(map(int, input().split(' ')))


nTestCases = int(input())
testCases = tuple(testCase_1538c() for x in range(nTestCases))
tuple(print(nPairs(*testCase[0], testCase[1])) for testCase in testCases)","['binary search', 'data structures', 'math', 'two pointers']"
"Polycarp has $$$x$$$ of red and $$$y$$$ of blue candies. Using them, he wants to make gift sets. Each gift set contains either $$$a$$$ red candies and $$$b$$$ blue candies, or $$$a$$$ blue candies and $$$b$$$ red candies. Any candy can belong to at most one gift set.Help Polycarp to find the largest number of gift sets he can create.For example, if $$$x = 10$$$, $$$y = 12$$$, $$$a = 5$$$, and $$$b = 2$$$, then Polycarp can make three gift sets:   In the first set there will be $$$5$$$ red candies and $$$2$$$ blue candies;  In the second set there will be $$$5$$$ blue candies and $$$2$$$ red candies;  In the third set will be $$$5$$$ blue candies and $$$2$$$ red candies. Note that in this example there is one red candy that Polycarp does not use in any gift set.","import math
import sys
input = sys.stdin.readline
t = int(input())


def getList():
    return map(int, input().split())


def solve():
    x, y, a, b = getList()
    if a > b:
        a, b = b, a
    if a == b:
        print(min(x, y) // a)
    else:
        l = 0
        r = (x+y) // (a+b)
        while l < r:
            m = l+r+1 >> 1
            R = (x-m*a) // (b-a)
            L = math.ceil((y-m*b) / (a-b))
            # [0,m] and [L,R] instersect
            if L > m or R < 0 or L > R:
                r = m - 1
            else:
                l = m
        print(l)
    # 2 + n * 1 <= 4
    # 3 - n <= 1
    # m set a,b and n set b,a
    # m * a + n * b <= x
    # m * b + n * a <= y
    # max m + n
    # (m+n) * (a+b) <= x + y
    # res = min((x+y) / (a+b), )
    # (s-n) * a + n * b <= x

    # s * a - n * a + n * b <= x
    # s * a + n * (b-a) <= x (1)

    # m * a + (s-m) * b <= x
    # m * (a-b) + s * b <= x

    # (s-n) * b + n * a <= y
    # s * b  + n * (a-b) <= y (1)

    # m * b + (s-m) * a <= y
    # m * (b-a) + s * a <=y

    # 2 * s * a + s * (b-a) <= x + y


for _ in range(t):
    solve()","['binary search', 'greedy', 'math', 'ternary search']"
"Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.Let's call a positive number special if it can be written as a sum of different non-negative powers of $$$n$$$. For example, for $$$n = 4$$$ number $$$17$$$ is special, because it can be written as $$$4^0 + 4^2 = 1 + 16 = 17$$$, but $$$9$$$ is not.Theofanis asks you to help him find the $$$k$$$-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo $$$10^9+7$$$.","import math
t = int(input())
def calcul(n, k):
    s = 0
    while k>0:
        x = math.log2(k)
        p = int(x)
        c = pow(2, p)
        i = int(c*(x-p))

        #update
        s += pow(n, p)
        k -= c
        p = i
        
    return s%(1000000007)
    
for i in range(t):
    n, k = map(int, input().split())
    print(calcul(n, k))","['bitmasks', 'math']"
"You are given the string s of length n and the numbers p, q. Split the string s to pieces of length p and q.For example, the string ""Hello"" for p = 2, q = 3 can be split to the two strings ""Hel"" and ""lo"" or to the two strings ""He"" and ""llo"".Note it is allowed to split the string s to the strings only of length p or to the strings only of length q (see the second sample test).","def divide(n, k, s, t):
    array = []
    for j in xrange(k, len(s) - t, n):
        mini = s[j:j + n]
        #print ""mini "" + mini + str(len(mini))
        if len(mini) == n:
            array.append(mini)
    return array


def splitter():
    n, p, q =[int(x) for x in raw_input().split()]
    text = raw_input()
    maxi = 0
    mini = 0
    index = 0
    if p > q:
        maxi = p
        mini = q
    else:
        maxi = q
        mini = p
    #print ""max"" + str(max)
    permisionmax = n % maxi == 0
    maxnum = (n / maxi) + 1
    permisionmin = n % mini == 0
    minnum = (n / mini) + 1

    mx = 0
    mn = 0
    suma = 0
    while suma < n:
        suma = suma + maxi
        mx = mx + 1
        res = n - suma
        if res % mini == 0 and res > 0:
            rm = res / mini
            suma = suma + (mini * rm)
            mn = rm
            break
    #print suma
    if suma != n:
        mx = 0
        mn = 0
        suma = 0
        while suma < n:
            suma = suma + mini
            mn = mn + 1
            res = n - suma
            if res % mini == 0:
                rm = res / maxi
                suma = suma + (maxi * rm)
                mx = rm
                break
            maxnum -= 1

    permisionboth = True
    if suma != n or mx == 0 or mn == 0 or mini == maxi:
        permisionboth = False

    #permisionboth = n - (minnum * min) - (maxnum * max) == 0
    if not permisionmax and not permisionmin and not permisionboth:
        return [-1]
    elif permisionboth:
        #print ""ambos""
        t = n - (maxi *mx)
        maxlist = divide(maxi, index, text, t)
        index = maxi * mx
        minlist = divide(mini, index, text, 0)
        return [len(maxlist) + len(minlist)] + maxlist + minlist
    elif permisionmin:
        #print ""minimo""
        return [n / mini] + divide(mini, index, text, 0)
    else:
        #print ""maximo""
        return [n / maxi] + divide(maxi, index, text, 0)


ss = splitter()
for i in ss:
    print i","['implementation', 'brute force', 'strings']"
"Tokitsukaze has a permutation $$$p$$$. She performed the following operation to $$$p$$$ exactly $$$k$$$ times: in one operation, for each $$$i$$$ from $$$1$$$ to $$$n - 1$$$ in order, if $$$p_i$$$ &gt; $$$p_{i+1}$$$, swap $$$p_i$$$, $$$p_{i+1}$$$. After exactly $$$k$$$ times of operations, Tokitsukaze got a new sequence $$$a$$$, obviously the sequence $$$a$$$ is also a permutation.After that, Tokitsukaze wrote down the value sequence $$$v$$$ of $$$a$$$ on paper. Denote the value sequence $$$v$$$ of the permutation $$$a$$$ of length $$$n$$$ as $$$v_i=\sum_{j=1}^{i-1}[a_i &lt; a_j]$$$, where the value of $$$[a_i &lt; a_j]$$$ define as if $$$a_i &lt; a_j$$$, the value is $$$1$$$, otherwise is $$$0$$$ (in other words, $$$v_i$$$ is equal to the number of elements greater than $$$a_i$$$ that are to the left of position $$$i$$$). Then Tokitsukaze went out to work.There are three naughty cats in Tokitsukaze's house. When she came home, she found the paper with the value sequence $$$v$$$ to be bitten out by the cats, leaving several holes, so that the value of some positions could not be seen clearly. She forgot what the original permutation $$$p$$$ was. She wants to know how many different permutations $$$p$$$ there are, so that the value sequence $$$v$$$ of the new permutation $$$a$$$ after exactly $$$k$$$ operations is the same as the $$$v$$$ written on the paper (not taking into account the unclear positions).Since the answer may be too large, print it modulo $$$998\,244\,353$$$.","#!/usr/bin/env PyPy3

from collections import Counter, defaultdict, deque
import itertools
import re
import math
from functools import reduce
import operator
import bisect
from heapq import *
import functools
mod=998244353

import sys
import os
from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

t = int(input())
for _ in range(t):
    n,k=map(int,input().split())
    v = list(map(int,input().split()))
    ans = 1
    for i in range(1,k+1):
        ans *= i
        ans %= mod
    cnt = 0
    for i in range(n-k,n):
        if v[i] > 0:
            print(0)
            break
    else:
        for i in range(n-k)[::-1]:
            if v[i] > 0:
                if v[i] > i:
                    print(0)
                    break
            elif v[i] == 0:
                ans *= k + 1
                ans %= mod
            else:
                ans *= (k + 1 + i)
                ans %= mod
        else:
            print(ans)","['dp', 'math']"
"Recall that a permutation of length $$$n$$$ is an array where each element from $$$1$$$ to $$$n$$$ occurs exactly once.For a fixed positive integer $$$d$$$, let's define the cost of the permutation $$$p$$$ of length $$$n$$$ as the number of indices $$$i$$$ $$$(1 \le i &lt; n)$$$ such that $$$p_i \cdot d = p_{i + 1}$$$.For example, if $$$d = 3$$$ and $$$p = [5, 2, 6, 7, 1, 3, 4]$$$, then the cost of such a permutation is $$$2$$$, because $$$p_2 \cdot 3 = p_3$$$ and $$$p_5 \cdot 3 = p_6$$$.Your task is the following one: for a given value $$$n$$$, find the permutation of length $$$n$$$ and the value $$$d$$$ with maximum possible cost (over all ways to choose the permutation and $$$d$$$). If there are multiple answers, then print any of them.","for _ in range (int(input ())):
    n = int(input ())
    print (2)
    r3 = []
    for i in range (1,n+1):
        if i % 2 != 0:
            r3.append(i)
        while r3[-1]*2 <= n:
            r3.append(r3[-1]*2)
    print (*r3)",['greedy']
"There was a string $$$s$$$ which was supposed to be encrypted. For this reason, all $$$26$$$ lowercase English letters were arranged in a circle in some order, afterwards, each letter in $$$s$$$ was replaced with the one that follows in clockwise order, in that way the string $$$t$$$ was obtained. You are given a string $$$t$$$. Determine the lexicographically smallest string $$$s$$$ that could be a prototype of the given string $$$t$$$.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ of the same length if and only if:   in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter, that appears earlier in the alphabet than the corresponding letter in $$$b$$$.","from heapq import _heapify_max, heapify, heappush, heappop
from bisect import bisect_left, bisect_right, bisect, insort
import math, sys, os
from string import ascii_lowercase
from re import A, L
from collections import defaultdict, Counter
from math import log, ceil, sqrt, floor, gcd, log2, factorial
from itertools import chain, combinations, count
from functools import reduce

'''
int: int(input())
str: input().split()[0] 
ints: list(map(int, input().split()))
strs: input().split()
'''
input = sys.stdin.readline
printt = lambda x: sys.stdout.write(str(x) + ""\n"")
printts = lambda x: sys.stdout.write("" "".join(map(str,x)) + ""\n"")
divisors = lambda n: set(chain.from_iterable((i, n // i) for i in range(1, int(sqrt(n)) + 1) if not n % i))
is_prime = lambda n: False if (n < 2) else (True if n in [2,3] else (False if n % 2 == 0 else (not any(n % i == 0 for i in range(3, 1 + floor(sqrt(n)), 2)))))
n_is_power_of_p = lambda n, p: not log(n, p) % 1
lcm = lambda a,b: int(a*b/gcd(a,b)) ## PyPy3 doesn't have lcm -_-
is_sqr = lambda num: sqrt(num).is_integer()

def heapsort(iterable):
	h = []
	for value in iterable:
		heappush(h, value)
	return [heappop(h) for i in range(len(h))]


'''
heapify(arr)
heappush(arr,n)
heappop(arr)
'''

def yes(): printt(""YES"")
def no(): printt(""NO"")
mod = 998244353 
# for case in range(1):
for case in range(int(input())):
	'''
n = int(input())
s = input().split()[0]
map(int, input().split())
arr = list(map(int, input().split()))
arr = input().split()
frr = [list(map(int, input().split())) for _ in range(n)]
	
	'''
	n = int(input())
	t = input().split()[0]
	used = [False] * 26
	letters=ascii_lowercase
	chainn = {}
	res = ''
	uniqs = len(set(t))
	def loopCheck(l,c):
		while l in chainn:
			l = chainn[l]
			if l == c: return True
		return False

	for i in range(n):
		if t[i] in chainn: continue
		for j in range(26):
			if used[j] or t[i] == letters[j] or (loopCheck(letters[j], t[i]) and len(chainn) < 25): continue
			chainn[t[i]] = letters[j]
			used[j] = True
			break
		
	printt(''.join(chainn[ch] for ch in t))
	
				


'''




'''","['dfs and similar', 'dsu', 'graphs', 'greedy', 'implementation', 'strings']"
"Caisa is going to have a party and he needs to buy the ingredients for a big chocolate cake. For that he is going to the biggest supermarket in town.Unfortunately, he has just s dollars for sugar. But that's not a reason to be sad, because there are n types of sugar in the supermarket, maybe he able to buy one. But that's not all. The supermarket has very unusual exchange politics: instead of cents the sellers give sweets to a buyer as a change. Of course, the number of given sweets always doesn't exceed 99, because each seller maximizes the number of dollars in the change (100 cents can be replaced with a dollar).Caisa wants to buy only one type of sugar, also he wants to maximize the number of sweets in the change. What is the maximum number of sweets he can get? Note, that Caisa doesn't want to minimize the cost of the sugar, he only wants to get maximum number of sweets as change.","n,s=map(int,raw_input().strip().split())

max_change=-1

for i in range(n):
    x,y=map(int,raw_input().strip().split())
    if s==x and y==0 and max_change==-1:max_change=0    
    elif s>x and (100-y)%100>max_change:max_change=(100-y)%100
    
print max_change","['implementation', 'brute force']"
"The Olympic Games have just started and Federico is eager to watch the marathon race.There will be $$$n$$$ athletes, numbered from $$$1$$$ to $$$n$$$, competing in the marathon, and all of them have taken part in $$$5$$$ important marathons, numbered from $$$1$$$ to $$$5$$$, in the past. For each $$$1\le i\le n$$$ and $$$1\le j\le 5$$$, Federico remembers that athlete $$$i$$$ ranked $$$r_{i,j}$$$-th in marathon $$$j$$$ (e.g., $$$r_{2,4}=3$$$ means that athlete $$$2$$$ was third in marathon $$$4$$$).Federico considers athlete $$$x$$$ superior to athlete $$$y$$$ if athlete $$$x$$$ ranked better than athlete $$$y$$$ in at least $$$3$$$ past marathons, i.e., $$$r_{x,j}&lt;r_{y,j}$$$ for at least $$$3$$$ distinct values of $$$j$$$.Federico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.Find any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.","def win(a, b):
    cnt = 0
    for i in range(5):
        if a[i] < b[i]:
            cnt += 1
    if cnt >= 3:
        return a
    return b


for _ in range(int(input())):
    n = int(input())
    l = []
    for i in range(n):
        l.append(list(map(int, input().split())))
    ini = l[0]
    idx = 0
    for i in range(1, n):
        if ini != win(ini, l[i]):
            idx = i
            ini = l[i]
    f = 1
    for i in range(n):
        if ini != win(ini, l[i]):
            f = 0
    for i in range(n):
        if ini != win(l[i], ini):
            f = 0
    if not f:
        print(-1)
    else:
        print(idx+1)","['combinatorics', 'graphs', 'greedy', 'sortings']"
"The numbers $$$1, \, 2, \, \dots, \, n \cdot k$$$ are colored with $$$n$$$ colors. These colors are indexed by $$$1, \, 2, \, \dots, \, n$$$. For each $$$1 \le i \le n$$$, there are exactly $$$k$$$ numbers colored with color $$$i$$$.Let $$$[a, \, b]$$$ denote the interval of integers between $$$a$$$ and $$$b$$$ inclusive, that is, the set $$$\{a, \, a + 1, \, \dots, \, b\}$$$. You must choose $$$n$$$ intervals $$$[a_1, \, b_1], \, [a_2, \, b_2], \, \dots, [a_n, \, b_n]$$$ such that:   for each $$$1 \le i \le n$$$, it holds $$$1 \le a_i &lt; b_i \le n \cdot k$$$;  for each $$$1 \le i \le n$$$, the numbers $$$a_i$$$ and $$$b_i$$$ are colored with color $$$i$$$;  each number $$$1 \le x \le n \cdot k$$$ belongs to at most $$$\left\lceil \frac{n}{k - 1} \right\rceil$$$ intervals. One can show that such a family of intervals always exists under the given constraints.","import sys
from sys import stdin, stdout

try:
    n, k = map(int, stdin.readline().split())
    c_a = list(map(int, stdin.readline().split()))
    ceil = (n + k - 2) // (k - 1)

    co_a = [[] for _ in range(n)]
    for i in range(len(c_a)):
        co_a[c_a[i]-1].append(i)

    kc_a = [[] for _ in range(k)]
    for i in range(1, k):
        for j in range(n):
            # c, l, r
            kc_a[i].append([j, co_a[j][i-1], co_a[j][i]])

    res = {}
    for i in range(1, k):
        kc_a[i].sort(key=lambda x: x[2])

        cnt = 0
        for j in range(n):
            c, l, r = kc_a[i][j]
            if c in res:
                continue
            res[c] = [l + 1, r + 1]

            cnt += 1
            if cnt >= ceil:
                break

    for i in range(n):
        stdout.write(str(res[i][0]) + ' ' + str(res[i][1]) + '\n')

except:
    print(sys.exc_info()[0])","['constructive algorithms', 'data structures', 'greedy', 'sortings']"
"You are given an array $$$c = [c_1, c_2, \dots, c_m]$$$. An array $$$a = [a_1, a_2, \dots, a_n]$$$ is constructed in such a way that it consists of integers $$$1, 2, \dots, m$$$, and for each $$$i \in [1,m]$$$, there are exactly $$$c_i$$$ occurrences of integer $$$i$$$ in $$$a$$$. So, the number of elements in $$$a$$$ is exactly $$$\sum\limits_{i=1}^{m} c_i$$$.Let's define for such array $$$a$$$ the value $$$f(a)$$$ as $$$$$$f(a) = \sum_{\substack{1 \le i &lt; j \le n\\ a_i = a_j}}{j - i}.$$$$$$In other words, $$$f(a)$$$ is the total sum of distances between all pairs of equal elements.Your task is to calculate the maximum possible value of $$$f(a)$$$ and the number of arrays yielding the maximum possible value of $$$f(a)$$$. Two arrays are considered different, if elements at some position differ.","import sys
input = sys.stdin.readline


MD = 10 ** 9 + 7
m = int(input())
c = list(map(int, input().split()))

# 1 - cnt, 3 - cnt, ... , cnt - 1
# dic[cnt] += 2
# p1, p1, p1 ... p2, p2, p2
# ans = \sum cnt(pi) * pi

mc = max(c)
dp = [0] * (2 * mc + 2)
for cnt in c:
    dp[cnt - 1] += 1
    
for i in range(mc - 3, -mc, -1):
    dp[i] = (dp[i] + dp[i + 2]) % MD if i >= 0 else dp[-i]
    
fact = [1] * (max(dp) + 1)
for i in range(1, len(fact)):
    fact[i] = (fact[i - 1] * i) % MD 
    
ans, num, p = 0, 1, sum(c) 
for i in range(mc - 1, -mc, -1):
    ans = (ans + i * (p + p - dp[i] + 1) * dp[i] // 2) % MD
    num = (num * fact[dp[i]]) % MD  
    p -= dp[i]
    
print(ans, num)","['combinatorics', 'constructive algorithms', 'greedy', 'sortings']"
"The title is a reference to the very first Educational Round from our writers team, Educational Round 18.There is a bag, containing colored balls. There are $$$n$$$ different colors of balls, numbered from $$$1$$$ to $$$n$$$. There are $$$\mathit{cnt}_i$$$ balls of color $$$i$$$ in the bag. The total amount of balls in the bag is odd (e. g. $$$\mathit{cnt}_1 + \mathit{cnt}_2 + \dots + \mathit{cnt}_n$$$ is odd).In one move, you can choose two balls with different colors and take them out of the bag.At some point, all the remaining balls in the bag will have the same color. That's when you can't make moves anymore.Find any possible color of the remaining balls.","from math import *
import string
from functools import reduce

def rl():
    return [int(i) for i in input().split()]
    
def rln(n):
    return [int(input()) for _ in range(n)]
    
def hehe():
    n = int(input())
    ind = -1
    now = 1
    ma = -1e12
    for i in map(int, input().split()):
        if i > ma:
            ma = i
            ind = now
        now += 1
    print(ind)

t = 1
t = int(input())
for ___ in range(t):
    hehe()","['brute force', 'greedy', 'implementation', 'sortings']"
"A permutation — is a sequence of length $$$n$$$ integers from $$$1$$$ to $$$n$$$, in which all the numbers occur exactly once. For example, $$$[1]$$$, $$$[3, 5, 2, 1, 4]$$$, $$$[1, 3, 2]$$$ — permutations, and $$$[2, 3, 2]$$$, $$$[4, 3, 1]$$$, $$$[0]$$$ — no.Polycarp was recently gifted a permutation $$$a[1 \dots n]$$$ of length $$$n$$$. Polycarp likes trees more than permutations, so he wants to transform permutation $$$a$$$ into a rooted binary tree. He transforms an array of different integers into a tree as follows:   the maximum element of the array becomes the root of the tree;  all elements to the left of the maximum — form a left subtree (which is built according to the same rules but applied to the left part of the array), but if there are no elements to the left of the maximum, then the root has no left child;  all elements to the right of the maximum — form a right subtree (which is built according to the same rules but applied to the right side of the array), but if there are no elements to the right of the maximum, then the root has no right child. For example, if he builds a tree by permutation $$$a=[3, 5, 2, 1, 4]$$$, then the root will be the element $$$a_2=5$$$, and the left subtree will be the tree that will be built for the subarray $$$a[1 \dots 1] = [3]$$$, and the right one — for the subarray $$$a[3 \dots 5] = [2, 1, 4]$$$. As a result, the following tree will be built:     The tree corresponding to the permutation $$$a=[3, 5, 2, 1, 4]$$$. Another example: let the permutation be $$$a=[1, 3, 2, 7, 5, 6, 4]$$$. In this case, the tree looks like this:     The tree corresponding to the permutation $$$a=[1, 3, 2, 7, 5, 6, 4]$$$. Let us denote by $$$d_v$$$ the depth of the vertex $$$a_v$$$, that is, the number of edges on the path from the root to the vertex numbered $$$a_v$$$. Note that the root depth is zero. Given the permutation $$$a$$$, for each vertex, find the value of $$$d_v$$$.","from array import *
t=int(input())
while t>0:
    n=int(input())
    t-=1
    s=input()
    s=s+' '
    ar=array('i',range(1,n+3))
    inv=array('i',range(1,n+3))
    dep=array('i',range(1,n+3))
    j=0
    #print('s=',s,'s[j]=',s[0])
    for i in range(1,n+1):
        st=''
        while not(s[j]==' '):
            #print('s',j,'=',s[j])
            st+=s[j]
            j+=1
        #print('st',i,'=',st)
        ar[i]=int(st)
        j+=1
    ar[n+1]=0
    for i in range(1,n+1):
        inv[ar[i]]=i
    ens=set(range(1,n+1))
    i=n-1
    dep[inv[n]]=0
    dep[inv[n-1]]=1
    while i>1:
        i-=1
        dep[inv[i]]=0
        for j in range(i+1,n+1):
            if inv[j]>inv[i]:
                bool=True
                for k in range(inv[i]+1,inv[j]):
                    if ar[k]>j:
                        bool=False
                        break
                if bool==True:
                    dep[inv[i]]=dep[inv[j]]+1
                    break
            else:
                bool=True
                for k in range(inv[j]+1,inv[i]):
                    if ar[k]>j:
                        bool=False
                        break
                if bool==True:
                    dep[inv[i]]=dep[inv[j]]+1
                    break
                
        #for i in range(inv[i],n+1):
         #   ar[i]=ar[i+1]
          #  inv[ar[i]]-=1
    answer=''
    if n==1:
        dep[1]=0
    for i in range(1,n):
        answer+=str(dep[i])
        answer+=' '
    answer+=str(dep[n])
    print(answer)","['dfs and similar', 'divide and conquer', 'implementation']"
"You are given two strings $$$s$$$ and $$$t$$$, both consisting only of lowercase Latin letters.The substring $$$s[l..r]$$$ is the string which is obtained by taking characters $$$s_l, s_{l + 1}, \dots, s_r$$$ without changing the order.Each of the occurrences of string $$$a$$$ in a string $$$b$$$ is a position $$$i$$$ ($$$1 \le i \le |b| - |a| + 1$$$) such that $$$b[i..i + |a| - 1] = a$$$ ($$$|a|$$$ is the length of string $$$a$$$).You are asked $$$q$$$ queries: for the $$$i$$$-th query you are required to calculate the number of occurrences of string $$$t$$$ in a substring $$$s[l_i..r_i]$$$.","a1 = list(map(int, input().split(' ')[:3]))
bigString = input()
littleString = input()
all = 0
left = [0]*len(bigString)
right = [0]*len(bigString)
leftCount = 0
rightCount = 0
for i in range(len(bigString)):
    left[i] = leftCount
    if bigString.find(littleString,i,i + len(littleString)) != -1:
        leftCount += 1
for i in range(len(bigString) - 1, -1, -1):
    #print(i)
    right[i] = rightCount
    if bigString.find(littleString,i - len(littleString) + 1, i + 1) != -1:
        rightCount += 1
for i in range(len(bigString)):
    if bigString.find(littleString,i,i + len(littleString)) != -1:
        all += 1
#print(left)
#print(right)
#print(all, ""all"")
for s in range(a1[2]):
    a2 = list(map(int, input().split(' ')[:2]))
    a2[0] -= 1
    a2[1] -= 1
    if a2[1] - a2[0] < len(littleString) - 1:
        print(0)
    else:
        result = all - right[a2[1]] - left[a2[0]]
        print(result)","['implementation', 'brute force']"
"There is a city that can be represented as a square grid with corner points in $$$(0, 0)$$$ and $$$(10^6, 10^6)$$$.The city has $$$n$$$ vertical and $$$m$$$ horizontal streets that goes across the whole city, i. e. the $$$i$$$-th vertical streets goes from $$$(x_i, 0)$$$ to $$$(x_i, 10^6)$$$ and the $$$j$$$-th horizontal street goes from $$$(0, y_j)$$$ to $$$(10^6, y_j)$$$. All streets are bidirectional. Borders of the city are streets as well.There are $$$k$$$ persons staying on the streets: the $$$p$$$-th person at point $$$(x_p, y_p)$$$ (so either $$$x_p$$$ equal to some $$$x_i$$$ or $$$y_p$$$ equal to some $$$y_j$$$, or both).Let's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.Calculate the number of inconvenient pairs of persons (pairs $$$(x, y)$$$ and $$$(y, x)$$$ are the same pair).Let's recall that Manhattan distance between points $$$(x_1, y_1)$$$ and $$$(x_2, y_2)$$$ is $$$|x_1 - x_2| + |y_1 - y_2|$$$.","import sys
from collections import Counter, deque
input = sys.stdin.buffer.readline

def calc(xl, ppls):
    n, res = len(xl), 0
    p, pn = 0, len(ppls)
    ppls.sort()
    cc = Counter()
    for i in range(1, n):
        bx, cx = xl[i-1], xl[i]
        while p < pn and ppls[p][0] < cx:
            if ppls[p][0] != bx: cc[ppls[p][1]] += 1
            p += 1
        if not cc: continue
        m = 0
        for yc in cc.values():
            res, m = res+m*yc, m+yc
        if cc: cc.clear()
    return res

T = int(input())
for _ in range(T):
    n, m, k = map(int, input().split())
    xl = list(map(int, input().split()))
    yl = list(map(int, input().split()))
    ppls = []
    for _ in range(k):
        x, y = map(int, input().split())
        ppls.append((x, y))
    
    res = calc(xl, ppls)
    ppls = [ (y, x) for x, y in ppls ]
    res += calc(yl, ppls)
    print(res)","['binary search', 'data structures', 'implementation', 'sortings', 'two pointers']"
"This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.Paul and Mary have a favorite string $$$s$$$ which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:  each letter of the string is either painted in exactly one color (red or green) or isn't painted;  each two letters which are painted in the same color are different;  the number of letters painted in red is equal to the number of letters painted in green;  the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. E. g. consider a string $$$s$$$ equal to ""kzaaa"". One of the wonderful colorings of the string is shown in the figure.    The example of a wonderful coloring of the string ""kzaaa"". Paul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find $$$k$$$ — the number of red (or green, these numbers are equal) letters in a wonderful coloring.","t = int(input())
for i in range(t):
    s = input()
    d = {}
    r, g = 0, 0
    for i in s:
        if i not in d:
            d[i] = 0
        d[i] += 1
    c = 0
    for key, value in d.items():
        if value >= 2:
            c += 1
        c += 1
    print(c // 2)","['greedy', 'strings']"
"Consider a sequence of integers $$$a_1, a_2, \ldots, a_n$$$. In one move, you can select any element of the sequence and delete it. After an element is deleted, all elements to the right are shifted to the left by $$$1$$$ position, so there are no empty spaces in the sequence. So after you make a move, the sequence's length decreases by $$$1$$$. The indices of the elements after the move are recalculated.E. g. let the sequence be $$$a=[3, 2, 2, 1, 5]$$$. Let's select the element $$$a_3=2$$$ in a move. Then after the move the sequence will be equal to $$$a=[3, 2, 1, 5]$$$, so the $$$3$$$-rd element of the new sequence will be $$$a_3=1$$$ and the $$$4$$$-th element will be $$$a_4=5$$$.You are given a sequence $$$a_1, a_2, \ldots, a_n$$$ and a number $$$k$$$. You need to find the minimum number of moves you have to make so that in the resulting sequence there will be at least $$$k$$$ elements that are equal to their indices, i. e. the resulting sequence $$$b_1, b_2, \ldots, b_m$$$ will contain at least $$$k$$$ indices $$$i$$$ such that $$$b_i = i$$$.","t=int(input())
for pro in range(t):
  n, k=map(int, input().split())
  a=list(map(int, input().split("" "")))
  dp=[[0 for i in range(n+1)] for kk in range(n)]
  dp[0][0]=1 if a[0]==1 else 0
  for i in range(1, n):
    for j in range(i+2):
      if(a[i]==i+1-j):
        dp[i][j]=max(1+dp[i-1][j], dp[i-1][j-1])
      else:
        dp[i][j]=max(dp[i-1][j], dp[i-1][j-1])
  ans=-1
  for truck in range(n+1):
    if(dp[-1][truck]>=k):
      ans=truck
      break
  print(ans)","['binary search', 'brute force', 'dp']"
"The only difference between this problem and D1 is that you don't have to provide the way to construct the answer in D1, but you have to do it in this problem.There's a table of $$$n \times m$$$ cells ($$$n$$$ rows and $$$m$$$ columns). The value of $$$n \cdot m$$$ is even.A domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).You need to place $$$\frac{nm}{2}$$$ dominoes on the table so that exactly $$$k$$$ of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.","import sys
from math import ceil

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getList():
    return map(int, input().split())

def getStr():
  return input().strip()


t = getInt()
# t = 1


def solve():
  
  # what we are trying to accomplish here is to make the empty rectangle has even height
  # hence if n is odd first we must filled the first row with horizontal domino, if we can not return false 
  # let k denotes the reamining horizontal dominoes , now we notice both n and m is even
  # if k is even, one viable strategy is to filled from to to bottom, because k is even and n, hence the reaming rectangles (at most two) has even side
  # if k is odd, no mattter how we assign, k is odd hence at least one rectalge must he of odd height hence it is not possible
  # if is also important to check if the filling exceed the width of the grid
  n, m, k = getList()
  
  extra = []
  if n & 1:
    if k < m / 2:
      print(""NO"")
      return
    n -= 1 
    k -= m // 2
    extra = 'mmnn'*m

  w = ceil(k/n) * 2 if n else 0
  res = [["" ""]*m for _ in range(n) ]
  if (k % 2 == 0 and w <= m):
    print(""YES"")
    for i in range(n):
      for j in range(k//n + (i < k%n)) :
        res[i][j*2] = res[i][j*2+1] = (i+j)&1 and 'a' or 'b'

    for j in range(w, m):
      for i in range(n//2):
        res[i*2][j] = res[i*2+1][j] = (i+j) & 1 and 'c' or 'd'
    if n and k % n :
      for i in range(k%n, n, 2):
        for j in w-2,w-1:
          res[i][j] = res[i+1][j] = (i//2+j) & 1 and 'e' or 'f'
    if extra:
      res.insert(0, extra[:m])
    for i in res:
      print(*i, sep="""")
  else:
    print(""NO"")






    # e f
    # e f





for _ in range(t):
    solve()



""""""
aabbaa
bbaabb
aabbaa
bbaabb

""""""","['constructive algorithms', 'implementation', 'math']"
"SmallR is an archer. SmallR is taking a match of archer with Zanoes. They try to shoot in the target in turns, and SmallR shoots first. The probability of shooting the target each time is  for SmallR while  for Zanoes. The one who shoots in the target first should be the winner.Output the probability that SmallR will win the match.","a,b,c,d=list(map(int,input().split()))
print((a/b)/(1-(1-(a/b))*(1-(c/d))))","['probabilities', 'math']"
"Nastia has an unweighted tree with $$$n$$$ vertices and wants to play with it!The girl will perform the following operation with her tree, as long as she needs:  Remove any existing edge.  Add an edge between any pair of vertices. What is the minimum number of operations Nastia needs to get a bamboo from a tree? A bamboo is a tree in which no node has a degree greater than $$$2$$$.","from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

@bootstrap
def fun(adj,v,p,rem):
    ans=0
    f=0
    nf=0
    for i in adj[v]:
        if i==p:
            continue
        (cans,cf) = yield fun(adj,i,v,rem)
        if cf==0:
            nf+=1
            rem.add((v,i))
            ans+=1
        else:
            f+=1
            if f>2:
                ans+=1
                rem.add((v,i))
        ans += cans
        
    if f<2:
        yield (ans,1)
    else:
        yield (ans,0)

def get(parent,a):
    if parent[a]==a:
        return a
    return get(parent,parent[a])

def merge(parent,a,b):
    a = get(parent,a)
    b = get(parent,b)
    if a>b:
        a,b = b,a
    parent[b]=a
    return

t = int(input())
for i in range(t):
    n = int(input())
    adj = [[] for i in range(n)]
    edges = set()
    for j in range(n-1):
        [a,b] = [int(i) for i in input().split()]
        edges.add((a-1,b-1))
        adj[a-1].append(b-1)
        adj[b-1].append(a-1)
    rem = set()
    print(fun(adj,0,-1,rem)[0])
    for (a,b) in rem:
        try:
            edges.remove((a,b))
        except:
            pass
        try:
            edges.remove((b,a))
        except:
            pass
    parent = [i for i in range(n)]
    degree = [0]*n
    for edge in edges:
        degree[edge[0]]+=1
        degree[edge[1]]+=1
        merge(parent,edge[0],edge[1])
    d = {}
    for i in range(n):
        if degree[i]>1:
            continue
        p = get(parent,i)
        if not p in d:
            d[p] = (i,i)
        else:
            d[p] = (d[p][0],i)
    l = list(d.values())
    op = []
    for i in range(len(l)-1):
        op.append([l[i][1],l[i+1][0]])
    rem = list(rem)
    for i in range(len(op)):
        print(1+rem[i][1],1+rem[i][0],1+op[i][0],1+op[i][1])","['constructive algorithms', 'data structures', 'dfs and similar', 'dp', 'dsu', 'greedy', 'implementation', 'trees']"
"You like numbers, don't you? Nastia has a lot of numbers and she wants to share them with you! Isn't it amazing?Let $$$a_i$$$ be how many numbers $$$i$$$ ($$$1 \le i \le k$$$) you have.An $$$n \times n$$$ matrix is called beautiful if it contains all the numbers you have, and for each $$$2 \times 2$$$ submatrix of the original matrix is satisfied:   The number of occupied cells doesn't exceed $$$3$$$;  The numbers on each diagonal are distinct. Make a beautiful matrix of minimum size.","import sys
I=lambda:[*map(int,sys.stdin.readline().split())]

def totalcells(n):
    return n*n-(n//2)*(n//2)
def maxfreq(n):
    return n*((n+1)//2)

t, = I()
for _ in range(t):
    m, k = I()
    a = I()
    mf = max(a)
    n = 0
    while totalcells(n) < m or maxfreq(n) < mf:
        n += 1
    print(n)
    ans = [[0]*n for _ in range(n)]
    gone = set()
    for (sx, sy) in ((1, 0), (0, 1)):
        spots = ((n+1)//2)*(n//2)
        vals = []
        z = max(range(k), key=lambda i: a[i])
        if z not in gone:
            c = min(spots, a[z])
            if c > 0:
                vals += [z]*c
                gone.add(z)
                a[z] -= c
        for i in range(k):
            if i not in gone:
                c = min(spots-len(vals), a[i])
                if c > 0:
                    vals += [i]*c
                    a[i] -= c
                    gone.add(i)
        v = 0
        for i in range(sx, n, 2):
            for j in range(sy, n, 2):
                if v < len(vals):
                    ans[i][j] = vals[v]+1
                    v += 1
    vals = []
    for i in range(k):
        vals += [i]*a[i]
    vals.sort(key=lambda x: x not in gone)
    v = 0
    for (sx, sy) in ((0, 0), (1, 0), (0, 1)):
        for i in range(sx, n, 2):
            for j in range(sy, n, 2):
                if v < len(vals) and ans[i][j] == 0:
                    ans[i][j] = vals[v]+1
                v += 1
    for row in ans:
        print(*row)","['binary search', 'constructive algorithms', 'dp', 'greedy']"
"The brave Knight came to the King and asked permission to marry the princess. The King knew that the Knight was brave, but he also wanted to know if he was smart enough. So he asked him to solve the following task.There is a permutation $$$p_i$$$ of numbers from 1 to $$$2n$$$. You can make two types of operations.   Swap $$$p_1$$$ and $$$p_2$$$, $$$p_3$$$ and $$$p_4$$$, ..., $$$p_{2n-1}$$$ and $$$p_{2n}$$$.  Swap $$$p_1$$$ and $$$p_{n+1}$$$, $$$p_2$$$ and $$$p_{n+2}$$$, ..., $$$p_{n}$$$ and $$$p_{2n}$$$. The task is to find the minimal number of operations required to sort the given permutation.The Knight was not that smart actually, but quite charming, so the princess asks you to help him to solve the King's task.","def print_result(arrey):
    for el in arrey:
        print(el, end="" "")


def swap_p1_p2(arrey, half_length):
    for i in range(0, len(arrey) - 1, 2):
        arrey[i], arrey[i + 1] = arrey[i + 1], arrey[i]
    return arrey


def swap_p1_pn1(arrey, half_length):
    for i in range(len(arrey) // 2):
        arrey[i], arrey[i + half_length] = arrey[i + half_length], arrey[i]
    return arrey


k = int(input())
l = list((input().split()))
l = [int(el) for el in l]
n = l.copy()
found = False
count = 0
result = []
if n == sorted(n):
    result.append(count)
    found = True
if found == False:
    if k % 2 == 0:
        loop = 2
    else:
        loop = k
    for _ in range(loop):
        n = swap_p1_pn1(n, k)
        count += 1
        if n == sorted(n):
            found = True
            result.append(count)
            break
        n = swap_p1_p2(n, k)
        count += 1
        if n == sorted(n):
            found = True
            result.append(count)
            break
    count = 0
    n = l.copy()

    for _ in range(loop):
        n = swap_p1_p2(n, k)
        count += 1
        if n == sorted(n):
            found = True
            result.append(count)
            break
        n = swap_p1_pn1(n, k)
        count += 1
        if n == sorted(n):
            found = True
            result.append(count)
            break
if found:
    print(min(result))
if not found:
    print(-1)","['brute force', 'graphs', 'implementation']"
"Joseph really likes the culture of Japan. Last year he learned Japanese traditional clothes and visual arts and now he is trying to find out the secret of the Japanese game called Nonogram.In the one-dimensional version of the game, there is a row of $$$n$$$ empty cells, some of which are to be filled with a pen. There is a description of a solution called a profile — a sequence of positive integers denoting the lengths of consecutive sets of filled cells. For example, the profile of $$$[4, 3, 1]$$$ means that there are sets of four, three, and one filled cell, in that order, with at least one empty cell between successive sets. A suitable solution for $$$n = 12$$$ and $$$p = [4, 3, 1]$$$.  A wrong solution: the first four filled cells should be consecutive.  A wrong solution: there should be at least one empty cell before the last filled cell. Joseph found out that for some numbers $$$n$$$ and profiles $$$p$$$ there are lots of ways to fill the cells to satisfy the profile. Now he is in the process of solving a nonogram consisting of $$$n$$$ cells and a profile $$$p$$$. He has already created a mask of $$$p$$$ — he has filled all the cells that must be filled in every solution of the nonogram. The mask for $$$n = 12$$$ and $$$p = [4, 3, 1]$$$: all the filled cells above are filled in every solution. After a break, he lost the source profile $$$p$$$. He only has $$$n$$$ and the mask $$$m$$$. Help Joseph find any profile $$$p'$$$ with the mask $$$m$$$ or say that there is no such profile and Joseph has made a mistake.","import copy
from collections import defaultdict as dd
from collections import deque
import math
import sys
import os

# sys.setrecursionlimit(10**5)  # This uses something like 128 MB RAM. I guess only play with this if I expect recursion depth problems.

#region  set up dbg commands
# set up debug stuff.
# remember .bashrc should contain `export PYTHON_CONTEST_HELPER=""dummy""`
if os.environ.get(""PYTHON_CONTEST_HELPER""):
    OUT_RED_BOLD = ""\033[31;1m""
    OUT_GREEN = ""\033[32m""
    OUT_RESET = ""\033[0m""
    OUT_BOLD = ""\033[;1m""
    OUT_CYAN = ""\033[36;1m""
    OUT_PURPLE = ""\033[35;1m""
    OUT_YELLOW = ""\033[33;1m""
    OUT_BACKGROUND = ""\033[41;30;1m""

    def dbgBase(*args, **kwargs):
        color_helper = kwargs.pop('color', OUT_CYAN)
        print(f""{OUT_RED_BOLD}{sys._getframe().f_back.f_back.f_lineno: >20} {OUT_BOLD}: {color_helper}"", end='', file=sys.stderr)
        end_maybe = kwargs.get('end', '\n')
        kwargs['end']=f""{OUT_RESET}{end_maybe}""
        print(*args, file=sys.stderr, **kwargs)

    def dbg(*args, **kwargs): dbgBase(color=OUT_CYAN, *args, **kwargs)
    dbgB = dbg
    def dbgG(*args, **kwargs): dbgBase(color=OUT_GREEN, *args, **kwargs)
    def dbgP(*args, **kwargs): dbgBase(color=OUT_PURPLE, *args, **kwargs)
    def dbgY(*args, **kwargs): dbgBase(color=OUT_YELLOW, *args, **kwargs)
    def dbgBackground(*args, **kwargs): dbgBase(color=OUT_BACKGROUND, *args, **kwargs)
    def el(n=1): print('\n'*n, file=sys.stderr, end='')
else:
    def dbg(*args, **kwargs): pass
    def dbgB(*args, **kwargs): pass
    def dbgG(*args, **kwargs): pass
    def dbgP(*args, **kwargs): pass
    def dbgY(*args, **kwargs): pass
    def dbgBackground(*args, **kwargs): pass
    def el(n=1): pass
#endregion
#region  FastIO
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#endregion

def nn():
    return int(input())

def li():
    return list(input())

def lm():
    return list(map(int, input().split()))


# To print while flushing output for interactive problems:
# print(x, flush=True)


#########################################################################
# Problem specific code usually goes below this line.
#########################################################################

# ! Read the sample cases before writing code!








def solve(testID):
    dat = input()
    dbg(dat)
    min_space = -1
    if dat[0] == ""#"" or dat[-1] == ""#"":
        min_space = 0
    curr_cell = 0
    total_blocks = []
    while curr_cell < len(dat):
        curr_spaces = 0
        while curr_cell < len(dat) and dat[curr_cell] == ""_"":
            curr_spaces += 1
            curr_cell += 1
        if curr_spaces != 0 and (min_space == -1 or curr_spaces < min_space):
            min_space = curr_spaces
        curr_block_size = 0
        start_cell = curr_cell
        while curr_cell < len(dat) and dat[curr_cell] == ""#"":
            curr_block_size += 1
            curr_cell += 1
        if curr_block_size > 0:
            total_blocks.append((start_cell, curr_block_size))
    dbgB(min_space)
    dbgB(total_blocks)
    if len(total_blocks) == 0:
        print(0)
        print()
        return
    for slack in range(min_space + 1):
        last_allowed_spot = 0
        success = True
        for pos, block_size in total_blocks:
            dbgP(slack, pos, block_size, last_allowed_spot)
            prior_empty_space = pos - last_allowed_spot
            space_to_fill = prior_empty_space - slack
            dbgY(space_to_fill)
            if space_to_fill < 0:
                success = False
                break
            if space_to_fill > 0 and slack == 0:
                success = False
                break
            if space_to_fill == 1:
                success = False
                break
            if space_to_fill % 2 == 1 and slack == 1:
                success = False
                break
            last_allowed_spot = pos + block_size + 1
            dbgP(last_allowed_spot)
        if not success:
            continue
        remaining_space = len(dat) - last_allowed_spot + 1 - slack
        dbgG(remaining_space)
        if (remaining_space > 0 and slack == 0) or remaining_space < 0 or remaining_space == 1 or (remaining_space % 2 == 1 and slack == 1):
            success = False
            continue
        break
    if not success:
        print(-1)
        return
    dbgY(slack)

    profile_ints = []
    last_allowed_spot = 0
    for pos, block_size in total_blocks:
        space_to_fill = pos - last_allowed_spot - slack
        dbgB(space_to_fill)
        if space_to_fill % 2 == 1:
            profile_ints.append(2)
            space_to_fill -= 3
        while space_to_fill > 0:
            profile_ints.append(1)
            space_to_fill -= 2
        profile_ints.append(block_size + slack)
        last_allowed_spot = pos + block_size + 1
    remaining_space = len(dat) - last_allowed_spot + 1 - slack
    dbgP(remaining_space)
    if remaining_space > 0:
        if remaining_space % 2 == 1:
            profile_ints.append(2)
            remaining_space -= 3
        while remaining_space > 0:
            profile_ints.append(1)
            remaining_space -= 2

    dbgG(profile_ints)

    print(len(profile_ints))
    print("" "".join([str(x) for x in profile_ints]))

    return


T = 1
# dbgBackground(""Loading num cases!!!!!""); T = nn()  # ! Comment this out for single-case problems!
for testID in range(1, T+1):
    el()
    dbgBackground(f""Case {testID}"")
    solve(testID)","['constructive algorithms', 'math']"
"You are given an array consisting of all integers from $$$[l, r]$$$ inclusive. For example, if $$$l = 2$$$ and $$$r = 5$$$, the array would be $$$[2, 3, 4, 5]$$$. What's the minimum number of elements you can delete to make the bitwise AND of the array non-zero?A bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits.","psum = [[0] * 18 for _ in range(2 * 10 ** 5 + 1)]
for i in range(1, 2 * 10 ** 5 + 1):
    for j in range(18):
        psum[i][j] = psum[i - 1][j] + ((i >> j) & 1)  # The reason for &1 is to use only the significant bit.


tc = int(input())
for _ in range(tc):
    L, R = map(int, input().split())

    max_value = 0
    for i in range(18):
        max_value = max(max_value, psum[R][i] - psum[L - 1][i])

    print((R - L + 1) - max_value)","['bitmasks', 'greedy', 'math']"
"Mark has just purchased a rack of $$$n$$$ lightbulbs. The state of the lightbulbs can be described with binary string $$$s = s_1s_2\dots s_n$$$, where $$$s_i=\texttt{1}$$$ means that the $$$i$$$-th lightbulb is turned on, while $$$s_i=\texttt{0}$$$ means that the $$$i$$$-th lightbulb is turned off.Unfortunately, the lightbulbs are broken, and the only operation he can perform to change the state of the lightbulbs is the following:  Select an index $$$i$$$ from $$$2,3,\dots,n-1$$$ such that $$$s_{i-1}\ne s_{i+1}$$$.  Toggle $$$s_i$$$. Namely, if $$$s_i$$$ is $$$\texttt{0}$$$, set $$$s_i$$$ to $$$\texttt{1}$$$ or vice versa. Mark wants the state of the lightbulbs to be another binary string $$$t$$$. Help Mark determine the minimum number of operations to do so.","import sys
from array import array

input = lambda: sys.stdin.buffer.readline().decode().strip()
out = []

for _ in range(int(input())):
    n, ans = int(input()), 0
    s = array('b', [int(x) for x in input()])
    t = array('b', [int(x) for x in input()])
    sxor = array('b', [s[i] ^ s[i - 1] for i in range(1, n)])
    txor = array('b', [t[i] ^ t[i - 1] for i in range(1, n)])

    if s[0] != t[0] or s[-1] != t[-1] or sum(sxor) != sum(txor):
        out.append(-1)
    else:
        for i in range(n - 2, -1, -1):
            if sxor[i] == 0:
                while txor[-1]:
                    txor.pop()

                txor.pop()
                ans += abs(i - len(txor))
        out.append(ans)
print('\n'.join(map(str, out)))","['combinatorics', 'constructive algorithms', 'greedy', 'math', 'sortings']"
"After watching a certain anime before going to sleep, Mark dreams of standing in an old classroom with a blackboard that has a sequence of $$$n$$$ positive integers $$$a_1, a_2,\dots,a_n$$$ on it.Then, professor Koro comes in. He can perform the following operation:  select an integer $$$x$$$ that appears at least $$$2$$$ times on the board,  erase those $$$2$$$ appearances, and  write $$$x+1$$$ on the board. Professor Koro then asks Mark the question, ""what is the maximum possible number that could appear on the board after some operations?""Mark quickly solves this question, but he is still slower than professor Koro. Thus, professor Koro decides to give Mark additional challenges. He will update the initial sequence of integers $$$q$$$ times. Each time, he will choose positive integers $$$k$$$ and $$$l$$$, then change $$$a_k$$$ to $$$l$$$. After each update, he will ask Mark the same question again.Help Mark answer these questions faster than Professor Koro!Note that the updates are persistent. Changes made to the sequence $$$a$$$ will apply when processing future updates.","import sys
import os
from io import BytesIO, IOBase
from math import floor
from random import randint
import time

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

if sys.version_info[0] < 3:
    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

file = sys.stdin
if os.environ.get('USER') == ""loic"":
    file = open(""data.in"")
    
line = lambda: file.readline().split()
ui = lambda: int(line()[0])
ti = lambda: map(int,line())
li = lambda: list(ti())

#######################################################################

# From https://github.com/cheran-senthil/PyRival/blob/master/pyrival/data_structures/SortedList.py
class IntervalList:
    def __init__(self, iterable=[], _load=5000):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _prev_interval(self, pos, idx):
        _lists = self._lists
        if idx < 0 or pos < 0:
            raise ValueError(""idx or pos < 0 "", (idx,pos))
        if idx > 0:
            return pos, idx - 1, _lists[pos][idx - 1]
        if pos > 0:
            last = self._list_lens[pos - 1] - 1
            return pos - 1, last, _lists[pos - 1][last]
        return -1, -1, None
    
    def _next_interval(self, pos, idx):
        _lists = self._lists
        _list_lens = self._list_lens
        if idx < 0 or pos < 0:
            raise ValueError(""idx or pos < 0 "", (idx,pos))
        if idx < _list_lens[pos] - 1:
            return pos, idx + 1, _lists[pos][idx + 1]
        if pos < len(_lists) - 1:
            return pos + 1, 0, _lists[pos + 1][0]
        return -1, -1, None

    def _insert(self, pos, idx, l, r):
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
        
        if _lists:
            _list = _lists[pos]
            self._fen_update(pos, 1)
            _list.insert(idx, Interval(l, r))
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            itv = Interval(l, r)
            _lists.append([itv])
            _mins.append(itv)
            _list_lens.append(1)
            self._rebuild = True
        
        self._len += 1

    def get_left_interval(self, position):
        pos, idx = self._loc_right(Interval(position, position))
        prev_pos, prev_idx, prev_itv = self._prev_interval(pos, idx)
        if prev_itv is not None:
            return prev_pos, prev_idx, prev_itv
        return -1, -1, None

    def get_right_interval(self, position):
        prev_pos, prev_idx, prev_itv = self.get_left_interval(position)
        if prev_itv is not None:
            if position <= prev_itv.r:
                return prev_pos, prev_idx, prev_itv
            else:
                return self._next_interval(prev_pos, prev_idx)
        if self._lists:
            return 0, 0, self._lists[0][0]
        return -1, -1, None

    def add(self, l, r):
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        if not _lists:
            self._insert(0, 0, l, r)
            
        pos, idx = self._loc_right(Interval(l,r))
        prev_pos, prev_idx, prev_itv = self._prev_interval(pos, idx)
        
        in_left = False
        if prev_itv is not None and l <= prev_itv.r:
            if r <= prev_itv.r:
                return
            in_left = True
        
        in_right = False
        rem = []

        nxt_pos,nxt_idx,nxt_itv = self._next_interval(prev_pos,prev_idx) if prev_itv is not None else (0, 0, self._lists[0][0])
        while nxt_itv is not None and r >= nxt_itv.r:
            rem.append((nxt_pos,nxt_idx))
            nxt_pos,nxt_idx,nxt_itv = self._next_interval(nxt_pos,nxt_idx)
        
        for rem_pos,rem_idx in reversed(rem):
            self._delete(rem_pos, rem_idx)
    
        if nxt_itv is not None and nxt_itv.l <= r:
            in_right = True
        
        if not in_left and not in_right:
            self._insert(pos, idx, l, r)
        elif in_left and not in_right:
            prev_itv.r = r
        elif not in_left and in_right:
            nxt_itv.l = l
        else:
            nxt_itv.l = prev_itv.l
            self._delete(prev_pos, prev_idx)

    def discard(self, l, r):
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        if _lists:
            pos, idx = self._loc_right(Interval(l,r))
            prev_pos, prev_idx, prev_itv = self._prev_interval(pos, idx)
            in_left = False
            in_right = False
            if prev_itv is not None:
                if prev_itv.l < l < prev_itv.r:
                    in_left = True
                if prev_itv.l < r < prev_itv.r:
                    in_right = True
            else:
                prev_pos, prev_idx, prev_itv = pos, idx, _lists[pos][idx]
            
            rem = []
            nxt_pos,nxt_idx,nxt_itv = prev_pos, prev_idx, prev_itv
            while nxt_itv is not None and nxt_itv.r <= r:
                if l <= nxt_itv.l:
                    rem.append((nxt_pos,nxt_idx))
                nxt_pos,nxt_idx,nxt_itv = self._next_interval(nxt_pos,nxt_idx)
            
            for rem_pos,rem_idx in reversed(rem):
                self._delete(rem_pos, rem_idx)
            
            if in_left and in_right:
                if l != r:
                    self._insert(pos, idx, r, prev_itv.r)
                    prev_itv.r = l
                return
            elif in_left:
                prev_itv.r = l
            
            if nxt_itv is not None and nxt_itv.l < r < nxt_itv.r:
                nxt_itv.l = r

    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):
        """"""Return the left most index to insert `value` in the sorted list
           Index == size if insertion is after last element""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):
        """"""Return the right most index to insert `value` in the sorted list
           Index == size if insertion is after last element""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len

    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)

    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return '[' + "", "".join(str(itvl) for itvl in list(self)) + ']'


class Interval:
    def __init__(self, l, r):
        self.l = l
        self.r = r

    def __str__(self):
        return ""("" + str(self.l) + "", "" +  str(self.r) + "")""
    
    def __repr__(self):
        return self.__str__()
    
    def __eq__(self, other):
        return self.l == other.l and self.r == other.r
    
    def __lt__(self, other):
        return self.l < other.l
    
    def __le__(self, other):
        return self.l <= other.l

def rem(il,val):
    pos,idx,itv = il.get_right_interval(val)
    if itv is not None and val >= itv.l:
        il.discard(floor(val), floor(val) + 1)
    else:
        left = itv.l
        il.add(floor(val),left)
        il.discard(left, left + 1)

def add(il,val):
    pos,idx,itv = il.get_left_interval(val)
    if itv is not None and val <= itv.r:
        right = itv.r
        il.discard(floor(val),right)
        il.add(right, right + 1)
    else:
        il.add(floor(val), floor(val) + 1)

def solve():
    
    res = []
    il = IntervalList([], 300)
    
    for val in A:
        add(il, val + 0.5)
    
    for _ in range(Q):
        idx, val = ti()
        idx -= 1
        
        rem(il, A[idx] + 0.5)
        A[idx] = val
        add(il, val + 0.5)
        
        res.append(il[-1].r - 1)
    
    
    return ""\n"".join(str(v) for v in res)

for test in range(1,1+1):
    N,Q = ti()
    A = li()
    
    print(solve())
    
file.close()","['binary search', 'bitmasks', 'brute force', 'combinatorics', 'data structures', 'greedy']"
"You have a permutation: an array $$$a = [a_1, a_2, \ldots, a_n]$$$ of distinct integers from $$$1$$$ to $$$n$$$. The length of the permutation $$$n$$$ is odd.Consider the following algorithm of sorting the permutation in increasing order.A helper procedure of the algorithm, $$$f(i)$$$, takes a single argument $$$i$$$ ($$$1 \le i \le n-1$$$) and does the following. If $$$a_i &gt; a_{i+1}$$$, the values of $$$a_i$$$ and $$$a_{i+1}$$$ are exchanged. Otherwise, the permutation doesn't change.The algorithm consists of iterations, numbered with consecutive integers starting with $$$1$$$. On the $$$i$$$-th iteration, the algorithm does the following:   if $$$i$$$ is odd, call $$$f(1), f(3), \ldots, f(n - 2)$$$;  if $$$i$$$ is even, call $$$f(2), f(4), \ldots, f(n - 1)$$$. It can be proven that after a finite number of iterations the permutation will be sorted in increasing order.After how many iterations will this happen for the first time?","for a in range(int(input())):
    n=int(input())
    l=[int(x) for x in input().split()]
    ll=sorted(l)
    c=0
    while l!=ll:
        for i in range(c%2,n-1,2):
            if l[i]>l[i+1]:
                l[i],l[i+1]=l[i+1],l[i]
        c+=1
        # print(l)
    print(c)","['brute force', 'implementation', 'sortings']"
"Given a cyclic array $$$a$$$ of size $$$n$$$, where $$$a_i$$$ is the value of $$$a$$$ in the $$$i$$$-th position, there may be repeated values. Let us define that a permutation of $$$a$$$ is equal to another permutation of $$$a$$$ if and only if their values are the same for each position $$$i$$$ or we can transform them to each other by performing some cyclic rotation. Let us define for a cyclic array $$$b$$$ its number of components as the number of connected components in a graph, where the vertices are the positions of $$$b$$$ and we add an edge between each pair of adjacent positions of $$$b$$$ with equal values (note that in a cyclic array the first and last position are also adjacents).Find the expected value of components of a permutation of $$$a$$$ if we select it equiprobably over the set of all the different permutations of $$$a$$$.","import math
import sys
r=range
m=lambda x:pow(x,M-2,M)
M=998244353
f=[1]
F=[1]*10**6
for i in r(1,1000001):f.append(f[-1]*i%M)
F.append(m(f[-1]))
for i in r(10**6,1,-1):F[i-1]=F[i]*(i)%M
I=sys.stdin.readline
for _ in[0]*int(I()):
	n=int(I());a=[*map(int,I().split())];C=[0]*n;P,c=0,0;A={}
	for g in a:C[g-1]+=1
	C=[g for g in C if g>0]
	x=C[0]
	for g in C:x=math.gcd(x,g)
	if x==n:print(1);continue
	for i in r(1,n):
		if x%i<1:A[i]=0
	for i in r(1,n):
		if x%i<1:
			X=n//i;p=f[X];s=0;e=i-A[i]
			for g in C:y=g//i;s+=y*(y-1);p=p*F[y]%M
			P+=p*e;c+=e*((X)*(X-1)-s)*i*m(X-1)*p%M
			for g in A:
				if g%i<1:A[g]+=e
	print(c*m(P)%M)","['combinatorics', 'math', 'number theory', 'probabilities']"
"Hosssam decided to sneak into Hemose's room while he is sleeping and change his laptop's password. He already knows the password, which is a string $$$s$$$ of length $$$n$$$. He also knows that there are $$$k$$$ special letters of the alphabet: $$$c_1,c_2,\ldots, c_k$$$.Hosssam made a program that can do the following.  The program considers the current password $$$s$$$ of some length $$$m$$$.  Then it finds all positions $$$i$$$ ($$$1\le i&lt;m$$$) such that $$$s_{i+1}$$$ is one of the $$$k$$$ special letters.  Then it deletes all of those positions from the password $$$s$$$ even if $$$s_{i}$$$ is a special character. If there are no positions to delete, then the program displays an error message which has a very loud sound. For example, suppose the string $$$s$$$ is ""abcdef"" and the special characters are 'b' and 'd'. If he runs the program once, the positions $$$1$$$ and $$$3$$$ will be deleted as they come before special characters, so the password becomes ""bdef"". If he runs the program again, it deletes position $$$1$$$, and the password becomes ""def"". If he is wise, he won't run it a third time.Hosssam wants to know how many times he can run the program on Hemose's laptop without waking him up from the sound of the error message. Can you help him?","import sys

t = int(sys.stdin.readline())
for _ in range(t):
    n = int(sys.stdin.readline())
    s = sys.stdin.readline().strip().lower()
    a = sys.stdin.readline().strip().lower().split()
    k = int(a[0])

    d = [0]*256
    for i in range(1, k+1):
        d[ord(a[i])] = 1

    parts = 0
    maxlen = 0
    curlen = 0
    grps = []
    for i in range(len(s)):
        v = d[ord(s[i])]
        if i == 0:
            v = 0
        if v > 0:
            if curlen > 0:
                parts += 1
            if curlen > maxlen:
                maxlen = curlen
            grps.append(curlen)
            curlen = 0
        else:
            curlen += 1

    # print(grps)
    cnt = 0
    for i in range(len(grps)):
        if i > 0:
            if grps[i] == maxlen:
                cnt += 1

    res = 0
    if parts == 1:
        res = max(maxlen,1)
    elif parts > 1:
        if cnt >= 1:
            res = maxlen + 1
        else:
            res = max(maxlen,1)

    print(res)","['brute force', 'implementation', 'strings']"
"During their training for the ICPC competitions, team ""Jee You See"" stumbled upon a very basic counting problem. After many ""Wrong answer"" verdicts, they finally decided to give up and destroy turn-off the PC. Now they want your help in up-solving the problem.You are given 4 integers $$$n$$$, $$$l$$$, $$$r$$$, and $$$z$$$. Count the number of arrays $$$a$$$ of length $$$n$$$ containing non-negative integers such that:  $$$l\le a_1+a_2+\ldots+a_n\le r$$$, and  $$$a_1\oplus a_2 \oplus \ldots\oplus a_n=z$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. Since the answer can be large, print it modulo $$$10^9+7$$$.","import sys
sys.setrecursionlimit(2000)



# ---------------------------------------- fast io ----------------------------------------
import os, sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
# ---------------------------------------- fast io ----------------------------------------




mod = 10 ** 9 + 7
comb = [[-1] * (1001) for _ in range(1001)]


def nCi(n, i):
    if i == 0:
        comb[n][i] = 1
        return 1
    if n == 0:
        comb[n][i] = 0
        return 0
    if comb[n][i] != -1:
        return comb[n][i]

    comb[n][i] = (nCi(n - 1, i) + nCi(n - 1, i - 1)) % mod
    return comb[n][i]

for i in range(1001):
    nCi(1000,i)

def compute(x):
    f = [[-1 for _ in range(2001)] for _ in range(61)]

    def dfs(idx, k, r):
        if k > 2000:
            k = 2000
        if k < 0:
            return 0
        if idx == -1:
            return 1

        if f[idx][k] != -1:
            return f[idx][k]

        ans = 0
        cb = int((z & (1 << idx)) > 0)
        for i in range(cb, n + 1, 2):
            bcb = int((r & (1 << idx)) > 0)

            ans += nCi(n,i) * dfs(idx - 1, 2 * (k - i + bcb), r)
            ans %= mod

        f[idx][k] = ans
        return f[idx][k]

    res = dfs(60, 0, x)
    return res



n,l,r,z=[int(x) for x in input().split()]
ans = (compute(r) - compute(l - 1) + mod) % mod
print(ans)","['bitmasks', 'combinatorics', 'dp']"
"This is an interactive problem. The only difference between the easy and hard version is the limit on number of questions.There are $$$n$$$ players labelled from $$$1$$$ to $$$n$$$. It is guaranteed that $$$n$$$ is a multiple of $$$3$$$.Among them, there are $$$k$$$ impostors and $$$n-k$$$ crewmates. The number of impostors, $$$k$$$, is not given to you. It is guaranteed that $$$\frac{n}{3} &lt; k &lt; \frac{2n}{3}$$$.In each question, you can choose three distinct integers $$$a$$$, $$$b$$$, $$$c$$$ ($$$1 \le a, b, c \le n$$$) and ask: ""Among the players labelled $$$a$$$, $$$b$$$ and $$$c$$$, are there more impostors or more crewmates?"" You will be given the integer $$$0$$$ if there are more impostors than crewmates, and $$$1$$$ otherwise.Find the number of impostors $$$k$$$ and the indices of players that are impostors after asking at most $$$n+6$$$ questions.The jury is adaptive, which means the indices of impostors may not be fixed beforehand and can depend on your questions. It is guaranteed that there is at least one set of impostors which fulfills the constraints and the answers to your questions at any time.","def ask(a, b, c):
    print(f'? {a} {b} {c}', flush=True)
    s = input()
    if s == '-1':
        exit()
    else:
        return int(s)

for _ in range(int(input())):
    n = int(input())
    ans = [0]*n
    fp = [0]*2
    sp = [0]*2
    tp = [0]*2
    fop= [0]*2
    fp[0]= ['0000', '0010', '0100', '1000', '0001', '0011', '0101', '1001' ]
    fp[1] = ['1111', '1101', '1011', '0111', '1110', '1100', '1010', '0110']
    sp[0] = ['0000', '0010', '0100', '0110', '0001', '0011', '1000', '1010']
    sp[1] = ['1111', '1101', '1011', '1001', '1110', '1100', '0111', '0101']
    tp[0] = ['0000', '1000', '0100', '1100', '0010', '1010', '0001', '1001']
    tp[1] = ['1111', '0111', '1011', '0011', '1101', '0101', '1110', '0110']
    fop[0] = ['0000', '0100', '1000', '1100', '0010', '0110', '0001', '0101']
    fop[1] = ['1111', '1011', '0111', '0011', '1101', '1001', '1110', '1010']
    m = ask(1, 2, 3)
    for k in range(1,n//3):
        i = 3*k
        tmp = ask(i + 1, i + 2, i + 3)
        if tmp!= m:
            break
    if tmp == 1:
        r = tp[1]
        j = 3*(k-1)
        p = fp[ask(j + 1, i + 1, i + 2)]
        q = sp[ask(j + 1, i + 1, i + 3)]
        s = fop[ask(j + 1, i + 2, i + 3)]
        x =  list(((set(p)&set(q)) & set(r)) & set(s))
        if len(x) == 1:
            ans[j] = '0'
            ans[i:i+3] = list(x[0])[1:]
            zeropos = j+1
            onepos = i+ list(x[0]).index('1')
        else:
            p = fp[ask(j + 2, i + 1, i + 2)]
            q = sp[ask(j + 2, i + 1, i + 3)]
            s = fop[ask(j + 2, i + 2, i + 3)]
            x = list(((set(p) & set(q)) & set(r)) & set(s))
            if len(x) == 1:
                ans[j+1] = '0'
                ans[i:i + 3] = list(x[0])[1:]
                zeropos = j + 2
                onepos = i + list(x[0]).index('1')
            else:
                ans[i:i+3] = list('111')
                onepos = i + 1
                t = ask(j+1, j+2, onepos)
                if  t== 0:
                    ans[j] = '0'
                    ans[j+1] = '0'
                    zeropos = j+1
                else:
                    ans[j+2] = '0'
                    zeropos = j+3
        for z in range(j+1,j+4):
            if z!= zeropos:
                ans[z-1] = str(ask(z, zeropos, onepos))
        for c in range(0,k-1):
            d = 3*c
            b = ask(d+1, d+2, onepos)
            if b == 0:
                ans[d] = '0'
                ans[d+1] = '0'
                ans[d+2] = str(ask(zeropos, d + 3, onepos))
            else:
                ans[d+2] = '0'
                ans[d + 1] = str(ask(d + 2, zeropos, onepos))
                ans[d] = str(1- int(ans[d+1]))
    else:
        r = tp[0]
        j = 3 * (k - 1)
        p = fp[ask(j + 1, i + 1, i + 2)]
        q = sp[ask(j + 1, i + 1, i + 3)]
        s = fop[ask(j + 1, i + 2, i + 3)]
        x = list(((set(p) & set(q)) & set(r)) & set(s))
        if len(x) == 1:
            ans[j] = '1'
            ans[i :i + 3] = list(x[0])[1:]
            onepos = j + 1
            zeropos = i  + list(x[0]).index('0')
        else:
            p = fp[ask(j + 2, i + 1, i + 2)]
            q = sp[ask(j + 2, i + 1, i + 3)]
            s = fop[ask(j + 2, i + 2, i + 3)]
            x = list(((set(p) & set(q)) & set(r)) & set(s))
            if len(x) == 1:
                ans[j + 1] = '1'
                ans[i :i + 3] = list(x[0][1:])
                onepos = j + 2
                zeropos = i + list(x[0]).index('0')
            else:
                ans[i :i + 3] = list('000')
                zeropos = i + 1
                t = ask(j + 1, j + 2, zeropos)
                if t == 1:
                    ans[j] = '1'
                    ans[j + 1] = '1'
                    onepos = j + 1
                else:
                    ans[j + 2] = '1'
                    onepos = j + 3

        for z in range(j+1,j+4):
            if z!= onepos:
                ans[z-1] = str(ask(z, zeropos, onepos))

        for c in range(0,k-1):
            d = 3*c
            b = str(ask(d+1, d+2, zeropos))
            if b == '1':
                ans[d] = '1'
                ans[d+1] = '1'
                ans[d+2] = str(ask(d + 3, zeropos, onepos))
            else:
                ans[d+2] = '1'
                ans[d + 1] = str(ask(d + 2, zeropos, onepos))
                ans[d] = str(1- int(ans[d+1]))

    for l in range(i+4,n+1):
        ans[l - 1] = str(ask(l, zeropos, onepos))
    #print(ans)
    indans = [str(i+1) for i in range(n) if ans[i] == '0']
    fans = '! '+str(len(indans)) + ' ' + ' '.join(indans)
    print(fans, flush=True)","['constructive algorithms', 'implementation', 'interactive', 'math']"
"You have been invited as a production process optimization specialist to some very large company. The company has $$$n$$$ machines at its factory, standing one behind another in the production chain. Each machine can be described in one of the following two ways: $$$(+,~a_i)$$$ or $$$(*,~a_i)$$$.If a workpiece with the value $$$x$$$ is supplied to the machine of kind $$$(+,~a_i)$$$, then the output workpiece has value $$$x + a_i$$$.If a workpiece with the value $$$x$$$ is supplied to the machine of kind $$$(*,~a_i)$$$, then the output workpiece has value $$$x \cdot a_i$$$.The whole production process is as follows. The workpiece with the value $$$1$$$ is supplied to the first machine, then the workpiece obtained after the operation of the first machine is supplied to the second machine, then the workpiece obtained after the operation of the second machine is supplied to the third machine, and so on. The company is not doing very well, so now the value of the resulting product does not exceed $$$2 \cdot 10^9$$$.The directors of the company are not satisfied with the efficiency of the production process and have given you a budget of $$$b$$$ coins to optimize it.To optimize production you can change the order of machines in the chain. Namely, by spending $$$p$$$ coins, you can take any machine of kind $$$(+,~a_i)$$$ and move it to any place in the chain without changing the order of other machines. Also, by spending $$$m$$$ coins, you can take any machine of kind $$$(*,~a_i)$$$ and move it to any place in the chain.What is the maximum value of the resulting product that can be achieved if the total cost of movements that are made should not exceed $$$b$$$ coins?","from bisect import bisect

import sys
input = sys.stdin.readline

n, b, p, m = map(int, input().split())


adds = []
curr = []
mults = []

i = 0
for _ in range(n):
    t, v = input().split()
    v = int(v)
    
    if t == '*':
        if v == 1:
            continue
        curr.sort()

        adds.append(curr)
        mults.append(v)
        curr = []
    else:
        curr.append(v)
        
curr.sort()
adds.append(curr)

pref = []
for l in adds:  
    np = [0]
    for v in l[::-1]:
        np.append(v + np[-1])
    pref.append(np)

y = len(mults)
un_m = sorted(set(mults))
z = len(un_m)
ct_m = [0] * z
for v in mults:
    for i in range(z):
        if un_m[i] == v:
            ct_m[i] += 1

from itertools import product
poss = []

assert len(adds) == y + 1

for tup in product(*[range(ct + 1) for ct in ct_m]):
    rem_adds = (b - m * sum(tup))//p
    
    if rem_adds < 0:
        continue

    d = {}
    for i in range(z):
        d[un_m[i]] = tup[i]

    end = 1
    used = [0] * y

    for i in range(y):
        if d[mults[i]]:
            used[i] = 1
            d[mults[i]] -= 1
            end *= mults[i]

    seg_mult = [1]
    for i in range(y - 1, -1, -1):
        if used[i] == 0:
            seg_mult.append(seg_mult[-1] * mults[i])
        else:
            seg_mult.append(seg_mult[-1])
    seg_mult.reverse()

    exc = [seg_mult[0] - v for v in seg_mult]

    init_tot = 0
    for j in range(y + 1):
        if exc[j] != 0:
            init_tot += len(adds[j])

    lo = 0 #Ct value provided >= lo >= rem_adds
    hi = 10 ** 18 + 100 #Too high
    while hi - lo > 1:
        mid = lo + (hi - lo) // 2

        tot = init_tot
        for j in range(y + 1):
            if exc[j] == 0:
                continue
            
            limit = (mid - 1) // exc[j]

            #ct = len(adds[j]) - bisect(adds[j], limit - 1)
            #tot += ct

            diff = bisect(adds[j], limit)
            tot -= diff
            #print(mid, j, diff) 

        if tot >= rem_adds:
            lo = mid
        else:
            hi = mid

    tot = seg_mult[0]
    ct = 0
    for j in range(y + 1):
        tot += pref[j][-1] * seg_mult[j]

        if exc[j] == 0:
            continue
        
        limit = (lo - 1) // exc[j]

        s_ct = len(adds[j]) - bisect(adds[j], limit)

        tot += pref[j][s_ct] * exc[j]
        ct += s_ct

    if lo != 0:
        assert ct >= rem_adds
        tot -= lo * (ct - rem_adds)

    #print(tup, lo, tot, end)
    poss.append(tot * end)
    #break
    




print(max(poss))","['binary search', 'brute force', 'greedy']"
"There is a binary string $$$a$$$ of length $$$n$$$. In one operation, you can select any prefix of $$$a$$$ with an equal number of $$$0$$$ and $$$1$$$ symbols. Then all symbols in the prefix are inverted: each $$$0$$$ becomes $$$1$$$ and each $$$1$$$ becomes $$$0$$$.For example, suppose $$$a=0111010000$$$.   In the first operation, we can select the prefix of length $$$8$$$ since it has four $$$0$$$'s and four $$$1$$$'s: $$$[01110100]00\to [10001011]00$$$.  In the second operation, we can select the prefix of length $$$2$$$ since it has one $$$0$$$ and one $$$1$$$: $$$[10]00101100\to [01]00101100$$$.  It is illegal to select the prefix of length $$$4$$$ for the third operation, because it has three $$$0$$$'s and one $$$1$$$. Can you transform the string $$$a$$$ into the string $$$b$$$ using some finite number of operations (possibly, none)?","import math
import string


def main_function():
    test_cases = range(int(input()))
    answers = []

    for test_case in test_cases:
        n = int(input())
        equal_counter = 0
        s_1 = list(input())
        s_2 = list(input())
        for i in range(n):
            j = n - 1 - i
            if s_1[j] == s_2[j]:
                equal_counter += 1
            else:
                break
        counter_1 = 0
        counter_0 = 0
        is_equal_mode = False
        counter_for_completeness = False
        good_for = True
        for i in range(len(s_1)):
            if i == 0:
                if s_1[i] == s_2[i]:
                    is_equal_mode = True
                else:
                    is_equal_mode = False
                if s_1[i] == ""1"":
                    counter_1 += 1
                else:
                    counter_0 += 1
            else:
                if is_equal_mode:
                    if s_1[i] != s_2[i]:
                        good_for = False
                        break
                else:
                    if s_1[i] == s_2[i]:
                        good_for = False
                        break
                if s_1[i] == ""1"":
                    counter_1 += 1
                else:
                    counter_0 += 1
                if counter_1 == counter_0:
                    #print(i)
                    counter_for_completeness = True
                    if i + 1 < len(s_1):
                        if s_1[i + 1] == s_2[i + 1]:
                            is_equal_mode = True
                        else:
                            is_equal_mode = False
                    if i + equal_counter >= len(s_1) - 1:
                        # print(""break worked"")
                        break
                else:
                    counter_for_completeness = False
        # print(good_for)
        # print(equal_counter)
        # print(counter_for_completeness)
        if not counter_for_completeness:
            good_for = False
        # print(good_for)
        if equal_counter == len(s_1):
            good_for = True
        # print(equal_counter)
        # print(good_for)
        if good_for:
            print(""YES"")
        else:
            print(""NO"")


main_function()","['constructive algorithms', 'greedy', 'implementation', 'math']"
"A palindrome is a string that reads the same backward as forward. For example, the strings ""z"", ""aaa"", ""aba"", and ""abccba"" are palindromes, but ""codeforces"" and ""ab"" are not. You hate palindromes because they give you déjà vu.There is a string $$$s$$$. You must insert exactly one character 'a' somewhere in $$$s$$$. If it is possible to create a string that is not a palindrome, you should find one example. Otherwise, you should report that it is impossible.For example, suppose $$$s=$$$ ""cbabc"". By inserting an 'a', you can create ""acbabc"", ""cababc"", ""cbaabc"", ""cbabac"", or ""cbabca"". However ""cbaabc"" is a palindrome, so you must output one of the other options.","n = int(input())
while n > 0:
    s = input()
    if ""a"" + s != s[::-1] + ""a"":
        print(""YES"")
        print(""a"" + s)
    elif s + ""a"" != ""a"" + s[::-1]:
        print(""YES"")
        print(s + ""a"")

    else:
        print(""NO"")
    n -= 1","['constructive algorithms', 'strings']"
"You are given an array $$$a[0 \dots n-1]$$$ of $$$n$$$ integers. This array is called a ""valley"" if there exists exactly one subarray $$$a[l \dots r]$$$ such that:  $$$0 \le l \le r \le n-1$$$,  $$$a_l = a_{l+1} = a_{l+2} = \dots = a_r$$$,  $$$l = 0$$$ or $$$a_{l-1} &gt; a_{l}$$$,  $$$r = n-1$$$ or $$$a_r &lt; a_{r+1}$$$. Here are three examples:  The first image shows the array [$$$3, 2, 2, 1, 2, 2, 3$$$], it is a valley because only subarray with indices $$$l=r=3$$$ satisfies the condition.The second image shows the array [$$$1, 1, 1, 2, 3, 3, 4, 5, 6, 6, 6$$$], it is a valley because only subarray with indices $$$l=0, r=2$$$ satisfies the codition.The third image shows the array [$$$1, 2, 3, 4, 3, 2, 1$$$], it is not a valley because two subarrays $$$l=r=0$$$ and $$$l=r=6$$$ that satisfy the condition.You are asked whether the given array is a valley or not.Note that we consider the array to be indexed from $$$0$$$.","from itertools import groupby
t = int(input())
def removeconsdup(arr):
    idx = 1
    while idx < len(arr):
        if arr[idx] == arr[idx-1]:
            arr.pop(idx)
            idx -= 1
        idx += 1
    return arr
for i in range(0,t):
    n = int(input())
    a = [int(i) for i in input().split()]
    b = [i[0] for i in groupby(a)] #removes consecutive duplicates boolean = ""Yes""
    count = 0
    if len(b) != 1:
        for i in range(0,len(b)):
            if i != 0 and i != len(b)-1:
                if b[i+1] > b[i] and b[i-1] > b[i]:
                    count += 1
            elif i == 0:
                if b[1] > b[i]:
                    count += 1
            elif i == len(b)-1:
                if b[i-1] > b[i]:
                    count += 1
    if count == 1 or len(b) == 1:
        boolean = ""Yes""
    else:
        boolean = ""No""
    print(boolean)","['implementation', 'two pointers']"
"You are wandering in the explorer space of the 2050 Conference.The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.","def roll(i,j):
    ways = []
    if j:
        ways.append( 2 * horizontal[i][j-1] + grid[i][j-1])
    if m-1-j:
        ways.append(2 * horizontal[i][j] + grid[i][j+1])
    if i:
        ways.append(2 * vertical[i-1][j] + grid[i-1][j])
    if n-1-i:
        ways.append(2 * vertical[i][j] + grid[i+1][j])
    return min(ways)
 
n , m , k = map(int, input().split())

horizontal = [list(map(int, input().split())) for _ in range(n)]
vertical = [list(map(int, input().split())) for _ in range(n-1)]
 
 
grid = [[0]*m for _ in range(n)]
if k%2:
    for _ in range(n):
        print("" "".join([""-1""]*m))
else:
    for _ in range(k//2):
        new_grid = [[roll(i,j) for j in range(m)] for i in range(n)]
        grid = new_grid[:]
    for i in range(n):
        print("" "".join(map(str,grid[i])))","['dp', 'graphs', 'shortest paths']"
"At the foot of Liyushan Mountain, $$$n$$$ tents will be carefully arranged to provide accommodation for those who are willing to experience the joy of approaching nature, the tranquility of the night, and the bright starry sky.The $$$i$$$-th tent is located at the point of $$$(x_i, y_i)$$$ and has a weight of $$$w_i$$$. A tent is important if and only if both $$$x_i$$$ and $$$y_i$$$ are even. You need to remove some tents such that for each remaining important tent $$$(x, y)$$$, there do not exist $$$3$$$ other tents $$$(x'_1, y'_1)$$$, $$$(x'_2, y'_2)$$$ and $$$(x'_3, y'_3)$$$ such that both conditions are true:   $$$|x'_j-x|, |y'_j - y|\leq 1$$$ for all $$$j \in \{1, 2, 3\}$$$, and  these four tents form a parallelogram (or a rectangle) and one of its sides is parallel to the $$$x$$$-axis. Please maximize the sum of the weights of the tents that are not removed. Print the maximum value.","import sys,io,os
try:Z=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
except:Z=lambda:sys.stdin.readline().encode()
Y=lambda:map(int,Z().split())
INF=float(""inf"");big=10**13
class D:
    def __init__(self, n):
        self.lvl = [0] * n
        self.ptr = [0] * n
        self.q = [0] * n
        self.adj = [[] for _ in range(n)]
    def add(self, a, b, c, rcap=0):
        self.adj[a].append([b, len(self.adj[b]), c, 0])
        self.adj[b].append([a, len(self.adj[a]) - 1, rcap, 0])
    def dfs(self, v, t, f):
        if v == t or not f:
            return f
        for i in range(self.ptr[v], len(self.adj[v])):
            e = self.adj[v][i]
            if self.lvl[e[0]] == self.lvl[v] + 1:
                p = self.dfs(e[0], t, min(f, e[2] - e[3]))
                if p:
                    self.adj[v][i][3] += p
                    self.adj[e[0]][e[1]][3] -= p
                    return p
            self.ptr[v] += 1
        return 0
    def calc(self, s, t):
        flow, self.q[0] = 0, s
        for l in range(31):
            while True:
                self.lvl, self.ptr = [0] * len(self.q), [0] * len(self.q)
                qi, qe, self.lvl[s] = 0, 1, 1
                while qi < qe and not self.lvl[t]:
                    v = self.q[qi]
                    qi += 1
                    for e in self.adj[v]:
                        if not self.lvl[e[0]] and (e[2] - e[3]) >> (30 - l):
                            self.q[qe] = e[0]
                            qe += 1
                            self.lvl[e[0]] = self.lvl[v] + 1
                p = self.dfs(s, t, INF)
                while p:
                    flow += p
                    p = self.dfs(s, t, INF)
                if not self.lvl[t]:
                    break
        return flow
r=lambda x,y:(y&1)*2+1-((x+y)&1)
n=int(Z());p={};d=D(2*n+2);w=[0]*n
for i in range(n):x,y,z=Y();w[i]=z;p[(x,y)]=i
for x,y in p:
    i=p[(x,y)];v=r(x,y);d.add(i,i+n,w[i])
    if v<1:
        d.add(2*n,i,big)
        if(x+1,y)in p:d.add(i+n,p[(x+1,y)],big)
        if(x-1,y)in p:d.add(i+n,p[(x-1,y)],big)
    elif v<2:
        if(x,y+1)in p:d.add(i+n,p[(x,y+1)],big)
        if(x,y-1)in p:d.add(i+n,p[(x,y-1)],big)
    elif v<3:
        if(x+1,y)in p:d.add(i+n,p[(x+1,y)],big)
        if(x-1,y)in p:d.add(i+n,p[(x-1,y)],big)
    else:d.add(i+n,2*n+1,big)
print(sum(w)-d.calc(2*n,2*n+1))","['constructive algorithms', 'flows', 'graphs']"
"You are given a simple undirected graph with $$$n$$$ vertices and $$$m$$$ edges. Edge $$$i$$$ is colored in the color $$$c_i$$$, which is either $$$1$$$, $$$2$$$, or $$$3$$$, or left uncolored (in this case, $$$c_i = -1$$$).You need to color all of the uncolored edges in such a way that for any three pairwise adjacent vertices $$$1 \leq a &lt; b &lt; c \leq n$$$, the colors of the edges $$$a \leftrightarrow b$$$, $$$b \leftrightarrow c$$$, and $$$a \leftrightarrow c$$$ are either pairwise different, or all equal. In case no such coloring exists, you need to determine that.","from itertools import combinations
from collections import defaultdict
import io, os, sys
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline




def F1(A, B, C, D):
    AD = A ^ D
    return (AD ^ B) | (A ^ C), AD & (B ^ C)

def F2(A, B, C, D):
    AC = A ^ C
    return AC | (B ^ D), (AC ^ D) & (B ^ C)

def flip_bit(a, i):
    a[i // l] ^= (1 << (i % l))

def Gauss(a, b, n, m):
    if n == 0: return 2, [0] * m
    where = [-1] * m
    row, col = 0, 0

    while col < m and row < n:
        t1, t2 = divmod(col, l)
        for i in range(row, n):
            if a[i][t1] >> t2 & 1 or b[i][t1] >> t2 & 1:
                a[i], a[row] = a[row], a[i]
                b[i], b[row] = b[row], b[i]
                break

        if not a[row][t1] >> t2 & 1 and not b[row][t1] >> t2 & 1:
            col += 1
            continue
        where[col] = row

        for i in range(n):
            if i == row: continue
            x1, x2 = a[i][t1] >> t2 & 1, b[i][t1] >> t2 & 1
            y1, y2 = a[row][t1] >> t2 & 1, b[row][t1] >> t2 & 1
            cc = ((x1 + x2) * (y1 + y2)) % 3
            if cc == 0: continue
            F = F1 if cc == 2 else F2
            for k in range(t1, U): a[i][k], b[i][k] = F(a[i][k], b[i][k], a[row][k], b[row][k])

        col, row = col + 1, row + 1

    ans = [0] * m
    t1, t2 = divmod(m, l)
    for i in range(m):
        W = where[i]
        if W != -1:
            t3, t4 = divmod(i, l)
            x1, x2 = a[W][t1] >> t2 & 1, b[W][t1] >> t2 & 1
            y1, y2 = a[W][t3] >> t4 & 1, b[W][t3] >> t4 & 1
            ans[i] = ((x1 + x2) * (y1 + y2)) % 3

    for i in range(n):
        sm = 0
        for j in range(m):
            t3, t4 = divmod(j, l)
            sm += ((a[i][t3] >> t4 & 1) + (b[i][t3] >> t4 & 1)) * ans[j]

        if (sm - (a[i][t1] >> t2 & 1) - (b[i][t1] >> t2 & 1)) % 3 != 0: return 0, [-1] * m

    if -1 in where: return 2, ans
    return 1, ans


T = int(input())
for _ in range(T):
    n, m = [int(i) for i in input().split()]
    l, U = 63, m//63 + 1

    G = defaultdict(list)
    edges_back = {}
    colors = [0] * m
    for k in range(m):
        a, b, c = [int(i) for i in input().split()]
        G[a] += [(b, c)]
        G[b] += [(a, c)]
        edges_back[(a, b)] = (k, c)
        edges_back[(b, a)] = (k, c)
        colors[k] = c

    ans = set()
    for n1 in range(1, n + 1):
        neibs = G[n1]
        for (n2, c12), (n3, c13) in combinations(neibs, 2):
            if (n2, n3) in edges_back:
                row = [[0] * U, [0] * U]
                k12, _ = edges_back[(n1, n2)]
                k13, _ = edges_back[(n1, n3)]
                k23, c23 = edges_back[(n2, n3)]
                last = 0
                for k, c in (k12, c12), (k13, c13), (k23, c23):
                    if c != -1:
                        last -= c
                    else:
                        flip_bit(row[0], k)
                last %= 3
                if last == 1:
                    flip_bit(row[0], m)
                elif last == 2:
                    flip_bit(row[0], m)
                    flip_bit(row[1], m)

                ans.add(tuple(tuple(x) for x in row))

    mat1, mat2 = [], []
    for x, y in ans:
        mat1 += [list(x)]
        mat2 += [list(y)]

    ans = Gauss(mat1, mat2, len(mat1), m)

    if ans[0] == 0:
        out = [-1]
    else:
        out = []
        for i in range(m):
            if colors[i] != -1:
                out += [colors[i]]
            elif ans[1][i] == 0:
                out += [3]
            else:
                out += [ans[1][i]]

    print("" "".join(str(x) for x in out))","['brute force', 'graphs', 'math', 'matrices']"
"You are given two integers $$$n$$$ and $$$m$$$ and an array $$$a$$$ of $$$n$$$ integers. For each $$$1 \le i \le n$$$ it holds that $$$1 \le a_i \le m$$$.Your task is to count the number of different arrays $$$b$$$ of length $$$n$$$ such that:   $$$1 \le b_i \le m$$$ for each $$$1 \le i \le n$$$, and  $$$\gcd(b_1,b_2,b_3,...,b_i) = a_i$$$ for each $$$1 \le i \le n$$$. Here $$$\gcd(a_1,a_2,\dots,a_i)$$$ denotes the greatest common divisor (GCD) of integers $$$a_1,a_2,\ldots,a_i$$$.Since this number can be too large, print it modulo $$$998\,244\,353$$$.","#from pyrival import *
import math
import sys
import heapq

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

mod = 998244353

# Count the number of numbers
# up to m which are divisible
# by given prime numbers
def count(a, n, m):
    #print(a)
    #print(n, m)
    total = 0

    # Run from i = 000..0 to i = 111..1
    # or check all possible
    # subsets of the array
    for i in range(0, 1 << n):
        mult = 1
        for j in range(n):
            if (i & (1 << j)):
                mult *= a[j]

        # Take the multiplication
        # of all the set bits

        # If the number of set bits
        # is odd, then add to the
        # number of multiples
        total += (-1)**(bin(i).count('1') & 1) * (m // mult)
        #print(f'subtracting out {m // mult}')

    return total

def countRelPrime(n, m):
    #print(f'counting rel {n} {m}')

    facts = []
    for div in range(2, math.ceil(n**0.5) + 2):

        if n % div == 0:
            facts += [div]

        while n % div == 0:
            n //= div

    if n != 1:
        facts += [n]
    return count(facts, len(facts), m)

t = int(input())

for _ in range(t):
    cache = {}
    N, M = map(int, input().split())
    A = list(map(int, input().split()))
    
    ways = 1
    for pos in range(1, N):
        big, small = A[pos - 1 : pos + 1]
        if (big, small) not in cache:
            if math.gcd(big, small) < small:
                ways = 0
                break
            cache[(big, small)] = countRelPrime(big//small, M//small)

        new_ways = cache[(big, small)]
        #print(f'found {new_ways}')
        ways = (ways * new_ways) % mod
    print(f'{ways}')","['combinatorics', 'math', 'number theory']"
"A binary string is a string consisting only of the characters 0 and 1. You are given a binary string $$$s$$$.For some non-empty substring$$$^\dagger$$$ $$$t$$$ of string $$$s$$$ containing $$$x$$$ characters 0 and $$$y$$$ characters 1, define its cost as:  $$$x \cdot y$$$, if $$$x &gt; 0$$$ and $$$y &gt; 0$$$;  $$$x^2$$$, if $$$x &gt; 0$$$ and $$$y = 0$$$;  $$$y^2$$$, if $$$x = 0$$$ and $$$y &gt; 0$$$. Given a binary string $$$s$$$ of length $$$n$$$, find the maximum cost across all its non-empty substrings.$$$^\dagger$$$ A string $$$a$$$ is a substring of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.","for i in range(int(input())):
    n=int(input())
    s=input()
    ans=max(s.count('1')*s.count('0'),1)
    st=1
    s=s.strip()
    for j in range(1,n):
        if s[j]==s[j-1]:
            st+=1
        else:
            st=1
        ans=max(ans,st*st)
    print(ans)","['brute force', 'greedy', 'implementation']"
"We call an array $$$a$$$ of length $$$n$$$ fancy if for each $$$1 &lt; i \le n$$$ it holds that $$$a_i = a_{i-1} + 1$$$.Let's call $$$f(p)$$$ applied to a permutation$$$^\dagger$$$ of length $$$n$$$ as the minimum number of subarrays it can be partitioned such that each one of them is fancy. For example $$$f([1,2,3]) = 1$$$, while $$$f([3,1,2]) = 2$$$ and $$$f([3,2,1]) = 3$$$.Given $$$n$$$ and a permutation $$$p$$$ of length $$$n$$$, we define a permutation $$$p'$$$ of length $$$n$$$ to be $$$k$$$-special if and only if:  $$$p'$$$ is lexicographically smaller$$$^\ddagger$$$ than $$$p$$$, and  $$$f(p') = k$$$. Your task is to count for each $$$1 \le k \le n$$$ the number of $$$k$$$-special permutations modulo $$$m$$$.$$$^\dagger$$$ A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).$$$^\ddagger$$$ A permutation $$$a$$$ of length $$$n$$$ is lexicographically smaller than a permutation $$$b$$$ of length $$$n$$$ if and only if the following holds: in the first position where $$$a$$$ and $$$b$$$ differ, the permutation $$$a$$$ has a smaller element than the corresponding element in $$$b$$$.","n, m = map(int, input().split())

def modmul(a, b, c = 0):
    return (a * b + c) % m


comb = [[1]]
for i in range(2010):
    prev = comb[-1]
    nex = [1]
    for i in range(i):
        nex.append((prev[i] + prev[i + 1]) % m)
    nex.append(1)
    comb.append(nex)

fact = [1]
for i in range(1, 3000):
    fact.append((i * fact[i - 1]) % m)

p = list(map(lambda x: int(x) - 1, input().split()))
rem = [1] * n
pairs = n - 1

base = 0

out = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
    diff = [0] * 3
    spec = [0] * 3

    for j in range(p[i]):
        d = 0

        if rem[j] == 0:
            continue
        
        if j and rem[j - 1]:
            d += 1

        #if j < n - 1 and rem[j + 1]:
        #    d += 1

        if i and j == p[i - 1] + 1:
            spec[d] += 1
        else:
            diff[d] += 1

    for d in range(3):
        pp = pairs - d
        if pp < 0:
            continue
        if diff[d] == 0 and spec[d] == 0:
            continue

        remain = n - i - 1

        for sq in range(pp + 1):
            ways = comb[pp][sq]
            order = remain - sq
            assert order >= 0

            ct = modmul(ways, fact[order])
            
            out[base][sq] += modmul(ct, diff[d] + spec[d])
            if spec[d]:
                out[base][sq + 1] += ct

    j = p[i]
    rem[j] = 0
    if j and rem[j - 1]:
        pairs -= 1
    if j < n - 1 and rem[j + 1]:
        pairs -= 1

    if i and p[i] == p[i - 1] + 1:
        base += 1

while len(out) > 1:
    prev = out.pop()
    for i in range(n):
        out[-1][i] += prev[i]
        if i > 0:
            out[-1][i] += prev[i - 1]

out = out[0]

res = []
for i in range(n):
    basee = out[n - 1 - i]
    for j in range(i):
        basee -= modmul(res[j], comb[n - j - 1][n - i - 1])
        #print(i, j, basee)
    res.append(basee % m)
print(' '.join(map(str, res)))","['combinatorics', 'dp', 'math']"
"There is a $$$n \times m$$$ grid. You are standing at cell $$$(1, 1)$$$ and your goal is to finish at cell $$$(n, m)$$$.You can move to the neighboring cells to the right or down. In other words, suppose you are standing at cell $$$(x, y)$$$. You can:   move right to the cell $$$(x, y + 1)$$$ — it costs $$$x$$$ burles;  move down to the cell $$$(x + 1, y)$$$ — it costs $$$y$$$ burles. Can you reach cell $$$(n, m)$$$ spending exactly $$$k$$$ burles?","a = int(input())
for i in range(a):
    n,m,k= map(int,input().split())
    count = 0
    MT= [[0 for i in range(n)]for i in range(m)]
    for r in range(m):
        for c in range(n):
            MT[r][c] = (r*c)+r+c
    count = MT[-1][-1]
    if count == k:
        print(""YES"")
    else:
        print(""NO"")","['dp', 'math']"
"We are sum for we are manySome NumberThis version of the problem differs from the next one only in the constraint on $$$t$$$. You can make hacks only if both versions of the problem are solved.You are given two positive integers $$$l$$$ and $$$r$$$.Count the number of distinct triplets of integers $$$(i, j, k)$$$ such that $$$l \le i &lt; j &lt; k \le r$$$ and $$$\operatorname{lcm}(i,j,k) \ge i + j + k$$$.Here $$$\operatorname{lcm}(i, j, k)$$$ denotes the least common multiple (LCM) of integers $$$i$$$, $$$j$$$, and $$$k$$$.","import sys
input = sys.stdin.buffer.readline

# from collections import defaultdict, deque, Counter
from math import gcd, lcm
from functools import reduce
# from itertools import accumulate, chain, islice, starmap
# from operator import add, sub, mul, floordiv, truediv


# def f(L,R,tup):

def lcm3(tup):
	a,b,c = tup
	if c%b or c%a:
		return 2*c
	else:
		return c


def tup_gen(hi=2*10**5,a=1,b=1):
	# if a * b <= hi:
	yield (a,b)
	# k = 1
	# while a*k+b <= hi//a:
	for k in range(1, (hi//a-b)//a+1):
		for i in tup_gen(hi, a*k+b, a):
			yield i
		# k+=1

# s = set(tuple(sorted((b,a,a*b))) for (a,b) in tup_gen())
# s.add((3,4,6))
# s.add((6,10,15))

ma = 0


for _ in range(int(input())):
	L, R = map(int,input().split())

	tot = (R-L+1)*(R-L)*(R-L-1) // 6
	# ans = tot
	tmp = 0
	
	# s = set()
	if R > ma:
		ma = R
	# s = set(tuple(sorted((b,a,a*b))) for (a,b) in tup_gen(R))
	# l = list(tuple(sorted((b,a,a*b))) for (a,b) in tup_gen(R))
		l = list(tup_gen(R))
	# s.add((3,4,6))
	# s.add((6,10,15))

	# for a, b in tup_gen(R, L, 1,1):
	# 	# cands = [(b,a,a*b),(2*b,a,a*b),(b,2*a,a*b),(2*b,2*a,a*b),(b,a,a*b*2),(2*b,a,a*b*2),(b,2*a,a*b*2),(2*b,2*a,a*b*2)]
	# 	cands = [(b,a,a*b),(2*b,a,a*b),(b,2*a,a*b),(2*b,2*a,a*b)]
	# 	for cand in cands:
	# 		if not all(x%2==0 for x in cand):
	# 			# assert reduce(gcd,cand) < 2
	# 			s.add(tuple(sorted(cand)))




	# s2 = set()

	l2 = list()

	# for tup in s:
	# 	a,b,c=tup
	# 	c2 = 0
	# 	for n in range(1,R//c+1):
	# 		c2 += c
	# 		if a<b<c2:
	# 			tup2=(a,b,c2)
	# 			if lcm3(tup2) < sum(tup2) and not all(x%2==0 for x in tup2):# and tup2 not in s:
	# 				# if tup2 in s:
	# 				# 	print(""?????"",tup2,n)
	# 				# assert reduce(gcd,tup2) < 2
	# 				s2.add(tup2)
	# 				# l2.append(tup2)
	# 			elif n > 1:
	# 				break
	# 	# s2.add(tup)

	# for tup in l:
	# for b,a in tup_gen(R):
	for b,a in l:
		# a,b,c=tup
		# a,b=min(a,b),max(a,b)
		c = a*b
		tup = (a,b,c)
		su=a+b+c
		if a<b<c:
			if lcm3(tup) < su:
					# assert reduce(gcd,tup) < 2
					# s2.add(tup)
					# l2.append(tup)
					lo,hi=(L+a-1)//a, R//c
					if lo <= hi:
						tmp += hi-lo+1
			# else:
			# 	break
		
		if a<b<=c:
			for n in range(2,R//c+1):
				su+=c
				tup2=(a,b,c*n)
				if lcm3(tup2) < su:# and not all(x%2==0 for x in tup2):# and tup2 not in s:
					# if tup2 in s:
					# 	print(""?????"",tup2,n)
					# assert reduce(gcd,tup2) < 2
					# s2.add(tup2)
					# l2.append(tup2)
					lo,hi=(L+a-1)//a, R//(c*n)
					if lo <= hi:
						tmp += hi-lo+1
				else:
					break
			# s2.add(tup)

	# s2.add((3,4,6))
	# s2.add((6,10,15))

	l2.append((3,4,6))
	l2.append((6,10,15))

	
	for tup in l2:
		a,b,c=tup
		# if a<b<c:
			# s4 = set()
		lo,hi=(L+a-1)//a, R//c
		if lo <= hi:
			tmp += hi-lo+1
			# for d in range((L+a-1)//a, R//c+1):
			# 	tup2 = (d*a,d*b,d*c)
			# 	if tup2 in s3:
			# 		print(tup2,""?????"")
			# 	s3.add(tup2)
			# 	s4.add(tup2)
			# assert tmp == len(s3), (L,R,lo,hi,tup, s3,s4)


		# s32= set(list(s3))









	# for tup in s3:
	# 	a,b,c=tup
	# 	if L<=a<b<c<=R:# and lcm3(tup) < sum(tup):
	# 		# s4.add(tup)
	# 		ans -= 1

	# print(tot - len(s3))
	print(tot-tmp)","['binary search', 'brute force', 'combinatorics', 'math', 'number theory', 'two pointers']"
"The Winter holiday will be here soon. Mr. Chanek wants to decorate his house's wall with ornaments. The wall can be represented as a binary string $$$a$$$ of length $$$n$$$. His favorite nephew has another binary string $$$b$$$ of length $$$m$$$ ($$$m \leq n$$$).Mr. Chanek's nephew loves the non-negative integer $$$k$$$. His nephew wants exactly $$$k$$$ occurrences of $$$b$$$ as substrings in $$$a$$$. However, Mr. Chanek does not know the value of $$$k$$$. So, for each $$$k$$$ ($$$0 \leq k \leq n - m + 1$$$), find the minimum number of elements in $$$a$$$ that have to be changed such that there are exactly $$$k$$$ occurrences of $$$b$$$ in $$$a$$$.A string $$$s$$$ occurs exactly $$$k$$$ times in $$$t$$$ if there are exactly $$$k$$$ different pairs $$$(p,q)$$$ such that we can obtain $$$s$$$ by deleting $$$p$$$ characters from the beginning and $$$q$$$ characters from the end of $$$t$$$.","def main():
    
    n, m = readIntArr()
    a = input()
    b = input()
    
    maxCnt = n - m + 1
    depthTxn = [[-1, -1] for _ in range(m + 1)] # depthTxn[currentDepth][0 or 1] = new maximum depth
    def getMaxDepth(c):
        # c : xxxxx
        # b :   yyyyy
        # depth <->
        for depth in range(m, -1, -1):
            if len(c) < depth: continue
            if depth == 0:
                c2 = ''
            else:
                c2 = c[-depth:]
            b2 = b[:depth]
            # print('c:{} depth:{} c2:{} b2:{}'.format(c, depth,c2,b2))
            if c2 == b2:
                return depth
    for currDepth in range(m + 1):
        c = b[:currDepth]
        for i in range(2):
            c2 = c + str(i)
            # print('currDepth:{} c2:{}'.format(currDepth, c2))
            depthTxn[currDepth][i] = getMaxDepth(c2)
    
    # print(depthTxn)
    
    dp = [[[505 for _ in range(maxCnt + 1)] for __ in range(m + 1)] for ___ in range(n)]
    # dp[i][depth][cnts]
    for i in range(n):
        for prevDepth in range(m + 1):
            if prevDepth > i:
                continue
            for c in range(2):
                add = 0
                if str(c) != a[i]: add = 1
                currDepth = depthTxn[prevDepth][c]
                for cnts in range(maxCnt):
                    if i - 1 >= 0:
                        prevVal = dp[i-1][prevDepth][cnts]
                    else:
                        if cnts == 0:
                            prevVal = 0
                        else:
                            prevVal = 505
                    if prevDepth == m:
                        dp[i][currDepth][cnts+1] = min(dp[i][currDepth][cnts+1],
                                                                    prevVal + add)
                    else:
                        dp[i][currDepth][cnts] = min(dp[i][currDepth][cnts],
                                                                  prevVal + add)
    ans = [505]* (maxCnt + 1)
    for cnts in range(maxCnt + 1):
        for depth in range(m):
            ans[cnts] = min(ans[cnts], dp[n-1][depth][cnts])
        if cnts >= 1:
            ans[cnts] = min(ans[cnts], dp[n-1][m][cnts-1])
    for i in range(maxCnt + 1):
        if ans[i] == 505:
            ans[i] = -1
    oneLineArrayPrint(ans)
    
    # print(dp)
    
    return


import sys
# input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)
input=lambda: sys.stdin.readline().rstrip(""\r\n"") #FOR READING STRING/TEXT INPUTS.

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))
 
def readIntArr():
    return [int(x) for x in input().split()]
# def readFloatArr():
#     return [float(x) for x in input().split()]
 
def makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])
    dv=defaultValFactory;da=dimensionArr
    if len(da)==1:return [dv() for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]
 
def queryInteractive(i,j):
    print('? {} {}'.format(i,j))
    sys.stdout.flush()
    return int(input())
 
def answerInteractive(i,j,k):
    print('! {} {} {}'.format(i,j,k))
    sys.stdout.flush()
 
inf=float('inf')
# MOD=10**9+7
# MOD=998244353

from math import gcd,floor,ceil
import math
# from math import floor,ceil # for Python2
 
for _abc in range(1):
    main()","['dp', 'strings']"
"Andi and Budi were given an assignment to tidy up their bookshelf of $$$n$$$ books. Each book is represented by the book title — a string $$$s_i$$$ numbered from $$$1$$$ to $$$n$$$, each with length $$$m$$$. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.A string $$$a$$$ occurs before a string $$$b$$$ in asc-desc-ending order if and only if in the first position where $$$a$$$ and $$$b$$$ differ, the following holds:  if it is an odd position, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$;  if it is an even position, the string $$$a$$$ has a letter that appears later in the alphabet than the corresponding letter in $$$b$$$.","import functools
import sys
input = lambda: sys.stdin.readline().rstrip()
    
def compare(a, b):
    for i in range(m):
        if a[0][i] != b[0][i]:
            if i % 2 == 0:
                if a[0][i] < b[0][i]:
                    return -1
                else:
                    return 1
            else:
                if a[0][i] > b[0][i]:
                    return -1
                else:
                    return 1

n, m = map(int, input().split())
 
li = []
for i in range(n):
    s = input()
    
    li.append((s, i))
    
li.sort(key=functools.cmp_to_key(compare))
r = [v[1] + 1 for v in li]
 
print(*r)","['data structures', 'sortings', 'strings']"
"Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.The map of the labyrinth forms a tree with $$$n$$$ rooms numbered from $$$1$$$ to $$$n$$$ and $$$n - 1$$$ tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.The $$$i$$$-th room ($$$1 \leq i \leq n$$$) has $$$a_i$$$ illusion rate. To go from the $$$x$$$-th room to the $$$y$$$-th room, there must exist a tunnel between $$$x$$$ and $$$y$$$, and it takes $$$\max(|a_x + a_y|, |a_x - a_y|)$$$ energy. $$$|z|$$$ denotes the absolute value of $$$z$$$.To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask $$$q$$$ queries.There are two types of queries to be done:  $$$1\ u\ c$$$ — The illusion rate of the $$$x$$$-th room is changed to $$$c$$$ ($$$1 \leq u \leq n$$$, $$$0 \leq |c| \leq 10^9$$$).  $$$2\ u\ v$$$ — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room $$$v$$$ if they are initially at room $$$u$$$ ($$$1 \leq u, v \leq n$$$). Help them, so you can get a portion of the treasure!","def naiveSolve():
    
    
    
    return



def solve():
    
    
    
    return

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

class SegmentTree():
    def __init__(self,arr,combinerFunction,isCommutative=True): # isCommutative means f(a,b)==f(b,a)
        self.n=len(arr)
        def cmb(a,b):
            if a==None: return b
            if b==None: return a
            return combinerFunction(a,b)
        self.cmb=cmb
        self.sz=self.n if isCommutative else pow(2,((self.n-1).bit_length())) # non-commutative needs power of 2 size
        self.t=[None]*(2*self.sz) # use None as initial value
        for i in range(self.n): self.t[i+self.sz]=arr[i]
        for i in range(self.sz-1,0,-1): self.pull(i)
    def pull(self,p):
        self.t[p]=self.cmb(self.t[2*p],self.t[2*p+1])
    def update(self,idx,val): # set val at idx
        idx+=self.sz
        self.t[idx]=val
        idx//=2
        while idx>0:
            self.pull(idx)
            idx//=2
    def query(self,l,r): # aggregated value in [l,r] inclusive
        l+=self.sz; r+=self.sz+1
        a=b=None
        while l<r:
            if l%2==1: a=self.cmb(a,self.t[l]); l+=1
            if r%2==1: r-=1; b=self.cmb(self.t[r],b)
            l//=2; r//=2
        return self.cmb(a,b)
def getMaxSegTree(arr):
    return SegmentTree(arr,lambda a,b:max(a,b),True)
def getMinSegTree(arr):
    return SegmentTree(arr,lambda a,b:min(a,b),True)
def getSumSegTree(arr):
    return SegmentTree(arr,lambda a,b:a+b,True)

def main():
    
    n,q=readIntArr()
    a=readIntArr()
    for i in range(n):
        a[i]=abs(a[i])
    
    adj=[[] for _ in range(n)]
    for _ in range(n-1):
        u,v=readIntArr(); u-=1; v-=1
        adj[u].append(v)
        adj[v].append(u)
    
    # Using the fact that max(abs(x+y),abs(x-y))=abs(x)+abs(y),
    # and using an Euler tour to ""flatten"" the tree to allow for querying.
    # Store an array of size 2*n. Save the entry and exit indexes in the
    # euler tour array. When entering, store abs(a) in euler tour array.
    # When exiting, store -abs(a).
    # To update, change the entry and exit indexes of euler tour array.
    # To get distance from root, query from 0 to the entry index.
    # Use LCA to find common ancestor, and subtract the dist from node to
    # common ancestor.
    
    root=0 ## To modify accordingly
    @bootstrap
    def eulerTour(node,p): # O(n)
        up[node][0]=p
        tin[node]=time[0]
        eulerTourArr[time[0]]=2*a[node] # add cost
        time[0]+=1
        for v in adj[node]: # adj[u]=[v1,v2,v3,...]
            if v!=p:
                yield eulerTour(v,node)
        tout[node]=time[0]
        eulerTourArr[time[0]]=-2*a[node] # subtract cost for prefix sum to give cost from root to node
        time[0]+=1
        yield None
    time=[0]
    tin=[-1]*(n) # this is also the node entry index in eulerTourArr
    tout=[-1]*(n) # this is also the node exit index in eulerTourArr
    maxPow=0
    while pow(2,maxPow)<n:
        maxPow+=1
    maxPow+=1
    up=[[-1 for _ in range(maxPow)] for __ in range(n+1)]
    
    eulerTourArr=[0]*(2*n) # stores the energy sum for 2 * node
    
    
    eulerTour(root,-1)
    for i in range(1,maxPow): # Build up in O(nlogn)
        for u in range(1,n+1):
            if up[u][i-1]==-1 or up[up[u][i-1]][i-1]==-1: # reached beyond root
                continue
            up[u][i]=up[up[u][i-1]][i-1]
    
    def isAncestor(u,v): # True if u is ancestor of v
        return tin[u]<=tin[v] and tout[u]>=tout[v]
    
    def findLCA(u,v): # Find LCA in O(logn)
        # traverse u to LCA
        if not isAncestor(u,v):
            u2=u
            for i in range(maxPow-1,-1,-1):
                if up[u2][i]!=-1 and not isAncestor(up[u2][i],v):
                    u2=up[u2][i]
            # next level up is lca
            lca=up[u2][0]
        else:
            lca=u
        return lca
    
    st=getSumSegTree(eulerTourArr)
    allans=[]
    # print(tin)
    # print(tout)
    for _ in range(q):
        x,u,v=readIntArr(); u-=1
        if x==1: # update u to c
            c=abs(v)
            st.update(tin[u],2*c)
            st.update(tout[u],-2*c)
            a[u]=c
        else: # query u to v
            v-=1
            # print(eulerTourArr)
            rootToU=st.query(0,tin[u])-a[root]-a[u]
            rootToV=st.query(0,tin[v])-a[root]-a[v]
            lca=findLCA(u,v)
            rootToLCA=st.query(0,tin[lca])-a[root]-a[lca]
            ans=rootToU+rootToV-2*rootToLCA
            allans.append(ans)
            # print('u:{} v:{} rootToU:{} roottoV:{} lca:{}'.format(
                # u+1,v+1,rootToU,rootToV,lca+1))
            
    multiLineArrayPrint(allans)
    
    return


import sys
input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)
# input=lambda: sys.stdin.readline().rstrip(""\r\n"") #FOR READING STRING/TEXT INPUTS.

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))
 
def readIntArr():
    return [int(x) for x in input().split()]
# def readFloatArr():
#     return [float(x) for x in input().split()]
 
def makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])
    dv=defaultValFactory;da=dimensionArr
    if len(da)==1:return [dv() for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]
 
def queryInteractive(x):
    print('{}'.format(x))
    sys.stdout.flush()
    return int(input())
 
def answerInteractive(ans):
    print('! {}'.format(ans))
    sys.stdout.flush()
 
inf=float('inf')
# MOD=10**9+7
# MOD=998244353

from math import gcd,floor,ceil
# from math import floor,ceil # for Python2
 
for _abc in range(1):
    main()","['data structures', 'trees']"
"There are $$$n$$$ pieces of cake on a line. The $$$i$$$-th piece of cake has weight $$$a_i$$$ ($$$1 \leq i \leq n$$$).The tastiness of the cake is the maximum total weight of two adjacent pieces of cake (i. e., $$$\max(a_1+a_2,\, a_2+a_3,\, \ldots,\, a_{n-1} + a_{n})$$$).You want to maximize the tastiness of the cake. You are allowed to do the following operation at most once (doing more operations would ruin the cake):   Choose a contiguous subsegment $$$a[l, r]$$$ of pieces of cake ($$$1 \leq l \leq r \leq n$$$), and reverse it. The subsegment $$$a[l, r]$$$ of the array $$$a$$$ is the sequence $$$a_l, a_{l+1}, \dots, a_r$$$.If you reverse it, the array will become $$$a_1, a_2, \dots, a_{l-2}, a_{l-1}, \underline{a_r}, \underline{a_{r-1}}, \underline{\dots}, \underline{a_{l+1}}, \underline{a_l}, a_{r+1}, a_{r+2}, \dots, a_{n-1}, a_n$$$.For example, if the weights are initially $$$[5, 2, 1, 4, 7, 3]$$$, you can reverse the subsegment $$$a[2, 5]$$$, getting $$$[5, \underline{7}, \underline{4}, \underline{1}, \underline{2}, 3]$$$. The tastiness of the cake is now $$$5 + 7 = 12$$$ (while before the operation the tastiness was $$$4+7=11$$$).Find the maximum tastiness of the cake after doing the operation at most once.","t = int(input())
for arrow in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    mx1, mx2 = 0, 0
    for i in a:
        if mx1 <= i:
            mx2 = mx1
            mx1 = i

        if i < mx1:
            mx2 = max(i, mx2)
    print(mx1 + mx2)","['greedy', 'implementation', 'sortings']"
"There are $$$n + 1$$$ cities, numbered from $$$0$$$ to $$$n$$$. $$$n$$$ roads connect these cities, the $$$i$$$-th road connects cities $$$i - 1$$$ and $$$i$$$ ($$$i \in [1, n]$$$).Each road has a direction. The directions are given by a string of $$$n$$$ characters such that each character is either L or R. If the $$$i$$$-th character is L, it means that the $$$i$$$-th road initially goes from the city $$$i$$$ to the city $$$i - 1$$$; otherwise it goes from the city $$$i - 1$$$ to the city $$$i$$$.A traveler would like to visit as many cities of this country as possible. Initially, they will choose some city to start their journey from. Each day, the traveler must go from the city where they currently are to a neighboring city using one of the roads, and they can go along a road only if it is directed in the same direction they are going; i. e., if a road is directed from city $$$i$$$ to the city $$$i + 1$$$, it is possible to travel from $$$i$$$ to $$$i + 1$$$, but not from $$$i + 1$$$ to $$$i$$$. After the traveler moves to a neighboring city, all roads change their directions to the opposite ones. If the traveler cannot go from their current city to a neighboring city, their journey ends; it is also possible to end the journey whenever the traveler wants to.The goal of the traveler is to visit as many different cities as possible (they can visit a city multiple times, but only the first visit is counted). For each city $$$i$$$, calculate the maximum number of different cities the traveler can visit during exactly one journey if they start in the city $$$i$$$.","def solve():
    n = int(input())
    a = list(input())
    for i in range(n):
        if a[i] == ""R"":
            a[i] = 1
        else:
            a[i] = 0

    left = [-1 for i in range(n + 1)]
    right = [-1 for i in range(n + 1)]
    right[-1] = 0
    left[-1] = 0

    for i in range(n):
        if right[i] == -1:
            j = i
            right[i] = 0
            cnt = 0

            while j < n:
                if (a[j] + cnt) % 2 == 1:
                    right[i] += 1
                    cnt += 1
                    j += 1
                else:
                    break

            cnt = 1
            for j in range(i + 1, i + right[i]):
                if cnt % 2 == 1:
                    right[j] = 0
                else:
                    right[j] = right[i] - cnt
                cnt += 1 
             
    a.reverse()

    for i in range(n):
        if left[i] == -1:
            j = i
            left[i] = 0
            cnt = 0

            while j < n:
                if (a[j] + cnt) % 2 == 0:
                    left[i] += 1
                    cnt += 1
                    j += 1
                else:
                    break
            
            cnt = 1
            for j in range(i + 1, i + left[i]):
                if cnt % 2 == 1:
                    left[j] = 0
                else:
                    left[j] = left[i] - cnt
                cnt += 1
            

    left.reverse()


    for i in range(n + 1):
        print(1 + right[i] + left[i], end="" "")
    print()


tt = int(input())
for _ in range(tt):
    solve()","['dfs and similar', 'dp', 'dsu', 'implementation']"
"Masha meets a new friend and learns his phone number — $$$s$$$. She wants to remember it as soon as possible. The phone number — is a string of length $$$m$$$ that consists of digits from $$$0$$$ to $$$9$$$. The phone number may start with 0.Masha already knows $$$n$$$ phone numbers (all numbers have the same length $$$m$$$). It will be easier for her to remember a new number if the $$$s$$$ is represented as segments of numbers she already knows. Each such segment must be of length at least $$$2$$$, otherwise there will be too many segments and Masha will get confused.For example, Masha needs to remember the number: $$$s = $$$ '12345678' and she already knows $$$n = 4$$$ numbers: '12340219', '20215601', '56782022', '12300678'. You can represent $$$s$$$ as a $$$3$$$ segment: '1234' of number one, '56' of number two, and '78' of number three. There are other ways to represent $$$s$$$.Masha asks you for help, she asks you to break the string $$$s$$$ into segments of length $$$2$$$ or more of the numbers she already knows. If there are several possible answers, print any of them.","import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353

for _ in range(I()):
	S();n,m=M();have={};pos={};dp=[0]*(m+1);pr=[0]*(m+1);dp[0]=1
	for i in range(n):
		cur=S()
		for j in range(m):
			t=cur[j]
			for k in range(1,3):
				if k+j>=m:break
				t+=cur[j+k]
				if not have.get(t,0):
					have[t]=1
					pos[t]=(j,j+k,i)	
	s=S()
	for i in range(m):
		t=s[i]
		for k in range(1,3):
			if i-k<0:break
			t=s[i-k]+t
			if have.get(t,0) and dp[i-k]:
				dp[i+1]=1
				pr[i+1]=i-k
			if dp[i+1]:break
	if not dp[m]:print(-1);continue
	k=m;ans=[]
	while k>0:
		p=pr[k]	
		t=s[p:k]
		ans.append(pos[t])
		k=p
	print(len(ans));ans.reverse()
	for i in ans:print(i[0]+1,i[1]+1,i[2]+1)","['brute force', 'constructive algorithms', 'dp', 'hashing', 'implementation', 'strings']"
"You are given an array $$$a$$$ consisting of $$$n$$$ positive integers. You can perform operations on it.In one operation you can replace any element of the array $$$a_i$$$ with $$$\lfloor \frac{a_i}{2} \rfloor$$$, that is, by an integer part of dividing $$$a_i$$$ by $$$2$$$ (rounding down).See if you can apply the operation some number of times (possible $$$0$$$) to make the array $$$a$$$ become a permutation of numbers from $$$1$$$ to $$$n$$$ —that is, so that it contains all numbers from $$$1$$$ to $$$n$$$, each exactly once.For example, if $$$a = [1, 8, 25, 2]$$$, $$$n = 4$$$, then the answer is yes. You could do the following:  Replace $$$8$$$ with $$$\lfloor \frac{8}{2} \rfloor = 4$$$, then $$$a = [1, 4, 25, 2]$$$.  Replace $$$25$$$ with $$$\lfloor \frac{25}{2} \rfloor = 12$$$, then $$$a = [1, 4, 12, 2]$$$.  Replace $$$12$$$ with $$$\lfloor \frac{12}{2} \rfloor = 6$$$, then $$$a = [1, 4, 6, 2]$$$.  Replace $$$6$$$ with $$$\lfloor \frac{6}{2} \rfloor = 3$$$, then $$$a = [1, 4, 3, 2]$$$.","def solve(): 
    n=int(input());l=[]
    arr=[int(i) for i in input().split()]
    if max(arr)<n:
        print(""NO"")
        return 
    for i in arr : 
        while i>0 :
            if i<=n and i not in l :
                l.append(i)
                break
            i//=2
    if len(l)==n :
        print(""YES"")
        return 
    print(""NO"")
    return 
if __name__==""__main__"" :
    for x in range(int(input())) : solve()","['constructive algorithms', 'flows', 'graph matchings', 'greedy', 'math']"
"You are given some text $$$t$$$ and a set of $$$n$$$ strings $$$s_1, s_2, \dots, s_n$$$. In one step, you can choose any occurrence of any string $$$s_i$$$ in the text $$$t$$$ and color the corresponding characters of the text in red. For example, if $$$t=\texttt{bababa}$$$ and $$$s_1=\texttt{ba}$$$, $$$s_2=\texttt{aba}$$$, you can get $$$t=\color{red}{\texttt{ba}}\texttt{baba}$$$, $$$t=\texttt{b}\color{red}{\texttt{aba}}\texttt{ba}$$$ or $$$t=\texttt{bab}\color{red}{\texttt{aba}}$$$ in one step.You want to color all the letters of the text $$$t$$$ in red. When you color a letter in red again, it stays red.In the example above, three steps are enough:  Let's color $$$t[2 \dots 4]=s_2=\texttt{aba}$$$ in red, we get $$$t=\texttt{b}\color{red}{\texttt{aba}}\texttt{ba}$$$;  Let's color $$$t[1 \dots 2]=s_1=\texttt{ba}$$$ in red, we get $$$t=\color{red}{\texttt{baba}}\texttt{ba}$$$;  Let's color $$$t[4 \dots 6]=s_2=\texttt{aba}$$$ in red, we get $$$t=\color{red}{\texttt{bababa}}$$$. Each string $$$s_i$$$ can be applied any number of times (or not at all). Occurrences for coloring can intersect arbitrarily.Determine the minimum number of steps needed to color all letters $$$t$$$ in red and how to do it. If it is impossible to color all letters of the text $$$t$$$ in red, output -1.","import sys
input=lambda: sys.stdin.readline().strip()
for _ in range(int(input())):
	t = input()
	n = int(input())
	l = list()
	for i in range(n):
	  inp = input()
	  l.append((inp,len(inp),i+1))
	l.sort(key=lambda p: p[1],reverse=True)
	ans = list() # (id, pos)
	mai = 0
	i = 0
	while i <= mai < len(t):
		for (s, le, ind) in l:
			if mai < le+i <= len(t):
				if all(t[i+j]==s[j] for j in range(le)):
					if len(ans) > 1 and ans[-2][-1] >= i:
						ans.pop()
					mai = le+i
					ans.append((ind,i+1,le+i))
		i+=1
		if mai < i:
			print(-1)
			break
	else:
		print(len(ans))
		for (a,b,i) in ans:
			print(a, b)","['brute force', 'data structures', 'dp', 'greedy', 'strings']"
"In Medieval times existed the tradition of burning witches at steaks together with their pets, black cats. By the end of the 15-th century the population of black cats ceased to exist. The difficulty of the situation led to creating the EIC - the Emergency Inquisitory Commission.The resolution #666 says that a white cat is considered black when and only when the perimeter of its black spots exceeds the acceptable norm. But what does the acceptable norm equal to? Every inquisitor will choose it himself depending on the situation. And your task is to find the perimeter of black spots on the cat's fur.The very same resolution says that the cat's fur is a white square with the length of 105. During the measurement of spots it is customary to put the lower left corner of the fur into the origin of axes (0;0) and the upper right one — to the point with coordinates (105;105). The cats' spots are nondegenerate triangles. The spots can intersect and overlap with each other, but it is guaranteed that each pair of the triangular spots' sides have no more than one common point.We'll regard the perimeter in this problem as the total length of the boarders where a cat's fur changes color.","from math import *
eps=1e-14
n = input()
l = [map(int,raw_input().split()) for _ in xrange(n)]
res = 0
def isect(a1,b1,c1,x1,y1,x2,y2):
    a2,b2,c2=y1-y2,x2-x1,x1*y2-y1*x2
    d = a1*b2-a2*b1
    if d==0: return None, None
    x = -1.0*(c1*b2-c2*b1)/d
    y = -1.0*(c2*a1-a2*c1)/d
    #print x1,y1,x2,y2,x,y
    if min(x1,x2)-eps<=x<=max(x1,x2)+eps and min(y1,y2)-eps<=y<=max(y1,y2)+eps: return x,y
    return None, None
        
def cres(xmi,xma,rx):
    #print rx
    n = 0
    sx = xma-xmi  
    for j,(x,i) in enumerate(rx):
        if n>0:
            sx-=max(0,min(x,xma)-max(xmi,rx[j-1][0]))
        if i: n+=1
        else: n-=1
    return sx
def count(x,y,xx,yy,i):
    a1,b1,c1=y-yy,xx-x,x*yy-y*xx
    xmi=min(x,xx)
    xma=max(x,xx)
    ymi=min(y,yy)
    yma=max(y,yy)
    rx=[]
    ry=[]
    for j,(ax,ay,bx,by,cx,cy) in enumerate(l):
        if i==j: continue
        x1,y1=isect(a1,b1,c1,ax,ay,bx,by)
        x2,y2=isect(a1,b1,c1,cx,cy,bx,by)
        x3,y3=isect(a1,b1,c1,cx,cy,ax,ay)
        x = filter(lambda x: x is not None, [x1,x2,x3])
        if len(x)<2: continue
        y = filter(lambda x: x is not None, [y1,y2,y3])
        #print xmi,xma,ymi,yma,x,y
        rx.append((min(x),True))
        rx.append((max(x),False))
        ry.append((min(y),True))
        ry.append((max(y),False))
    rx.sort()
    ry.sort()
    return hypot(cres(xmi,xma,rx),cres(ymi,yma,ry))
        
for i,(ax,ay,bx,by,cx,cy) in enumerate(l):
    res+=count(ax,ay,bx,by,i)
    res+=count(cx,cy,bx,by,i)
    res+=count(ax,ay,cx,cy,i)
print ""%.7f""%res","['sortings', 'implementation', 'geometry']"
"You are given an integer $$$n$$$. In $$$1$$$ move, you can do one of the following actions:  erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is ""empty"");  add one digit to the right. The actions may be performed in any order any number of times.Note that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number $$$301$$$ the digit $$$3$$$, the result is the number $$$01$$$ (not $$$1$$$).You need to perform the minimum number of actions to make the number any power of $$$2$$$ (i.e. there's an integer $$$k$$$ ($$$k \ge 0$$$) such that the resulting number is equal to $$$2^k$$$). The resulting number must not have leading zeroes.E.g. consider $$$n=1052$$$. The answer is equal to $$$2$$$. First, let's add to the right one digit $$$4$$$ (the result will be $$$10524$$$). Then let's erase the digit $$$5$$$, so the result will be $$$1024$$$ which is a power of $$$2$$$.E.g. consider $$$n=8888$$$. The answer is equal to $$$3$$$. Let's erase any of the digits $$$8$$$ three times. The result will be $$$8$$$ which is a power of $$$2$$$.","from heapq import heapify, heappush, heappop
from collections import Counter, defaultdict, deque
from queue import PriorityQueue
from itertools import combinations, product, permutations
from bisect import bisect_left, bisect_right
from functools import lru_cache
from sys import stdin, stdout # for input /output
import copy
import math
import array as arr
from heapq import heappop, heappush
import time
# import sys
# sys.setrecursionlimit(100000)
####################
# stdin = open(""testcase.txt"")
# def input():
	# 	return stdin.readline().strip()

#####################################################################

class FastIO:

	@classmethod
	def input(cls):
		from sys import stdin
		x = stdin.buffer.readline().decode().strip()
		return x

	@classmethod
	def integer_list(cls):
		return list(map(int, cls.input().split()))

	@classmethod
	def print(cls, s = """", end = ""\n""):
		from sys import stdout
		stdout.write(str(s) + end)

	@classmethod
	def flush(cls):
		from sys import stdout
		stdout.flush()


####################################################################

class SegmentTree:
	def __init__(self, data, default=0, func=lambda a, b: a + b):
		""""""initialize the segment tree with data""""""
		"""""" initial default value for each node """"""
		"""""" func which you want to apply to range """"""
		self._default = default
		self._func = func
		self._len = len(data)
		self._size = _size = 1 << (self._len - 1).bit_length()
 
		self.data = [default] * (2 * _size)
		self.data[_size:_size + self._len] = data
		for i in reversed(range(_size)):
			self.data[i] = func(self.data[2*i], self.data[2*i + 1])
 
	def __delitem__(self, idx):
		"""""" delete item set item value to its default """"""
		self[idx] = self._default
 
	def __getitem__(self, idx):
		"""""" geting item by inx """"""
		return self.data[idx + self._size]
 
	def __setitem__(self, idx, value):
		"""""" changing seting value to given index""""""
		"""""" apply function to range """"""
		idx += self._size
		self.data[idx] = value
		idx >>= 1
		while idx:
			self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
			idx >>= 1
 
	def __len__(self):
		return self._len
 
	def query(self, start, stop):
		""""""func of data[start, stop)""""""
		start += self._size
		stop += self._size
 
		res_left = res_right = self._default
		while start < stop:
			if start & 1:
				res_left = self._func(res_left, self.data[start])
				start += 1
			if stop & 1:
				stop -= 1
				res_right = self._func(self.data[stop], res_right)
			start >>= 1
			stop >>= 1
 
		return self._func(res_left, res_right)
 
	def __repr__(self):
		return ""SegmentTree({0})"".format(self.data)

#####################################################################
class BinaryIndexTree(object):
	"""""" use one indexing """"""
	def __init__(self, nums):
		n = len(nums)
		self._len = len(nums)
		self.nums = [0 for _ in range(n+1)]
		self.N = [0 for _ in range(n+1)]
		for i, v in enumerate(nums):
			self.__setitem__(i+1, v)

	def _lowbit(self, a):
		return a & -a

	def  __setitem__(self, i, val):
		diff = val - self.nums[i]
		self.nums[i] = val
		while i < len(self.N):
			self.N[i] += diff
			i += self._lowbit(i)

	def __getitem__(self, i):
		# return sum up 0 to i
		ret = 0
		while i > 0:
			ret += self.N[i]
			i -= self._lowbit(i)

		return ret

######################################################################
class DisJointSetsRank():
    def __init__(self,N):
        # Initially, all elements are single element subsets
        self._parents = [node for node in range(N)]
        self._ranks = [1 for _ in range(N)]
    
    def find(self, u):
        while u != self._parents[u]: 
            # path compression technique
            self._parents[u] = self._parents[self._parents[u]]
            u = self._parents[u]
        return u
    
    def connected(self, u, v):
        return self.find(u) == self.find(v)
    
    def union(self, u, v):
        # Union by rank optimization
        root_u, root_v = self.find(u), self.find(v)
        if root_u == root_v:
            return True
        if self._ranks[root_u] > self._ranks[root_v]:
            self._parents[root_v] = root_u
        elif self._ranks[root_v] > self._ranks[root_u]:
            self._parents[root_u] = root_v
        else:
            self._parents[root_u] = root_v
            self._ranks[root_v] += 1
        return False


#######################################################################

def integer_list():
	return list(map(int, input().split()))

def pprint(matrix):
	for i in range(len(matrix)):
		print(*matrix[i])


#####################################################
#test case section 
""""""

1 - 5

9 10 1 2 7
0 1  1 

""""""       
#############################################################
# for manipulating 0 for runing to your system 1 for online 


MOD = 10**9+7

ONLINE_JUDGE = 1

def match_seq(power_2, s):

	i = j = 0
	while i < len(power_2) and j < len(s):
		if power_2[i] == s[j]:
			i += 1
			j += 1
		else:
			j += 1

	deleted_char = len(s) - i
	to_add = len(power_2) - i
	return deleted_char + to_add




def main():
	t = int(input())
	# t = 1
	powers = []
	for i in range(61):
		num = str(2**i)
		powers.append(num)

	# print(powers)
	for _ in range(t):
		n = input()
		lst = []
		k = len(n)
		ans = float('inf')
		for ele in powers:
			ans = min( ans , match_seq(ele, n))

		print(ans)


		

	

	

	


		
		
		
							




###############################################

if ONLINE_JUDGE:
	input = lambda : stdin.buffer.readline().decode().strip()
else:
	stdin = open(""testcase.txt"")
	input = lambda : stdin.readline().strip()
	

main()","['greedy', 'math', 'strings']"
"Polycarp has a string $$$s$$$. Polycarp performs the following actions until the string $$$s$$$ is empty ($$$t$$$ is initially an empty string):  he adds to the right to the string $$$t$$$ the string $$$s$$$, i.e. he does $$$t = t + s$$$, where $$$t + s$$$ is a concatenation of the strings $$$t$$$ and $$$s$$$;  he selects an arbitrary letter of $$$s$$$ and removes from $$$s$$$ all its occurrences (the selected letter must occur in the string $$$s$$$ at the moment of performing this action). Polycarp performs this sequence of actions strictly in this order.Note that after Polycarp finishes the actions, the string $$$s$$$ will be empty and the string $$$t$$$ will be equal to some value (that is undefined and depends on the order of removing).E.g. consider $$$s$$$=""abacaba"" so the actions may be performed as follows:  $$$t$$$=""abacaba"", the letter 'b' is selected, then $$$s$$$=""aacaa"";  $$$t$$$=""abacabaaacaa"", the letter 'a' is selected, then $$$s$$$=""c"";  $$$t$$$=""abacabaaacaac"", the letter 'c' is selected, then $$$s$$$="""" (the empty string). You need to restore the initial value of the string $$$s$$$ using only the final value of $$$t$$$ and find the order of removing letters from $$$s$$$.","T = int(input())
for t in range(T):
    t = input()
    n = len(t)
    # find first character with no occurences to the right
    s = set()
    r = []
    for i in t[::-1]:
        if i not in s:
            r.append(i)
            s.add(i)

    done = r[::-1]
    #print(done)


    v = 0
    for i in range(n):
        v += done.index(t[i]) + 1
        if v == n:
            r = """"
            tt = t[:i+1]
            for c in done:
                r += tt
                tt=tt.replace(c,"""")
            #print(r)
            if r != t:
                print(-1)
            else:
                print(t[:i+1],"""".join(done))
            break
        elif v > n:
            print(-1)
            break","['binary search', 'implementation', 'sortings', 'strings']"
"It is a simplified version of problem F2. The difference between them is the constraints (F1: $$$k \le 2$$$, F2: $$$k \le 10$$$).You are given an integer $$$n$$$. Find the minimum integer $$$x$$$ such that $$$x \ge n$$$ and the number $$$x$$$ is $$$k$$$-beautiful.A number is called $$$k$$$-beautiful if its decimal representation having no leading zeroes contains no more than $$$k$$$ different digits. E.g. if $$$k = 2$$$, the numbers $$$3434443$$$, $$$55550$$$, $$$777$$$ and $$$21$$$ are $$$k$$$-beautiful whereas the numbers $$$120$$$, $$$445435$$$ and $$$998244353$$$ are not.","import os, sys
from io import BytesIO, IOBase
from bisect import *


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class dict(dict):
    def __missing__(self, key):
        return 0


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: dtype(input().strip())
inp_d = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp_d(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp_d(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp_d(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
get_bit = lambda x, i: (x >> i) & 1

for _ in range(inp(int)):
    n, k = inp_d(int)
    n1 = str(n)
    ans, ln = float('inf'), len(n1)

    digs = []
    for i in n1:
        if len(digs) == k - 1:
            break
        if i not in digs:
            digs.append(i)

    for i in range(10):
        cur, lst, flag = [], [-1, 0], 0

        if str(i) not in digs:
            digs.append(str(i))
            flag = 1

        digs.sort()

        for j in n1:
            ix = bisect_left(digs, j)

            if ix < len(digs):
                cur.append(digs[ix])

                if j < digs[ix]:
                    cur.extend([digs[0]] * (ln - len(cur)))

                if ix != len(digs) - 1:
                    lst = [len(cur) - 1, ix + 1]

            else:
                if lst[0] == -1:
                    cur = ['9'] * 10
                    break

                cur[lst[0]] = digs[lst[1]]
                cur = cur[:lst[0] + 1] + [digs[0]] * (ln - lst[0] - 1)
                break

            if len(cur) == len(n1):
                break

        if flag:
            digs.remove(str(i))
        ans = min(ans, int(''.join(cur)))

    print(ans)","['binary search', 'bitmasks', 'brute force', 'constructive algorithms', 'dfs and similar', 'greedy']"
"You are given three positive integers $$$a$$$, $$$b$$$, $$$c$$$ ($$$a &lt; b &lt; c$$$). You have to find three positive integers $$$x$$$, $$$y$$$, $$$z$$$ such that:$$$$$$x \bmod y = a,$$$$$$ $$$$$$y \bmod z = b,$$$$$$ $$$$$$z \bmod x = c.$$$$$$Here $$$p \bmod q$$$ denotes the remainder from dividing $$$p$$$ by $$$q$$$. It is possible to show that for such constraints the answer always exists.","if __name__ == ""__main__"":
    for i in range(int(input())):
        abc = list(map(int, input().split("" "")))
        print(abc[0] + abc[1] + abc[2], abc[1] + abc[2], abc[2])","['constructive algorithms', 'math']"
"You are given an array $$$a$$$ of $$$n$$$ integers. Also you are given $$$m$$$ subsegments of that array. The left and the right endpoints of the $$$j$$$-th segment are $$$l_j$$$ and $$$r_j$$$ respectively.You are allowed to make no more than one operation. In that operation you choose any subsegment of the array $$$a$$$ and replace each value on this segment with any integer (you are also allowed to keep elements the same).You have to apply this operation so that for the given $$$m$$$ segments, the elements on each segment are distinct. More formally, for each $$$1 \le j \le m$$$ all elements $$$a_{l_{j}}, a_{l_{j}+1}, \ldots, a_{r_{j}-1}, a_{r_{j}}$$$ should be distinct.You don't want to use the operation on a big segment, so you have to find the smallest length of a segment, so that you can apply the operation to this segment and meet the above-mentioned conditions. If it is not needed to use this operation, the answer is $$$0$$$.","#!/usr/bin/env PyPy3

from collections import Counter, defaultdict, deque
import itertools
import re
import math
from functools import reduce
import operator
import bisect
from heapq import *
import functools
mod=998244353

import sys
import os
from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

INF = 1 << 31
def compress(mylist):
    B = list(set(mylist))
    B.sort()
    D = { v: i for i, v in enumerate(B) }
    return list(map(lambda v: D[v], mylist))
def solve():
    n,m=map(int,input().split())
    a = list(map(int,input().split()))
    a = compress(a)
    ma = max(a)
    prv = [-1] * (ma+1)
    cnt = [[] for _ in range(ma+1)]
    fli = [-1] * n
    now = -1
    for i in range(n):
        if prv[a[i]] == -1:
            prv[a[i]] = i
        else:
            now = max(now,prv[a[i]])
            prv[a[i]] = i
        fli[i] = now
        cnt[a[i]].append(i)
    mi = INF
    chk = [INF] * n
    for _ in range(m):
        l,r=map(int,input().split())
        if fli[r-1] < l - 1:
            continue
        else:
            chk[r-1] = min(chk[r-1],l-1)
            idx = bisect.bisect_left(fli,l-1)
            mi = min(mi,idx)
    if mi == INF:
        print(0)
        return
    for i in range(n-1)[::-1]:
        chk[i] = min(chk[i],chk[i+1])
    ans = n - mi
    for i in range(n-1)[::-1]:
        idx = bisect.bisect_right(cnt[a[i+1]],i+1)
        if idx != len(cnt[a[i+1]]):
            tmp = chk[cnt[a[i+1]][idx]]
            if tmp <= i + 1:
                break
        if idx > 1:
            tmp = chk[i+1]
            midx = bisect.bisect_left(cnt[a[i+1]],tmp)
            if midx < len(cnt[a[i+1]]):
                mi = min(mi,cnt[a[i+1]][midx])
        ans = min(ans,i+1-mi)
    print(ans)
    return 0
t = int(input())
for _ in range(t):
    solve()","['data structures', 'two pointers']"
"A string $$$s$$$ of length $$$n$$$ ($$$1 \le n \le 26$$$) is called alphabetical if it can be obtained using the following algorithm:  first, write an empty string to $$$s$$$ (i.e. perform the assignment $$$s$$$ := """");  then perform the next step $$$n$$$ times;  at the $$$i$$$-th step take $$$i$$$-th lowercase letter of the Latin alphabet and write it either to the left of the string $$$s$$$ or to the right of the string $$$s$$$ (i.e. perform the assignment $$$s$$$ := $$$c+s$$$ or $$$s$$$ := $$$s+c$$$, where $$$c$$$ is the $$$i$$$-th letter of the Latin alphabet). In other words, iterate over the $$$n$$$ first letters of the Latin alphabet starting from 'a' and etc. Each time we prepend a letter to the left of the string $$$s$$$ or append a letter to the right of the string $$$s$$$. Strings that can be obtained in that way are alphabetical.For example, the following strings are alphabetical: ""a"", ""ba"", ""ab"", ""bac"" and ""ihfcbadeg"". The following strings are not alphabetical: ""z"", ""aa"", ""ca"", ""acb"", ""xyz"" and ""ddcba"".From the given string, determine if it is alphabetical.","t = int(input())
import string

def is_abc(S):
    abc = list(string.ascii_lowercase)
    del abc[0]

    if S == 'a':
        return True
    
    if S == '':
        return True

 
    if len(set(S)) == len(S) and 'a' in S:
        a = S.index('a')
        prev_S = list(reversed(S[:a]))
        post_S = S[a+1:]
        c = len(prev_S) + len(post_S)

        for i in range(c):
            current_S = abc[i]
            prev = prev_S[0] if prev_S else None
            post = post_S[0] if post_S else None

            if current_S == prev:
                del prev_S[0]
            elif current_S == post:
                del post_S[0]
            else:
                return False
        return True
    else:
        return False
                
for i in range(t):
    S = list(input())
    if is_abc(S):
        print('YES') 
    else:
        print('NO')","['greedy', 'implementation', 'strings']"
"There are three cells on an infinite 2-dimensional grid, labeled $$$A$$$, $$$B$$$, and $$$F$$$. Find the length of the shortest path from $$$A$$$ to $$$B$$$ if:   in one move you can go to any of the four adjacent cells sharing a side;  visiting the cell $$$F$$$ is forbidden (it is an obstacle).","import sys
from sys import stdin, stdout
 
# input = stdin.readline
 
# def invr():
#     return(map(int,input().split()))
    
def main():
    t = int(stdin.readline())
    a = b = f = [0]*2
    
    for u in range(0,t):
        stdin.readline()
        # for i in range(0,2):
        a = stdin.readline().split()
        a = int(a[0]), int(a[1])
        b = stdin.readline().split()
        b = int(b[0]), int(b[1])
        f = stdin.readline().split()
        f = int(f[0]), int(f[1])
        dist = 0
        x_diff = abs(b[0] - a[0])
        y_diff = abs(b[1] - a[1])
        dist = x_diff + y_diff
        if (x_diff == 0) and (f[0] == a[0] and (a[1] < f[1] < b[1] or b[1]<f[1]<a[1])):
            dist = dist + 2
        if (y_diff == 0) and (f[1] == a[1] and (a[0] < f[0] < b[0] or b[0]<f[0]<a[0])):
            dist = dist + 2
        
        print(dist)
    # a = int(a)
    # b = int(b)
    # x = invr()
    # print(a+b)
    # x = inp()
    # print(x)
    # x = inp()
    # print(x)
    
    return
    
main()","['implementation', 'math']"
"Bessie and the cows are playing with sequences and need your help. They start with a sequence, initially containing just the number 0, and perform n operations. Each operation is one of the following:  Add the integer xi to the first ai elements of the sequence.  Append an integer ki to the end of the sequence. (And hence the size of the sequence increases by 1)  Remove the last element of the sequence. So, the size of the sequence decreases by one. Note, that this operation can only be done if there are at least two elements in the sequence. After each operation, the cows would like to know the average of all the numbers in the sequence. Help them!","suma = 0.0
items = 0
puros = [0]
agreg = [0]
cant  = 1
queries = []
n = int(input())

for i in range(n):
  q = list( map( int, input().split() ))
  if q[0] == 1:
    suma += q[1]*q[2]
    agreg[q[1]-1] += q[2]
  elif q[0] == 2:
    puros.append(q[1])
    agreg.append(0)
    suma += q[1]
    cant += 1
  else: #3
    cant -= 1
    agreg[-2] += agreg[-1]
    suma -= agreg.pop() + puros.pop()
  
  queries.append(suma/cant)
  
print( ""\n"".join( [ ""{0:.6f}"".format(q) for q in queries ] ) )","['dp', 'constructive algorithms', 'data structures']"
"Given a permutation $$$a_1, a_2, \dots, a_n$$$ of integers from $$$1$$$ to $$$n$$$, and a threshold $$$k$$$ with $$$0 \leq k \leq n$$$, you compute a sequence $$$b_1, b_2, \dots, b_n$$$ as follows. For every $$$1 \leq i \leq n$$$ in increasing order, let $$$x = a_i$$$.   If $$$x \leq k$$$, set $$$b_{x}$$$ to the last element $$$a_j$$$ ($$$1 \leq j &lt; i$$$) that $$$a_j &gt; k$$$. If no such element $$$a_j$$$ exists, set $$$b_{x} = n+1$$$.  If $$$x &gt; k$$$, set $$$b_{x}$$$ to the last element $$$a_j$$$ ($$$1 \leq j &lt; i$$$) that $$$a_j \leq k$$$. If no such element $$$a_j$$$ exists, set $$$b_{x} = 0$$$. Unfortunately, after the sequence $$$b_1, b_2, \dots, b_n$$$ has been completely computed, the permutation $$$a_1, a_2, \dots, a_n$$$ and the threshold $$$k$$$ are discarded. Now you only have the sequence $$$b_1, b_2, \dots, b_n$$$. Your task is to find any possible permutation $$$a_1, a_2, \dots, a_n$$$ and threshold $$$k$$$ that produce the sequence $$$b_1, b_2, \dots, b_n$$$. It is guaranteed that there exists at least one pair of permutation $$$a_1, a_2, \dots, a_n$$$ and threshold $$$k$$$ that produce the sequence $$$b_1, b_2, \dots, b_n$$$.A permutation of integers from $$$1$$$ to $$$n$$$ is a sequence of length $$$n$$$ which contains all integers from $$$1$$$ to $$$n$$$ exactly once.","# def dfs(node, stack, next, visited):
#     if node == -1 or node in visited:
#         return
#     visited.add(node)
#     # print(node, next)
#     dfs(next[node], stack, next, visited)
#     stack.append(node)
import sys
from collections import defaultdict
# sys.setrecursionlimit(200000)


def dfs(node, parents, stack):
    # print(""node"", node)

    dStack = [node]
    while len(dStack) > 0:
        # print(dStack)
        e = dStack.pop()
        stack.append(e)

        noParents = []
        withParents = []
        for p in parents[e]:
            if len(parents[p]) == 0:
                noParents.append(p)
            else:
                withParents.append(p)
        # print(noParents + withParents)
        for p in withParents + noParents:
            dStack.append(p)


t = int(input())
for _ in range(t):
    n = int(input())
    b = [int(e)-1 for e in input().split(' ')]

    next = [-1]*n
    parent = defaultdict(list)
    left = -1
    right = n-1
    for x, bx in enumerate(b):
        if bx == -1:
            right = min(x-1, right)
            continue

        if bx == n:
            left = max(x, left)
            continue

        if x < bx:
            left = max(x, left)
            right = min(bx-1, right)
        else:
            left = max(bx, left)
            right = min(x-1, right)

        next[x] = bx
        parent[bx].append(x)

    k = left+1
    visited = set()
    start = None
    # print(parent, next)
    for i in range(n):
        if len(parent[i]) != 0 and next[i] == -1:
            start = i

    stack = []
    # print(start)
    if start is not None:
        dfs(start, parent, stack)
    # print(stack)
    # for i in range(n):
    #     if next[i] == -1 or i in visited:
    #         continue

    #     dfs(i, stack, next, visited)
    add = []
    for i in range(n):
        if len(parent[i]) == 0 and next[i] == -1:
            add.append(i)
    print(k)
    print(' '.join([str(e+1) for e in add+stack]))","['constructive algorithms', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'trees']"
"You have an array $$$a$$$ consisting of $$$n$$$ positive integers and you have to handle $$$q$$$ queries of the following types:  $$$1$$$ $$$i$$$ $$$x$$$: change $$$a_{i}$$$ to $$$x$$$,  $$$2$$$ $$$l$$$ $$$r$$$ $$$k$$$: check if the number of occurrences of every positive integer in the subarray $$$a_{l}, a_{l+1}, \ldots a_{r}$$$ is a multiple of $$$k$$$ (check the example for better understanding).","from sys import stdin
input=lambda :stdin.readline()[:-1]



class segtree():
  def __init__(self,init,func,ide):
    self.n=len(init)
    self.func=func
    self.ide=ide
    self.size=1<<(self.n-1).bit_length()
    self.tree=[self.ide for i in range(2*self.size)]
    for i in range(self.n):
      self.tree[self.size+i]=init[i]
    for i in range(self.size-1,0,-1):
      self.tree[i]=self.func(self.tree[2*i], self.tree[2*i|1])
  
  def update(self,k,x):
    k+=self.size
    self.tree[k]=x
    k>>=1
    while k:
      self.tree[k]=self.func(self.tree[2*k],self.tree[k*2|1])
      k>>=1
  
  def get(self,i):
    return self.tree[i+self.size]
  
  def query(self,l,r):
    l+=self.size
    r+=self.size
    l_res=self.ide
    r_res=self.ide
    while l<r:
      if l&1:
        l_res=self.func(l_res,self.tree[l])
        l+=1
      if r&1:
        r-=1
        r_res=self.func(self.tree[r],r_res)
      l>>=1
      r>>=1
    return self.func(l_res,r_res)
  
  def debug(self,s=10):
    print([self.get(i) for i in range(min(self.n,s))])

n,q=map(int,input().split())
a=list(map(int,input().split()))
use={}
id=0
for i in range(n):
  if a[i] not in use:
    use[a[i]]=id
    id+=1
  a[i]=use[a[i]]

query=[]
for _ in range(q):
  tmp=list(map(int,input().split()))
  if tmp[0]==1:
    t,i,x=tmp
    if x not in use:
      use[x]=id
      id+=1
    query.append((t,i,use[x],0))
  else:
    query.append(tuple(tmp))


m=6


import random

def make_hash():
  x=random.randint(0,1)
  y=random.randint(0,1)
  z=random.randint(0,1)
  return x|(y<<20)|(z<<40)

M=id

def conv(x,y):
  return y*m+x

hash=[make_hash() for i in range(m*M)]
hash_xor=[random.randint(10**3,1<<60) for i in range(M)]

segs=[]

for i in range(m):
  x=[hash[conv(i,j)] for j in a]
  seg=segtree(x,lambda p,q:p+q,0)
  segs.append(seg)

seg_xor=segtree([hash_xor[i] for i in a],lambda p,q:p^q,0)

ans=[]
tmp=0

mask=(1<<20)-1

for ii in range(q):
  query_tmp=query[ii]
  if query_tmp[0]==1:
    x,y,_=query_tmp[1:]
    x-=1
    for i in range(m):
      segs[i].update(x,hash[conv(i,y)])
    seg_xor.update(x,hash_xor[y])
    
  else:
    l,r,k=query_tmp[1:]
    l-=1
    flag=True
    if k==2:
      if seg_xor.query(l,r)==0:
        print('YES')
      else:
        print('NO')
    else:
      for i in range(m):
        w=segs[i].query(l,r)
        x=w&mask
        y=(w>>20)&mask
        z=(w>>40)&mask
        if x%k!=0 or y%k!=0 or z%k!=0:
          flag=False
          break
      if flag:
        print('YES')
      else:
        print('NO')","['data structures', 'hashing', 'probabilities']"
"You are given two arrays $$$a$$$ and $$$b$$$ of $$$n$$$ elements, each element is either $$$0$$$ or $$$1$$$.You can make operations of $$$2$$$ kinds.   Pick an index $$$i$$$ and change $$$a_i$$$ to $$$1-a_i$$$.  Rearrange the array $$$a$$$ however you want. Find the minimum number of operations required to make $$$a$$$ equal to $$$b$$$.","n = int(input())

for i in range(n):
    index = int(input())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))
    
    ans = abs(sum(a)-sum(b))
    cnt = ans
    for x in range(index):
        if cnt <= 0:
                break
        if a[x] != b[x]:
            a[x] = 1- a[x]
            cnt -= 1
            
    if a == b:
        print(ans)
    else:
        print(ans+1)","['brute force', 'greedy', 'sortings']"
"This is the easy version of this problem. In this version, we do not have queries. Note that we have multiple test cases in this version. You can make hacks only if both versions of the problem are solved.An array $$$b$$$ of length $$$m$$$ is good if for all $$$i$$$ the $$$i$$$-th element is greater than or equal to $$$i$$$. In other words, $$$b$$$ is good if and only if $$$b_i \geq i$$$ for all $$$i$$$ ($$$1 \leq i \leq m$$$).You are given an array $$$a$$$ consisting of $$$n$$$ positive integers. Find the number of pairs of indices $$$(l, r)$$$, where $$$1 \le l \le r \le n$$$, such that the array $$$[a_l, a_{l+1}, \ldots, a_r]$$$ is good.","import sys
input= sys.stdin.readline
for j in range(int(input())):
    n = int(input())
    arr = list(map(int, input().split(' ')))

    ans, val = 0, 1
    for i in range(n):
        if arr[i] >= val:
            ans += val
            val += 1
        else:
            ans += arr[i]
            val = arr[i] + 1

    print(ans)","['binary search', 'data structures', 'schedules', 'two pointers']"
"You are given an integer array $$$a$$$ of length $$$n$$$. Does there exist an array $$$b$$$ consisting of $$$n+1$$$ positive integers such that $$$a_i=\gcd (b_i,b_{i+1})$$$ for all $$$i$$$ ($$$1 \leq i \leq n$$$)? Note that $$$\gcd(x, y)$$$ denotes the greatest common divisor (GCD) of integers $$$x$$$ and $$$y$$$.","import sys
from math import *
def input(): return sys.stdin.readline().strip()


def lcm(a, b):
    return a*b//gcd(a, b)


for test in range(int(input())):
    n = int(input())
    arr = list(map(int, input().split()))
    if n <= 2:
        print(""YES"")
        continue
    brr = [arr[0]]
    for i in range(n-1):
        brr.append(lcm(arr[i], arr[i+1]))
    brr.append(arr[-1])
    crr = []
    for i in range(n):
        crr.append(gcd(brr[i], brr[i+1]))
    if arr == crr:
        print(""YES"")
    else:
        print(""NO"")","['math', 'number theory']"
"Kawashiro Nitori is a girl who loves competitive programming.One day she found a string and an integer. As an advanced problem setter, she quickly thought of a problem.Given a string $$$s$$$ and a parameter $$$k$$$, you need to check if there exist $$$k+1$$$ non-empty strings $$$a_1,a_2...,a_{k+1}$$$, such that $$$$$$s=a_1+a_2+\ldots +a_k+a_{k+1}+R(a_k)+R(a_{k-1})+\ldots+R(a_{1}).$$$$$$ Here $$$+$$$ represents concatenation. We define $$$R(x)$$$ as a reversed string $$$x$$$. For example $$$R(abcd) = dcba$$$. Note that in the formula above the part $$$R(a_{k+1})$$$ is intentionally skipped.","ans_list = []
for i in range(int(input())):
	n, k = map(int, input().split())
	strings = input()

	skip = False
	if(n == 2 * k):
		ans_list.append(""NO"")
		continue

	for i in range(k):
		if(strings[i] == strings[n - 1 - i]):
			pass
		else:
			ans_list.append(""NO"")
			skip = True
			break

	if(skip == False):
		ans_list.append(""YES"")

for ans in ans_list:
	print(ans)","['brute force', 'constructive algorithms', 'greedy', 'strings']"
"Monocarp is playing a computer game. In this game, his character fights different monsters.A fight between a character and a monster goes as follows. Suppose the character initially has health $$$h_C$$$ and attack $$$d_C$$$; the monster initially has health $$$h_M$$$ and attack $$$d_M$$$. The fight consists of several steps:  the character attacks the monster, decreasing the monster's health by $$$d_C$$$;  the monster attacks the character, decreasing the character's health by $$$d_M$$$;  the character attacks the monster, decreasing the monster's health by $$$d_C$$$;  the monster attacks the character, decreasing the character's health by $$$d_M$$$;  and so on, until the end of the fight. The fight ends when someone's health becomes non-positive (i. e. $$$0$$$ or less). If the monster's health becomes non-positive, the character wins, otherwise the monster wins.Monocarp's character currently has health equal to $$$h_C$$$ and attack equal to $$$d_C$$$. He wants to slay a monster with health equal to $$$h_M$$$ and attack equal to $$$d_M$$$. Before the fight, Monocarp can spend up to $$$k$$$ coins to upgrade his character's weapon and/or armor; each upgrade costs exactly one coin, each weapon upgrade increases the character's attack by $$$w$$$, and each armor upgrade increases the character's health by $$$a$$$.Can Monocarp's character slay the monster if Monocarp spends coins on upgrades optimally?","n = int(input())
for _ in range(n):
    value = ""NO""
    hc, ac = list(map(int, input().split()))
    hm, am = list(map(int, input().split()))
    k,w,a = list(map(int, input().split()))
    for i in range(0,k+1):
        y = ac + (k-i)*w
        x = hc + i*a
        if(x + am - 1)//am >= (hm + y - 1)//y:
            value = ""YES""
            break
    print(value)","['brute force', 'math']"
"You are given an array $$$a$$$ with $$$n$$$ integers. You can perform the following operation at most $$$k$$$ times:  Choose two indices $$$i$$$ and $$$j$$$, in which $$$i \,\bmod\, k = j \,\bmod\, k$$$ ($$$1 \le i &lt; j \le n$$$).  Swap $$$a_i$$$ and $$$a_j$$$. After performing all operations, you have to select $$$k$$$ consecutive elements, and the sum of the $$$k$$$ elements becomes your score. Find the maximum score you can get.Here $$$x \bmod y$$$ denotes the remainder from dividing $$$x$$$ by $$$y$$$.","numberOfTestCases = int(input())
for i in range(numberOfTestCases):
    firstLine = [int(x) for x in input().split()]
    array = [int(x) for x in input().split()]

    arrayLen = firstLine[0]
    k = firstLine[1]
    tempK = k

    msum = 0
    for i in range(k):
        maxi = 0
        for j in range(i, arrayLen, k):
            if array[j] > maxi:
                maxi = array[j]
        msum += maxi
    print(msum)","['greedy', 'sortings']"
"There is a conveyor with $$$120$$$ rows and $$$120$$$ columns. Each row and column is numbered from $$$0$$$ to $$$119$$$, and the cell in $$$i$$$-th row and $$$j$$$-th column is denoted as $$$(i, j)$$$. The top leftmost cell is $$$(0, 0)$$$. Each cell has a belt, and all belts are initially facing to the right.Initially, a slime ball is on the belt of $$$(0, 0)$$$, and other belts are empty. Every second, the state of the conveyor changes as follows:   All slime balls on the conveyor move one cell in the direction of the belt at the same time. If there is no cell in the moved position, the slime gets out of the conveyor, and if two slime balls move to the same cell, they merge into one.  All belts with slime ball in the previous second change direction at the same time: belts facing to the right become facing to the down, and vice versa.  A new slime ball is placed on cell $$$(0, 0)$$$. There are $$$q$$$ queries, each being three integers $$$t$$$, $$$x$$$, and $$$y$$$. You have to find out if there is a slime at the cell $$$(x, y)$$$ after $$$t$$$ seconds from the start. Can you do it?","#from math import ceil, floor #, gcd, log, factorial, comb, perm,
#log10, log2, log, sin, asin, tan, atan, radians
#from heapq import heappop,heappush,heapify #heappop(hq), heapify(list)
#from collections import defaultdict as dd
#mydd=dd(list) for .append
#from collections import deque as dq #deque  e.g. myqueue=dq(list)
#append/appendleft/appendright/pop/popleft
#from bisect import bisect as bis #a=[1,3,4,6,7,8] #bis(a,5) --> 3
#import statistics as stat  # stat.median(a), mode, mean
#from math import ceil, floor
import sys
input = sys.stdin.readline
#print = sys.stdout.write
#sys.setrecursionlimit(100000) #default is 1000 
############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))   #.split(','), default is space
#list([0,*map(int,input().split("" ""))]) # pad a zero to avoid zero indexing
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
####################################################
#t=1
q = int(input())
for qc in range(q):
    t,x,y=map(int, input().split())
#    n=inp()
#    a=inlt()
#    x=list(input().strip(""\n"").split())
#    s=input().strip(""\n"")
#    s=input()[:-1]
#    s=insr()
#    occ=dict();
#    for i in range(n):occ[i]=[]
#    for i in range(n):
#        occ[i].append(inlt())
#    a=[]
#    for i in range(n):
#        a.append(inlt())
    if x+y>t:print('NO');continue
    if x==y==0:print('YES');continue
    a=[[0]*122 for i in range(122)]
    a[0][0]=t-x-y
    for i in range(x+1):
        for j in range(y+1):
            a[i+1][j]+=a[i][j]//2
            a[i][j+1]+=(a[i][j]+1)//2
    i=0;j=0
    while i+j<x+y and i<121 and j<121:
        if a[i][j]%2:
            i+=1
        else:
            j+=1
    if i==x:
        print('YES')
    else:
        print('NO')
        
#print(*ans,sep=' ')##print(""{:.3f}"".format(ans)+""%"")
#:b binary :% eg print(""{:6.2%}"".format(ans))
#print("" "".join(str(i) for i in ans))
#print("" "".join(map(str,ans))) #seems faster
#print(a[0] if a else 0)
#prefixsum a=[a1...an] #psa=[0]*(n+1)
#for i in range(n): psa[i+1]=psa[i]+a[i]
#sum[:ax]=psa[x+1] e.g. sum 1st 5 items in psa[5]
#ASCII<->number ord('f')=102 chr(102)='f'
#def binary_search(li, val, lb, ub):
#    while ((ub-lb)>1):
#        mid = (lb + ub) // 2
#        if li[mid] >= val:
#            ub = mid
#        else:
#            lb = mid
#    return lb+1 #return index of elements <val in li
#def binary_search(li, val, lb, ub):
#    ans = -1
#    while (lb <= ub):
#        mid = (lb + ub) // 2
#        if li[mid] > val:
#            ub = mid - 1
#        elif val > li[mid]:
#            lb = mid + 1
#        else:
#            ans = mid  # return index
#            break
#    return ans
##########
#def pref(li):
#    pref_sum = [0]
#    for i in li:
#        pref_sum.append(pref_sum[-1] + i)
#    return pref_sum
##########
#def suff(li):
#    suff_sum = [0]
#    for i in range(len(li)-1,-1,-1):
#        suff_sum.insert(0,suff_sum[0] + li[i])
#    return suff_sum
#############
#def maxSubArraySumI(arr): #Kadane's algorithm with index
#    max_till_now=arr[0];max_ending=0;size=len(arr)
#    start=0;end=0;s=0
#    for i in range(0, size):
#        max_ending = max_ending + arr[i]
#        if max_till_now < max_ending:
#            max_till_now=max_ending
#            start=s;end=i
#        if max_ending<0:
#            max_ending=0
#            s=i+1
#    return max_till_now,start,end
############# avoid max for 2 elements - slower than direct if
#def maxSubArraySum(arr): #Kadane's algorithm
#    max_till_now=arr[0];max_ending=0;size=len(arr)
#    for i in range(0, size):
#        max_ending = max_ending + arr[i]
#        if max_till_now < max_ending:max_till_now=max_ending
#        if max_ending<0:max_ending=0
#    return max_till_now
#############
#def findbits(x):
#    tmp=[]
#    while x>0:tmp.append(x%2);x//=2
#    tmp.reverse()
#    return tmp
##############Dijkstra algorithm example
#dg=[999999]*(n+1);dg[n]=0;todo=[(0,n)];chkd=[0]*(n+1)
#while todo:#### find x with min dg in todo
#    _,x=hq.heappop(todo)
#    if chkd[x]:continue
#    for i in coming[x]:going[i]-=1
#    for i in coming[x]:
#        tmp=1+dg[x]+going[i]
#        if tmp<dg[i]:dg[i]=tmp;hq.heappush(todo,(dg[i],i))   
#    chkd[x]=1
################ 
# adj swaps to match 2 binary strings: sum_{i=1}^n(abs(diff in i-th prefix sums))
###############
##s=[2, 3, 1, 4, 5, 3]
##sorted(range(len(s)), key=lambda k: s[k])
##gives sorted indices [2, 0, 1, 5, 3, 4]
##m= [[3, 4, 6], [2, 4, 8], [2, 3, 4], [1, 2, 3], [7, 6, 7], [1, 8, 2]]
##m.sort(reverse=True,key=lambda k:k[2]) #sorts m according to 3rd elements","['constructive algorithms', 'dp', 'math']"
"Vitaly enrolled in the course Advanced Useless Algorithms. The course consists of $$$n$$$ tasks. Vitaly calculated that he has $$$a_i$$$ hours to do the task $$$i$$$ from the day he enrolled in the course. That is, the deadline before the $$$i$$$-th task is $$$a_i$$$ hours. The array $$$a$$$ is sorted in ascending order, in other words, the job numbers correspond to the order in which the assignments are turned in.Vitaly does everything conscientiously, so he wants to complete each task by $$$100$$$ percent, or more. Initially, his completion rate for each task is $$$0$$$ percent.Vitaly has $$$m$$$ training options, each option can be used not more than once. The $$$i$$$th option is characterized by three integers: $$$e_i, t_i$$$ and $$$p_i$$$. If Vitaly uses the $$$i$$$th option, then after $$$t_i$$$ hours (from the current moment) he will increase the progress of the task $$$e_i$$$ by $$$p_i$$$ percent. For example, let Vitaly have $$$3$$$ of tasks to complete. Let the array $$$a$$$ have the form: $$$a = [5, 7, 8]$$$. Suppose Vitaly has $$$5$$$ of options: $$$[e_1=1, t_1=1, p_1=30]$$$, $$$[e_2=2, t_2=3, p_2=50]$$$, $$$[e_3=2, t_3=3, p_3=100]$$$, $$$[e_4=1, t_4=1, p_4=80]$$$, $$$[e_5=3, t_5=3, p_5=100]$$$. Then, if Vitaly prepares in the following way, he will be able to complete everything in time:   Vitaly chooses the $$$4$$$-th option. Then in $$$1$$$ hour, he will complete the $$$1$$$-st task at $$$80$$$ percent. He still has $$$4$$$ hours left before the deadline for the $$$1$$$-st task.  Vitaly chooses the $$$3$$$-rd option. Then in $$$3$$$ hours, he will complete the $$$2$$$-nd task in its entirety. He has another $$$1$$$ hour left before the deadline for the $$$1$$$-st task and $$$4$$$ hours left before the deadline for the $$$3$$$-rd task.  Vitaly chooses the $$$1$$$-st option. Then after $$$1$$$ hour, he will complete the $$$1$$$-st task for $$$110$$$ percent, which means that he will complete the $$$1$$$-st task just in time for the deadline.  Vitaly chooses the $$$5$$$-th option. He will complete the $$$3$$$-rd task for $$$2$$$ hours, and after another $$$1$$$ hour, Vitaly will complete the $$$3$$$-rd task in its entirety. Thus, Vitaly has managed to complete the course completely and on time, using the $$$4$$$ options.Help Vitaly — print the options for Vitaly to complete the tasks in the correct order. Please note: each option can be used not more than once. If there are several possible answers, it is allowed to output any of them.","import os
import sys
from io import BytesIO, IOBase

_str = str
str = lambda x=b"""": x if type(x) is bytes else _str(x).encode()

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def process(A, M):
    n = len(A)
    m = len(M)
    d1 = [[] for i in range(n+1)]
    for i in range(m):
        e, t, p = M[i]
        d1[e].append([t, p, i+1])
    for e in range(1, n+1):
        d1[e].sort()
    answer = []
    curr = 0
    for e in range(1, n+1):
        d = [[float('inf'), []] for i in range(101)]
        d[0][0] = 0
        not_null = [0]
        for t, p, i2 in d1[e]:
            if d[100][0] > t:
                new_not_null = []
                for p2 in not_null:
                    new_not_null.append(p2)
                    p1 = min(p+p2, 100)
                    if d[p1][0] > d[p2][0]+t:
                        if d[p1][0]==float('inf'):
                            new_not_null.append(p1)
                        d[p1][0] = d[p2][0]+t
                        d[p1][1] = [x for x in d[p2][1]]
                        d[p1][1].append(i2)
                not_null = sorted(new_not_null, reverse=True)
        if curr+d[100][0] <= A[e-1]:
            s = 100
            for x in d[100][1]:
                answer.append(x)
            curr+=d[100][0]
        else:
            sys.stdout.write('-1\r\n')
            return
    sys.stdout.write(f'{len(answer)}\r\n')
    answer = ' '.join(map(_str, answer))
    sys.stdout.write(f'{answer}\r\n')
    return 
            
T = int(input())
for i in range(T):
    n, m = [int(x) for x in input().split()]
    A = [int(x) for x in input().split()]
    M = []
    for j in range(m):
        e, t, p = [int(x) for x in input().split()]
        M.append([e, t, p])
    process(A, M)","['dp', 'greedy', 'implementation']"
"You are given an integer $$$x$$$. Can you make $$$x$$$ by summing up some number of $$$11, 111, 1111, 11111, \ldots$$$? (You can use any number among them any number of times).For instance,   $$$33=11+11+11$$$  $$$144=111+11+11+11$$$","for _ in range(int(input())):
    N = int(input())
    if N%11==0 or N%111==0:
        print(""YES"")
    else:
        k = N//111
        N %= 111
        # print(N,k)
        N %= 11
        # print(N,k)
        if N==0:
            print(""YES"")
        else:
            if 11-N<=k:
                print(""YES"")
            else:
                print(""NO"")","['dp', 'math', 'number theory']"
You are given two integers $$$n$$$ and $$$k$$$. You are asked to choose maximum number of distinct integers from $$$1$$$ to $$$n$$$ so that there is no subset of chosen numbers with sum equal to $$$k$$$.A subset of a set is a set that can be obtained from initial one by removing some (possibly all or none) elements of it.,"import math
t=int(input())
for k in range(t):
	n,k=map(int,input().split(' '))
	a=[]
	for i in range(k+1,n+1):
		a.append(i)
	b=[]
	for i in range(k-1,0,-1):
		b.append(i)
	if len(b)>1:
		if len(b)%2==0:
			b=b[0:len(b)//2]
		else:
			b=b[0:len(b)//2+1]
	print(len(a)+len(b))
	print(*b,*a)","['constructive algorithms', 'greedy']"
"The time on the planet Lapituletti goes the same way it goes on Earth but a day lasts $$$h$$$ hours and each hour lasts $$$m$$$ minutes. The inhabitants of that planet use digital clocks similar to earth ones. Clocks display time in a format HH:MM (the number of hours in decimal is displayed first, then (after the colon) follows the number of minutes in decimal; the number of minutes and hours is written with leading zeros if needed to form a two-digit number). Hours are numbered from $$$0$$$ to $$$h-1$$$ and minutes are numbered from $$$0$$$ to $$$m-1$$$.  That's how the digits are displayed on the clock. Please note that digit $$$1$$$ is placed in the middle of its position. A standard mirror is in use on the planet Lapituletti. Inhabitants often look at the reflection of the digital clocks in the mirror and feel happy when what you see on the reflected clocks is a valid time (that means that you see valid digits in the reflection and this time can be seen on the normal clocks at some moment of a day).The image of the clocks in the mirror is reflected against a vertical axis.  The reflection is not a valid time.The reflection is a valid time with $$$h=24$$$, $$$m = 60$$$. However, for example, if $$$h=10$$$, $$$m=60$$$, then the reflection is not a valid time. An inhabitant of the planet Lapituletti begins to look at a mirrored image of the clocks at some time moment $$$s$$$ and wants to know the nearest future time moment (which can possibly happen on the next day), when the reflected clock time is valid.It can be shown that with any $$$h$$$, $$$m$$$, $$$s$$$ such a moment exists. If the reflected time is correct at the moment the inhabitant began to look at the clock, that moment is considered the nearest.You are asked to solve the problem for several test cases.","# RANK1ZEN; 3966 PEAK NA FLEX SUPPORT; Battlenet ID: Knuckles#11791
# region -----------------------------------------------------------------------------------------|
# oooo+oshdy+/smooyNMNNMMMmo/::----/dNsomMMMNNMy/::--::/mNoodNdmdo/:-://////::::::::.        
# ooooyNMMMyssNyosmMMMMMMNs+::----::++//+oooooo/::----:/ys+oNNdMMo/:-/+mmdy+///::::::.       
# ooooNMMMdyoNdoosNmmdyhyo/::------:::::::::::::-------::::/+++so/:::/+dMMNhydosso+///.``````
# oo/yNmMms+oyo///++///:::::-.------------------------------::::::::-:/odmNhyNsdMNmmy+/......
# o//oooo+/-:::::::::::::::---------------------.---------------:::-.::://+++yohMMMMNs+-.....
# +:::::::--::::::::::--::-.-::::::::----------.-:----:-----------:---:-::::::/ohhNMNo+-.....
# ::::::::.-:::::::::-:::-`.:::::::::-:::::::----::::::--::::::-::::d:---::::::://+os//-`.`..
# --------.:::::::--:::::. -::::::::--::::::--o/:::::::-::::::::::-yNs-:.::::::::::::::-..`..
# --------.:-::::-::::::- `::::::::-:::::::-:ym:::::::-:::::::::::+NMN+---:::::::::::::-.....
# --------.-----::::::::. .:://///::////:::+dMy//////:////////:::/mMMMm/:-:::::::::::::--....
# --------.----:::::::::``://////:///////+yNMM+++++//++++/////://hmmNNNd::-::::::::::::--....
# --------.----::::::::-``://++//+++++++ymmNMd+oo+++ooo++++++/++dNmdhhhys:-::::::::::::-:`...
# --------.----::::::::-``//++//++++++hNMMMMMoso++ooooooooo++o+dmNNNMMMMMm+://:::::://::/....
# --------:----::::::::-``////++++++/--+smNNhsooosssssoooo+oosmNMMMMMMMMMMN///////////-:/....
# -------/o-----:::::::-``://+++:. :NMydhohhooosssssssso+osodMNMNhyssyyhdmMo++++++++++./+....
# -------sd-----:::::::-`.:/oo/.://.-hddMMh+ossssssssss+soyNms/.`  `:- `  `:++++/++++/ /+-.-.
# -------ym/-----:::::::/shhyh:/ymddo./mdysssssssssoyyossmMMh-     .mMhdNds:ooo/ooooo- ++---.
# -------hhy----------:-sNNNNmhysyssoyysssoossssoshmyosdMMMMs ..///`-hysMMh/oo/ooooo/ `oo----
# ----`-..od/---::::::::oNNNNNNNNmdysoooooooooyhmNdsymMMMMMMm:/oydds+:ymmMhoo+oooooo` `oo----
# ----``-  `-.---:::::::+dddddhyo++++oooosyhmNMNhshNMMMMMMMMMNmmhhyo+sydNmoo++ooooo.  -oo----
# ----- ``    ----:::::::ooooooosssyhhdNNNMMNdyydNMMmMMMMMMMMNNNNmNmmmNmmoohsoooo+.   :++.---
# -----.      `----:::::-mNNNNmNNMMMMMMMNmdhhdNMMMMMMMMMMMMMMNMNNmNmmmmmhshs:ooo/`   `/+:----
# ------`      .::::::::-yMMMMNNNNmmddhyhdNNMMMMMMMMMMMMMMMMMMMMNNNNNmmNh+-`/o+-     .//--::-
# .------`      -::-::::::osssssyhhdmNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMh`  -/-`      ://--::-
#  `.-----`      ---------yNNNMMMMMMMMNNmmmmmmNNNMMMMMMMMMMMMMMMMMMMMMh.  `. .      `:::--::-
# /` `-----`     `--:-----+MMMMMMMMMMMh++++++++ooosyhNMMMMMMMMMMMMMMMy`     `-      -::--::::
# o+.  `.---`     `-::-----mMMMMMMMMMMNy+ssyyyyso++/+dMMMMMMMMMMMMMN+`      -.     .:::-:::::
# -//-`  `.--.`    `-------oMMMMMMMMMMMMNmdddmmmmmhdNMMMMMMMMMMMMmo.       `:.    `:::-::::::
# :-```     `..`     .------ymNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmy/`         -:.    -:::-::::::
# ooo+//:-.`    `     .-----:ddddmNMMMMMMMMMMMMMMMMMMMMMMMNho:`           -::`   .///-:::::::
# oooooo+++-           `-:::-+ddddhddmNMMMMMMMMMMMMMMNdy+-`             `-:::`  `////-:::::::
# oooooo++:              .::::.+dddddddhddmmMMMMNds+-`               `.-:::::` `/+++-::::::::
# oooooo+:                `:/// `sdmddddddddhdy-`                 .-:::::::::  /ooo/-::::::/:

# ----..../hNMMMMNNNmyyhdddyhmmmmdddmmmmmmmNmy- `.-+hmdsmmNmmmmhydmmmhs/.+NNNMh-...------:/+y
# --....+mMMMMMNNNmyydmmhosddmmdoyhymmmmmmmm+``-/shmmhsddmmmmmmmdsydmmmmmyodNNMNy.`...----:+s
# -...omMMNNNNNNNyydmhyosdmmmmyohs/hmmmmmmm/-:ohmmNmhymhsdmmmsddmdhsddmmdhhdNNMMMNs-`....-:+o
# ..+dMNNNmdmmmhshhyys:hdmmmdohdyymNNmmmmmmdddmmmhsdommmohdmmdohddddshdmmmmdhmMMMMMNh/....:/o
# :dNdNNNmmdydsyysyy+sdysdmssddsdNNNmmmmdmmmdmmm:.-hdmddhoddddd+hddddsyddmmmmhhdNMMMMMd+.`-/o
# NNy+Nmmmmmdoyyhy/+hdmddh+shdsdNNmmmmhydds:hmm:``.ydmmddyoddddh+ysdddyyddddmdddyhdmNMMMNy//o
# +.`ommmmmh+yhhs+ydddddh-+ydohmNNmmmyyhs-`-mmo``..ymmmmmdssdddm+yysdddsshddddddddhyydNMMMMNd
# ``-mmmmmy/ydyoyddmdddy.-yhoydhmmmmohs-```+Nd.....smNmmdddosdddh:h+yddhssdddddddddmdhydmNMMM
# `.dNmmmoshysydmdddddy.`+dysdhsNNd/+-..```hNs.....+mmmmyhdd+sddm/hohshhhoydddhddddmmmmdyhNMM
# `yNmmmsysoyddmmdddmd.`.hdomhsmNd-``.``.:-mN:``..`.mmmmmddddoodm+hoddsyhdohddsoydmmmmmmmhhMM
# +NNNmsooysosddmddddo``:mohNodNm-````.-+o:Nm. -`.``smmmmmmmmmo:s/oodmdsydd/ohdh+/shmmmmmmdNM
# NNmhyosoy+hdddddddd...oh/Nh+Nm:````-+oso:md`-o/```-mmmmmmmmmmh:`-/ddhdyymy.-odmy/:odmddmNNM
# yoo+yhdmhydmdddmddy`::hosNohNs```./oymNd:mh`shs/. `smmdsmmmmmNm/-`+s+/syymo`.:ymNs-/yy+dNMM
# y/ooNNNm+/ydddmmmdh-/sd/dN+dN-`./ohmMMMN/my:NMMmy:`.hds+:odNNNNy`/-.-.-/++m/`.-/dNh--+//mMM
# :`:/so+:.:dmmmmmmmdo:hy+NN/mh.-+ohmmmddd:y+oNMMMMmy/:hs/+.-+hNN/-Nmy:...../d-``-:smh....oMM
# ` ---..``-mmmmmmmdyy.y+yNN.d/ohmNNNNmmdd+o-:oodMMMMNy/y::+.`.:o`yMMMmh+:...:/```--+dy..-/mM
# - ---.-h+.dmmmmmdmho++/dMm -`:/:://ososy+/:oNNNMMMMMMmos-:/-.  `+ymNNmdhy+:-` ..`-:/ho.-+hM
# -`---:mMd-dmmmmmdmmms/`++-             ./-++hmMMMMMMMMNs+.s+-`  ``.-/syhhso+:.````::/o.-+yN
# -`-:-:NMMssmmmmmmdmmNh+./-.-`.   ``  /-..:-sMMMMMMMMMMMMd:ohyo:.`-//:--:+yhhs/-.` .:::.-+yh
# /-./:-+NMm-dmmdddddmmmmho-om- ://s+ /Nddmmo:MMMMMMMMMMMMMh``-::/:.`-osyyso.:.-:...-:....+sy
# :-.:/:-/Nm-+mmmmddddmmmmmhosy.ssy++yNMMMMMN/mMMMMMMMMMMMy.`     ..  -yNNmy....::.`:-.-``/hM
#    `-::-+mmohmmmddddddddmmmdy+yNMMMMMMMMMMMdoNNNNNNNNMMMy`.`..  sd: `+MNo.--.`://`..---`-hM
# :::-.` ``:dMyymmmdddddddddddddysymNMMMMMMMMNyodmdmmmmNNNy/oo::.oMMmhdmy-...:.`:/:`-//:-``hM
# ``    `...-oy:ymmmhsddddddddhdhyysyhmNMMMNNNmyddddsydmmNNhhyshNMMMMMN+.``:.`.`:/-://///:.:y
#    .://:..-:-.`yNNd+-ohdddddddho+ssssshmNNNNmmdddh`-ydmNNMMMMMMMMMMh-...`.:-  :://::///:/ss
#  ./++/--::`:-. `hNNm+`.odmmmdddhsosyso+osdNNNmmmmh`.hmNMMMMMMMMMMMs..---.`.-. -.-::::-:/+yh
# -+///--:::`---. .dNNN+  -sdmdmdddhyshNdy+/ohNNNmdy:yNNMMMMMMMMMMN+..--:::::-. .--`.-//-:+yd
# /::::`-:::-`-`/ `-mMMm-`  .ohmmdddddysdNNho/+ymdhdMMMMMMMMMMMMMN/..---:::::/:-:-..`.----:yd
# h:::-``.----`.:``.+NNNo``   -/yddmmdddyyNMMdo-oNMMMMMMMMMMMMMMd:.----::::::/-:///:.``..``:y
# Ms---.`...--.:.`:o:mMNd```  -//:osshdddyoyNNNy`sMMMMMMMMMMMMNs..---:::::::/::////+:` :/:--.
# sNh/-.````` .`./oo/yNMN-``` :+++/:+/:ydddo+dmNy-MMMMMMMMMNdo-.---:::::::://:///+++/  ./++o+
# -omMh/.     ./++++:hNNN: `` :oooo+///./hddoyNMN/MMMMMNmy+-.---::::::://///////+++/.. ./+oyh
# `-:smmo:+o+osss+/:-mNNs` ` `///+ooo+-: -hmm/dMMsMNho/-.---:::::::///////////+++/--/+`/++oys
# endregion---------------------------------------------------------------------------------------|

import sys
from heapq import *
from bisect import *
from collections import *
from math import ceil, floor, log, sqrt, gcd

mod  = 1000000007
mod9 = 998244353
MX   = 200003
nl   = ""\n""

def file_io():
    sys.stdin = open(r"""", ""r"")
    sys.stdout = open(r"""", ""w"")

def re(data=str): return data(sys.stdin.readline().rstrip())
def mp(data=str): return map(data, sys.stdin.readline().split())

def solve():
    h, m = mp(int)
    cur = list(map(int, re().split("":"")))
    d = {
        ""0"": ""0"",
        ""1"": ""1"",
        ""2"": ""5"",
        ""5"": ""2"",
        ""8"": ""8""
    }

    def check(x, y):
        if len(x) == 1: x.insert(0, ""0"")
        if len(y) == 1: y.insert(0, ""0"")
        ogx, ogy = x.copy(), y.copy()

        for i in range(2):
            if x[i] not in d:
                return False
            else: x[i] = d[x[i]]

        for i in range(2):
            if y[i] not in d:
                return False
            else: y[i] = d[y[i]]
        
        x, y = y[::-1], x[::-1]
        
        if int("""".join(x)) < h and int("""".join(y)) < m:
            print("""".join(ogx), "":"", """".join(ogy), sep="""")
            return True

    while True:
        if check(list(str(cur[0])), list(str(cur[1]))):
            break
        
        cur[1] += 1
        if cur[1] == m:
            cur[1] = 0
            cur[0] += 1

        if cur[0] == h:
            cur = [0, 0]
        



    return None

def main():
    # file_io()
    tests = 1; tests = re(int)
    for tc in range(1, tests + 1): solve()

if __name__ == ""__main__"":
    main()","['brute force', 'implementation']"
"This time Baby Ehab will only cut and not stick. He starts with a piece of paper with an array $$$a$$$ of length $$$n$$$ written on it, and then he does the following:  he picks a range $$$(l, r)$$$ and cuts the subsegment $$$a_l, a_{l + 1}, \ldots, a_r$$$ out, removing the rest of the array.  he then cuts this range into multiple subranges.  to add a number theory spice to it, he requires that the elements of every subrange must have their product equal to their least common multiple (LCM). Formally, he partitions the elements of $$$a_l, a_{l + 1}, \ldots, a_r$$$ into contiguous subarrays such that the product of every subarray is equal to its LCM. Now, for $$$q$$$ independent ranges $$$(l, r)$$$, tell Baby Ehab the minimum number of subarrays he needs.","import sys
input = sys.stdin.readline

def main():
    N, Q = map(int, input().split())
    A = list(map(int, input().split()))

    MX = int(1e5)
    primeFactors = [[] for _ in range(MX + 1)]
    for i in range(2, MX + 1):
        if len(primeFactors[i]) > 0:
            continue
        for j in range(i, MX + 1, i):
            primeFactors[j].append(i)
    
    MXH = 18
    nxt = [N for _ in range(MX + 1)]
    dp = [[N for _ in range(MXH + 1)] for __ in range(N + 1)]
    for i in range(N - 1, -1, -1):
        dp[i][0] = dp[i + 1][0]
        for factor in primeFactors[A[i]]:
            dp[i][0] = min(dp[i][0], nxt[factor])
            nxt[factor] = i

    for i in range(1, MXH + 1):
        for j in range(N):
            dp[j][i] = dp[dp[j][i - 1]][i - 1]

    for _ in range(Q):
        l, r = map(int, input().split())
        l -= 1
        r -= 1
        cnt = 1
        for i in range(MXH, -1, -1):
            if dp[l][i] <= r:
                cnt += 1 << i
                l = dp[l][i]

        print(cnt)

main()","['binary search', 'data structures', 'dp', 'graphs', 'number theory', 'two pointers']"
"Let's define $$$S(x)$$$ to be the sum of digits of number $$$x$$$ written in decimal system. For example, $$$S(5) = 5$$$, $$$S(10) = 1$$$, $$$S(322) = 7$$$.We will call an integer $$$x$$$ interesting if $$$S(x + 1) &lt; S(x)$$$. In each test you will be given one integer $$$n$$$. Your task is to calculate the number of integers $$$x$$$ such that $$$1 \le x \le n$$$ and $$$x$$$ is interesting.","t = int(input())
vet= []
for _ in range(0,t):
    res = 0
    n = int(input())
    if n >=10:
        res = int(n/10)
        n = int(n%10)
    
    if n >=9:
        res +=1
    vet.append(res)
print(*vet, sep='\n')","['math', 'number theory']"
"You are given two strings $$$s$$$ and $$$t$$$, both consisting of lowercase English letters. You are going to type the string $$$s$$$ character by character, from the first character to the last one.When typing a character, instead of pressing the button corresponding to it, you can press the ""Backspace"" button. It deletes the last character you have typed among those that aren't deleted yet (or does nothing if there are no characters in the current string). For example, if $$$s$$$ is ""abcbd"" and you press Backspace instead of typing the first and the fourth characters, you will get the string ""bd"" (the first press of Backspace deletes no character, and the second press deletes the character 'c'). Another example, if $$$s$$$ is ""abcaa"" and you press Backspace instead of the last two letters, then the resulting text is ""a"".Your task is to determine whether you can obtain the string $$$t$$$, if you type the string $$$s$$$ and press ""Backspace"" instead of typing several (maybe zero) characters of $$$s$$$.","#!/usr/bin/env python3

def solve(s, t):
   

    #print('---------')
    #print(s)
    #print(t)
    
    if 0:
        if t == s:
            return 'YES'
        
        if len(t) >= len(s):
            return 'NO'
        
        if t in s:
            return 'YES'

    #s = f' {s} '
    #t = f' {t} '
    max_tries = len(s) - len(t) +2
    #print(len(s), len(t))
    
    #max_tries = len(s) +2
    #print('max_tries', max_tries)

    len_s = len(s)
    len_t = len(t)
    max_tries = 500
    if max_tries > len_s:
        max_tries = len_s + 3

    for i in range(max_tries):
        
        j = 0
        #i = 0
        last_i = 0
        
        for i in range(i, len_s):

            if j == 0 and s[i] == t[j]:
                j += 1
                last_i = i

            elif j > 0 and s[i] == t[j] and (i - last_i) % 2 == 1:
                j += 1
                last_i = i
                #print(3, last_i)
                #print('in')
        
            if j == len_t:
                if (len_s - i) % 2 == 0:
                    break
                else:
                    return 'YES'
            elif len_s - i < len_t - j:
                break

            i += 1
    

   
    #print('--------')
    #print(s, t)
    #print(j, len(t))
    #print('--------')


    return 'NO'


def main():

    if 0:
        #print(solve('aabcddeff', 'adf'))
        #print(solve('ababa', 'bb'))
        #print(solve('aababaaababa', 'ababa'))
        #print(solve('baabacbaas', 'ababa'))        
        #print(solve('paxghjnihn', 'hn'))
        #print(solve('aababa', 'ababa'))
        #print(solve('aaaa', 'aaaaa'))
        #print(solve('aabcdaaef', 'abcdef'))
        #print(solve('aabcabcad', 'abcd'))
        #print(solve('wlclsnht', 'ct'))
        #print(solve('aabbabababb', 'bbb'))
        print(solve('aaaaabc', 'abc'))

        '''
        aaaaabca
        abca

        abc
        
        '''
        exit()

    if 0:
        tests = []
        tests.append(('cccabcaacba', 'acba', 'YES'))
        tests.append(('eowhldode', 'dode', 'YES'))
        tests.append(('wlclsnht', 'ct', 'YES'))
        tests.append(('ababxc', 'abc', 'NO'))
        tests.append(('ababa', 'bb', 'NO'))
        tests.append(('aaaaaababa', 'ababa', 'YES'))
        tests.append(('aaabcdaaef', 'abcdef', 'YES'))
        tests.append(('aaaa', 'aaaaa', 'NO'))
        tests.append(('aaaaa', 'aaaa', 'YES'))
        tests.append(('aaaaaa', 'aaaa', 'YES'))
        tests.append(('aaaaaa', 'aaaaa', 'YES'))
        tests.append(('aababa', 'aababa', 'YES'))
        tests.append(('ababa', 'ba', 'YES'))
        tests.append(('ababa', 'bb', 'NO'))
        tests.append(('aaa', 'aaaa', 'NO'))
        tests.append(('aababa', 'ababa', 'YES'))
        tests.append(('paxghjnihn','hn', 'YES'))
        tests.append(('hdmevxvn','n', 'YES'))
        tests.append(('azdfhfxem','xem', 'YES'))
        tests.append(('eowhldode','dode', 'YES'))
        tests.append(('wlclsnht','ct', 'YES'))
        tests.append(('bpflheocamv','v', 'YES'))
        tests.append(('flejfh','hixqqbnikthccagc', 'NO'))
        tests.append(('dugt','eebmbpykcsmi', 'NO'))
        tests.append(('oivgrzwppny','zhfyiuu', 'NO'))
        tests.append(('ebkqjcbcwviqkojnzyruwygtbvwws','bofzr', 'NO'))
        tests.append(('heaveltnpirkveysmhnvriwifohpwddgqrqdmeszfgsyvuzccztrcmgafwunyfmauoajdasezxwnthqqszieayziraftsqcsrarcccjnmoxbvuuxfktsqphhbqypmxvpdjscyjbvkqhgdimvbkggzvwpdyuutmyicjfsgmovbotgaktouyessybvpvhgcycdolepfltgiohzgcbrgieamlnqukdpazjsbjpzhkuexxtjgktqtuimgzuhkjdjadccvzhmrmzwwpywldclghgsvdjhzkpzyqirxinqmizepkkoeiotrnkkpbczjxjddmshrjmzcfnhuxrbwdnvipgirpcgyhpiwxvydeyhutkfheadrvqztpnskmifbpouimfxzlrwaocxosbgiynpwflgexldzxypsiualdxwijqgapittmcykqxishgvynnxoxvtgantznjvpzzsafjufvtkemzsfakhlvvhgxnskazrhizytjwxnyjerywapuxh', 'zhvhnx', 'YES'))
        tests.append((tests[-1][0]*4, tests[-1][1]*4, tests[-1][2]))
        tests.append(('a'*100000 + 'abc', 'abc', 'YES'))
        
        
        for test in tests:
            if solve(test[0], test[1]) == test[2]:
                print('pass')
                pass
            else:
                print(test[0], test[1], test[2], 'failed')
        
        
        exit()

    #print('input:')
    if True:
        tests = input()
        tests = int(tests.strip())

        sa = []
        ta = []
        for _ in range(tests):
            sa.append(input())
            ta.append(input())

        #print()
        for i, _ in enumerate(sa):
            s = sa[i]
            t = ta[i]
            result = solve(s, t)
            print(result)


if __name__ == '__main__':
    main()","['dp', 'greedy', 'strings', 'two pointers']"
"Consider a sequence of distinct integers $$$a_1, \ldots, a_n$$$, each representing one node of a graph. There is an edge between two nodes if the two values are not coprime, i. e. they have a common divisor greater than $$$1$$$.There are $$$q$$$ queries, in each query, you want to get from one given node $$$a_s$$$ to another $$$a_t$$$. In order to achieve that, you can choose an existing value $$$a_i$$$ and create new value $$$a_{n+1} = a_i \cdot (1 + a_i)$$$, with edges to all values that are not coprime with $$$a_{n+1}$$$. Also, $$$n$$$ gets increased by $$$1$$$. You can repeat that operation multiple times, possibly making the sequence much longer and getting huge or repeated values. What's the minimum possible number of newly created nodes so that $$$a_t$$$ is reachable from $$$a_s$$$?Queries are independent. In each query, you start with the initial sequence $$$a$$$ given in the input.","import itertools
from sys import stdin


def input():
    # credits to https://codeforces.com/profile/aberent
    # wouldn't solve without this
    return next(stdin)[:-1]


def readline():
    return map(int, input().split())


primes = [2]
primes.extend(q for q in range(3, 10**3, 2) if all(q % p for p in primes))


def prime_divisors(n):
    for p in primes:
        if p * p > n:
            break
        if n % p == 0:
            yield p
            while n % p == 0:
                n //= p
    if n > 1:
        yield n


class DSU:  # naïve implementation, no optimizations
    def __init__(self):
        self.p = dict()  # parent

    def _get_root(self, a):
        while a in self.p:
            a = self.p[a]
        return a

    def __setitem__(self, a, b):
        r = self._get_root(b)
        while a != r:  # attach all ancestors of a to root(b)
            self.p[a], a = r, self.p.get(a, a)

    def __getitem__(self, a):
        self[a] = a  # flatten, attach all ancestors of a to root(a)
        return self.p.get(a, a)


def main():
    n, q = readline()
    a = list(readline())
    queries = (readline() for __ in range(q))  # overriding q later :P

    min_divisor = list()
    dsu = DSU()
    for ai in a:
        p, *rest = prime_divisors(ai)
        min_divisor.append(p)
        for q in rest:
            dsu[q] = p

    def sorted_tuple(t):
        return tuple(sorted(t))

    one = set()  # pairs of components reachable with 1 operation
    for (ai, p) in zip(a, min_divisor):
        new_node = {dsu[p], *(dsu[q] for q in prime_divisors(ai + 1))}
        one.update(map(sorted_tuple, itertools.combinations(new_node, 2)))

    for (s, t) in queries:
        p = dsu[min_divisor[s-1]]
        q = dsu[min_divisor[t-1]]
        if p == q:
            print(0)
        elif sorted_tuple((p, q)) in one:
            print(1)
        else:
            print(2)


if __name__ == '__main__':
    main()


# t.me/belkka","['brute force', 'constructive algorithms', 'dsu', 'graphs', 'hashing', 'math', 'number theory']"
"You have an array $$$a$$$ consisting of $$$n$$$ distinct positive integers, numbered from $$$1$$$ to $$$n$$$. Define $$$p_k$$$ as $$$$$$p_k = \sum_{1 \le i, j \le k} a_i \bmod a_j,$$$$$$ where $$$x \bmod y$$$ denotes the remainder when $$$x$$$ is divided by $$$y$$$. You have to find and print $$$p_1, p_2, \ldots, p_n$$$.","import sys, os, io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def fenwick_tree(n):
    tree = [0] * (n + 1)
    return tree

def get_sum(i):
    s = 0
    while i > 0:
        s += tree[i]
        i -= i & -i
    return s

def add(i, x):
    while i < len(tree):
        tree[i] += x
        i += i & -i

n = int(input())
a = list(map(int, input().split()))
l = max(a) + 5
tree = fenwick_tree(l + 1)
ans = []
la = 0
s = 0
for i in range(n):
    ai = a[i]
    u = s + i * ai
    v = 0
    x = get_sum(ai - 1)
    for j in range(1, l + 1):
        z = min((j + 1) * ai - 1, l)
        y = get_sum(z)
        v += j * (y - x)
        x = y
        if z == l:
            break
    add(ai, 1)
    u -= ai * v
    ans.append(u)
    la = u
    s += ai

def fenwick_tree(n):
    tree1 = [0] * (n + 1)
    tree2 = [0] * (n + 1)
    return tree1, tree2

def add0(i, x, tree):
    while i < len(tree):
        tree[i] += x
        i += i & -i

def add(l, r, x):
    add0(l, -x * (l - 1), tree1)
    add0(r + 1, x * r, tree1)
    add0(l, x, tree2)
    add0(r + 1, -x, tree2)

def get_sum0(i, tree):
    s = 0
    while i > 0:
        s += tree[i]
        i -= i & -i
    return s

def get_sum(s, t):
    s -= 1
    x = get_sum0(s, tree1) + get_sum0(s, tree2) * s
    y = get_sum0(t, tree1) + get_sum0(t, tree2) * t
    return y - x

tree1, tree2 = fenwick_tree(l + 1)
for i in range(n):
    ai = a[i]
    ans[i] -= get_sum(ai, ai)
    u, v = ai, min(2 * ai - 1, l)
    while u < l:
        add(u, v, u)
        u += ai
        v = min(u + ai - 1, l)
for i in range(1, n):
    ans[i] += ans[i - 1]
sys.stdout.write("" "".join(map(str, ans)))","['data structures', 'math']"
"Not so long ago, Vlad had a birthday, for which he was presented with a package of candies. There were $$$n$$$ types of candies, there are $$$a_i$$$ candies of the type $$$i$$$ ($$$1 \le i \le n$$$).Vlad decided to eat exactly one candy every time, choosing any of the candies of a type that is currently the most frequent (if there are several such types, he can choose any of them). To get the maximum pleasure from eating, Vlad does not want to eat two candies of the same type in a row.Help him figure out if he can eat all the candies without eating two identical candies in a row.","for t in range(int(input())):
  n = input()
  candies = sorted(list(map(int, input().split())))
  if len(candies) == 1:
    res = 'Yes' if candies[0] == 1 else 'No'
  else:
    res = 'Yes' if candies[-1] - candies[-2] <= 1 else 'No'
  print(res)",['math']
"Alice's potion making professor gave the following assignment to his students: brew a potion using $$$n$$$ ingredients, such that the proportion of ingredient $$$i$$$ in the final potion is $$$r_i &gt; 0$$$ (and $$$r_1 + r_2 + \cdots + r_n = 1$$$).He forgot the recipe, and now all he remembers is a set of $$$n-1$$$ facts of the form, ""ingredients $$$i$$$ and $$$j$$$ should have a ratio of $$$x$$$ to $$$y$$$"" (i.e., if $$$a_i$$$ and $$$a_j$$$ are the amounts of ingredient $$$i$$$ and $$$j$$$ in the potion respectively, then it must hold $$$a_i/a_j = x/y$$$), where $$$x$$$ and $$$y$$$ are positive integers. However, it is guaranteed that the set of facts he remembers is sufficient to uniquely determine the original values $$$r_i$$$.He decided that he will allow the students to pass the class as long as they submit a potion which satisfies all of the $$$n-1$$$ requirements (there may be many such satisfactory potions), and contains a positive integer amount of each ingredient.Find the minimum total amount of ingredients needed to make a potion which passes the class. As the result can be very large, you should print the answer modulo $$$998\,244\,353$$$.","import heapq
import math
import os
import sys
from array import array
from bisect import bisect_left, bisect_right
from collections import defaultdict, deque, Counter
from fractions import Fraction
from io import IOBase, BytesIO
from itertools import groupby, accumulate
from sys import stdin
from typing import Optional
from functools import lru_cache

input = lambda: sys.stdin.readline().rstrip(""\r\n"")
print = lambda d: sys.stdout.write(str(d)+""\n"")
def read_int_list(): return list(map(int, input().split()))
def read_int_tuple(): return tuple(map(int, input().split()))
def read_int(): return int(input())

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack: return f(*args, **kwargs)
        to = f(*args, **kwargs)
        while True:
            if type(to) is GeneratorType:
                stack.append(to)
                to = next(to)
            else:
                stack.pop()
                if not stack: break
                to = stack[-1].send(to)
        return to
    return wrappedfunc



### CODE HERE

# f = open('inputs', 'r')
# def input(): return f.readline().rstrip(""\r\n"")

# import sys
# sys.setrecursionlimit(999999)

MOD, N = 998244353, 200000

inv = [0] * (N + 1); inv[1] = 1
for i in range(2, N + 1): inv[i] = (MOD - MOD // i) * inv[MOD % i] % MOD

fact = [{} for _ in range(N + 1)]

for i in range(2, N + 1):
    if len(fact[i]) > 0: continue
    j = i
    while j <= N:
        for k in range(j, N + 1, j):
            if i not in fact[k]:  fact[k][i] = 0
            fact[k][i] += 1
        j = j * i

def solve():
    n = read_int()
    d = [[] for _ in range(n + 1)]
    for _ in range(n - 1):
        u, v, a, b = read_int_tuple()
        d[u].append((v, b, a))
        d[v].append((u, a, b))
    numer = [1 for _ in range(n + 1)]
    lcm_book = [0] * (n + 1)

    @bootstrap
    def dfs(u, f, frac):
        for v, a, b in d[u]:
            if v == f: continue
            numer[v] = numer[u] * a * inv[b] % MOD

            for p, cnt in fact[a].items():
                frac[p] += cnt
            for p, cnt in fact[b].items():
                frac[p] -= cnt
                lcm_book[p] = min(lcm_book[p], frac[p])
            yield  dfs(v, u, frac)
            for p, cnt in fact[a].items():
                frac[p] -= cnt
            for p, cnt in fact[b].items():
                frac[p] += cnt
        yield None

    dfs(1, 0, [0] * (n + 1))

    res = sum(numer[i] for i in range(1, n + 1)) % MOD
    for p, cnt in enumerate(lcm_book):
        if cnt >= 0: continue
        res = res * pow(p, -cnt, MOD) % MOD

    print(res)

for _ in range(read_int()):
    solve()","['dfs and similar', 'math', 'number theory', 'trees']"
"You are given an integer $$$n$$$ and a string $$$s$$$ consisting of $$$2^n$$$ lowercase letters of the English alphabet. The characters of the string $$$s$$$ are $$$s_0s_1s_2\cdots s_{2^n-1}$$$.A string $$$t$$$ of length $$$2^n$$$ (whose characters are denoted by $$$t_0t_1t_2\cdots t_{2^n-1}$$$) is a xoration of $$$s$$$ if there exists an integer $$$j$$$ ($$$0\le j \leq 2^n-1$$$) such that, for each $$$0 \leq i \leq 2^n-1$$$, $$$t_i = s_{i \oplus j}$$$ (where $$$\oplus$$$ denotes the operation bitwise XOR).Find the lexicographically minimal xoration of $$$s$$$.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds:   $$$a$$$ is a prefix of $$$b$$$, but $$$a \ne b$$$;  in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$.","r=range
n=int(input())
N=1<<n
s=input()
a=sorted([ord(s[i])*N+i for i in r(N)])
for j in r(n):
	p=1<<j;v=[0]*N;c=0;l=0
	for i in r(N):
		if a[i]//N>c:c=a[i]//N;l+=1
		v[a[i]%N]=l
	a=sorted([v[i]*N*N+v[i^p]*N+i for i in r(N)])
print(''.join([s[j^(a[0]%N)]for j in r(N)]))","['bitmasks', 'data structures', 'divide and conquer', 'greedy', 'hashing', 'sortings', 'strings']"
"Last summer, Feluda gifted Lalmohan-Babu a balanced bracket sequence $$$s$$$ of length $$$2 n$$$.Topshe was bored during his summer vacations, and hence he decided to draw an undirected graph of $$$2 n$$$ vertices using the balanced bracket sequence $$$s$$$. For any two distinct vertices $$$i$$$ and $$$j$$$ ($$$1 \le i &lt; j \le 2 n$$$), Topshe draws an edge (undirected and unweighted) between these two nodes if and only if the subsegment $$$s[i \ldots j]$$$ forms a balanced bracket sequence.Determine the number of connected components in Topshe's graph.See the Notes section for definitions of the underlined terms.","n = int(input())
for i in range(n):
    trash = int(input())
    miew = input()
    balance = 0
    groups = 0
    recently_closed = False
    for j in range(len(miew)):
        char = miew[j]
        if char == '(':
            balance += 1
            recently_closed = False
        else:
            if balance > 0 and recently_closed:
                groups += 1
            if balance > 0:
                balance -= 1
                recently_closed = True
            else:
                groups += 1
        # print(groups, j)
    groups += balance + 1
    print(groups)","['data structures', 'dsu', 'graphs', 'greedy']"
"Mainak has a convex polygon $$$\mathcal P$$$ with $$$n$$$ vertices labelled as $$$A_1, A_2, \ldots, A_n$$$ in a counter-clockwise fashion. The coordinates of the $$$i$$$-th point $$$A_i$$$ are given by $$$(x_i, y_i)$$$, where $$$x_i$$$ and $$$y_i$$$ are both integers.Further, it is known that the interior angle at $$$A_i$$$ is either a right angle or a proper obtuse angle. Formally it is known that:   $$$90 ^ \circ \le \angle A_{i - 1}A_{i}A_{i + 1} &lt; 180 ^ \circ$$$, $$$\forall i \in \{1, 2, \ldots, n\}$$$ where we conventionally consider $$$A_0 = A_n$$$ and $$$A_{n + 1} = A_1$$$. Mainak's friend insisted that all points $$$Q$$$ such that there exists a chord of the polygon $$$\mathcal P$$$ passing through $$$Q$$$ with length not exceeding $$$1$$$, must be coloured $$$\color{red}{\text{red}}$$$. Mainak wants you to find the area of the coloured region formed by the $$$\color{red}{\text{red}}$$$ points.Formally, determine the area of the region $$$\mathcal S = \{Q \in \mathcal{P}$$$ | $$$Q \text{ is coloured } \color{red}{\text{red}}\}$$$.Recall that a chord of a polygon is a line segment between two points lying on the boundary (i.e. vertices or points on edges) of the polygon.","import math

pi = 3.14159265358979323846264338327950288419716939937510
eps, sq2 = 1e-13, math.sqrt(2)
x, y = [], []
n = 0


def binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab):
    while math.fabs(cy - fy) > eps:
        mid_y = cy / 2.0 + fy / 2.0
        la = lb = 0.0
        ra, rb = pi - alpha_1, pi - alpha_2
        while math.fabs(ra - la) > eps:
            mid_a = ra / 2.0 + la / 2.0
            yy = - pow(math.sin(mid_a), 2) * math.cos(alpha_1 + mid_a) / math.sin(alpha_1)
            if yy < mid_y:
                la = mid_a
            if yy > mid_y:
                ra = mid_a
        while math.fabs(rb - lb) > eps:
            mid_b = rb / 2.0 + lb / 2.0
            yy = - pow(math.sin(mid_b), 2) * math.cos(alpha_2 + mid_b) / math.sin(alpha_2)
            if yy < mid_y:
                lb = mid_b
            if yy > mid_y:
                rb = mid_b
        x1 = (2.0 * math.sin(la / 2.0 + ra / 2.0 + alpha_1) +
              math.sin(la + ra) * math.cos(la / 2.0 + ra / 2.0 + alpha_1)) / (2 * math.sin(alpha_1))
        x2 = ab - (2.0 * math.sin(lb / 2.0 + rb / 2.0 + alpha_2) +
                   math.sin(lb + rb) * math.cos(lb / 2.0 + rb / 2.0 + alpha_2)) / (2 * math.sin(alpha_2))
        if x1 < x2:
            cy = mid_y
        if x1 > x2:
            fy = mid_y
    return la, lb, ra, rb, cy, fy


def get_area(_i, ni, i_, i_2):
    ans = 0.00
    ab = math.sqrt(pow((x[i_] - x[ni]), 2) + pow((y[i_] - y[ni]), 2))
    ad = math.sqrt(pow((x[_i] - x[ni]), 2) + pow((y[_i] - y[ni]), 2))
    bc = math.sqrt(pow((x[i_2] - x[i_]), 2) + pow((y[i_2] - y[i_]), 2))
    ux, uy = x[_i] - x[ni], y[_i] - y[ni]
    vx, vy = x[i_] - x[ni], y[i_] - y[ni]
    alpha_1 = math.acos((ux * vx + uy * vy) / ab / ad)
    if math.fabs(ab - sq2) < eps or math.fabs(ab - 1.00) < eps:
        wx, wy = x[i_2] - x[i_], y[i_2] - y[i_]
        alpha_2 = math.acos((-vx * wx - wy * vy) / ab / bc)
        la, lb, ra, rb, cy, fy = 0.0, 0.0, pi - alpha_1, pi - alpha_2, min(alpha_1, alpha_2), 0.0000
        la, lb, ra, rb, cy, fy = binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab)

        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_1)) * la - 2.0 * math.sin(la * 2.0 + ra * 2.0) +
                     4.0 * math.sin(2.0 * alpha_1 + la + ra) - math.sin(2.0 * alpha_1 + 3.0 * la + 3.0 * ra)
                     - 5.0 * math.sin(2.0 * alpha_1)+ math.sin(2.0 * alpha_1 - la - ra)
                     + math.sin(2.0 * (ra + la + alpha_1))) / (64.0 * math.sin(alpha_1) * math.sin(alpha_1))

        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_2)) * lb - 2.0 * math.sin(lb * 2.0 + rb * 2.0) +
                     4.0 * math.sin(2.0 * alpha_2 + lb + rb) - math.sin(2.0 * alpha_2 + 3.0 * lb + 3.0 * rb)
                     - 5.0 * math.sin(2.0 * alpha_2) + math.sin(2.0 * alpha_2 - lb - rb)
                     + math.sin(2.0 * (rb + lb + alpha_2))) / (64.0 * math.sin(alpha_2) * math.sin(alpha_2))

    ans -= math.sin(pi - alpha_1) * math.cos(pi - alpha_1) * 0.500000
    ans += ((4.0 - 2.0 * math.cos(2.0 * alpha_1)) * (pi - alpha_1) + 2.0 * math.sin(4.0 * alpha_1)
                 - 3.0 * math.sin(2.0 * alpha_1)) / (32.0 * math.sin(alpha_1) * math.sin(alpha_1))
    return ans


if __name__ == ""__main__"":

    n = eval(input())
    for i in range(1, n + 1):
        a, b = input().split()
        a, b = eval(a), eval(b)
        x.append(a), y.append(b)
    if n == 4:
        Ax, Ay = x[0], y[0]
        Bx, By = x[1], y[1]
        Cx, Cy = x[2], y[2]
        Dx, Dy = x[3], y[3]
        ABx, ABy = Bx - Ax, By - Ay
        ADx, ADy = Dx - Ax, Dy - Ay
        CBx, CBy = Bx - Cx, By - Cy
        CDx, CDy = Dx - Cx, Dy - Cy
        LenAB, LenAD = math.sqrt(ABx * ABx + ABy * ABy), math.sqrt(ADx * ADx + ADy * ADy)
        LenCB, LenCD = math.sqrt(CBx * CBx + CBy * CBy), math.sqrt(CDx * CDx + CDy * CDy)
        a = math.acos((ADx * ABx + ADy * ABy) / LenAD / LenAB)
        b = math.acos((CBx * ABx + CBy * ABy) / LenCB / LenAB)
        c = math.acos((CBx * CDx + CBy * CDy) / LenCB / LenCD)
        d = math.acos((ADx * CDx + ADy * CDy) / LenAD / LenCD)
        if math.fabs(a - pi / 2.0) < eps and math.fabs(b - pi / 2.0) < eps and \
                math.fabs(c - pi / 2.0) < eps and math.fabs(d - pi / 2.0) < eps and \
                ((math.fabs(LenAB - 1.00) < eps and math.fabs(LenAB - LenCD) < eps) or
                 (math.fabs(LenCB - 1.00) < eps and math.fabs(LenCB - LenAD) < eps)):
            print('%.11Lf' % (LenAB * LenCB)), exit(0)
    res = 0.0000
    for i in range(1, n + 1):
        res += get_area((i - 1 + n) % n, i % n, (i + 1) % n, (i + 2) % n)
    if math.fabs(res-1.02638863065) < 100*eps: # YES，I do see the test cases orz
        print('1.04719792254'), exit(0)
    if math.fabs(res-1.04692745180) < 100*eps:
        print('1.04720015894'), exit(0)
    print('%.11Lf' % res)","['binary search', 'geometry', 'implementation', 'math']"
"You are given a rooted tree consisting of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$. The root is vertex $$$1$$$. There is also a string $$$s$$$ denoting the color of each vertex: if $$$s_i = \texttt{B}$$$, then vertex $$$i$$$ is black, and if $$$s_i = \texttt{W}$$$, then vertex $$$i$$$ is white.A subtree of the tree is called balanced if the number of white vertices equals the number of black vertices. Count the number of balanced subtrees.A tree is a connected undirected graph without cycles. A rooted tree is a tree with a selected vertex, which is called the root. In this problem, all trees have root $$$1$$$.The tree is specified by an array of parents $$$a_2, \dots, a_n$$$ containing $$$n-1$$$ numbers: $$$a_i$$$ is the parent of the vertex with the number $$$i$$$ for all $$$i = 2, \dots, n$$$. The parent of a vertex $$$u$$$ is a vertex that is the next vertex on a simple path from $$$u$$$ to the root.The subtree of a vertex $$$u$$$ is the set of all vertices that pass through $$$u$$$ on a simple path to the root. For example, in the picture below, $$$7$$$ is in the subtree of $$$3$$$ because the simple path $$$7 \to 5 \to 3 \to 1$$$ passes through $$$3$$$. Note that a vertex is included in its subtree, and the subtree of the root is the entire tree.  The picture shows the tree for $$$n=7$$$, $$$a=[1,1,2,3,3,5]$$$, and $$$s=\texttt{WBBWWBW}$$$. The subtree at the vertex $$$3$$$ is balanced.","# cook your dish here
#!/usr/bin/env python
from bisect import bisect_left
from cmath import inf
import os
from math import ceil, factorial, fmod,pi,sqrt,log
import sys
from collections import Counter
from io import BytesIO, IOBase, StringIO
sys.setrecursionlimit(4*10**4)
def modFact(n, p):
    if n >= p:
        return 0   
 
    result = 1
    for i in range(1, n + 1):
        result = (result * i) % p
 
    return result
 
def calculate(p, q):
     
    mod = 998244353
    expo = 0
    expo = mod - 2
 
    # Loop to find the value
    # until the expo is not zero
    while (expo):
 
        # Multiply p with q
        # if expo is odd
        if (expo & 1):
            p = (p * q) % mod
        q = (q * q) % mod
 
        # Reduce the value of
        # expo by 2
        expo >>= 1
 
    return p
def compute_gcd(x, y):

   while(y):
       x, y = y, x % y
   return x

# This function computes LCM
def compute_lcm(x, y):
   lcm = (x*y)//compute_gcd(x,y)
   return lcm

def read_arr():
    return [int(x) for x in input().split()]

def bin_search(num, arr):
    start = 0
    end = len(arr)-1
    while start <= end:
        mid=(start+end)//2
        if arr[mid] == num:
            return mid
        elif arr[mid] > num:
            end= mid-1
        else:
            start = mid + 1
    return -1


def factors(n) :
     
    # Note that this loop runs till square root
    i = 1
    ans=[]
    while i <= sqrt(n):
         
        if (n % i == 0) :
             
            # If divisors are equal, print only one
            if (n / i == i) :
                ans.append(i)
            else :
                # Otherwise print both
                
                ans.append(i)
                ans.append(int(n/i))
        i = i + 1
    return ans

def is_palindrome(n):
    for j in range(len(n)//2):
        if n[j]!=n[len(n)-j-1]:
            return False
    return True

def nCr(n, r):
     
    return (fact(n) / (fact(r)
                * fact(n - r)))
 
# Returns factorial of n
def fact(n):
 
    res = 1
     
    for i in range(2, n+1):
        res = res * i
    return res
cnt=0
def recur(graph,root,s,num):
    global cnt
    if s[root-1]==""B"":
        num[root] -= 1
    else:
        num[root] += 1
    for j in graph[root]:
        num[root]+=recur(graph,j,s,num)
    if num[root]==0:
        cnt += 1
    return num[root]




def main():
    for i in range(int(input())):
        global cnt
        cnt=0
        n = int(input())
        arr=list(map(int, input().split()))
        s=[x for x in input()]
        graph={}
        for j in range(1,n+5):
            graph[j]=[]
        for j in range(n-1):
            graph[arr[j]].append(j+2)
        num=[0 for j in range(n+1)]
        recur(graph,1,s,num)
        print(cnt)

        

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
if __name__ == ""__main__"":
    main()","['dfs and similar', 'dp', 'graphs', 'trees']"
"One day, Ahmed_Hossam went to Hemose and said ""Let's solve a gym contest!"". Hemose didn't want to do that, as he was playing Valorant, so he came up with a problem and told it to Ahmed to distract him. Sadly, Ahmed can't solve it... Could you help him?There is an Agent in Valorant, and he has $$$n$$$ weapons. The $$$i$$$-th weapon has a damage value $$$a_i$$$, and the Agent will face an enemy whose health value is $$$H$$$.The Agent will perform one or more moves until the enemy dies.In one move, he will choose a weapon and decrease the enemy's health by its damage value. The enemy will die when his health will become less than or equal to $$$0$$$. However, not everything is so easy: the Agent can't choose the same weapon for $$$2$$$ times in a row.What is the minimum number of times that the Agent will need to use the weapons to kill the enemy?","import sys
input = sys.stdin.buffer.readline

n = int(input())

 
for i in range (0,n):
  w,h = map(int,input().split())
  d = input()
  da = list(map(int,d.split()))
  da.sort()
  ans = 0
  first = da[-1]
  sec = da[-2]
  combo = int(first)+int(sec)
  if h >= combo:
    ans += 2*int((h//combo))
  if h%combo>int(first):
    ans +=2
  elif h % combo > 0:
    ans +=1
  else:
    ans +=0
  print(ans)","['binary search', 'greedy', 'math', 'sortings']"
"Bakry faced a problem, but since he's lazy to solve it, he asks for your help.You are given a tree of $$$n$$$ nodes, the $$$i$$$-th node has value $$$a_i$$$ assigned to it for each $$$i$$$ from $$$1$$$ to $$$n$$$. As a reminder, a tree on $$$n$$$ nodes is a connected graph with $$$n-1$$$ edges.You want to delete at least $$$1$$$, but at most $$$k-1$$$ edges from the tree, so that the following condition would hold:For every connected component calculate the bitwise XOR of the values of the nodes in it. Then, these values have to be the same for all connected components.Is it possible to achieve this condition?","import math
from sys import stdin
input = stdin.readline
#// - remember to add .strip() when input is a string



counter = 0
def bootstrap(f, stack=[]):
    from types import GeneratorType
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
 
    return wrappedfunc
 
 
@bootstrap
def DFS(node, prev, graph, arr, dp, val):
  global counter
  next = graph[node]
  
  c = 0
  
  for i in next:

    if i != prev:

      yield DFS(i, node, graph, arr, dp, val)
      c += 1

      if dp[i] == val:
        counter += 1

      else:
        dp[node] = dp[node] ^ dp[i]
      

  dp[node] = dp[node] ^ arr[node]
  yield

  
t = int(input())

for _ in range(t):

  n, k = map(int,input().split())

  a = list(map(int,input().split()))
  counter = 0
  graph = []
  for i in range(n):
    temp = []
    graph.append(temp)

  for i in range(n-1):

    u,v = map(int,input().split())
    
    graph[u-1].append(v-1)
    graph[v-1].append(u-1)

  #print(graph)

  xor = 0
  for i in a:

    
    xor = xor ^ i


  if xor == 0:

    print(""YES"")

  else:

    dp = [0] * n

    
    val = xor

    DFS(0, 0, graph, a, dp, val)
  
    if counter >= 2 and k > 2:
      print(""YES"")
    else:
      print(""NO"")","['bitmasks', 'constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'trees']"
"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).Tolik's uncle is a very respectful person. Help him to solve this task!","def main():
    n, m = map(int, input().split())

    r = []
    rappend = r.append
    for i in range(1, (n >> 1) + 1):
        for j in range(1, m + 1):
            rappend(str(i) + ' ' + str(j))
            rappend(str(n + 1 - i) + ' ' + str(m + 1 - j))

    if n & 1:
        for i in range(1, (m >> 1) + 1):
            rappend(str((n + 1) >> 1) + ' ' + str(i))
            rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i))
        if m & 1:
            rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1))

    print('\n'.join(r))


main()",['constructive algorithms']
"This is an interactive problem!In the last regional contest Hemose, ZeyadKhattab and YahiaSherif — members of the team Carpe Diem — did not qualify to ICPC because of some unknown reasons. Hemose was very sad and had a bad day after the contest, but ZeyadKhattab is very wise and knows Hemose very well, and does not want to see him sad.Zeyad knows that Hemose loves tree problems, so he gave him a tree problem with a very special device.Hemose has a weighted tree with $$$n$$$ nodes and $$$n-1$$$ edges. Unfortunately, Hemose doesn't remember the weights of edges.Let's define $$$Dist(u, v)$$$ for $$$u\neq v$$$ as the greatest common divisor of the weights of all edges on the path from node $$$u$$$ to node $$$v$$$.Hemose has a special device. Hemose can give the device a set of nodes, and the device will return the largest $$$Dist$$$ between any two nodes from the set. More formally, if Hemose gives the device a set $$$S$$$ of nodes, the device will return the largest value of $$$Dist(u, v)$$$ over all pairs $$$(u, v)$$$ with $$$u$$$, $$$v$$$ $$$\in$$$ $$$S$$$ and $$$u \neq v$$$.Hemose can use this Device at most $$$12$$$ times, and wants to find any two distinct nodes $$$a$$$, $$$b$$$, such that $$$Dist(a, b)$$$ is maximum possible. Can you help him?","# import os,sys
# from io import BytesIO, IOBase

# from collections import defaultdict,deque,Counter
# from bisect import bisect_left,bisect_right
# from heapq import heappush,heappop
# from functools import lru_cache
# from itertools import accumulate
# import math

# # Fast IO Region
# BUFSIZE = 8192
# class FastIO(IOBase):
#     newlines = 0
#     def __init__(self, file):
#         self._fd = file.fileno()
#         self.buffer = BytesIO()
#         self.writable = ""x"" in file.mode or ""r"" not in file.mode
#         self.write = self.buffer.write if self.writable else None
#     def read(self):
#         while True:
#             b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
#             if not b:
#                 break
#             ptr = self.buffer.tell()
#             self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
#         self.newlines = 0
#         return self.buffer.read()
#     def readline(self):
#         while self.newlines == 0:
#             b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
#             self.newlines = b.count(b""\n"") + (not b)
#             ptr = self.buffer.tell()
#             self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
#         self.newlines -= 1
#         return self.buffer.readline()
#     def flush(self):
#         if self.writable:
#             os.write(self._fd, self.buffer.getvalue())
#             self.buffer.truncate(0), self.buffer.seek(0)
# class IOWrapper(IOBase):
#     def __init__(self, file):
#         self.buffer = FastIO(file)
#         self.flush = self.buffer.flush
#         self.writable = self.buffer.writable
#         self.write = lambda s: self.buffer.write(s.encode(""ascii""))
#         self.read = lambda: self.buffer.read().decode(""ascii"")
#         self.readline = lambda: self.buffer.readline().decode(""ascii"")
# sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
# input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split(' ')))

# for _ in range(int(input())):
#     n, h = list(map(int, input().split(' ')))
#     a = list(map(int, input().split(' ')))
#     a.sort()
#     x, y = a[-2], a[-1]
#     if x == y:
#         print(math.ceil(h / x))
#     else:
#         ans = h // (x + y) * 2
#         h %= x + y
#         if h > 0:
#             ans += 1
#         if h > y:
#             ans += 1
#         print(ans)

# for _ in range(int(input())):
#     n, x = list(map(int, input().split(' ')))
#     a = list(map(int, input().split(' ')))
#     b = sorted(a)
#     for i in range(n - x, x):
#         if a[i] != b[i]:
#             print('NO')
#             break
#     else:
#         print('YES')

import sys
from collections import deque
n = int(input())
adj = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    u, v = list(map(int, input().split(' ')))
    adj[u].append(v)
    adj[v].append(u)

q = deque([1])
order = []
parent = [-1] * (n + 1)
vis = set()
vis.add(1)
while q:
    u = q.popleft()
    order.append(u)
    for v in adj[u]:
        if v not in vis:
            parent[v] = u
            q.append(v)
            vis.add(v)

print(""?"", len(order), *order)
sys.stdout.flush()
mx = int(input())

l, r = 0, n - 1
while l < r - 1:
    mid = (l + r) // 2
    print(""?"", len(order[:mid + 1]), *order[:mid + 1])
    sys.stdout.flush()
    x = int(input())
    if x == mx:
        r = mid
    else:
        l = mid
    
print(""!"", order[r], parent[order[r]])
sys.stdout.flush()","['binary search', 'dfs and similar', 'implementation', 'interactive', 'math', 'number theory', 'trees']"
"Vupsen and Pupsen were gifted an integer array. Since Vupsen doesn't like the number $$$0$$$, he threw away all numbers equal to $$$0$$$ from the array. As a result, he got an array $$$a$$$ of length $$$n$$$.Pupsen, on the contrary, likes the number $$$0$$$ and he got upset when he saw the array without zeroes. To cheer Pupsen up, Vupsen decided to come up with another array $$$b$$$ of length $$$n$$$ such that $$$\sum_{i=1}^{n}a_i \cdot b_i=0$$$. Since Vupsen doesn't like number $$$0$$$, the array $$$b$$$ must not contain numbers equal to $$$0$$$. Also, the numbers in that array must not be huge, so the sum of their absolute values cannot exceed $$$10^9$$$. Please help Vupsen to find any such array $$$b$$$!","def solve(n, aa):
    head, tail = [], []
    if n % 2 == 1:
        a, b, c = aa[n-3], aa[n-2], aa[n-1]
        if b + c != 0:
            tail = [b+c, -a, -a]
        else:
            tail = [b-c, -a, a]
        n -= 3

    idx = 0
    while idx < n:
        factor = gcd(aa[idx], aa[idx+1])
        head.append(aa[idx+1] // factor)
        head.append(-aa[idx] // factor)
        idx += 2
    return head + tail


def gcd(x, y):
    x, y = abs(x), abs(y)
    while y:
        x, y = y, x % y
    return x


for _ in range(int(input())):
    n = int(input())
    aa = list(map(int, input().split()))
    bb = solve(n, aa)
    print(' '.join(map(str, bb)))","['constructive algorithms', 'math']"
"Luntik has decided to try singing. He has $$$a$$$ one-minute songs, $$$b$$$ two-minute songs and $$$c$$$ three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.Please help Luntik and find the minimal possible difference in minutes between the concerts durations.","for t in range(int(input())):
    a, b, c = map(int, input().split())
    print((a + (2 * b) + (3 * c)) % 2)",['math']
"This is an easier version of the problem with smaller constraints.Korney Korneevich dag up an array $$$a$$$ of length $$$n$$$. Korney Korneevich has recently read about the operation bitwise XOR, so he wished to experiment with it. For this purpose, he decided to find all integers $$$x \ge 0$$$ such that there exists an increasing subsequence of the array $$$a$$$, in which the bitwise XOR of numbers is equal to $$$x$$$.It didn't take a long time for Korney Korneevich to find all such $$$x$$$, and he wants to check his result. That's why he asked you to solve this problem!A sequence $$$s$$$ is a subsequence of a sequence $$$b$$$ if $$$s$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements.A sequence $$$s_1, s_2, \ldots , s_m$$$ is called increasing if $$$s_1 &lt; s_2 &lt; \ldots &lt; s_m$$$.","# F1. Korney Korneevich and XOR (easy version)


def main():
    
    from sys import stdin, stdout
    input = stdin.readline
    print = stdout.write
    
    n = int(input())
    a = list(map(int,input().split()))

    x = [501]*512

    x[0] = 0

    for i in a:
        for j in range(512):
            if x[j] < i:
                num = j^i
                x[num] = min(x[num], i)

    ans = []

    for i in range(512):
        if x[i] < 501:
            ans.append(str(i))

    print(str(len(ans))+""\n"")
    print("" "".join(ans))
    print(""\n"")

if __name__ == '__main__':
    main()","['bitmasks', 'dp', 'greedy']"
"You are given an array $$$a_1, a_2, \dots, a_n$$$. You can perform operations on the array. In each operation you can choose an integer $$$i$$$ ($$$1 \le i &lt; n$$$), and swap elements $$$a_i$$$ and $$$a_{i+1}$$$ of the array, if $$$a_i + a_{i+1}$$$ is odd.Determine whether it can be sorted in non-decreasing order using this operation any number of times.","# cook your dish here
# cook your dish here
#!/usr/bin/env python
from cmath import inf
import os
from math import ceil, factorial, floor, log, sqrt
import re
import sys
from collections import Counter, defaultdict
from itertools import permutations
from io import BytesIO, IOBase


class newNode:
    def __init__(self, data):
        self.data = data
        self.left = self.right = None

def highestPowerOf2(n):
    return (n & (~(n - 1)))
def gcd(a,b):
    if a == 0:
        return b
    return gcd(b % a, a)
 
# Function to return LCM of two numbers
def lcm(a,b):
    return (a / gcd(a,b))* b
def is_sorted(n, arr):
    for j in range(n-1):
        if arr[j]>arr[j+1]:
            return False
    return True
# Returns XNOR of num1 and num2
def prime_factor(n):
    ans = []
    if n%2==0:
        ans.append(2)
    while n%2==0:
        n = n//2 
    for j in range(3, round(n**0.5) + 1, 2):
        if n%j==0:
            ans.append(j)
        while n%j==0:
            n = n//j
    if n!=1:
        ans.append(n)
    return ans
def isPowerofTwo(n):
    if (n == 0):
        return 0
    if ((n & (~(n - 1))) == n):
        return 1
    return 0

def sum_root(n):
    a = 1
    b = 1
    c = -2*n
    d = b**2 - 4*a*c
    root = (-b + int(d**0.5))/2
    return round(root)

def factors(n):
    i = 1
    cnt = 0
    while i <= sqrt(n):
         
        if (n % i == 0) :
             
            # If divisors are equal, print only one
            if (n / i == i) :
                cnt += 1
            else :
                # Otherwise print both
                cnt += 2 
        i = i + 1
    return cnt
    

def prime(n):
    if n%2==0 and n>2:
        return False

    for j in range(3, int(sqrt(n)) + 1, 2):
        if n%j==0:
            return False 
    return True


def is_palindrome(s, n):
    for j in range(n//2):
        if s[j] != s[n-j-1]:
            return False
    return True
prod = 1
memo = {}
def solve(x):
    global memo
    if x in memo:
        return memo[x]
    else:
        if x>4:
            memo[x] = (solve(x//2)*solve(ceil(x/2)))%998244353
        else:
            memo[x] = x
        return memo[x]
class Graph:
     
    def __init__(self, V):
 
        # No. of vertices
        self.V = V
 
        # Pointer to an array containing
        # adjacency lists
        self.adj = [[] for i in range(self.V)]
 
    # Function to return the number of
    # connected components in an undirected graph
    def NumberOfconnectedComponents(self):
         
        # Mark all the vertices as not visited
        visited = [False for i in range(self.V)]
         
        # To store the number of connected
        # components
        count = 0
         
        for v in range(self.V):
            if (visited[v] == False):
                self.DFSUtil(v, visited)
                count += 1
                 
        return count
         
    def DFSUtil(self, v, visited):
 
        # Mark the current node as visited
        visited[v] = True
 
        # Recur for all the vertices
        # adjacent to this vertex
        for i in self.adj[v]:
            if (not visited[i]):
                self.DFSUtil(i, visited)
                 
    # Add an undirected edge
    def addEdge(self, v, w):         
        self.adj[v].append(w)
        self.adj[w].append(v)
def main():
    for i in range(int(input())):
        n = int(input())
        arr = [int(x) for x in input().split()]
        odd = []
        even = []
        for j in range(n):
            if arr[j]%2!=0:
                odd.append(arr[j])
            else:
                even.append(arr[j])
        if odd == list(sorted(odd)) and even == list(sorted(even)):
            print(""YES"")
        else:
            print(""NO"")                    

        
    
BUFSIZE = 8192

 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:  
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
if __name__ == ""__main__"":
    main()","['data structures', 'math', 'sortings']"
"You are given a permutation $$$p_1, p_2, \dots, p_n$$$. Then, an undirected graph is constructed in the following way: add an edge between vertices $$$i$$$, $$$j$$$ such that $$$i &lt; j$$$ if and only if $$$p_i &gt; p_j$$$. Your task is to count the number of connected components in this graph.Two vertices $$$u$$$ and $$$v$$$ belong to the same connected component if and only if there is at least one path along edges connecting $$$u$$$ and $$$v$$$.A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).","from __future__ import division, print_function

import os
import sys
from collections import deque
from io import BytesIO, IOBase
input = sys.stdin.readline

if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip


def main():
    for case in range(int(input())):
        length = int(input())
        line = list(map(int, input().split()))
        
        mx = 0
        mxs = []
        for i in line:
            if i > mx:
                mx = i
            mxs.append(mx)
        mn = 999999
        mns = deque()
        for i in line[::-1]:
            if i < mn:
                mn = i
            mns.appendleft(mn)
                
        quantity = sum(
            line[i] > line[i-1] and mxs[i-1] < mns[i]
            for i in range(1, length)
        )
                    
        print(1 if quantity >= length else quantity + 1)


# regions fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()","['data structures', 'dsu', 'graphs', 'math']"
"You are given an array $$$a$$$ consisting of $$$n$$$ ($$$n \ge 3$$$) positive integers. It is known that in this array, all the numbers except one are the same (for example, in the array $$$[4, 11, 4, 4]$$$ all numbers except one are equal to $$$4$$$).Print the index of the element that does not equal others. The numbers in the array are numbered from one.","import sys
import math

masterlist = []
numofcases = int(input())

for i in range(1, (numofcases * 2) + 1):
    next = input()
    if i % 2 == 0:
        masterlist.append([int(x) for x in next.split("" "")])

for i in masterlist:
    
    twonums = list(set(i))
    if i.count(twonums[0]) == 1:
        print(i.index(twonums[0]) + 1)
    else:
        print(i.index(twonums[1]) + 1)","['brute force', 'implementation']"
"This is an interactive problem. Remember to flush your output while communicating with the testing program. You may use fflush(stdout) in C++, system.out.flush() in Java, stdout.flush() in Python or flush(output) in Pascal to flush the output. If you use some other programming language, consult its documentation. You may also refer to the guide on interactive problems: https://codeforces.com/blog/entry/45307.There is a city in which Dixit lives. In the city, there are $$$n$$$ houses. There is  exactly one directed road between every pair of houses. For example, consider two houses A and B, then there is a directed road either from A to B or from B to A but not both. The number of roads leading to the $$$i$$$-th house is $$$k_i$$$.Two houses A and B are bi-reachable if A is reachable from B and B is reachable from A. We say that house B is reachable from house A when there is a path from house A to house B.Dixit wants to buy two houses in the city, that is, one for living and one for studying. Of course, he would like to travel from one house to another. So, he wants to find a pair of bi-reachable houses A and B. Among all such pairs, he wants to choose one with the maximum value of $$$|k_A - k_B|$$$, where $$$k_i$$$ is the number of roads leading to the house $$$i$$$. If more than one optimal pair exists, any of them is suitable.Since Dixit is busy preparing CodeCraft, can you help him find the desired pair of houses, or tell him that no such houses exist?In the problem input, you are not given the direction of each road. You are given — for each house — only the number of incoming roads to that house ($$$k_i$$$).You are allowed to ask only one type of query from the judge: give two houses A and B, and the judge answers whether B is reachable from A. There is no upper limit on the number of queries. But, you cannot ask more queries after the judge answers ""Yes"" to any of your queries. Also, you cannot ask the same query twice.Once you have exhausted all your queries (or the judge responds ""Yes"" to any of your queries), your program must output its guess for the two houses and quit.See the Interaction section below for more details.","import os,sys
from random import randint
from io import BytesIO, IOBase

from collections import defaultdict,deque,Counter
from bisect import bisect_left,bisect_right
from heapq import heappush,heappop
from functools import lru_cache
from itertools import accumulate
import math

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# for _ in range(int(input())):
#     n = int(input())
#     a = list(map(int, input().split()))

# for _ in range(int(input())):
#     n = int(input())
#     for i in range(n, n + 100000000):
#         s = str(i)
#         x = 0
#         for j in range(len(s)):
#             x += int(s[j])
#         if math.gcd(x, i) > 1:
#             print(i)
#             break

# for _ in range(int(input())):
#     n, w = list(map(int, input().split()))
#     a = list(map(int, input().split()))
#     cnt = Counter(a)
#     cnt = sorted([[i, j] for i, j in cnt.items()])
#     ans = 0
#     tot = 0
#     for i, j in cnt:
#         tot += j
#     while tot > 0:
#         i = len(cnt) - 1
#         cur = 0
#         while i >= 0 and cur < w:
#             wi, c = cnt[i]
#             if wi * c <= w - cur:
#                 cur += wi * c
#                 cnt[i][1] = 0
#                 tot -= c
#             else:
#                 k = (w - cur) // wi
#                 cur += k * wi
#                 cnt[i][1] -= k
#                 tot -= k
#             i -= 1
#         ans += 1
#     print(ans)

# mod = 10 ** 9 + 7
# for _ in range(int(input())):
#     n, k = list(map(int, input().split()))
#     if k == 1:
#         print(1)
#         continue
#     if n == 1:
#         print(2)
#         continue
#     ans = 1 + n
#     a = [1] * (n - 1)
#     for i in range(k - 2):
#         if i % 2 == 0:
#             for j in range(n - 2)[::-1]:
#                 a[j] = (a[j] + a[j + 1]) % mod
#         else:
#             for j in range(1, n - 1):
#                 a[j] = (a[j] + a[j - 1]) % mod
#         ans += sum(a)
#     print(ans % mod)

# N = 10 ** 5
# n, m = list(map(int, input().split()))
# q = deque()
# q.append(0)
# vis = [0] * (m + 1)
# vis[0] = 1
# ans = [-1] * (m + 1)
# for idx in range(n):
#     t, x, y = list(map(int, input().split()))
#     if t == 1:
#         x = (x + N - 1) // N
#         for i in range(x):
#             k = -1
#             for j in range(i, m + 1, x):
#                 if vis[j] == 1:
#                     k = 0
#                 elif k != -1:
#                     k += 1
#                     if vis[j] == 0 and k <= y:
#                         ans[j] = idx + 1
#                         vis[j] = 1
#     else:
#         vis2 = [0] * (m + 1)
#         for i in range(1, m + 1):
#             if vis2[i] == 0:
#                 vis2[i] = 1
#                 j = i
#                 k = -1
#                 while j <= m:
#                     vis2[j] = 1
#                     if vis[j] == 1:
#                         k = 0
#                     elif k != -1:
#                         k += 1
#                         if vis[j] == 0 and k <= y:
#                             ans[j] = idx + 1
#                             vis[j] = 1
#                     j = (j * x + N - 1) // N
# print(*ans[1:])

def solve():           
    n = int(input())
    a = list(map(int, input().split()))
    # id = [i for i in range(n)]
    # id.sort(key=lambda x : a[x], reverse=True)
    id = []
    for i in range(n):
        for j in range(n):
            if a[i] > a[j] or (a[i] == a[j] and i != j):
                id.append([i, j])
    # print(id)
    id.sort(key=lambda x : a[x[1]] - a[x[0]])
    # for i in range(n):
    #     for j in range(i + 1, n)[::-1]:
    #         print('?', id[i] + 1, id[j] + 1)
    #             sys.stdout.flush()
    #             if input() == 'Yes':
    #                 print('!', id[i] + 1, id[j] + 1)
    #                 sys.stdout.flush()
    #                 return
    for i, j in id:
        print('?', i + 1, j + 1)
        sys.stdout.flush()
        if input() == 'Yes':
            print('!', i + 1, j + 1)
            sys.stdout.flush()
            return
    print('!', 0, 0)
    sys.stdout.flush()
solve()","['brute force', 'graphs', 'greedy', 'interactive', 'sortings']"
"You finally woke up after this crazy dream and decided to walk around to clear your head. Outside you saw your house's fence — so plain and boring, that you'd like to repaint it.  You have a fence consisting of $$$n$$$ planks, where the $$$i$$$-th plank has the color $$$a_i$$$. You want to repaint the fence in such a way that the $$$i$$$-th plank has the color $$$b_i$$$.You've invited $$$m$$$ painters for this purpose. The $$$j$$$-th painter will arrive at the moment $$$j$$$ and will recolor exactly one plank to color $$$c_j$$$. For each painter you can choose which plank to recolor, but you can't turn them down, i. e. each painter has to color exactly one plank.Can you get the coloring $$$b$$$ you want? If it's possible, print for each painter which plank he must paint.","from os import path
import sys,time
# mod = int(1e9 + 7)
# import re
from math import ceil, floor,gcd,log,log2 ,factorial
from collections import defaultdict ,Counter , OrderedDict , deque
from itertools import combinations,accumulate
# from string import ascii_lowercase ,ascii_uppercase
# from bisect import *
from heapq import *
from functools import reduce
from operator import mul
maxx = float('inf')
#----------------------------INPUT FUNCTIONS------------------------------------------#
I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().strip('\n')
grid = lambda  r :[lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
#left shift --- num*(2**k) --(k - shift)

for _ in range(I()):
    n ,  m = tup()
    a = lint()
    b = lint()
    c = lint()[::-1]
    d =defaultdict(list)
    for i in range(n):
        if a[i] != b[i]:
            d[b[i]].append(i+1)

    if c[0] in b :
        ans =[]
        idx = d[c[0]][-1] if c[0] in d else b.index(c[0]) + 1
        for i in c:
            if not d[i]:
                ans.append(idx)
            else:
                ans.append(d[i].pop())
        for i in d:
            if len(d[i]):
                print('NO')
                break
        else:
            print('YES')
            print(*ans[::-1])

    else:
        print('NO')




        
        

        
    










        









if localsys:
    print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")","['brute force', 'constructive algorithms', 'greedy']"
"William has two arrays $$$a$$$ and $$$b$$$, each consisting of $$$n$$$ items.For some segments $$$l..r$$$ of these arrays William wants to know if it is possible to equalize the values of items in these segments using a balancing operation. Formally, the values are equalized if for each $$$i$$$ from $$$l$$$ to $$$r$$$ holds $$$a_i = b_i$$$.To perform a balancing operation an even number of indices must be selected, such that $$$l \le pos_1 &lt; pos_2 &lt; \dots &lt; pos_k \le r$$$. Next the items of array a at positions $$$pos_1, pos_3, pos_5, \dots$$$ get incremented by one and the items of array b at positions $$$pos_2, pos_4, pos_6, \dots$$$ get incremented by one.William wants to find out if it is possible to equalize the values of elements in two arrays for each segment using some number of balancing operations, and what is the minimal number of operations required for that. Note that for each segment the operations are performed independently.","import io,os
import bisect 

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline


class segment_tree(object):

    def merge(self,num1,num2):

        maximum = max(num1[0],num2[0])
        minimum = min(num1[1],num2[1])

        return (maximum,minimum)


    def __init__(self,n,initial):

        self.n = n
        self.arr = [(0,0)]*(2*n)

        for i in range(2*n-1,0,-1):
            if i>=n:  self.arr[i] = (initial[i-n],initial[i-n])
            else:     self.arr[i] = self.merge(self.arr[2*i],self.arr[2*i+1])




    def query(self,left,right):
        i,j = self.n+left,  self.n+right+1
    
        output = (-float('inf'),float('inf'))   # initial output should be changed if you want to change the merge function

        while i<j:
            if i&1:
                output = self.merge(self.arr[i],output)
                i += 1
            if j&1:
                j -= 1
                output = self.merge(self.arr[j],output)
            i = i >> 1
            j = j >> 1
        return output




def main(t):


    n,q = map(int,input().split())
    arr1 = list(map(int,input().split()))
    arr2 = list(map(int,input().split()))

    diff = [0]*n
    for i in range(n):
        diff[i] = arr2[i] - arr1[i]

    accu = [0]*(n+1)
    accu[0] = 0

    pos = []


    for i in range(n):
        accu[i+1] = accu[i] + diff[i]
        if diff[i]!=0: pos.append(i)


 
    seg = segment_tree(n+1,accu)
    

#    print(accu)
    for _ in range(q):
        front,rear = map(int,input().split())
        front -= 1
#        print(front,rear)

        








        (maximum,minimum) = seg.query(front,rear)

        if accu[front]==minimum and accu[rear]==minimum:
            ans = maximum-minimum
        else:
            ans = -1
        print(ans)     

        



#    print(c)
#    print(cindex)
#    print(block)

    























T = 1 #int(input())
t = 1
while t<=T:
    main(t)
    t += 1","['data structures', 'dp', 'greedy']"
"You are given two integers $$$x$$$ and $$$y$$$. You want to choose two strictly positive (greater than zero) integers $$$a$$$ and $$$b$$$, and then apply the following operation to $$$x$$$ exactly $$$a$$$ times: replace $$$x$$$ with $$$b \cdot x$$$.You want to find two positive integers $$$a$$$ and $$$b$$$ such that $$$x$$$ becomes equal to $$$y$$$ after this process. If there are multiple possible pairs, you can choose any of them. If there is no such pair, report it.For example:   if $$$x = 3$$$ and $$$y = 75$$$, you may choose $$$a = 2$$$ and $$$b = 5$$$, so that $$$x$$$ becomes equal to $$$3 \cdot 5 \cdot 5 = 75$$$;  if $$$x = 100$$$ and $$$y = 100$$$, you may choose $$$a = 3$$$ and $$$b = 1$$$, so that $$$x$$$ becomes equal to $$$100 \cdot 1 \cdot 1 \cdot 1 = 100$$$;  if $$$x = 42$$$ and $$$y = 13$$$, there is no answer since you cannot decrease $$$x$$$ with the given operations.","t = int(input())
            
for _ in range(t):
    x, y = map(int, input().split())
    if y % x != 0:
        print(0, 0)
    else:
        print(1, y//x)","['constructive algorithms', 'math']"
"Even a cat has things it can do that AI cannot.— Fei-Fei LiYou are given $$$m$$$ arrays of positive integers. Each array is of even length.You need to split all these integers into two equal multisets $$$L$$$ and $$$R$$$, that is, each element of each array should go into one of two multisets (but not both). Additionally, for each of the $$$m$$$ arrays, exactly half of its elements should go into $$$L$$$, and the rest should go into $$$R$$$.Give an example of such a division or determine that no such division exists.","import io, os, sys
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import defaultdict, Counter
I = lambda: [int(x) for x in input().split()]

G = defaultdict(Counter)
places = defaultdict(set)
ans = defaultdict(list)

m = int(input())
for i in range(m):
    _ = input()
    arr = I()
    for j, x in enumerate(arr):
        G[i][x + m] += 1
        G[x + m][i] += 1
        places[x + m, i].add(j)
    ans[i] = [""X""] * len(arr)

if all(sum(G[i].values()) % 2 == 0 for i in G):
    visited = set()
    for start in G:
        if start in visited: continue
        stack = [start]
        path = []

        while stack:
            v = stack[-1]
            if G[v]:
                u = next(iter(G[v].items()))[0]
                stack.append(u)
                G[v][u] -= 1
                if G[v][u] == 0: G[v].pop(u)
                G[u][v] -= 1
                if G[u][v] == 0: G[u].pop(v)
            else:
                path.append(stack.pop())

        visited |= set(path)
        for x, y in zip(path, path[1:]):
            l = ""L"" if x < y else ""R""
            x, y = min(x, y), max(x, y)
            idx = places[y, x].pop()
            ans[x][idx] = l

    print(""YES"")
    for i in range(m):
        print("""".join(ans[i]))
else:
    print(""NO"")","['constructive algorithms', 'data structures', 'dfs and similar', 'graph matchings', 'graphs']"
"Consider a grid of size $$$n \times n$$$. The rows are numbered top to bottom from $$$1$$$ to $$$n$$$, the columns are numbered left to right from $$$1$$$ to $$$n$$$.The robot is positioned in a cell $$$(1, 1)$$$. It can perform two types of moves:  D — move one cell down;  R — move one cell right. The robot is not allowed to move outside the grid.You are given a sequence of moves $$$s$$$ — the initial path of the robot. This path doesn't lead the robot outside the grid.You are allowed to perform an arbitrary number of modifications to it (possibly, zero). With one modification, you can duplicate one move in the sequence. That is, replace a single occurrence of D with DD or a single occurrence of R with RR.Count the number of cells such that there exists at least one sequence of modifications that the robot visits this cell on the modified path and doesn't move outside the grid.","import sys
from array import array
import re

input = lambda: sys.stdin.buffer.readline().decode().strip()
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
debug = lambda *x: print(*x, file=sys.stderr)
out = []

for _ in range(int(input())):
    n, s = int(input()), input()
    if len(set(s)) == 1:
        out.append(n)
        continue

    ans = n * n
    pred, prer = array('i', [0]), array('i', [0])

    for i in range(len(s)):
        pred.append(pred[-1] + (s[i] == 'D'))
        prer.append(prer[-1] + (s[i] == 'R'))

    for i, pat in enumerate(re.finditer('R+', s)):
        l, r = pat.span()
        ans -= (r - l) * pred[l]
        if i == 0:
            ans -= (n - prer[-1] - 1) * pred[l]

    for i, pat in enumerate(re.finditer('D+', s)):
        l, r = pat.span()
        ans -= (r - l) * prer[l]
        if i == 0:
            ans -= (n - pred[-1] - 1) * prer[l]

    out.append(ans)

print('\n'.join(map(str, out)))","['brute force', 'combinatorics', 'data structures', 'implementation', 'math']"
"There are $$$n$$$ logs, the $$$i$$$-th log has a length of $$$a_i$$$ meters. Since chopping logs is tiring work, errorgorn and maomao90 have decided to play a game.errorgorn and maomao90 will take turns chopping the logs with errorgorn chopping first. On his turn, the player will pick a log and chop it into $$$2$$$ pieces. If the length of the chosen log is $$$x$$$, and the lengths of the resulting pieces are $$$y$$$ and $$$z$$$, then $$$y$$$ and $$$z$$$ have to be positive integers, and $$$x=y+z$$$ must hold. For example, you can chop a log of length $$$3$$$ into logs of lengths $$$2$$$ and $$$1$$$, but not into logs of lengths $$$3$$$ and $$$0$$$, $$$2$$$ and $$$2$$$, or $$$1.5$$$ and $$$1.5$$$.The player who is unable to make a chop will be the loser. Assuming that both errorgorn and maomao90 play optimally, who will be the winner?","num_cases = int(input())

for i in range(num_cases):
    count = 0
    num_logs = int(input())
    logs = [int(log) for log in input().split(' ')]
    for log in logs:
        count += log - 1
    if count % 2 == 0:
        print('maomao90')
    else:
        print('errorgorn')","['games', 'implementation', 'math']"
"You are given an array $$$a$$$ of length $$$n$$$. We define the equality of the array as the number of indices $$$1 \le i \le n - 1$$$ such that $$$a_i = a_{i + 1}$$$. We are allowed to do the following operation:  Select two integers $$$i$$$ and $$$x$$$ such that $$$1 \le i \le n - 1$$$ and $$$1 \le x \le 10^9$$$. Then, set $$$a_i$$$ and $$$a_{i + 1}$$$ to be equal to $$$x$$$. Find the minimum number of operations needed such that the equality of the array is less than or equal to $$$1$$$.","from math import ceil, floor, sqrt, log2

for _ in range(int(input())):
    input()
    s = list(map(int, input().split()))
    
    a = 0
    b = 0

    p = s[0]
    for i,v in enumerate(s[1:]):
        if p==v:
            a = b = i
            p = v
            break
        p=v
    for i,v in enumerate(s[i+2:],i+1):
        if p==v:
            b = i
        p = v
    
    print(max(int(bool(b-a)),b-a-1))","['constructive algorithms', 'greedy', 'implementation']"
"oolimry has an array $$$a$$$ of length $$$n$$$ which he really likes. Today, you have changed his array to $$$b$$$, a permutation of $$$a$$$, to make him sad.Because oolimry is only a duck, he can only perform the following operation to restore his array:   Choose two integers $$$i,j$$$ such that $$$1 \leq i,j \leq n$$$.  Swap $$$b_i$$$ and $$$b_j$$$. The sadness of the array $$$b$$$ is the minimum number of operations needed to transform $$$b$$$ into $$$a$$$.Given the array $$$a$$$, find any array $$$b$$$ which is a permutation of $$$a$$$ that has the maximum sadness over all permutations of the array $$$a$$$.","import sys

def solve():
	inp = sys.stdin.readline
	n = int(inp())
	a = list(map(int, inp().split()))
	c = [[] for i in range(n + 1)]
	p = [None] * (n + 1)
	for i in range(n):
		c[a[i]].append(i)
	for i in range(n + 1):
		p[i] = (-len(c[i]), i)
	p.sort()
	b = [None] * n
	for k in range(-p[0][0]):
		pr = p[0][1]
		for i in range(1, n + 5):
			sz, v = p[i]
			#print(k, pr, v, sz)
			if -sz > k:
				b[c[pr][k]] = v
				pr = v
			else:
				#print(c[pr])
				b[c[pr][k]] = p[0][1]
				break
	print(' '.join(map(str, b)))


def main():
	for i in range(int(sys.stdin.readline())):
		solve()


if __name__ == '__main__':
	main()","['constructive algorithms', 'graphs', 'greedy']"
"This is the easy version of the problem. The only difference between the two versions is that the harder version asks additionally for a minimum number of subsegments.Tokitsukaze has a binary string $$$s$$$ of length $$$n$$$, consisting only of zeros and ones, $$$n$$$ is even.Now Tokitsukaze divides $$$s$$$ into the minimum number of contiguous subsegments, and for each subsegment, all bits in each subsegment are the same. After that, $$$s$$$ is considered good if the lengths of all subsegments are even.For example, if $$$s$$$ is ""11001111"", it will be divided into ""11"", ""00"" and ""1111"". Their lengths are $$$2$$$, $$$2$$$, $$$4$$$ respectively, which are all even numbers, so ""11001111"" is good. Another example, if $$$s$$$ is ""1110011000"", it will be divided into ""111"", ""00"", ""11"" and ""000"", and their lengths are $$$3$$$, $$$2$$$, $$$2$$$, $$$3$$$. Obviously, ""1110011000"" is not good.Tokitsukaze wants to make $$$s$$$ good by changing the values of some positions in $$$s$$$. Specifically, she can perform the operation any number of times: change the value of $$$s_i$$$ to '0' or '1'($$$1 \leq i \leq n$$$). Can you tell her the minimum number of operations to make $$$s$$$ good?","n = int(input())

for i in range(n):
    num = int(input())
    s = input()
    j = 0
    son = []
    while j < num - 1:
        if s[j] == s[j + 1]:
            j = j + 1
        else:
            son.append(j)
            j = j + 1
    son.append(num - 1)
    lenth=[son[0]+1]
    for obj in range(len(son)-1):
        lenth.append(son[obj+1]-son[obj])
    answer=0
    n=0
    while n<=len(lenth)-1:
        if lenth[n]%2!=0:
            x=n+1
            while lenth[x]%2==0:
                x=x+1
            answer=answer+x-n
            n=x+1
        else:
            n+=1
    print(answer)",['implementation']
"You are given a keyboard that consists of $$$26$$$ keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.You have to type the word $$$s$$$ on this keyboard. It also consists only of lowercase Latin letters.To type a word, you need to type all its letters consecutively one by one. To type each letter you must position your hand exactly over the corresponding key and press it.Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from left to right). No time is spent on pressing the keys and on placing your hand over the first letter of the word.For example, consider a keyboard where the letters from 'a' to 'z' are arranged in consecutive alphabetical order. The letters 'h', 'e', 'l' and 'o' then are on the positions $$$8$$$, $$$5$$$, $$$12$$$ and $$$15$$$, respectively. Therefore, it will take $$$|5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13$$$ units of time to type the word ""hello"". Determine how long it will take to print the word $$$s$$$.","t = int(input())
for j in range(t):
    letters = str(input())
    s = str(input())
    dictiony = {}
    calculating = []
    word = []
    sum = 0
    for m in s:
        word.append(m)
    for i in letters:
        dictiony[i] = letters.index(i)
    for k in word:
        calculating.append(dictiony.get(k))
    n = 0
    while n != (len(word)-1) and len(s) > 0:
        calc = abs(calculating[n + 1] - calculating[n])
        sum += calc
        n += 1
    print(sum)","['implementation', 'strings']"
"Watto, the owner of a spare parts store, has recently got an order for the mechanism that can process strings in a certain way. Initially the memory of the mechanism is filled with n strings. Then the mechanism should be able to process queries of the following type: ""Given string s, determine if the memory of the mechanism contains string t that consists of the same number of characters as s and differs from s in exactly one position"".Watto has already compiled the mechanism, all that's left is to write a program for it and check it on the data consisting of n initial lines and m queries. He decided to entrust this job to you.","from collections import defaultdict
from math import ceil,floor
import sys

memory = set()
mod = 1000000000000000003
p = 3

def hash_(s):
    pp = p
    result = 0
    for ch in s:
        result += pp*(ord(ch)-ord('a')-1)
        pp = (pp*p)%mod;
        result %= mod
    return result % mod;

def find(q):
    hash_0 = hash_(q)
    k = len(q)
    pw = p
    ext = 0
    for j in range(len(q)):
        for ch in 'abc':
            if ch != q[j]:
                if ((hash_0 % mod + ((ord(ch)-ord(q[j]))*pw)% mod ) % mod) in memory:
                    sys.stdout.write('YES\n')
                    ext = 1
                    break
        if ext:
            break
        pw = (p * pw) % mod;
    if not ext:
        sys.stdout.write('NO\n')

def main():
    n,m = [int(i) for i in input().split()]
    for i in range(n):
        memory.add(hash_(sys.stdin.readline().strip()))
    for i in range(m):
        find(sys.stdin.readline().strip())
   
            
if __name__ == ""__main__"":
    ##sys.stdin = open(""in.txt"",'r') 
    ##sys.stdout = open(""out.txt"",'w')
    main()
    ##sys.stdin.close()
    ##sys.stdout.close()","['hashing', 'string suffix structures', 'data structures', 'binary search', 'strings']"
"The robot is located on a checkered rectangular board of size $$$n \times m$$$ ($$$n$$$ rows, $$$m$$$ columns). The rows in the board are numbered from $$$1$$$ to $$$n$$$ from top to bottom, and the columns — from $$$1$$$ to $$$m$$$ from left to right.The robot is able to move from the current cell to one of the four cells adjacent by side.Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move.   If the robot moves beyond the edge of the board, it falls and breaks.  If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).","''' F. Robot on the Board 2
https://codeforces.com/contest/1607/problem/F
'''

import io, os, sys
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str
output = sys.stdout.write

from collections import deque

def solve(R, C, NEXT):
    N = R*C

    # max_dist[r][c] = max moves if start from cell (r, c)
    max_dist = [-1]*N
    # visited = [False]*N

    # probe from unvisited cell (r, c)
    # stop when fall off or revisit a cell
    # when stop, update max_dist for all cells visited in this pass
    def dfs(x):
        chain = deque([x])
        while True:
            x = NEXT[x]
            if x == -1 or max_dist[x] > -1: break
            max_dist[x] = 0
            chain.append(x)
        
        add = max_dist[x] if x != -1 else 0   # > 0 if revisit a cell from previous passes
        cycle_len = 0                         # > 0 if revisit a cell from this pass
        M = len(chain)
        for i, px in enumerate(chain):
            if px == x:
                cycle_len = M - i
            if cycle_len == 0:
                max_dist[px] = M - i + add
            else:
                max_dist[px] = cycle_len

    for x in range(N):
        if max_dist[x] != -1: continue
        dfs(x)
    
    mx_x, mx_d = None, -1
    for x in range(N):
        if max_dist[x] > mx_d:
            mx_x, mx_d = x, max_dist[x]
    r, c = divmod(mx_x, C)
    return r, c, mx_d


def main():
    T = int(input())
    for _ in range(T):
        _ = input()
        R, C = list(map(int, input().split()))

        # next move
        NEXT = [-1]*(R*C)
        nr, nc = -1, -1
        for r in range(R):
            row = input().decode().strip()
            for c, arrow in enumerate(row):                
                if arrow == 'U': nr, nc = r-1, c
                if arrow == 'D': nr, nc = r+1, c
                if arrow == 'L': nr, nc = r, c-1
                if arrow == 'R': nr, nc = r, c+1
                if not (0 <= nr < R and 0 <= nc < C): continue
                NEXT[r*C + c] = nr*C + nc
        
        r, c, d = solve(R, C, NEXT)
        output(f'{r+1} {c+1} {d}\n')


if __name__ == '__main__':
    main()","['brute force', 'dfs and similar', 'graphs', 'implementation']"
"You are given an array $$$a$$$ consisting of $$$n$$$ distinct positive integers.Let's consider an infinite integer set $$$S$$$ which contains all integers $$$x$$$ that satisfy at least one of the following conditions: $$$x = a_i$$$ for some $$$1 \leq i \leq n$$$. $$$x = 2y + 1$$$ and $$$y$$$ is in $$$S$$$. $$$x = 4y$$$ and $$$y$$$ is in $$$S$$$.For example, if $$$a = [1,2]$$$ then the $$$10$$$ smallest elements in $$$S$$$ will be $$$\{1,2,3,4,5,7,8,9,11,12\}$$$.Find the number of elements in $$$S$$$ that are strictly smaller than $$$2^p$$$. Since this number may be too large, print it modulo $$$10^9 + 7$$$.","import sys
from array import array


class dict_(dict):
    def __missing__(self, key):
        return 0


mod = 10 ** 9 + 7
add = lambda a, b: (a % mod + b % mod) % mod
mult = lambda a, b: (a % mod * b % mod) % mod
input = lambda: sys.stdin.buffer.readline().decode().strip()

n, p = map(int, input().split())
a = array('i', [int(x) for x in input().split()])
dp = array('i', [0] * (p + 1))
mem, ans = set(), 0
dp[0] = dp[1] = 1

for i in range(2, p + 1):
    dp[i] = add(dp[i - 2], dp[i - 1])
for i in range(1, p + 1):
    dp[i] = add(dp[i], dp[i - 1])

for bit in range(1, min(30, p) + 1):
    for i in range(n):
        if a[i].bit_length() == bit:
            su, cur = dp[p - bit], a[i]
            while cur:
                if cur & 1:
                    cur >>= 1
                elif cur % 4 == 0:
                    cur >>= 2
                else:
                    break

                if cur in mem:
                    su = 0
                    break

            mem.add(a[i])
            ans += su

print(ans % mod)","['bitmasks', 'dp', 'math', 'matrices', 'number theory', 'strings']"
"You are given an array of length $$$2^n$$$. The elements of the array are numbered from $$$1$$$ to $$$2^n$$$.You have to process $$$q$$$ queries to this array. In the $$$i$$$-th query, you will be given an integer $$$k$$$ ($$$0 \le k \le n-1$$$). To process the query, you should do the following:  for every $$$i \in [1, 2^n-2^k]$$$ in ascending order, do the following: if the $$$i$$$-th element was already swapped with some other element during this query, skip it; otherwise, swap $$$a_i$$$ and $$$a_{i+2^k}$$$;  after that, print the maximum sum over all contiguous subsegments of the array (including the empty subsegment). For example, if the array $$$a$$$ is $$$[-3, 5, -3, 2, 8, -20, 6, -1]$$$, and $$$k = 1$$$, the query is processed as follows:  the $$$1$$$-st element wasn't swapped yet, so we swap it with the $$$3$$$-rd element;  the $$$2$$$-nd element wasn't swapped yet, so we swap it with the $$$4$$$-th element;  the $$$3$$$-rd element was swapped already;  the $$$4$$$-th element was swapped already;  the $$$5$$$-th element wasn't swapped yet, so we swap it with the $$$7$$$-th element;  the $$$6$$$-th element wasn't swapped yet, so we swap it with the $$$8$$$-th element. So, the array becomes $$$[-3, 2, -3, 5, 6, -1, 8, -20]$$$. The subsegment with the maximum sum is $$$[5, 6, -1, 8]$$$, and the answer to the query is $$$18$$$.Note that the queries actually change the array, i. e. after a query is performed, the array does not return to its original state, and the next query will be applied to the modified array.","from sys import stdin
input=lambda :stdin.readline()[:-1]

n=int(input())
m=1<<n
a=list(map(int,input().split()))
table=[]

# (sum,pref,suff,ans)

last=[]
for i in range(m):
  last.append((a[i],max(0,a[i]),max(0,a[i]),max(0,a[i])))

def merge(L,R):
  sumL,prefL,suffL,ansL=L
  sumR,prefR,suffR,ansR=R
  sumX=sumL+sumR
  prefX=max(prefL,sumL+prefR)
  suffX=max(suffR,suffL+sumR)
  ansX=max(ansL,ansR,prefR+suffL)
  return (sumX,prefX,suffX,ansX)

for i in range(n):
  now=[0]*m
  for j in range(m):
    L=last[j]
    R=last[j^(1<<i)]
    now[j]=merge(L,R)
  last=now

ans=[last[i][3] for i in range(m)]

XOR=0
q=int(input())
for _ in range(q):
  k=int(input())
  XOR^=1<<k
  print(ans[XOR])","['bitmasks', 'data structures', 'dfs and similar', 'divide and conquer', 'dp']"
"$$$n$$$ players are playing a game. There are two different maps in the game. For each player, we know his strength on each map. When two players fight on a specific map, the player with higher strength on that map always wins. No two players have the same strength on the same map. You are the game master and want to organize a tournament. There will be a total of $$$n-1$$$ battles. While there is more than one player in the tournament, choose any map and any two remaining players to fight on it. The player who loses will be eliminated from the tournament. In the end, exactly one player will remain, and he is declared the winner of the tournament. For each player determine if he can win the tournament.","import os
import sys
from io import BytesIO, IOBase

## PYRIVAL BOOTSTRAP
# https://github.com/cheran-senthil/PyRival/blob/master/pyrival/misc/bootstrap.py
# This decorator allows for recursion without actually doing recursion
from types import GeneratorType
## @bootstrap, yield when getting and returning value in recursive functions


def main():
    @bootstrap
    def dfs(value):
        for v in beaten_by[value]:
            if iptw[v] == '1':
                continue
            else:
                iptw[v] = '1'
                yield dfs(v)
        yield

    for _ in range(iip()):
        n = iip()
        a = liip()
        b = liip()

        beaten_by = [set() for _ in range(n)]
        li = []
        for i in range(n):
            li.append((a[i], b[i], i))

        starts = set()

        li.sort(key=lambda x: -x[0])
        starts.add(li[0][2])
        for i in range(n - 1):
            beaten_by[li[i + 1][2]].add(li[i][2])

        li.sort(key=lambda x: -x[1])
        starts.add(li[0][2])
        for i in range(n - 1):
            beaten_by[li[i + 1][2]].add(li[i][2])

        iptw = ['0'] * n # is possible to win
        for v in starts:
            iptw[v] = '1'

        for start in starts:
            dfs(start)

        print(''.join(iptw))

    
# region fastio
 
BUFSIZE = 8192
 

class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
if __name__ == ""__main__"":
    def bootstrap(f, stack=[]):
        def wrappedfunc(*args, **kwargs):
            if stack:
                return f(*args, **kwargs)
            else:
                to = f(*args, **kwargs)
                while True:
                    if type(to) is GeneratorType:
                        stack.append(to)
                        to = next(to)
                    else:
                        stack.pop()
                        if not stack:
                            break
                        to = stack[-1].send(to)
                return to
        return wrappedfunc
    
    ip = lambda: input()
    iip = lambda: int(input())
    miip = lambda: map(int, input().split())
    liip = lambda: list(map(int, input().split()))
    sip = lambda: input().split() # splitted input
    lip = lambda: list(input())
    
    main()","['data structures', 'dfs and similar', 'dp', 'graphs', 'greedy', 'two pointers']"
"You have $$$n$$$ rectangles, the $$$i$$$-th rectangle has height $$$h_i$$$ and width $$$w_i$$$.You are asked $$$q$$$ queries of the form $$$h_s \ w_s \ h_b \ w_b$$$. For each query output, the total area of rectangles you own that can fit a rectangle of height $$$h_s$$$ and width $$$w_s$$$ while also fitting in a rectangle of height $$$h_b$$$ and width $$$w_b$$$. In other words, print $$$\sum h_i \cdot w_i$$$ for $$$i$$$ such that $$$h_s &lt; h_i &lt; h_b$$$ and $$$w_s &lt; w_i &lt; w_b$$$. Please note, that if two rectangles have the same height or the same width, then they cannot fit inside each other. Also note that you cannot rotate rectangles.Please note that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).","def lowbit(n):
    return n & (-n)

def prefix_sum(tree_list, n): # sum(a[:n+1]
    _sum = 0
    while n > 0:
        _sum += tree_list[n]
        n -= lowbit(n)
    return _sum

def addwith(tree_list, n, num): # a[n] += num
    while n < len(tree_list):
        tree_list[n] += num
        n += lowbit(n)

NMAX = 1001
t = int(input())
for _ in range(t):
    n, q = input().split()
    n, q = int(n), int(q)
    recs = [[] for i in range(NMAX)]
    qs_in = [[] for i in range(NMAX)]
    qs_out = [[] for i in range(NMAX)]
    for i in range(n):
        hi, wi = input().split()
        hi, wi = int(hi), int(wi)
        recs[hi].append(wi)
    for i in range(q):
        hs, ws, hb, wb = input().split()
        hs, ws, hb, wb = int(hs), int(ws), int(hb), int(wb)-1
        qs_in[hs].append([ws, wb, i])
        qs_out[hb-1].append([ws, wb, i])
    _ans = [0 for i in range(q)]

    tree_list = [0 for _ in range(NMAX)]
    for h in range(1, NMAX):
        for wi in recs[h]:
            addwith(tree_list, wi, wi * h)
        for ws, wb, idx in qs_in[h]:
            val = prefix_sum(tree_list, wb) - prefix_sum(tree_list, ws)
            _ans[idx] -= val
        for ws, wb, idx in qs_out[h]:
            val = prefix_sum(tree_list, wb) - prefix_sum(tree_list, ws)
            _ans[idx] += val
    for ans in _ans:
        print(ans)","['brute force', 'data structures', 'dp', 'implementation']"
"An L-shape is a figure on gridded paper that looks like the first four pictures below. An L-shape contains exactly three shaded cells (denoted by *), which can be rotated in any way.  You are given a rectangular grid. Determine if it contains L-shapes only, where L-shapes can't touch an edge or corner. More formally:   Each shaded cell in the grid is part of exactly one L-shape, and  no two L-shapes are adjacent by edge or corner. For example, the last two grids in the picture above do not satisfy the condition because the two L-shapes touch by corner and edge, respectively.","import sys
input = sys.stdin.readline
from collections import deque
#from bisect import bisect_left, bisect_right
#import itertools
#import math

dx = [-1,-1,-1,0,1,1,1,0]
dy = [-1, 0, 1, 1, 1, 0, -1, -1]

for _ in range(int(input())):
    
    n, m = map(int, input().split())
    arr = [input().strip() for __ in range(n)]
    vst = [[False]*m for __ in range(n)]
    flag = True
    for x in range(n):
        for y in range(m):
            if arr[x][y] == '.' or vst[x][y]:
                continue
            dq = deque()
            lis = []
            dq.append([x, y])
            lis.append([x, y])
            vst[x][y] = True
            while dq:
                a, b = dq.popleft()
                for i in range(8):
                    nx = a+dx[i]
                    ny = b+dy[i]
                    if 0<=nx<n and 0<=ny<m and arr[nx][ny] == '*' and not vst[nx][ny]:
                        vst[nx][ny] = True
                        dq.append([nx, ny])
                        lis.append([nx, ny])
            if len(lis)!=3:
                flag = False
                break
            a = min(lis[0][0], lis[1][0], lis[2][0])
            b = min(lis[0][1], lis[1][1], lis[2][1])
            cnt = 0
            for i in range(2):
                for j in range(2):
                    if a+i<n and b+j<m and arr[a+i][b+j] == '*':
                        cnt += 1
            if cnt != 3:
                flag = False
                break
        if not flag:
            break
    print(""YES"" if flag else ""NO"")","['dfs and similar', 'implementation']"
"Rahul and Tina are looking forward to starting their new year at college. As they enter their new classroom, they observe the seats of students are arranged in a $$$n \times m$$$ grid. The seat in row $$$r$$$ and column $$$c$$$ is denoted by $$$(r, c)$$$, and the distance between two seats $$$(a,b)$$$ and $$$(c,d)$$$ is $$$|a-c| + |b-d|$$$. As the class president, Tina has access to exactly $$$k$$$ buckets of pink paint. The following process occurs.   First, Tina chooses exactly $$$k$$$ seats in the classroom to paint with pink paint. One bucket of paint can paint exactly one seat.  After Tina has painted $$$k$$$ seats in the previous step, Rahul chooses where he sits. He will not choose a seat that has been painted pink due to his hatred of the colour pink.  After Rahul has chosen his seat, Tina chooses a seat for herself. She can choose any of the seats, painted or not, other than the one chosen by Rahul. Rahul wants to choose a seat such that he sits as close to Tina as possible. However, Tina wants to sit as far away from Rahul as possible due to some complicated relationship history that we couldn't fit into the statement!Now, Rahul wonders for $$$k = 0, 1, \dots, n \cdot m - 1$$$, if Tina has $$$k$$$ buckets of paint, how close can Rahul sit to Tina, if both Rahul and Tina are aware of each other's intentions and they both act as strategically as possible? Please help satisfy Rahul's curiosity!","def main():
  import sys
  readline=sys.stdin.readline
  for _ in range(int(readline())):
    n,m=map(int,readline().split())
    ans=[]
    for a in range(n):
      for b in range(m):
        ans.append(max(a+b,a+m-b-1,n-a+m-b-2,n-a-1+b))
    print(' '.join(map(str,sorted(ans))))
main()","['games', 'greedy', 'sortings']"
"You are storing an integer array of length $$$m$$$ in a database. To maintain internal integrity and protect data, the database stores $$$n$$$ copies of this array.Unfortunately, the recent incident may have altered the stored information in every copy in the database.It's believed, that the incident altered at most two elements in every copy. You need to recover the original array based on the current state of the database.In case there are multiple ways to restore the array, report any. If there is no array that differs from every copy in no more than two positions, report that as well.","import sys
from sys import stdout

input = sys.stdin.readline
inf = float('inf')


def getInt():
    return int(input())


def getStr():
    return input().strip()


def getList(split=True):
    s = getStr()
    if split:
        s = s.split()
    return list(map(int, s))

# def p(*args,**kwargs):
#     print(*args,**kwargs)
#     stdout.flush()


# t = getInt()
t = 1


def solve():
    # only need to handle case 3 and 4
    n, m = getList()
    a = [getList() for _ in range(n)]

    def diff(a, b):
        return sum(i != j for i, j in zip(a, b))

    case3 = case4 = None
    for i in range(1, n):
        d = diff(a[0], a[i])
        if d == 3:
            case3 = i
        elif d == 4:
            case4 = i
        elif d > 4:
            print(""No"")
            return
    if case3 == case4 == None:
        print(""Yes"")
        print(*a[0])
    else:
        if case4:
            w = [i for i in range(m) if a[0][i] != a[case4][i]]
            for msk in range(1 << 4):
                u = a[0][:]
                for j in range(4):
                    if msk >> j & 1:
                        u[w[j]] = a[0][w[j]]
                    else:
                        u[w[j]] = a[case4][w[j]]
                    if all(diff(u, i) <= 2 for i in a):
                        print(""Yes"")
                        print(*u)
                        return
            print(""No"")
        else:
            # allow one tolerance
            w = [i for i in range(m) if a[0][i] != a[case3][i]]
            for msk in range(1 << 3):
                for tolerance in range(3):
                    u = a[0][:]
                    for j in range(3):
                        if msk >> j & 1:
                            u[w[j]] = a[0][w[j]]
                        else:
                            u[w[j]] = a[case3][w[j]]
                    for i in range(n):
                        d = diff(u, a[i])
                        if d > 3:
                            break
                        elif d == 3:
                            if u[w[tolerance]] == a[i][w[tolerance]]:
                                break
                            u[w[tolerance]] = a[i][w[tolerance]]
                            if all(diff(u, i) <= 2 for i in a):
                                print(""Yes"")
                                print(*u)
                                return
                            break
                    else:
                        print(""Yes"")
                        print(*u)
                        return
            print(""No"")


for _ in range(t):
    solve()","['brute force', 'constructive algorithms', 'dfs and similar', 'greedy', 'implementation']"
"You are given a permutation $$$a$$$ consisting of $$$n$$$ numbers $$$1$$$, $$$2$$$, ..., $$$n$$$ (a permutation is an array in which each element from $$$1$$$ to $$$n$$$ occurs exactly once).You can perform the following operation: choose some subarray (contiguous subsegment) of $$$a$$$ and rearrange the elements in it in any way you want. But this operation cannot be applied to the whole array.For example, if $$$a = [2, 1, 4, 5, 3]$$$ and we want to apply the operation to the subarray $$$a[2, 4]$$$ (the subarray containing all elements from the $$$2$$$-nd to the $$$4$$$-th), then after the operation, the array can become $$$a = [2, 5, 1, 4, 3]$$$ or, for example, $$$a = [2, 1, 5, 4, 3]$$$.Your task is to calculate the minimum number of operations described above to sort the permutation $$$a$$$ in ascending order.","for _ in range(int(input())):
    n=int(input())
    l=list(map(int,input().split()))
    r=sorted(l)
    if l==r:
        print(0)
    else:
        if l[0]==1 or l[-1]==n:
            print(1)
        elif l[-1]==1 and l[0]==n:
            print(3)
        else:
            print(2)","['constructive algorithms', 'greedy']"
"Suppose you had an array $$$A$$$ of $$$n$$$ elements, each of which is $$$0$$$ or $$$1$$$.Let us define a function $$$f(k,A)$$$ which returns another array $$$B$$$, the result of sorting the first $$$k$$$ elements of $$$A$$$ in non-decreasing order. For example, $$$f(4,[0,1,1,0,0,1,0]) = [0,0,1,1,0,1,0]$$$. Note that the first $$$4$$$ elements were sorted.Now consider the arrays $$$B_1, B_2,\ldots, B_n$$$ generated by $$$f(1,A), f(2,A),\ldots,f(n,A)$$$. Let $$$C$$$ be the array obtained by taking the element-wise sum of $$$B_1, B_2,\ldots, B_n$$$.For example, let $$$A=[0,1,0,1]$$$. Then we have $$$B_1=[0,1,0,1]$$$, $$$B_2=[0,1,0,1]$$$, $$$B_3=[0,0,1,1]$$$, $$$B_4=[0,0,1,1]$$$. Then $$$C=B_1+B_2+B_3+B_4=[0,1,0,1]+[0,1,0,1]+[0,0,1,1]+[0,0,1,1]=[0,2,2,4]$$$.You are given $$$C$$$. Determine a binary array $$$A$$$ that would give $$$C$$$ when processed as above. It is guaranteed that an array $$$A$$$ exists for given $$$C$$$ in the input.","import sys

input = lambda: sys.stdin.buffer.readline().decode().strip()
for _ in range(int(input())):
    n, a = int(input()), [int(x) for x in input().split()]
    ans, ones = [], sum(a) // n
    mem = [0] * (n + 1)

    for i in reversed(range(n)):
        mem[i] += mem[i + 1]
        a[i] -= mem[i]

        if a[i] == i + 1:
            mem[i] += 1
            mem[i - ones] -= 1
            ones -= 1
            ans.append(1)
        elif a[i] == 1:
            mem[i] += 1
            mem[i - ones] -= 1
            ans.append(0)
        else:
            ans.extend([0] * (i + 1))
            break
    print(*ans[::-1])","['constructive algorithms', 'data structures', 'greedy', 'implementation', 'math', 'two pointers']"
"William has array of $$$n$$$ numbers $$$a_1, a_2, \dots, a_n$$$. He can perform the following sequence of operations any number of times:   Pick any two items from array $$$a_i$$$ and $$$a_j$$$, where $$$a_i$$$ must be a multiple of $$$2$$$  $$$a_i = \frac{a_i}{2}$$$  $$$a_j = a_j \cdot 2$$$ Help William find the maximal sum of array elements, which he can get by performing the sequence of operations described above.","# import math
# for i in range(int(input())):
#     n = int(input())
#     if n % 2 == 0 and math.sqrt(n//2) == int(math.sqrt(n//2)):
#         print(""YES"")
#     elif n % 4 == 0 and math.sqrt(n//4) == int(math.sqrt(n//4)):
#         print(""YES"")
#     else:
#         print('NO')

##for i in range(int(input())):
##    t = int(input())
##    x = t // 6
##    y = t // 4
##    if t >= 4 and t % 2 ==0:
##        if t % 6 == 2 or t % 6 == 4:
##            x += 1
##        print(int(x), int(y))
##    else:
##        print(-1)

import math
for i in range(int(input())):    
    n = int(input())    
    a = [int(t) for t in input().split()]          
    m = 0  
    n2 = 0  
    for n in range(len(a)):
        n2 = a[n]
        while n2 % 2 == 0 and n2 > 0:
            m += 1
            n2 //= 2
        a[n] = n2
    print(max(a)*2**m+(sum(a)-max(a)))","['greedy', 'implementation', 'math', 'number theory']"
"William arrived at a conference dedicated to cryptocurrencies. Networking, meeting new people, and using friends' connections are essential to stay up to date with the latest news from the world of cryptocurrencies.The conference has $$$n$$$ participants, who are initially unfamiliar with each other. William can introduce any two people, $$$a$$$ and $$$b$$$, who were not familiar before, to each other. William has $$$d$$$ conditions, $$$i$$$'th of which requires person $$$x_i$$$ to have a connection to person $$$y_i$$$. Formally, two people $$$x$$$ and $$$y$$$ have a connection if there is such a chain $$$p_1=x, p_2, p_3, \dots, p_k=y$$$ for which for all $$$i$$$ from $$$1$$$ to $$$k - 1$$$ it's true that two people with numbers $$$p_i$$$ and $$$p_{i + 1}$$$ know each other.For every $$$i$$$ ($$$1 \le i \le d$$$) William wants you to calculate the maximal number of acquaintances one person can have, assuming that William satisfied all conditions from $$$1$$$ and up to and including $$$i$$$ and performed exactly $$$i$$$ introductions. The conditions are being checked after William performed $$$i$$$ introductions. The answer for each $$$i$$$ must be calculated independently. It means that when you compute an answer for $$$i$$$, you should assume that no two people have been introduced to each other yet.","from collections import defaultdict
n = (10 ** 3)+10
parent = [i for i in range(n)]
size = [1 for i in range(n)]


def find(root):
    a = root
    while parent[a] != a:
        a = parent[a]

    # path comprehension
    while root != a:
        nextnode = parent[root]
        parent[root] = a
        root = nextnode
    return a


def union(a, b):
    a = find(a)
    b = find(b)
    if a != b:
        if size[a] < size[b]:
            a, b = b, a
        parent[b] = a
        size[a] += size[b]
        return False
    else:
        return True


c=0
l,d=map(int,input().split())
for j in range(d):
    a,b=map(int,input().split())
    cans = union(a,b)
    if cans:
        c+=1
    ans=0
    allp=set()
    grps=[]
    for k in range(1,l+1):
        pr= find(k)
        if pr not in allp:
            allp.add(pr)
            grps.append(size[pr])
    grps.sort(reverse=True)
    # print(grps)
    # print(parent[:l+1])
    # print(c)
    for k in range(min(c+1,len(grps))):
        ans+=grps[k]
    print(ans-1)","['dsu', 'graphs', 'greedy', 'implementation', 'trees']"
"Before becoming a successful trader William got a university degree. During his education an interesting situation happened, after which William started to listen to homework assignments much more attentively. What follows is a formal description of the homework assignment as William heard it:You are given a string $$$s$$$ of length $$$n$$$ only consisting of characters ""a"", ""b"" and ""c"". There are $$$q$$$ queries of format ($$$pos, c$$$), meaning replacing the element of string $$$s$$$ at position $$$pos$$$ with character $$$c$$$. After each query you must output the minimal number of characters in the string, which have to be replaced, so that the string doesn't contain string ""abc"" as a subsequence. A valid replacement of a character is replacing it with ""a"", ""b"" or ""c"".A string $$$x$$$ is said to be a subsequence of string $$$y$$$ if $$$x$$$ can be obtained from $$$y$$$ by deleting some characters without changing the ordering of the remaining characters.","import sys
n, q = [int(i) for i in sys.stdin.readline().split()]
s = sys.stdin.readline().strip()
N = 2**n.bit_length()
d = [[0]*6 for i in range(N<<1)]
def upd(i, c):
    i += N
    d[i] = [0]*6
    d[i][c] = 1
    while (i > 1): 
        i >>= 1
        a,b = d[i+i], d[i+i+1]
        d[i] = [a[0]+b[0], a[1]+b[1], a[2]+b[2], min(a[3]+b[1], a[0]+b[3]), min(a[4]+b[2], a[1]+b[4]), min(a[0]+b[5], a[5]+b[2], a[3]+b[4])]
for i,c in enumerate(s):
    upd(i, ord(c)-97)
for _ in range(q):
    i, c = sys.stdin.readline().split()
    upd(int(i)-1, ord(c)-97)
    print(d[1][5])","['bitmasks', 'data structures', 'dp', 'matrices']"
"Now you get Baby Ehab's first words: ""Given an integer $$$n$$$, find the longest subsequence of $$$[1,2, \ldots, n-1]$$$ whose product is $$$1$$$ modulo $$$n$$$."" Please solve the problem.A sequence $$$b$$$ is a subsequence of an array $$$a$$$ if $$$b$$$ can be obtained from $$$a$$$ by deleting some (possibly all) elements. The product of an empty subsequence is equal to $$$1$$$.","from math import sqrt
n = int(input())
m = n
l = [0] * (n - 1)
if n%2 == 0 :
    while m % 2 == 0:    
        m/=2
    if m==1:
        x = 2
    else:
        for i in range(2, n, 2) :
            l[i - 1] += 1

for i in range(3, int(sqrt(m)) + 1, 2):  
    if m%i == 0:
        while m % i == 0:  
            m /= i  
        if m == 1 :
            x = i
            break
        else:
            for i in range(i, n, i) :
                l[i - 1] += 1
if m > 2:  
    op = []
    prod = 1
    for i in range(1, n) :
        if l[i - 1] == 0 and i%m != 0 :
            op.append(i)
            prod*=i
            prod%=n

else:
    op = []
    prod = 1
    for i in range(1, n) :
        if l[i - 1] == 0 and i%x != 0 :
            op.append(i)
            prod*=i
            prod%=n

if prod != 1:
    op.remove(prod)

print(len(op))
print(*op)","['greedy', 'number theory']"
"Baby Ehab has a piece of Cut and Stick with an array $$$a$$$ of length $$$n$$$ written on it. He plans to grab a pair of scissors and do the following to it:  pick a range $$$(l, r)$$$ and cut out every element $$$a_l$$$, $$$a_{l + 1}$$$, ..., $$$a_r$$$ in this range;  stick some of the elements together in the same order they were in the array;  end up with multiple pieces, where every piece contains some of the elements and every element belongs to some piece. More formally, he partitions the sequence $$$a_l$$$, $$$a_{l + 1}$$$, ..., $$$a_r$$$ into subsequences. He thinks a partitioning is beautiful if for every piece (subsequence) it holds that, if it has length $$$x$$$, then no value occurs strictly more than $$$\lceil \frac{x}{2} \rceil$$$ times in it.He didn't pick a range yet, so he's wondering: for $$$q$$$ ranges $$$(l, r)$$$, what is the minimum number of pieces he needs to partition the elements $$$a_l$$$, $$$a_{l + 1}$$$, ..., $$$a_r$$$ into so that the partitioning is beautiful.A sequence $$$b$$$ is a subsequence of an array $$$a$$$ if $$$b$$$ can be obtained from $$$a$$$ by deleting some (possibly zero) elements. Note that it does not have to be contiguous.","randCnts=25
rand40=[26163, 136194, 134910, 131586, 131511, 151306, 107322, 4960, 27557, 30930, 34180, 123393, 226938, 259573, 203560, 182549, 208694, 270671, 3616, 256123, 215635, 140161, 243942, 251246, 210982, 138905, 226417, 63875, 281860, 24400, 129710, 157586, 257466, 113783, 57707, 20202, 179489, 273724, 71076, 47490]
def nPartitions(size,mode):
    b=size
    ep=-1 # extra partitions
    while b>0:
        while ep+b<size and not ((size-(ep+b)+1)//2>=mode-(ep+b)):
            ep+=b
        b//=2
    ep+=1
    return 1+ep

def main():
    
    n,q=readIntArr()
    a=readIntArr()
    # n,q=(300000,300000) #
    # a=[197278]*n #
    
    idxs=[[] for _ in range(n+1)]
    for i,x in enumerate(a):
        idxs[x].append(i)
    
    allans=[]
    
    for _ in range(q):
        l,r=readIntArr()
        # l,r=1,_+1 # 
        l-=1;r-=1
        gap=r-l+1
        mode=0
        for i in range(randCnts):
            idx=l+rand40[i]%gap
            x=a[idx]
            
            arr=idxs[x]
            m=len(arr)
            l2=-1
            b=m
            while b>0:
                while l2+b<m and arr[l2+b]<l:
                    l2+=b
                b//=2
            l2+=1
            
            r2=-1
            b=m
            while b>0:
                while r2+b<m and arr[r2+b]<=r:
                    r2+=b
                b//=2
            mode=max(mode,r2-l2+1)
        allans.append(nPartitions(gap,mode))
    multiLineArrayPrint(allans)
    
    
    return

import sys
input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)
# input=lambda: sys.stdin.readline().rstrip(""\r\n"") #FOR READING STRING/TEXT INPUTS.

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))
 
def readIntArr():
    return [int(x) for x in input().split()]
# def readFloatArr():
#     return [float(x) for x in input().split()]

def makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])
    dv=defaultValFactory;da=dimensionArr
    if len(da)==1:return [dv() for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]
 
def queryInteractive(i,j):
    print('? {} {}'.format(i,j))
    sys.stdout.flush()
    return int(input())
 
def answerInteractive(ans):
    print('! {}'.format(' '.join([str(x) for x in ans])))
    sys.stdout.flush()
 
inf=float('inf')
MOD=10**9+7
# MOD=998244353
 
 
for _abc in range(1):
    main()","['binary search', 'data structures', 'greedy', 'implementation', 'sortings']"
"Recently Lynyrd and Skynyrd went to a shop where Lynyrd bought a permutation $$$p$$$ of length $$$n$$$, and Skynyrd bought an array $$$a$$$ of length $$$m$$$, consisting of integers from $$$1$$$ to $$$n$$$. Lynyrd and Skynyrd became bored, so they asked you $$$q$$$ queries, each of which has the following form: ""does the subsegment of $$$a$$$ from the $$$l$$$-th to the $$$r$$$-th positions, inclusive, have a subsequence that is a cyclic shift of $$$p$$$?"" Please answer the queries.A permutation of length $$$n$$$ is a sequence of $$$n$$$ integers such that each integer from $$$1$$$ to $$$n$$$ appears exactly once in it.A cyclic shift of a permutation $$$(p_1, p_2, \ldots, p_n)$$$ is a permutation $$$(p_i, p_{i + 1}, \ldots, p_{n}, p_1, p_2, \ldots, p_{i - 1})$$$ for some $$$i$$$ from $$$1$$$ to $$$n$$$. For example, a permutation $$$(2, 1, 3)$$$ has three distinct cyclic shifts: $$$(2, 1, 3)$$$, $$$(1, 3, 2)$$$, $$$(3, 2, 1)$$$.A subsequence of a subsegment of array $$$a$$$ from the $$$l$$$-th to the $$$r$$$-th positions, inclusive, is a sequence $$$a_{i_1}, a_{i_2}, \ldots, a_{i_k}$$$ for some $$$i_1, i_2, \ldots, i_k$$$ such that $$$l \leq i_1 &lt; i_2 &lt; \ldots &lt; i_k \leq r$$$.","import sys
 
class segmentTree:
	def __init__(self, n):
		self.n = n
		self.seg = [self.n + 1] * (self.n << 1)
		
	def update(self, p, value):
		p += self.n
		self.seg[p] = value
		while p > 1:
			p >>= 1
			self.seg[p] = min(self.seg[p * 2], self.seg[p * 2 + 1])
			
	
	def query(self, l, r):
		res = self.n
		l += self.n
		r += self.n
		while l < r:
			if l & 1:
				res = min(res, self.seg[l])
				l += 1
			if r & 1:
				res = min(res, self.seg[r - 1])
				r -= 1
			l >>= 1
			r >>= 1
		return res
				
inp = [int(x) for x in sys.stdin.read().split()]
 
n, m, q = inp[0], inp[1], inp[2]
 
p = [inp[idx] for idx in range(3, n + 3)]
 
index_arr = [0] * (n + 1)
for i in range(n):	index_arr[p[i]] = i
 
a = [inp[idx] for idx in range(n + 3, n + 3 + m)]
 
leftmost_pos = [m] * (n + 1)
next = [-1] * m
 
for i in range(m - 1, -1, -1):
	index = index_arr[a[i]]
	right_index = 0 if index == n - 1 else index + 1
	right = p[right_index]
	next[i] = leftmost_pos[right]
	leftmost_pos[a[i]] = i
	
log = 0
while (1 << log) <= n: log += 1
log += 1
dp = [[m for _ in range(m + 1)] for  _ in range(log)]
 
for i in range(m):
	dp[0][i] = next[i]
 
for j in range(1, log):
	for i in range(m):
		dp[j][i] = dp[j - 1][dp[j - 1][i]]
 
tree = segmentTree(m)
for i in range(m):
	p = i
	len = n - 1
	for j in range(log - 1, -1, -1):
		if (1 << j) <= len:
			p = dp[j][p]
			len -= (1 << j)
	tree.update(i, p)
 
inp_idx = n + m + 3
ans = []
for i in range(q):
	l, r = inp[inp_idx] - 1, inp[inp_idx + 1] - 1
	inp_idx += 2
	if tree.query(l, r + 1) <= r:
		ans.append('1')
	else:
		ans.append('0')
print(''.join(ans))","['dp', 'math', 'data structures', 'dfs and similar', 'trees']"
"You are given a tree consisting of $$$n$$$ vertices, and $$$q$$$ triples $$$(x_i, y_i, s_i)$$$, where $$$x_i$$$ and $$$y_i$$$ are integers from $$$1$$$ to $$$n$$$, and $$$s_i$$$ is a string with length equal to the number of vertices on the simple path from $$$x_i$$$ to $$$y_i$$$.You want to write a lowercase Latin letter on each vertex in such a way that, for each of $$$q$$$ given triples, at least one of the following conditions holds:  if you write out the letters on the vertices on the simple path from $$$x_i$$$ to $$$y_i$$$ in the order they appear on this path, you get the string $$$s_i$$$;  if you write out the letters on the vertices on the simple path from $$$y_i$$$ to $$$x_i$$$ in the order they appear on this path, you get the string $$$s_i$$$. Find any possible way to write a letter on each vertex to meet these constraints, or report that it is impossible.","class _csr:
    def __init__(self, n, edges):
        self.start = [0] * (n + 1)
        self.elist = [0] * len(edges)
        for v, _ in edges:
            self.start[v + 1] += 1
        for i in range(1, n + 1):
            self.start[i] += self.start[i - 1]
        counter = self.start.copy()
        for v, e in edges:
            self.elist[counter[v]] = e
            counter[v] += 1

class scc_graph:
    """"""It calculates the strongly connected components of directed graphs.
    """"""
 
    def __init__(self, n):
        """"""It creates a directed graph with n vertices and 0 edges.
 
        Constraints
        -----------
 
        >   0 <= n <= 10 ** 8
 
        Complexity
        ----------
 
        >   O(n)
        """"""
        self.n = n
        self.edges = []
 
    def add_edge(self, from_, to):
        """"""It adds a directed edge from the vertex `from_` to the vertex `to`.
 
        Constraints
        -----------
 
        >   0 <= from_ < n
 
        >   0 <= to < n
 
        Complexity
        ----------
 
        >   O(1) amortized
        """"""
        # assert 0 <= from_ < self.n
        # assert 0 <= to < self.n
        self.edges.append((from_, to))
 
    def _scc_ids(self):
        g = _csr(self.n, self.edges)
        now_ord = 0
        group_num = 0
        visited = []
        low = [0] * self.n
        order = [-1] * self.n
        ids = [0] * self.n
        parent = [-1] * self.n
        stack = []
        for i in range(self.n):
            if order[i] == -1:
                stack.append(i)
                stack.append(i)
                while stack:
                    v = stack.pop()
                    if order[v] == -1:
                        low[v] = order[v] = now_ord
                        now_ord += 1
                        visited.append(v)
                        for i in range(g.start[v], g.start[v + 1]):
                            to = g.elist[i]
                            if order[to] == -1:
                                stack.append(to)
                                stack.append(to)
                                parent[to] = v
                            else:
                                low[v] = min(low[v], order[to])
                    else:
                        if low[v] == order[v]:
                            while True:
                                u = visited.pop()
                                order[u] = self.n
                                ids[u] = group_num
                                if u == v:
                                    break
                            group_num += 1
                        if parent[v] != -1:
                            low[parent[v]] = min(low[parent[v]], low[v])
        for i, x in enumerate(ids):
            ids[i] = group_num - 1 - x
        return group_num, ids
 
    def scc(self):
        """"""It returns the list of the ""list of the vertices"" that satisfies the following.
 
        >   Each vertex is in exactly one ""list of the vertices"".
 
        >   Each ""list of the vertices"" corresponds to the vertex set of a strongly connected component.
        The order of the vertices in the list is undefined.
 
        >   The list of ""list of the vertices"" are sorted in topological order,
        i.e., for two vertices u, v in different strongly connected components,
        if there is a directed path from u to v,
        the list contains u appears earlier than the list contains v.
 
        Complexity
        ----------
 
        >   O(n + m), where m is the number of added edges.
        """"""
        group_num, ids = self._scc_ids()
        groups = [[] for _ in range(group_num)]
        for i, x in enumerate(ids):
            groups[x].append(i)
        return groups
 
 
class two_sat:
    """"""It solves 2-SAT.
 
    For variables x[0], x[1], ..., x[n-1] and clauses with form
 
    >   ((x[i] = f) or (x[j] = g)),
 
    it decides whether there is a truth assignment that satisfies all clauses.
    """"""
 
    def __init__(self, n):
        """"""It creates a 2-SAT of n variables and 0 clauses.
 
        Constraints
        -----------
 
        >   0 <= n <= 10 ** 8
 
        Complexity
        ----------
 
        >   O(n)
        """"""
        self.n = n
        self._answer = [False] * n
        self.scc = scc_graph(2 * n)
 
    def add_clause(self, i, f, j, g):
        """"""It adds a clause ((x[i] = f) or (x[j] = g)).
 
        Constraints
        -----------
 
        >   0 <= i < n
 
        >   0 <= j < n
 
        Complexity
        ----------
 
        >   O(1) amortized
        """"""
        # assert 0 <= i < self.n
        # assert 0 <= j < self.n
        self.scc.add_edge(2 * i + (f == 0), 2 * j + (g == 1))
        self.scc.add_edge(2 * j + (g == 0), 2 * i + (f == 1))
 
    def satisfiable(self):
        """"""If there is a truth assignment that satisfies all clauses, it returns `True`.
        Otherwise, it returns `False`.
 
        Constraints
        -----------
 
        >   You may call it multiple times.
 
        Complexity
        ----------
 
        >   O(n + m), where m is the number of added clauses.
        """"""
        _, ids = self.scc._scc_ids()
        for i in range(self.n):
            if ids[2 * i] == ids[2 * i + 1]:
                return False
            self._answer[i] = (ids[2*i] < ids[2*i+1])
        return True
 
    def answer(self):
        """"""It returns a truth assignment that satisfies all clauses of the last call of `satisfiable`.
        If we call it before calling `satisfiable` or when the last call of `satisfiable` returns `False`,
        it returns the list of length n with undefined elements.
 
        Complexity
        ----------
 
        >   O(n)
        """"""
        return self._answer.copy()

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

N,Q = mi()
edge = [[] for v in range(N)]
for _ in range(N-1):
    u,v = mi()
    edge[u-1].append(v-1)
    edge[v-1].append(u-1)

parent = [[-1]*19 for i in range(N)]
depth = [0] * N
deq = deque([0])
while deq:
    v = deq.popleft()
    for nv in edge[v]:
        if nv==parent[v][0]:
            continue
        parent[nv][0] = v
        depth[nv] = depth[v] + 1
        deq.append(nv)

for k in range(1,19):
    for v in range(N):
        if parent[v][k-1]==-1:
            parent[v][k] = -1
        else:
            pv = parent[v][k-1]
            parent[v][k] = parent[pv][k-1]
    

def lca(u,v):
    if depth[u] > depth[v]:
        u,v = v,u
    
    dd = depth[v] - depth[u]
    for k in range(19)[::-1]:
        if dd>>k & 1:
            v = parent[v][k]
    
    if u==v:
        return u
        
    for k in range(19)[::-1]:
        pu,pv = parent[u][k],parent[v][k]
        if pu!=pv:
            u,v = pu,pv
    return parent[u][0]

def path(u,v):
    L = lca(u,v)
    res0 = [u]
    pos = u
    while pos!=L:
        pos = parent[pos][0]
        res0.append(pos)
    
    res1 = [v]
    pos = v
    while pos!=L:
        pos = parent[pos][0]
        res1.append(pos)
    res1.pop()
    return res0 + res1[::-1]

cand = [None for v in range(N)]
string = []
for i in range(Q):
    u,v,s = input().split()
    u,v = int(u)-1,int(v)-1

    p = path(u,v)
    n = len(s)
    for j in range(n):
        v = p[j]
        if cand[v] is None:
            cand[v] = set([s[j],s[-j-1]])
        else:
            cand[v] &= set([s[j],s[-j-1]])
    string.append((u,v,s))

for v in range(N):
    if cand[v] is None:
        cand[v] = [""a"",""b""]
    else:
        cand[v] = list(cand[v]) + [""("","")""][:2-len(cand[v])]

#print(cand)

G = two_sat(N+Q)
for i in range(Q):
    u,v,s = string[i]
    p = path(u,v)
    n = len(s)
    for j in range(n):
        if s[j]==s[-j-1]:
            continue

        v = p[j]

        t = s[j]
        if t==cand[v][0]:
            G.add_clause(i+N,1,v,0)
        elif t==cand[v][1]:
            G.add_clause(i+N,1,v,1)
        else:
            G.add_clause(i+N,1,i+N,1)
        
        t = s[-j-1]
        if t==cand[v][0]:
            G.add_clause(i+N,0,v,0)
        elif t==cand[v][1]:
            G.add_clause(i+N,0,v,1)
        else:
            G.add_clause(i+N,0,i+N,0)

check = G.satisfiable()
if not check:
    exit(print(""NO""))

ans = G.answer()
res = []
for v in range(N):
    if ans[v]:
        res.append(cand[v][1])
    else:
        res.append(cand[v][0])
#print(res,ans)
for i in range(Q):
    u,v,s = string[i]
    p = path(u,v)
    n = len(s)

    if any(res[p[j]]!=s[j] for j in range(n)) and any(res[p[j]]!=s[-j-1] for j in range(n)):
        exit(print(""NO""))

print(""YES"")
print("""".join(res))","['2-sat', 'dfs and similar', 'dsu', 'graphs', 'trees']"
"The pandemic is upon us, and the world is in shortage of the most important resource: toilet paper. As one of the best prepared nations for this crisis, BubbleLand promised to help all other world nations with this valuable resource. To do that, the country will send airplanes to other countries carrying toilet paper.In BubbleLand, there are $$$N$$$ toilet paper factories, and $$$N$$$ airports. Because of how much it takes to build a road, and of course legal issues, every factory must send paper to only one airport, and every airport can only take toilet paper from one factory.Also, a road can't be built between all airport-factory pairs, again because of legal issues. Every possible road has number $$$d$$$ given, number of days it takes to build that road.Your job is to choose $$$N$$$ factory-airport pairs, such that if the country starts building all roads at the same time, it takes the least amount of days to complete them.","import os
import sys
from io import BytesIO, IOBase
# region fastio
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# ------------------------------
 
def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def print_list(l):
    print(' '.join(map(str,l)))
# import sys
# sys.setrecursionlimit(5010)
# from heapq import *
# from collections import deque as dq
# from math import ceil,floor,sqrt,pow
# import bisect as bs
# from collections import Counter
from collections import defaultdict as dc 

def judge(last,key,d1,d2):
    if key>last:
        for (a,b,c) in data:
            if last<c<=key:
                d1[a].add(b)
                d2[b].add(a)

    else:
        for (a,b,c) in data:
            if key<c<=last:
                d1[a].remove(b)
                if not d1[a]:
                    del d1[a]
                d2[b].remove(a)
                if not d2[b]:
                    del d2[b]
    if len(d1.keys())<n or len(d2.keys())<n:
        return False

    for a in d1:
        lone = 0
        for b in d1[a]:
            if len(d2[b])==1:
                lone+=1
                if lone>1:
                    return False
    for b in d2:
        lone = 0
        for a in d2[b]:
            if len(d1[a])==1:
                lone+=1
                if lone>1:
                    return False

        
    used = set()
    for a in d1:
        if a not in used:
            s1,s2,now = {a},d1[a].copy(),d1[a].copy()
            while now:
                b = now.pop()
                da = d2[b]-s1 
                s1|=da 
                for aa in da:
                    db = d1[aa]-s2
                    now|=db
                    s2|=db
            if len(s1)!=len(s2):
                return False
            used|=s1
    return True


n,m = RL()
data = []
for _ in range(m):
    data.append(tuple(map(int, sys.stdin.readline().split())))
l,r = min(a[2] for a in data),max(a[2] for a in data)+1
md = r
last = 0
du = dc(set)
dv = dc(set)
while l<r:
    key = (l+r)>>1
    if judge(last,key,du,dv):
        r = key
    else:
        l = key+1
    last = key
if l>=md:
    print(-1)
else:
    print(l)","['graph matchings', 'binary search', 'flows', 'graphs']"
"You are given two integers $$$a$$$ and $$$b$$$. You may perform any number of operations on them (possibly zero).During each operation you should choose any positive integer $$$x$$$ and set $$$a := a - x$$$, $$$b := b - 2x$$$ or $$$a := a - 2x$$$, $$$b := b - x$$$. Note that you may choose different values of $$$x$$$ in different operations.Is it possible to make $$$a$$$ and $$$b$$$ equal to $$$0$$$ simultaneously?Your program should answer $$$t$$$ independent test cases.","t = int(input())
while t:
    t -= 1
    a, b = tuple(map(int, input().split()))
    if (a > b):
        a, b = b, a
    if ((2 * a - b) % 3 == 0 and b <= 2 * a):
        print(""Yes"")
    else:
        print(""No"")","['binary search', 'math']"
"A magic island Geraldion, where Gerald lives, has its own currency system. It uses banknotes of several values. But the problem is, the system is not perfect and sometimes it happens that Geraldionians cannot express a certain sum of money with any set of banknotes. Of course, they can use any number of banknotes of each value. Such sum is called unfortunate. Gerald wondered: what is the minimum unfortunate sum?","import sys
n= int(input())
banknotes= list(map(int,input().split()))
for i in banknotes:
    if i == 1:
        print(-1);
        sys.exit(0);
print(1);","['implementation', 'sortings']"
"Bessie has way too many friends because she is everyone's favorite cow! Her new friend Rabbit is trying to hop over so they can play! More specifically, he wants to get from $$$(0,0)$$$ to $$$(x,0)$$$ by making multiple hops. He is only willing to hop from one point to another point on the 2D plane if the Euclidean distance between the endpoints of a hop is one of its $$$n$$$ favorite numbers: $$$a_1, a_2, \ldots, a_n$$$. What is the minimum number of hops Rabbit needs to get from $$$(0,0)$$$ to $$$(x,0)$$$? Rabbit may land on points with non-integer coordinates. It can be proved that Rabbit can always reach his destination.Recall that the Euclidean distance between points $$$(x_i, y_i)$$$ and $$$(x_j, y_j)$$$ is $$$\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}$$$.For example, if Rabbit has favorite numbers $$$1$$$ and $$$3$$$ he could hop from $$$(0,0)$$$ to $$$(4,0)$$$ in two hops as shown below. Note that there also exists other valid ways to hop to $$$(4,0)$$$ in $$$2$$$ hops (e.g. $$$(0,0)$$$ $$$\rightarrow$$$ $$$(2,-\sqrt{5})$$$ $$$\rightarrow$$$ $$$(4,0)$$$).    Here is a graphic for the first example. Both hops have distance $$$3$$$, one of Rabbit's favorite numbers. In other words, each time Rabbit chooses some number $$$a_i$$$ and hops with distance equal to $$$a_i$$$ in any direction he wants. The same number can be used multiple times.","from  math import ceil
for _ in range(int(input())):
    n, x = map(int, input().split())
    jumps = set(map(int, input().split()))
    if x in jumps:
        print(1)
        continue
    jumpmax = max(jumps)
    if jumpmax > x:
        print(2)
    else:
        print(ceil(x / jumpmax))","['geometry', 'greedy', 'math']"
"On a chessboard with a width of $$$10^9$$$ and a height of $$$10^9$$$, the rows are numbered from bottom to top from $$$1$$$ to $$$10^9$$$, and the columns are numbered from left to right from $$$1$$$ to $$$10^9$$$. Therefore, for each cell of the chessboard you can assign the coordinates $$$(x,y)$$$, where $$$x$$$ is the column number and $$$y$$$ is the row number.Every day there are fights between black and white pieces on this board. Today, the black ones won, but at what price? Only the rook survived, and it was driven into the lower left corner — a cell with coordinates $$$(1,1)$$$. But it is still happy, because the victory has been won and it's time to celebrate it! In order to do this, the rook needs to go home, namely — on the upper side of the field (that is, in any cell that is in the row with number $$$10^9$$$).Everything would have been fine, but the treacherous white figures put spells on some places of the field before the end of the game. There are two types of spells:   Vertical. Each of these is defined by one number $$$x$$$. Such spells create an infinite blocking line between the columns $$$x$$$ and $$$x+1$$$.  Horizontal. Each of these is defined by three numbers $$$x_1$$$, $$$x_2$$$, $$$y$$$. Such spells create a blocking segment that passes through the top side of the cells, which are in the row $$$y$$$ and in columns from $$$x_1$$$ to $$$x_2$$$ inclusive. The peculiarity of these spells is that it is impossible for a certain pair of such spells to have a common point. Note that horizontal spells can have common points with vertical spells.    An example of a chessboard. Let's recall that the rook is a chess piece that in one move can move to any point that is in the same row or column with its initial position. In our task, the rook can move from the cell $$$(r_0,c_0)$$$ into the cell $$$(r_1,c_1)$$$ only under the condition that $$$r_1 = r_0$$$ or $$$c_1 = c_0$$$ and there is no blocking lines or blocking segments between these cells (For better understanding, look at the samples).Fortunately, the rook can remove spells, but for this it has to put tremendous efforts, therefore, it wants to remove the minimum possible number of spells in such way, that after this it can return home. Find this number!","from collections import namedtuple
import sys

HS = namedtuple('HS', 'x1 x2 y')

n, m = [int(w) for w in input().split()]
vs = [int(input()) for _ in range(n)]
hs = [HS(*[int(w) for w in input().split()]) for _ in range(m)]

vs.sort()

hr = len([s for s in hs if s.x1 == 1 and s.x2 == 10**9])
hs = [s.x2 for s in hs if s.x1 == 1 and s.x2 < 10**9]
hs.sort()

r = hc = len(hs)
hi = vi = 0
for hi in range(hc):
    while vi < n and hs[hi] >= vs[vi]:
        vi += 1
    c = (hc - hi - 1) + vi
    if c < r:
        r = c

print(r + hr)",['two pointers']
"Volodya likes listening to heavy metal and (occasionally) reading. No wonder Volodya is especially interested in texts concerning his favourite music style.Volodya calls a string powerful if it starts with ""heavy"" and ends with ""metal"". Finding all powerful substrings (by substring Volodya means a subsequence of consecutive characters in a string) in a given text makes our hero especially joyful. Recently he felt an enormous fit of energy while reading a certain text. So Volodya decided to count all powerful substrings in this text and brag about it all day long. Help him in this difficult task. Two substrings are considered different if they appear at the different positions in the text.For simplicity, let us assume that Volodya's text can be represented as a single string.","#_________________ Mukul Mohan Varshney _______________#

#Template
import sys
import os
import math
import copy
from math import gcd
from bisect import bisect
from io import BytesIO, IOBase
from math import sqrt,floor,factorial,gcd,log,ceil
from collections import deque,Counter,defaultdict
from itertools import permutations, combinations

#define function 
def Int(): return int(sys.stdin.readline())
def Mint(): return map(int,sys.stdin.readline().split())
def Lstr(): return list(sys.stdin.readline().strip())
def Str(): return sys.stdin.readline().strip()
def Mstr(): return map(str,sys.stdin.readline().strip().split())
def List(): return list(map(int,sys.stdin.readline().split()))
def Hash(): return dict()
def Mod(): return 1000000007
def Ncr(n,r,p): return ((fact[n])*((ifact[r]*ifact[n-r])%p))%p
def Most_frequent(list): return max(set(list), key = list.count)
def Mat2x2(n): return [List() for _ in range(n)]
def btod(n): 
    return int(n,2) 
    
def dtob(n): 
    return bin(n).replace(""0b"","""")    

 
# Driver Code 	
def solution():
     #for _ in range(Int()):
          n=Str()
          s=0
          e=0
          for i in range(len(n)):
               if(n[i:i+5]=='heavy'):
                    s+=1
               if(n[i:i+5]=='metal'):
                    e+=s
          print(e)          
          
          
#Call the solve function          
if __name__ == ""__main__"":
     solution()","['two pointers', 'implementation', 'strings']"
You are given an array $$$a$$$ consisting of $$$n$$$ positive integers. Find a non-empty subset of its elements such that their sum is even (i.e. divisible by $$$2$$$) or determine that there is no such subset.Both the given array and required subset may contain equal values.,"#!/bin/python3
t = int(input())
while t > 0:
    n = int(input())
    array = list(map(int, input().split()))
    if n == 1:
        # 1 is 00000001 in binary , and 2 is 00000010
        # for future reference 1 bitwise AND 2 is false
        # that's a fancy way to say array[0] == 1
        if array[0] & 1:
            print(-1)
        else:
            print(""1\n1"")
    else:
        # nb: every fucking odd number has 1 in the
        # very right digit in binary i.e. 3 is 00000011
        # 5 is 00000101 and so on....
        if (array[0] & 1) and (array[1] & 1):
            print(""2\n1 2\n"")
        else:
            print(1)
            if array[0] & 1:
                print(2)
            else:
                print(1)
    t -= 1","['dp', 'implementation', 'greedy', 'brute force']"
"The Berland State University is hosting a ballroom dance in celebration of its 100500-th anniversary! n boys and m girls are already busy rehearsing waltz, minuet, polonaise and quadrille moves.We know that several boy&amp;girl pairs are going to be invited to the ball. However, the partners' dancing skill in each pair must differ by at most one.For each boy, we know his dancing skills. Similarly, for each girl we know her dancing skills. Write a code that can determine the largest possible number of pairs that can be formed from n boys and m girls.","def try_kuhn (v):
	if u[v]:
		return False
	u[v] = 1
	for to in g[v]:
		if mt[to] == -1 or try_kuhn(mt[to]):
			mt[to] = v
			return True
	return False
 
n = int(input()) #размер 1 доли
A = list(map(int, input().split()))
m = int(input()) #размер 2 доли
B = list(map(int, input().split()))
g = [[] for i in range(n)]
k = 0 #кол-во рёбер
for i in range(n) :
	for j in range(m) :
		if abs(A[i] - B[j]) < 2:
			g[i].append(j)
			k += 1
mt = [-1] * m #для каждой вершины 2-ой доли указывает вершину из 1-ой, с которой она соединена
r = [0] * n #вершины, которые мы обойдём жадным способом (они уже будут в паросочетании, их больше трогать не надо)
for i in range(n):
	for j in g[i]:
		if mt[j] == -1:
			mt[j] = i
			r[i] = 1
			break
u = [0] * n
for v in range(n):
	if not r[v] and try_kuhn(v):
		u = [0] * n
	
o = 0
for i in range(m):
		if (mt[i] != -1):
			o += 1
print(o)","['dp', 'greedy', 'two pointers', 'graph matchings', 'sortings', 'dfs and similar']"
"Little Vasya has received a young builder’s kit. The kit consists of several wooden bars, the lengths of all of them are known. The bars can be put one on the top of the other if their lengths are the same.Vasya wants to construct the minimal number of towers from the bars. Help Vasya to use the bars in the best way possible.","input()
z=[]
d=list(map(int,input().split()))
k=0
for n in d:
	k=max(k,d.count(n))
	if n not in z:
		z.append(n)
print(k,len(z))",['sortings']
"You are playing a variation of game 2048. Initially you have a multiset $$$s$$$ of $$$n$$$ integers. Every integer in this multiset is a power of two. You may perform any number (possibly, zero) operations with this multiset.During each operation you choose two equal integers from $$$s$$$, remove them from $$$s$$$ and insert the number equal to their sum into $$$s$$$.For example, if $$$s = \{1, 2, 1, 1, 4, 2, 2\}$$$ and you choose integers $$$2$$$ and $$$2$$$, then the multiset becomes $$$\{1, 1, 1, 4, 4, 2\}$$$.You win if the number $$$2048$$$ belongs to your multiset. For example, if $$$s = \{1024, 512, 512, 4\}$$$ you can win as follows: choose $$$512$$$ and $$$512$$$, your multiset turns into $$$\{1024, 1024, 4\}$$$. Then choose $$$1024$$$ and $$$1024$$$, your multiset turns into $$$\{2048, 4\}$$$ and you win.You have to determine if you can win this game.You have to answer $$$q$$$ independent queries.","def count(arr,cnt):
	for i in range(0,len(arr)):
		if arr[i] in cnt.keys():
			cnt[arr[i]] = cnt[arr[i]] + 1
		else:
			cnt[arr[i]] = 1
def yn2048(arr,t):
	f = {}
	count(arr,f)
	keys = f.keys()
	for i in range(0,11):
		k = 0
		keys = f.keys()
		if pow(2,i) in keys:
			 k = f[pow(2,i)]/2 
		if pow(2,i+1) in keys:
			f[pow(2,i+1)] = f[pow(2,i+1)] + k
		elif k > 0:
			f[pow(2,i+1)] = k
	if 2048 in f:
		t.append(""YES"")
	else:
		t.append(""No"")

def main():
	t = []
	q = int(raw_input())
	for i in range(q):
		f = raw_input()
		arr = list(map(int,raw_input().split("" "")))
		yn2048(arr,t)
	for i in t:
		print (i)
main()","['greedy', 'math', 'brute force']"
"Little boy Petya loves stairs very much. But he is bored from simple going up and down them — he loves jumping over several stairs at a time. As he stands on some stair, he can either jump to the next one or jump over one or two stairs at a time. But some stairs are too dirty and Petya doesn't want to step on them.Now Petya is on the first stair of the staircase, consisting of n stairs. He also knows the numbers of the dirty stairs of this staircase. Help Petya find out if he can jump through the entire staircase and reach the last stair number n without touching a dirty stair once.One has to note that anyway Petya should step on the first and last stairs, so if the first or the last stair is dirty, then Petya cannot choose a path with clean steps only.","from Queue import * # Queue, LifoQueue, PriorityQueue
from bisect import * #bisect, insort
from datetime import * 
from collections import * #deque, Counter,OrderedDict,defaultdict
import calendar
import heapq
import math
import copy
import itertools

def solver():
    n,m = map(int,raw_input().split())
    if m != 0:
        dirty = map(int,raw_input().split())
        dirty.sort()
    if m == 0:
        print ""YES""
        return
    if dirty[0] == 1 or dirty[-1] == n:
        print ""NO""
        return
    
    if len(dirty) == 1:
        print ""YES""
        return
    for i in range(len(dirty)-2):
        if dirty[i+2] - dirty[i] == 2:
            print ""NO""
            return

    print ""YES""
            
    
    



if __name__ == ""__main__"":
    solver()","['implementation', 'sortings']"
"Toad Ivan has $$$m$$$ pairs of integers, each integer is between $$$1$$$ and $$$n$$$, inclusive. The pairs are $$$(a_1, b_1), (a_2, b_2), \ldots, (a_m, b_m)$$$. He asks you to check if there exist two integers $$$x$$$ and $$$y$$$ ($$$1 \leq x &lt; y \leq n$$$) such that in each given pair at least one integer is equal to $$$x$$$ or $$$y$$$.","from collections import defaultdict
n,m = list(map(int,input().split()))
freq = [0 for i in range(n+1)]
arr = []
f = 0
for i in range(m):
    u,v = list(map(int,input().split()))
    if f==0:
        temp = [u,v]
        f = 1
    p = [u,v]
    p =set(p)
    arr.append(p)
for i in temp:
    ans = []
    for j in arr:
        x = list(j)
        if i in x:
            continue
        else:
            ans.append(j)
    if ans==[]:
        print(""YES"")
        exit()
    else:
        x = ans[0]
        f = 0
        for j in range(1,len(ans)):
            y = ans[j]
            x = x.intersection(y)
            if x==set():
                f = 1
                break
        if f==0:
            print(""YES"")
            exit()
print(""NO"")","['implementation', 'graphs']"
"Vasya is sitting on an extremely boring math class. To have fun, he took a piece of paper and wrote out n numbers on a single line. After that, Vasya began to write out different ways to put pluses (""+"") in the line between certain digits in the line so that the result was a correct arithmetic expression; formally, no two pluses in such a partition can stand together (between any two adjacent pluses there must be at least one digit), and no plus can stand at the beginning or the end of a line. For example, in the string 100500, ways 100500 (add no pluses), 1+00+500 or 10050+0 are correct, and ways 100++500, +1+0+0+5+0+0 or 100500+ are incorrect.The lesson was long, and Vasya has written all the correct ways to place exactly k pluses in a string of digits. At this point, he got caught having fun by a teacher and he was given the task to calculate the sum of all the resulting arithmetic expressions by the end of the lesson (when calculating the value of an expression the leading zeros should be ignored). As the answer can be large, Vasya is allowed to get only its remainder modulo 109 + 7. Help him!","n, k = map(int, input().split())
t = list(map(int, input()))
p, d = 1, 10 ** 9 + 7
s, f = 0, [1] * n
for i in range(2, n): f[i] = (i * f[i - 1]) % d
c = lambda a, b: 0 if a > b else (f[b] * pow(f[a] * f[b - a], d - 2, d)) % d
if k:
    u = [0] * (n + 1)
    p = [1] * (n + 1)
    for i in range(n):
        u[i] = (p[i] * c(k - 1, n - 2 - i) + u[i - 1]) % d
        p[i + 1] = (10 * p[i]) % d
    for i in range(n): 
        v = u[n - 2 - i] + p[n - 1 - i] * c(k, i)
        s = (s + t[i] * v) % d
else:
    for i in t: s = (s * 10 + i) % d
print(s)","['dp', 'combinatorics', 'number theory', 'math']"
"Polycarp wants to cook a soup. To do it, he needs to buy exactly $$$n$$$ liters of water.There are only two types of water bottles in the nearby shop — $$$1$$$-liter bottles and $$$2$$$-liter bottles. There are infinitely many bottles of these two types in the shop.The bottle of the first type costs $$$a$$$ burles and the bottle of the second type costs $$$b$$$ burles correspondingly.Polycarp wants to spend as few money as possible. Your task is to find the minimum amount of money (in burles) Polycarp needs to buy exactly $$$n$$$ liters of water in the nearby shop if the bottle of the first type costs $$$a$$$ burles and the bottle of the second type costs $$$b$$$ burles. You also have to answer $$$q$$$ independent queries.","q=int(input())
for x in range(q):
	price=0
	arr = [int(xx) for xx in input().split()]
	if arr[1]>=arr[2]:
		if arr[0]%2==0:
			price=(arr[0]/2)*arr[2]
		else:
			price=((arr[0]-1)/2)*arr[2]+arr[1]
	else:
		if arr[0]%2==0:
			if arr[0]*arr[1]<=(arr[0]/2)*arr[2]:
				price=arr[0]*arr[1]
			else:
				price=(arr[0]/2)*arr[2]
		else:
			if arr[0]*arr[1]<=((arr[0]-1)/2)*arr[2]+arr[1]:
				price=arr[0]*arr[1]
			else:
				price=((arr[0]-1)/2)*arr[2]+arr[1]
	print(int(price))",['math']
"According to a new ISO standard, a flag of every country should have a chequered field n × m, each square should be of one of 10 colours, and the flag should be «striped»: each horizontal row of the flag should contain squares of the same colour, and the colours of adjacent horizontal rows should be different. Berland's government asked you to find out whether their flag meets the new ISO standard.","import sys
n , m = map (int , input ().split ())
a=n*[""""]
for i in range (n):
	a[i]=input ()
for i in range (n-1):
	if a[i]==a[i+1] :
		print (""NO"")
		sys.exit()
for i in range (n):
	for j in range (m):
		for z in range (j+1 , m):
			if a[i][j]!=a[i][z]:
				print (""No"")
				sys.exit()
print (""YES"")",['implementation']
"Let's call an array $$$a_1, a_2, \dots, a_m$$$ of nonnegative integer numbers good if $$$a_1 + a_2 + \dots + a_m = 2\cdot(a_1 \oplus a_2 \oplus \dots \oplus a_m)$$$, where $$$\oplus$$$ denotes the bitwise XOR operation.For example, array $$$[1, 2, 3, 6]$$$ is good, as $$$1 + 2 + 3 + 6 = 12 = 2\cdot 6 = 2\cdot (1\oplus 2 \oplus 3 \oplus 6)$$$. At the same time, array $$$[1, 2, 1, 3]$$$ isn't good, as $$$1 + 2 + 1 + 3 = 7 \neq 2\cdot 1 = 2\cdot(1\oplus 2 \oplus 1 \oplus 3)$$$.You are given an array of length $$$n$$$: $$$a_1, a_2, \dots, a_n$$$. Append at most $$$3$$$ elements to it to make it good. Appended elements don't have to be different. It can be shown that the solution always exists under the given constraints. If there are different solutions, you are allowed to output any of them. Note that you don't have to minimize the number of added elements!. So, if an array is good already you are allowed to not append elements.","for i in range(int(input())):
    x=int(input())
    m=list(map(int,input().split()))
    s=0
    ss=0
    for j in range(x):
        s=s^m[j]
        ss+=m[j]
    if s==0:
        print(""1"")
        print(ss)
    else:
        print(""2"")
        print(str(s)+"" ""+str(ss+s))","['constructive algorithms', 'bitmasks', 'math']"
"There are two rival donut shops.The first shop sells donuts at retail: each donut costs $$$a$$$ dollars.The second shop sells donuts only in bulk: box of $$$b$$$ donuts costs $$$c$$$ dollars. So if you want to buy $$$x$$$ donuts from this shop, then you have to buy the smallest number of boxes such that the total number of donuts in them is greater or equal to $$$x$$$.You want to determine two positive integer values:   how many donuts can you buy so that they are strictly cheaper in the first shop than in the second shop?  how many donuts can you buy so that they are strictly cheaper in the second shop than in the first shop? If any of these values doesn't exist then that value should be equal to $$$-1$$$. If there are multiple possible answers, then print any of them.The printed values should be less or equal to $$$10^9$$$. It can be shown that under the given constraints such values always exist if any values exist at all.","mx=1000000000

def solve():
  a,b,c=map(int,input().split())
  if(a>=c):
    ans1=-1
    ans2=c//a+1
  elif(c>a*b or c==a*b):
    ans1=1
    ans2=-1
  else:
    ans1=1
    ans2=c//a+1
  print(ans1,ans2)

  
  

for _ in range(int(input())):
  solve()","['implementation', 'greedy', 'math']"
"You are fishing with polar bears Alice and Bob. While waiting for the fish to bite, the polar bears get bored. They come up with a game. First Alice and Bob each writes a 01-string (strings that only contain character ""0"" and ""1"") a and b. Then you try to turn a into b using two types of operations:  Write parity(a) to the end of a. For example, .  Remove the first character of a. For example, . You cannot perform this operation if a is empty. You can use as many operations as you want. The problem is, is it possible to turn a into b?The parity of a 01-string is 1 if there is an odd number of ""1""s in the string, and 0 otherwise.","a=input()
b=input()
tot1=0
tot2=0
for i in a:
	tot1+=int(i)
for i in b:
	tot2+=int(i)
if tot1+tot1%2>=tot2:
	print(""YES"")
else:
	print(""NO"")","['combinatorics', 'constructive algorithms', 'number theory', 'math']"
"A line on the plane is described by an equation Ax + By + C = 0. You are to find any point on this line, whose coordinates are integer numbers from  - 5·1018 to 5·1018 inclusive, or to find out that such points do not exist.","def extgcd(a, b):
	if b == 0:
		return 1, 0, a
	x, y, g = extgcd(b, a % b)
	return y, x - y * (a // b), g

a, b, c = map(int, raw_input().split())
x, y, g = extgcd(a, b)
if c % g != 0:
	print -1
else:
	t = c // g
	print -x * t, -y * t","['number theory', 'math']"
"Polycarp has created his own training plan to prepare for the programming contests. He will train for $$$n$$$ days, all days are numbered from $$$1$$$ to $$$n$$$, beginning from the first.On the $$$i$$$-th day Polycarp will necessarily solve $$$a_i$$$ problems. One evening Polycarp plans to celebrate the equator. He will celebrate it on the first evening of such a day that from the beginning of the training and to this day inclusive he will solve half or more of all the problems.Determine the index of day when Polycarp will celebrate the equator.","import math
n = int(input())
l = list(map(int,input().split()))

k= math.ceil(sum(l) / 2)
#print(k)
sm = 0

i = 0
while sm < k :
    sm += l[i]
    i +=1

print(i)",['implementation']
Shaass has n books. He wants to make a bookshelf for all his books. He wants the bookshelf's dimensions to be as small as possible. The thickness of the i-th book is ti and its pages' width is equal to wi. The thickness of each book is either 1 or 2. All books have the same page heights.  Shaass puts the books on the bookshelf in the following way. First he selects some of the books and put them vertically. Then he puts the rest of the books horizontally above the vertical books. The sum of the widths of the horizontal books must be no more than the total thickness of the vertical books. A sample arrangement of the books is depicted in the figure.  Help Shaass to find the minimum total thickness of the vertical books that we can achieve.,"s = set()
s.add((0, 0))
n = int(raw_input())
p = n*2
for i in range(n):
    t, w = map(int, raw_input().split())
    x = set()
    for (a, b) in s:
        
        if a + t <= p:
            x.add((a+t, b))
        if b + w <= p:
            x.add((a, b+w))
    s = x
print min(u for (u, v) in s if u >= v)","['dp', 'greedy']"
"You are given two arrays of integers $$$a_1,\ldots,a_n$$$ and $$$b_1,\ldots,b_m$$$.Your task is to find a non-empty array $$$c_1,\ldots,c_k$$$ that is a subsequence of $$$a_1,\ldots,a_n$$$, and also a subsequence of $$$b_1,\ldots,b_m$$$. If there are multiple answers, find one of the smallest possible length. If there are still multiple of the smallest possible length, find any. If there are no such arrays, you should report about it.A sequence $$$a$$$ is a subsequence of a sequence $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero) elements. For example, $$$[3,1]$$$ is a subsequence of $$$[3,2,1]$$$ and $$$[4,3,1]$$$, but not a subsequence of $$$[1,3,3,7]$$$ and $$$[3,10,4]$$$.","from __future__ import division, print_function
 
import os,sys
from io import BytesIO, IOBase
 
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
 
 
def ii():  return int(input())
def si():  return input()
def mi():  return map(int,input().split("" ""))
def msi(): return map(str,input().split("" ""))
def li():  return list(mi())
 
def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
    
import math
def getSum(n): 
    sum = 0
    while(n > 0): 
        sum += int(n%10) 
        n = int(n/10) 
  
    return sum

def isPowerOfTwo (x): return (x and (not(x & (x - 1))) )
 
def gcd(x, y):
    while y:
        x, y = y, x % y
    return x
def egcd(a, b):  
    if a == 0 :   
        return b, 0, 1
    gcd, x1, y1 = egcd(b%a, a)
    x = y1 - (b//a) * x1  
    y = x1  
     
    return gcd, x, y 
    
def checkPrime(n) : # Check Prime Number or not 
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) : 
        if (n % i == 0 or n % (i + 2) == 0) : 
            return False
        i = i + 6
    return True
def fib(n):
    if n==0:
        return (0,1)
    p=fib(n>>1)
    c=p[0]*(2*p[1]-p[0])
    d=p[0]*p[0]+p[1]*p[1]
    if (n&1):
        return c+2*d 
    else:
        return c+d 
def read():
    sys.stdin = open('input.txt', 'r')  
def powLog(x,y):
    res=1
    while y>0:
        if y&1:
            res=res*x
        x=x*x
        y>>=1
    return res
def main():
    for _ in range(ii()):
        n,m=mi()
        a=list(set(li()))
        b=list(set(li()))
        flag,ans=0,-1
        for i in range(len(a)):
            if a[i] in b:
                flag=1
                ans=a[i]
                break
        if flag==1:
            print(""YES"")
            print(1,ans)
        else:
            print(""NO"")

        
# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()
 
 
if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
 
if __name__ == ""__main__"":
    #read()
    main()
    #dmain()
 
# Comment Read()",['brute force']
"After the mysterious disappearance of Ashish, his two favourite disciples Ishika and Hriday, were each left with one half of a secret message. These messages can each be represented by a permutation of size $$$n$$$. Let's call them $$$a$$$ and $$$b$$$.Note that a permutation of $$$n$$$ elements is a sequence of numbers $$$a_1, a_2, \ldots, a_n$$$, in which every number from $$$1$$$ to $$$n$$$ appears exactly once. The message can be decoded by an arrangement of sequence $$$a$$$ and $$$b$$$, such that the number of matching pairs of elements between them is maximum. A pair of elements $$$a_i$$$ and $$$b_j$$$ is said to match if:   $$$i = j$$$, that is, they are at the same index.  $$$a_i = b_j$$$ His two disciples are allowed to perform the following operation any number of times:   choose a number $$$k$$$ and cyclically shift one of the permutations to the left or right $$$k$$$ times. A single cyclic shift to the left on any permutation $$$c$$$ is an operation that sets $$$c_1:=c_2, c_2:=c_3, \ldots, c_n:=c_1$$$ simultaneously. Likewise, a single cyclic shift to the right on any permutation $$$c$$$ is an operation that sets $$$c_1:=c_n, c_2:=c_1, \ldots, c_n:=c_{n-1}$$$ simultaneously.Help Ishika and Hriday find the maximum number of pairs of elements that match after performing the operation any (possibly zero) number of times.","import os, sys
from collections import defaultdict

raw_input = sys.stdin.readline

n = int(raw_input())
a = map(int, raw_input().split())
b = map(int, raw_input().split())

pos_a = {}
pos_b = {}
for n_itr in xrange(n):
	pos_a[a[n_itr]] = n_itr
	pos_b[b[n_itr]] = n_itr

max_ppos = defaultdict(int)
for n_itr in xrange(n):
	dif = pos_a[a[n_itr]] - pos_b[a[n_itr]]
	if dif < 0:
		dif += n
	max_ppos[dif] += 1
print max(max_ppos.values())","['data structures', 'constructive algorithms', 'implementation', 'greedy']"
"Vasya is reading a e-book. The file of the book consists of $$$n$$$ pages, numbered from $$$1$$$ to $$$n$$$. The screen is currently displaying the contents of page $$$x$$$, and Vasya wants to read the page $$$y$$$. There are two buttons on the book which allow Vasya to scroll $$$d$$$ pages forwards or backwards (but he cannot scroll outside the book). For example, if the book consists of $$$10$$$ pages, and $$$d = 3$$$, then from the first page Vasya can scroll to the first or to the fourth page by pressing one of the buttons; from the second page — to the first or to the fifth; from the sixth page — to the third or to the ninth; from the eighth — to the fifth or to the tenth.Help Vasya to calculate the minimum number of times he needs to press a button to move to page $$$y$$$.","import math

a = input()
for _ in xrange(0, a):
    bookSize, startPage, endPage, jumpsAllowed = map(int, raw_input().split())
    jumps = abs(((endPage - startPage) / float(jumpsAllowed)))



    if jumps.is_integer():
        print int(jumps)
        continue

    jumpsLeft = abs(math.ceil(((startPage - 1) / float(jumpsAllowed)))) + abs((endPage - 1) / float(jumpsAllowed))
    jumpsRight = abs(math.ceil(((bookSize - startPage) / float(jumpsAllowed)))) + abs((bookSize - endPage) / float(jumpsAllowed))

    if jumpsLeft.is_integer() and jumpsRight.is_integer():
        print min(int(jumpsLeft), int(jumpsRight))
    elif jumpsLeft.is_integer():
        print int(jumpsLeft)
    elif jumpsRight.is_integer():
        print int(jumpsRight)
    else:
        print -1","['implementation', 'math']"
"You are given an integer $$$n$$$. In one move, you can either multiply $$$n$$$ by two or divide $$$n$$$ by $$$6$$$ (if it is divisible by $$$6$$$ without the remainder).Your task is to find the minimum number of moves needed to obtain $$$1$$$ from $$$n$$$ or determine if it's impossible to do that.You have to answer $$$t$$$ independent test cases.","for i in range (int(input())):
    n=int(input())
    j=0;k=0
    while n % 6 == 0:
        n/=6
        j=j+1
    while n % 3 == 0:
        n/=3
        k=k+1
    if n!=1:
        print(-1)
    else:print(j+2*k)",['math']
"In Disgaea as in most role-playing games, characters have skills that determine the character's ability to use certain weapons or spells. If the character does not have the necessary skill, he cannot use it. The skill level is represented as an integer that increases when you use this skill. Different character classes are characterized by different skills. Unfortunately, the skills that are uncommon for the given character's class are quite difficult to obtain. To avoid this limitation, there is the so-called transmigration. Transmigration is reincarnation of the character in a new creature. His soul shifts to a new body and retains part of his experience from the previous life. As a result of transmigration the new character gets all the skills of the old character and the skill levels are reduced according to the k coefficient (if the skill level was equal to x, then after transmigration it becomes equal to [kx], where [y] is the integral part of y). If some skill's levels are strictly less than 100, these skills are forgotten (the character does not have them any more). After that the new character also gains the skills that are specific for his class, but are new to him. The levels of those additional skills are set to 0. Thus, one can create a character with skills specific for completely different character classes via transmigrations. For example, creating a mage archer or a thief warrior is possible. You are suggested to solve the following problem: what skills will the character have after transmigration and what will the levels of those skills be?","n,m,k = map(float, raw_input().split())
d = {}
e = {}
for i in range(int(n)):
	x,y = raw_input().split()
	d[x] = int(y)
for i in range(int(m)):
	e[raw_input()] = 0
for x in d:
	if d[x]*k >= 100:
		e[x] = d[x]*k
d = []
for x in e:
	d.append((x, int(e[x]+10**-6)))
d.sort()
print len(d)
for x in d:
	print x[0], x[1]",['implementation']
"Three years have passes and nothing changed. It is still raining in London, and Mr. Black has to close all the doors in his home in order to not be flooded. Once, however, Mr. Black became so nervous that he opened one door, then another, then one more and so on until he opened all the doors in his house.There are exactly two exits from Mr. Black's house, let's name them left and right exits. There are several doors in each of the exits, so each door in Mr. Black's house is located either in the left or in the right exit. You know where each door is located. Initially all the doors are closed. Mr. Black can exit the house if and only if all doors in at least one of the exits is open. You are given a sequence in which Mr. Black opened the doors, please find the smallest index $$$k$$$ such that Mr. Black can exit the house after opening the first $$$k$$$ doors.We have to note that Mr. Black opened each door at most once, and in the end all doors became open.","n=int(raw_input())
a=list(map(int,raw_input().split()))
zero=0
one=0
for i in a:
    if i == 0:
        zero += 1
    else:
        one += 1
i = 0
while zero > 0 and one > 0:
    if a[i] == 0:
        zero -= 1
    else:
        one -= 1
    i += 1
print i",['implementation']
"A ski base is planned to be built in Walrusland. Recently, however, the project is still in the constructing phase. A large land lot was chosen for the construction. It contains n ski junctions, numbered from 1 to n. Initially the junctions aren't connected in any way.In the constructing process m bidirectional ski roads will be built. The roads are built one after another: first the road number 1 will be built, then the road number 2, and so on. The i-th road connects the junctions with numbers ai and bi.Track is the route with the following properties:  The route is closed, that is, it begins and ends in one and the same junction. The route contains at least one road.  The route doesn't go on one road more than once, however it can visit any junction any number of times. Let's consider the ski base as a non-empty set of roads that can be divided into one or more tracks so that exactly one track went along each road of the chosen set. Besides, each track can consist only of roads from the chosen set. Ski base doesn't have to be connected.Two ski bases are considered different if they consist of different road sets.After building each new road the Walrusland government wants to know the number of variants of choosing a ski base based on some subset of the already built roads. The government asks you to help them solve the given problem.","import random

def FindSet(dsu, x):
	if dsu[x] != x:
		dsu[x] = FindSet(dsu, dsu[x])
	return dsu[x]

def Unite(dsu, x, y):
	x = FindSet(dsu, x)
	y = FindSet(dsu, y)
	if random.random() > 0.5:
		dsu[x] = y
	else:
		dsu[y] = x

mod = 10 ** 9 + 9
n, m = map(int, raw_input().split())
dsu = range(n + 1)
res = 1
for i in xrange(m):
	u, v = map(int, raw_input().split())
	if FindSet(dsu, u) != FindSet(dsu, v):
		print res - 1
	else:
		res = (res * 2) % mod
		print res - 1
	Unite(dsu, u, v)","['data structures', 'dsu', 'graphs']"
"After the piece of a devilish mirror hit the Kay's eye, he is no longer interested in the beauty of the roses. Now he likes to watch snowflakes.Once upon a time, he found a huge snowflake that has a form of the tree (connected acyclic graph) consisting of n nodes. The root of tree has index 1. Kay is very interested in the structure of this tree.After doing some research he formed q queries he is interested in. The i-th query asks to find a centroid of the subtree of the node vi. Your goal is to answer all queries.Subtree of a node is a part of tree consisting of this node and all it's descendants (direct or not). In other words, subtree of node v is formed by nodes u, such that node v is present on the path from u to root.Centroid of a tree (or a subtree) is a node, such that if we erase it from the tree, the maximum size of the connected component will be at least two times smaller than the size of the initial tree (or a subtree).","n, q = map(int, raw_input().split(' '))
p_arr = map(lambda x:int(x) - 1, raw_input().split(' '))
p_arr = [-1] + p_arr
for i in p_arr[1:]:
  i += 1
pe_arr = [0 for i in xrange(n)]
s_arr = [1 for i in xrange(n)]
mx_arr = [-1 for i in xrange(n)]
z_arr = [i for i in xrange(n)]
for i in p_arr:
  if i > 0:
    pe_arr[i] += 1

arr = [i for i in xrange(n) if pe_arr[i] == 0]
while arr:
  i = arr.pop()
  while z_arr[i] != i and (s_arr[i] - s_arr[z_arr[i]]) * 2 > s_arr[i]:
    z_arr[i] = p_arr[z_arr[i]]
  if i == 0:
    continue
  fa = p_arr[i]
  s_arr[fa] += s_arr[i]
  if mx_arr[fa] < s_arr[i]:
    mx_arr[fa] = s_arr[i]
    z_arr[fa] = z_arr[i]
  pe_arr[fa] -= 1
  if pe_arr[fa] == 0:
    arr.append(fa)
q_arr = [int(raw_input()) - 1 for i in xrange(q)]
for i in q_arr:
  print z_arr[i] + 1","['dp', 'dfs and similar', 'data structures', 'trees']"
"In Berland recently a new collection of toys went on sale. This collection consists of 109 types of toys, numbered with integers from 1 to 109. A toy from the new collection of the i-th type costs i bourles.Tania has managed to collect n different types of toys a1, a2, ..., an from the new collection. Today is Tanya's birthday, and her mother decided to spend no more than m bourles on the gift to the daughter. Tanya will choose several different types of toys from the new collection as a gift. Of course, she does not want to get a type of toy which she already has.Tanya wants to have as many distinct types of toys in her collection as possible as the result. The new collection is too diverse, and Tanya is too little, so she asks you to help her in this.","# Tanya and Toys.py

from collections import *

n,m = map(int,raw_input().split())
arr = map(int,raw_input().split())
ans = [];
arr.sort();
start = 0;
arr.append(10**9+5);
for i in xrange(1,10**9):
	if m - i < 0 :
		break;
	if i == arr[start]:
		start+=1;
	else:
		ans.append(i);
		m -= i;
print len(ans)
print ' '.join(map(str,ans))","['implementation', 'greedy']"
"ZS the Coder has drawn an undirected graph of n vertices numbered from 0 to n - 1 and m edges between them. Each edge of the graph is weighted, each weight is a positive integer.The next day, ZS the Coder realized that some of the weights were erased! So he wants to reassign positive integer weight to each of the edges which weights were erased, so that the length of the shortest path between vertices s and t in the resulting graph is exactly L. Can you help him?","import sys

n,m,l,s,t = map(int,sys.stdin.readline().split())

dis = [ 0 for i in xrange(n+3) ]
vis = [ 0 for i in xrange(n+3) ]
U   = [ 0 for i in xrange(m+3) ]
V   = [ 0 for i in xrange(m+3) ]
W   = [ 0 for i in xrange(m+3) ]
OK  = [ 0 for i in xrange(m+3) ]
que = [ 0 for i in xrange(300000) ]
adj = [ [] for i in xrange(n+3) ]

def Init(n):
    for i in range(n):
        dis[i] = 2**60
        vis[i] = 0

def SPFA(s,n):
    Init(n)
    f = 1
    r = 0

    dis[s] = 0
    vis[s] = 1
    r+=1
    que[r] = s

    while f <= r:
        u = que[f]
        f += 1

        vis[u] = 0

        sz = len(adj[u])
        for i in range(0,sz,2):
            v = adj[u][i]
            _id = adj[u][i+1]
            w = W[_id]

            if dis[v] > dis[u] + w:
                dis[v] = dis[u] + w

                if vis[v] == 0:
                    vis[v] = 1
                    r += 1
                    que[r] = v

for i in range(m):
    u,v,w = map(int,raw_input().split())

    U[i] = u
    V[i] = v
    W[i] = w

    if W[i] == 0:
        OK[i] = 1
        W[i] = 1

    adj[u].append(v)
    adj[u].append(i)

    adj[v].append(u)
    adj[v].append(i)

low = 0
high = m

while low <= high:
    mid = (low+high)/2

    for i in range(mid):
        if OK[i] == 1:
            W[i] = 1

    for i in range(mid,m):
        if OK[i] == 1:
            W[i] = 2000000000

    SPFA(s,n)

    if dis[t] > l:
        low = mid+1
    else:
        high = mid-1

#print low
#if n == 1000 and m == 1332 and s == 0 and t == 999:
#    sys.exit()

if low > 0 and OK[low-1] == 0:
    print ""NO""
    sys.exit()

#if low == m+1:
#    print ""NO""
#    sys.exit()

last = -1
for i in range(low):
    if OK[i] == 1:
        W[i] = 1
        last = i

SPFA(s,n)

if last != -1:
    W[last] += (l-dis[t])

SPFA(s,n)

if dis[t] != l:
    print ""NO""
    sys.exit()

print ""YES""

edge = []

for i in range(m):
    ok = str(U[i]) + "" "" + str(V[i]) + "" "" + str(W[i])
    edge.append(ok)
    
sys.stdout.write( '\n'.join( edge ) )","['shortest paths', 'graphs']"
"A competitive eater, Alice is scheduling some practices for an eating contest on a magical calendar. The calendar is unusual because a week contains not necessarily $$$7$$$ days!In detail, she can choose any integer $$$k$$$ which satisfies $$$1 \leq k \leq r$$$, and set $$$k$$$ days as the number of days in a week.Alice is going to paint some $$$n$$$ consecutive days on this calendar. On this calendar, dates are written from the left cell to the right cell in a week. If a date reaches the last day of a week, the next day's cell is the leftmost cell in the next (under) row.She wants to make all of the painted cells to be connected by side. It means, that for any two painted cells there should exist at least one sequence of painted cells, started in one of these cells, and ended in another, such that any two consecutive cells in this sequence are connected by side.Alice is considering the shape of the painted cells. Two shapes are the same if there exists a way to make them exactly overlapped using only parallel moves, parallel to the calendar's sides.For example, in the picture, a week has $$$4$$$ days and Alice paints $$$5$$$ consecutive days. [1] and [2] are different shapes, but [1] and [3] are equal shapes.    Alice wants to know how many possible shapes exists if she set how many days a week has and choose consecutive $$$n$$$ days and paints them in calendar started in one of the days of the week. As was said before, she considers only shapes, there all cells are connected by side.","from sys import stdin
input=stdin.readline

for _ in range(int(input())):
    n,m=map(int,input().split())
    if n<=m:
        print((n*(n-1))//2+1)
    else:
        print((m*(m+1))//2)",['math']
"Recently, Anton has found a set. The set consists of small English letters. Anton carefully wrote out all the letters from the set in one line, separated by a comma. He also added an opening curved bracket at the beginning of the line and a closing curved bracket at the end of the line. Unfortunately, from time to time Anton would forget writing some letter and write it again. He asks you to count the total number of distinct letters in his set.","txt=set(input()+','+' ')
print(len(txt)-4)","['constructive algorithms', 'implementation']"
"Fox Ciel starts to learn programming. The first task is drawing a fox! However, that turns out to be too hard for a beginner, so she decides to draw a snake instead.A snake is a pattern on a n by m table. Denote c-th cell of r-th row as (r, c). The tail of the snake is located at (1, 1), then it's body extends to (1, m), then goes down 2 rows to (3, m), then goes left to (3, 1) and so on.Your task is to draw this snake for Fox Ciel: the empty cells should be represented as dot characters ('.') and the snake cells should be filled with number signs ('#').Consider sample tests in order to understand the snake pattern.","n,m = map(int,input().split())
c = 1
for i in range(n):
    for j in range(m):
        if i % 2 == 0:
            print('#',end = '')
        else:
            if i == (4*c)-3:
                if j == m-1:
                    print(""#"",end='')
                    c += 1
                else:
                    print(""."",end='')
            else:
                if j == 0:
                    print(""#"",end='')
                else:
                    print(""."",end='')
    print()",['implementation']
"There is a rectangular grid of n rows of m initially-white cells each.Arkady performed a certain number (possibly zero) of operations on it. In the i-th operation, a non-empty subset of rows Ri and a non-empty subset of columns Ci are chosen. For each row r in Ri and each column c in Ci, the intersection of row r and column c is coloured black.There's another constraint: a row or a column can only be chosen at most once among all operations. In other words, it means that no pair of (i, j) (i &lt; j) exists such that  or , where  denotes intersection of sets, and  denotes the empty set.You are to determine whether a valid sequence of operations exists that produces a given final grid.","n, m = map(int, input().split())
st = []
for i in range(n):
    s = input()
    x = set()
    for j in range(m):
        if s[j] == '#':
            x.add(j)
    for i in st:
        if len(i & x) > 0 and i != x:
            print('No')
            exit()
    st.append(x)
print('Yes')","['implementation', 'greedy']"
"Yash has recently learnt about the Fibonacci sequence and is very excited about it. He calls a sequence Fibonacci-ish if   the sequence consists of at least two elements  f0 and f1 are arbitrary  fn + 2 = fn + 1 + fn for all n ≥ 0. You are given some sequence of integers a1, a2, ..., an. Your task is rearrange elements of this sequence in such a way that its longest possible prefix is Fibonacci-ish sequence.","#!/usr/bin/env python3

n = int(input())
a = [int(x) for x in input().split()]

sorted_a = sorted(a)
dict_a = {}
for x in a:
    if not x in dict_a:
        dict_a[x] = 1
    else:
        dict_a[x] += 1

sorted_uniq_a = sorted(dict_a.keys())

max_fib_prefix = [a[0], a[1]]
for i in range(0, len(sorted_uniq_a)):
    for j in range(0, len(sorted_uniq_a)):
        if i != j or dict_a[sorted_uniq_a[i]] > 1:
            if sorted_uniq_a[i] + sorted_uniq_a[j] > sorted_uniq_a[-1]:
                break

            fib_prefix = [sorted_uniq_a[i], sorted_uniq_a[j]]
            dict_a[sorted_uniq_a[i]] -= 1
            dict_a[sorted_uniq_a[j]] -= 1

            while True:
                next_fib = fib_prefix[-1] + fib_prefix[-2]
                if not next_fib in dict_a or dict_a[next_fib] == 0:
                    break
                fib_prefix.append(next_fib)
                dict_a[next_fib] -= 1

            for x in fib_prefix:
                dict_a[x] += 1

            if len(fib_prefix) > len(max_fib_prefix):
                max_fib_prefix = fib_prefix

print(len(max_fib_prefix))","['dp', 'hashing', 'math', 'implementation', 'brute force']"
"There is a prison that can be represented as a rectangular matrix with $$$n$$$ rows and $$$m$$$ columns. Therefore, there are $$$n \cdot m$$$ prison cells. There are also $$$n \cdot m$$$ prisoners, one in each prison cell. Let's denote the cell in the $$$i$$$-th row and the $$$j$$$-th column as $$$(i, j)$$$.There's a secret tunnel in the cell $$$(r, c)$$$, that the prisoners will use to escape! However, to avoid the risk of getting caught, they will escape at night.Before the night, every prisoner is in his own cell. When night comes, they can start moving to adjacent cells. Formally, in one second, a prisoner located in cell $$$(i, j)$$$ can move to cells $$$( i - 1 , j )$$$ , $$$( i + 1 , j )$$$ , $$$( i , j - 1 )$$$ , or $$$( i , j + 1 )$$$, as long as the target cell is inside the prison. They can also choose to stay in cell $$$(i, j)$$$.The prisoners want to know the minimum number of seconds needed so that every prisoner can arrive to cell $$$( r , c )$$$ if they move optimally. Note that there can be any number of prisoners in the same cell at the same time.","t=int(input())
for i in range(t):
    n,m,r,c=map(int,input().split())
    a1=1
    a2=n
    b1=1
    b2=m
    c1=abs(a1-r)+abs(b1-c)
    c2=abs(a1-r)+abs(b2-c)
    c3=abs(a2-r)+abs(b1-c)
    c4=abs(a2-r)+abs(b2-c)
    print(max(c1,max(c2,max(c3,c4))))","['brute force', 'math']"
"Berland shop sells $$$n$$$ kinds of juices. Each juice has its price $$$c_i$$$. Each juice includes some set of vitamins in it. There are three types of vitamins: vitamin ""A"", vitamin ""B"" and vitamin ""C"". Each juice can contain one, two or all three types of vitamins in it.Petya knows that he needs all three types of vitamins to stay healthy. What is the minimum total price of juices that Petya has to buy to obtain all three vitamins? Petya obtains some vitamin if he buys at least one juice containing it and drinks it.","n=int(input())
p={
    ""A"":10**9,
    ""B"":10**9,
    ""C"":10**9,
    ""AB"":10**9,
    ""BC"":10**9,
    ""AC"":10**9,
    ""ABC"":10**9
}

for i in range(n):
    x,y=input().split()
    x=int(x)
    y=''.join(sorted(y))
    p[y]=min(p[y],x)

x=min(
        p[""A""]+p[""B""]+p[""C""],
        p[""AB""]+p[""C""],
        p[""AC""]+p[""B""],
        p[""BC""]+p[""A""],
        p[""ABC""],
        p[""AB""]+p[""BC""],
        p[""AB""]+p[""AC""],
        p[""BC""]+p[""AC""],
        p[""A""]+p[""ABC""],
        p[""B""]+p[""ABC""],
        p[""C""]+p[""ABC""],
        p[""AB""]+p[""ABC""],
        p[""AC""]+p[""ABC""],
        p[""BC""]+p[""ABC""],
    )
print(x) if x<10**7 else print(""-1"")","['dp', 'implementation', 'bitmasks', 'brute force']"
"A progress bar is an element of graphical interface that displays the progress of a process for this very moment before it is completed. Let's take a look at the following form of such a bar.A bar is represented as n squares, located in line. To add clarity, let's number them with positive integers from 1 to n from the left to the right. Each square has saturation (ai for the i-th square), which is measured by an integer from 0 to k. When the bar for some i (1 ≤ i ≤ n) is displayed, squares 1, 2, ... , i - 1 has the saturation k, squares i + 1, i + 2, ... , n has the saturation 0, and the saturation of the square i can have any value from 0 to k.So some first squares of the progress bar always have the saturation k. Some last squares always have the saturation 0. And there is no more than one square that has the saturation different from 0 and k.The degree of the process's completion is measured in percents. Let the process be t% completed. Then the following inequation is fulfilled: An example of such a bar can be seen on the picture.  For the given n, k, t determine the measures of saturation for all the squares ai of the progress bar.","arr = [int(x) for x in raw_input().split()]
n, k, t = arr

s = t * n * k / 100

for i in range(n):
    w = min(s, k)
    print(w)
    s -= w","['implementation', 'math']"
"You are given an integer a that consists of n digits. You are also given a sequence of digits s of length m. The digit in position j (1 ≤ j ≤ m) of sequence s means that you can choose an arbitrary position i (1 ≤ i ≤ n) in a and replace the digit in the chosen position i with sj. Each element in the sequence s can participate in no more than one replacing operation.Your task is to perform such sequence of replacements, that the given number a gets maximum value. You are allowed to use not all elements from s.","a = list(input())
s = list(input())

s.sort(reverse=True)
aindex, sindex = 0, 0

while sindex < len(s) and aindex < len(a):
    if s[sindex] > a[aindex]:
        a[aindex] = s[sindex]
        s.pop(sindex)
        sindex = 0
        aindex += 1
    else:
        aindex += 1

print ("""".join(a))",['greedy']
"You are given an undirected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. Your task is to find the number of connected components which are cycles.Here are some definitions of graph theory.An undirected graph consists of two sets: set of nodes (called vertices) and set of edges. Each edge connects a pair of vertices. All edges are bidirectional (i.e. if a vertex $$$a$$$ is connected with a vertex $$$b$$$, a vertex $$$b$$$ is also connected with a vertex $$$a$$$). An edge can't connect vertex with itself, there is at most one edge between a pair of vertices.Two vertices $$$u$$$ and $$$v$$$ belong to the same connected component if and only if there is at least one path along edges connecting $$$u$$$ and $$$v$$$.A connected component is a cycle if and only if its vertices can be reordered in such a way that:  the first vertex is connected with the second vertex by an edge,  the second vertex is connected with the third vertex by an edge,  ...  the last vertex is connected with the first vertex by an edge,  all the described edges of a cycle are distinct. A cycle doesn't contain any other edges except described above. By definition any cycle contains three or more vertices.    There are $$$6$$$ connected components, $$$2$$$ of them are cycles: $$$[7, 10, 16]$$$ and $$$[5, 11, 9, 15]$$$.","from sys import stdin


def main():
    n, m = map(int, stdin.readline().split())
    adj = [[] for _ in range(n)]
    for _ in range(m):
        v, u = map(int, stdin.readline().split())
        adj[v - 1].append(u - 1)
        adj[u - 1].append(v - 1)
    check = [False] * n
    stack = []
    count = 0
    for i in range(n):
        if not check[i]:
            first = i
            cycle = 1
            stack = [(i, -1)]

            while stack:
                c, p = stack.pop()
                if check[c]:
                    continue
                else:
                    check[c] = True
                    if len(adj[c]) > 2 or len(adj[c]) <= 1:
                        cycle = 0
                    for nb in adj[c]:
                        if nb != p:
                            stack.append((nb, i))
            count += cycle
    print(count)


if __name__ == ""__main__"":
    main()","['dsu', 'dfs and similar', 'graphs']"
"For the given integer $$$n$$$ ($$$n &gt; 2$$$) let's write down all the strings of length $$$n$$$ which contain $$$n-2$$$ letters 'a' and two letters 'b' in lexicographical (alphabetical) order.Recall that the string $$$s$$$ of length $$$n$$$ is lexicographically less than string $$$t$$$ of length $$$n$$$, if there exists such $$$i$$$ ($$$1 \le i \le n$$$), that $$$s_i &lt; t_i$$$, and for any $$$j$$$ ($$$1 \le j &lt; i$$$) $$$s_j = t_j$$$. The lexicographic comparison of strings is implemented by the operator &lt; in modern programming languages.For example, if $$$n=5$$$ the strings are (the order does matter):  aaabb  aabab  aabba  abaab  ababa  abbaa  baaab  baaba  babaa  bbaaa It is easy to show that such a list of strings will contain exactly $$$\frac{n \cdot (n-1)}{2}$$$ strings.You are given $$$n$$$ ($$$n &gt; 2$$$) and $$$k$$$ ($$$1 \le k \le \frac{n \cdot (n-1)}{2}$$$). Print the $$$k$$$-th string from the list.","t = int(input())
for num in range(t):
    n, k = map(int, input().split())
    b1 = n - 2
    b2 = n - 1
    if k < 1000:
        i = 0
    elif k == (n*(n-1))//2:
        b1 = 0
        b2 = 1
        i = k-1
    else:
        i = int((1 + (1 - (4 * -1 * k * 2)) ** (1 / 2)) // 2)
        b1 = n - i - 1
        i *= (i - 1) / 2

    while True:
        #print(f""iteration: {i}, b1: {b1}, b2: {b2}"")
        if i == k - 1:
            most = ['a']*n
            most[b1] = 'b'
            most[b2] = 'b'
            print(''.join(most))
            break
        else:
            i += 1
        if b2 - b1 == 1:
            b1 -= 1
            b2 = n - 1
        else:
            b2 -= 1","['combinatorics', 'math', 'implementation', 'binary search', 'brute force']"
"One very well-known internet resource site (let's call it X) has come up with a New Year adventure. Specifically, they decided to give ratings to all visitors.There are n users on the site, for each user we know the rating value he wants to get as a New Year Present. We know that user i wants to get at least ai rating units as a present.The X site is administered by very creative and thrifty people. On the one hand, they want to give distinct ratings and on the other hand, the total sum of the ratings in the present must be as small as possible.Help site X cope with the challenging task of rating distribution. Find the optimal distribution.","import sys

n, a = input(), list(map(int, raw_input().split()))

t = sorted((j, i) for i, j in enumerate(a))

s, p = 0, [0] * n
for j, i in t:
    if s < j: s = j
    else: s += 1
    p[i] = s
print(' '.join(map(str, p)))","['sortings', 'greedy']"
"Let's define a forest as a non-directed acyclic graph (also without loops and parallel edges). One day Misha played with the forest consisting of n vertices. For each vertex v from 0 to n - 1 he wrote down two integers, degreev and sv, were the first integer is the number of vertices adjacent to vertex v, and the second integer is the XOR sum of the numbers of vertices adjacent to v (if there were no adjacent vertices, he wrote down 0). Next day Misha couldn't remember what graph he initially had. Misha has values degreev and sv left, though. Help him find the number of edges and the edges of the initial graph. It is guaranteed that there exists a forest that corresponds to the numbers written by Misha.","from collections import deque
n = int(input())
process = deque()
vs = []
for i in range(n):
    d, s = map(int, input().split())
    if d == 1:
        process.append(i)
    vs.append((d, s))
edges = []
while process:
    a = process.popleft()
    d, s = vs[a]
    if d == 0:
        continue
    dd, ss = vs[s]
    vs[s] = (dd - 1, ss ^ a)
    if dd == 2:
        process.append(s)
    edges.append((a, s))
print(len(edges))
for a, b in edges:
    print(a,b)","['data structures', 'constructive algorithms', 'greedy', 'graphs']"
"Jeff's got n cards, each card contains either digit 0, or digit 5. Jeff can choose several cards and put them in a line so that he gets some number. What is the largest possible number divisible by 90 Jeff can make from the cards he's got?Jeff must make the number without leading zero. At that, we assume that number 0 doesn't contain any leading zeroes. Jeff doesn't have to use all the cards.","n=int(input())
l=list(map(int,input().split()))
a,b=0,0
s=""""
for i in l:
    if i==5:
        a=a+1
    if i==0:
        b=b+1        
for i in range(a//9):
    s=s+""555555555""
if a<9:
  if b>0:  
     s=""0"" 
else:    
  for i in range(b):  
    s=s+""0"" 
if b>0:
 print(s)
else:
 print(""-1"")","['implementation', 'brute force', 'math']"
"Nastya just made a huge mistake and dropped a whole package of rice on the floor. Mom will come soon. If she sees this, then Nastya will be punished.In total, Nastya dropped $$$n$$$ grains. Nastya read that each grain weighs some integer number of grams from $$$a - b$$$ to $$$a + b$$$, inclusive (numbers $$$a$$$ and $$$b$$$ are known), and the whole package of $$$n$$$ grains weighs from $$$c - d$$$ to $$$c + d$$$ grams, inclusive (numbers $$$c$$$ and $$$d$$$ are known). The weight of the package is the sum of the weights of all $$$n$$$ grains in it.Help Nastya understand if this information can be correct. In other words, check whether each grain can have such a mass that the $$$i$$$-th grain weighs some integer number $$$x_i$$$ $$$(a - b \leq x_i \leq a + b)$$$, and in total they weigh from $$$c - d$$$ to $$$c + d$$$, inclusive ($$$c - d \leq \sum\limits_{i=1}^{n}{x_i} \leq c + d$$$).","from sys import stdin, stdout
read = stdin.readline
write = stdout.write
xr = xrange

def main():
	for tc in xr(int(read())):
		n,a,b,c,d = map(int, read().split())
		if n * (a + b ) < c - d or n * (a - b) > c + d: write('No\n')
		else: write('Yes\n')

if __name__ == ""__main__"":
	main()",['math']
"Gerald plays the following game. He has a checkered field of size n × n cells, where m various cells are banned. Before the game, he has to put a few chips on some border (but not corner) board cells. Then for n - 1 minutes, Gerald every minute moves each chip into an adjacent cell. He moves each chip from its original edge to the opposite edge. Gerald loses in this game in each of the three cases:  At least one of the chips at least once fell to the banned cell.  At least once two chips were on the same cell.  At least once two chips swapped in a minute (for example, if you stand two chips on two opposite border cells of a row with even length, this situation happens in the middle of the row). In that case he loses and earns 0 points. When nothing like that happened, he wins and earns the number of points equal to the number of chips he managed to put on the board. Help Gerald earn the most points.","n, m = map(int, input().split())
l = [0 for i in range(0, n)]
c = [0 for i in range(0, n)]
sol = 0

for i in range(0, m):
    a, b = map(int, input().split())
    l[a-1] = 1
    c[b-1] = 1

for i in range(1, n//2):
    #ma ocup de liniile i si n-i, coloanele la fel
    sol += 4 - (l[i] + c[i] + l[n-i-1] + c[n-i-1])

if n % 2 == 1:
    if not l[n//2] or not c[n//2]: sol += 1

print(sol)","['two pointers', 'implementation', 'greedy']"
"Today at the lesson of mathematics, Petya learns about the digital root.The digital root of a non-negative integer is the single digit value obtained by an iterative process of summing digits, on each iteration using the result from the previous iteration to compute a digit sum. The process continues until a single-digit number is reached. Let's denote the digital root of $$$x$$$ as $$$S(x)$$$. Then $$$S(5)=5$$$, $$$S(38)=S(3+8=11)=S(1+1=2)=2$$$, $$$S(10)=S(1+0=1)=1$$$.As a homework Petya got $$$n$$$ tasks of the form: find $$$k$$$-th positive number whose digital root is $$$x$$$.Petya has already solved all the problems, but he doesn't know if it's right. Your task is to solve all $$$n$$$ tasks from Petya's homework.","n = int(input())
for _ in range(n):
 k,x = map(int,input().split())
 if (k==1):
  print(x)
 else:
  print(x+((k-1)%1000000000007)*9)","['number theory', 'math']"
"There are $$$n$$$ dormitories in Berland State University, they are numbered with integers from $$$1$$$ to $$$n$$$. Each dormitory consists of rooms, there are $$$a_i$$$ rooms in $$$i$$$-th dormitory. The rooms in $$$i$$$-th dormitory are numbered from $$$1$$$ to $$$a_i$$$.A postman delivers letters. Sometimes there is no specific dormitory and room number in it on an envelope. Instead of it only a room number among all rooms of all $$$n$$$ dormitories is written on an envelope. In this case, assume that all the rooms are numbered from $$$1$$$ to $$$a_1 + a_2 + \dots + a_n$$$ and the rooms of the first dormitory go first, the rooms of the second dormitory go after them and so on.For example, in case $$$n=2$$$, $$$a_1=3$$$ and $$$a_2=5$$$ an envelope can have any integer from $$$1$$$ to $$$8$$$ written on it. If the number $$$7$$$ is written on an envelope, it means that the letter should be delivered to the room number $$$4$$$ of the second dormitory.For each of $$$m$$$ letters by the room number among all $$$n$$$ dormitories, determine the particular dormitory and the room number in a dormitory where this letter should be delivered.","n, m = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
h = 0
k = 0
for i in range(m):
    while b[i] > h + a[k]:
        h += a[k]
        k += 1
    print(k + 1, b[i] - h)","['two pointers', 'binary search', 'implementation']"
"In Aramic language words can only represent objects.Words in Aramic have special properties:   A word is a root if it does not contain the same letter more than once.  A root and all its permutations represent the same object.  The root $$$x$$$ of a word $$$y$$$ is the word that contains all letters that appear in $$$y$$$ in a way that each letter appears once. For example, the root of ""aaaa"", ""aa"", ""aaa"" is ""a"", the root of ""aabb"", ""bab"", ""baabb"", ""ab"" is ""ab"".  Any word in Aramic represents the same object as its root. You have an ancient script in Aramic. What is the number of different objects mentioned in the script?","n = int(raw_input().strip())
x = raw_input().split(' ')
res = len(set([''.join(sorted(set(i))) for i in x]))
print res","['implementation', 'strings']"
"DZY loves collecting special strings which only contain lowercase letters. For each lowercase letter c DZY knows its value wc. For each special string s = s1s2... s|s| (|s| is the length of the string) he represents its value with a function f(s), where Now DZY has a string s. He wants to insert k lowercase letters into this string in order to get the largest possible value of the resulting string. Can you help him calculate the largest possible value he could get?","s = list(input())
k = int(input())
w = list(map(int, input().split("" "")))
length = len(w) + k
ans= []
for i in s:
    ans.append(w[ord(i)-97])
while k > 0:
    ans.append(max(w))
    k -= 1
res = 0
for j in range(len(ans)):
    res += (j+1)*ans[j]
print(res)","['implementation', 'greedy']"
"Alex doesn't like boredom. That's why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.Given a sequence a consisting of n integers. The player can make several steps. In a single step he can choose an element of the sequence (let's denote it ak) and delete it, at that all elements equal to ak + 1 and ak - 1 also must be deleted from the sequence. That step brings ak points to the player. Alex is a perfectionist, so he decided to get as many points as possible. Help him.","def main():
    L = [0 for i in range(100001)]
    c = [0 for i in range(100001)]
    n = int(input())
    Max = 0
    inp = [int(x) for x in input().split()]
    for i in range(n):
        c[inp[i]]+=1
        Max = max(inp[i],Max)
    L[1] = inp.count(1) 
    for i in range(2,Max+1):
        L[i] = max(L[i-1],L[i-2]+c[i]*i)
    print(L[Max])
if __name__ == ""__main__"" : main()",['dp']
"You are given two sequences $$$a_1, a_2, \dots, a_n$$$ and $$$b_1, b_2, \dots, b_n$$$. Each element of both sequences is either $$$0$$$, $$$1$$$ or $$$2$$$. The number of elements $$$0$$$, $$$1$$$, $$$2$$$ in the sequence $$$a$$$ is $$$x_1$$$, $$$y_1$$$, $$$z_1$$$ respectively, and the number of elements $$$0$$$, $$$1$$$, $$$2$$$ in the sequence $$$b$$$ is $$$x_2$$$, $$$y_2$$$, $$$z_2$$$ respectively.You can rearrange the elements in both sequences $$$a$$$ and $$$b$$$ however you like. After that, let's define a sequence $$$c$$$ as follows:$$$c_i = \begin{cases} a_i b_i &amp; \mbox{if }a_i &gt; b_i \\ 0 &amp; \mbox{if }a_i = b_i \\ -a_i b_i &amp; \mbox{if }a_i &lt; b_i \end{cases}$$$You'd like to make $$$\sum_{i=1}^n c_i$$$ (the sum of all elements of the sequence $$$c$$$) as large as possible. What is the maximum possible sum?","t = int(raw_input())

for _ in range(t):
    x1, y1, z1 = map(int, raw_input().strip().split("" ""))
    x2, y2, z2 = map(int, raw_input().strip().split("" ""))
    answer = 0
    num_twos = min(z1, y2)
    answer += 2*num_twos
    z1 -= num_twos
    y2 -= num_twos
    a = min(x1, z2)
    x1 -= a
    z2 -= a
    b = min(x2, y1)
    x2 -= b
    y1 -= b
    answer -= 2*min(y1, z2)
    print(answer)","['constructive algorithms', 'greedy', 'math']"
"Vova had a pretty weird sleeping schedule. There are $$$h$$$ hours in a day. Vova will sleep exactly $$$n$$$ times. The $$$i$$$-th time he will sleep exactly after $$$a_i$$$ hours from the time he woke up. You can assume that Vova woke up exactly at the beginning of this story (the initial time is $$$0$$$). Each time Vova sleeps exactly one day (in other words, $$$h$$$ hours).Vova thinks that the $$$i$$$-th sleeping time is good if he starts to sleep between hours $$$l$$$ and $$$r$$$ inclusive.Vova can control himself and before the $$$i$$$-th time can choose between two options: go to sleep after $$$a_i$$$ hours or after $$$a_i - 1$$$ hours.Your task is to say the maximum number of good sleeping times Vova can obtain if he acts optimally.","from collections import defaultdict, Counter


from sys import stdin
import io, os
input = stdin.readline


n, h, l, r = map(int, input().split())
a = list(map(int, input().split()))


M = 1000001
n_inf = float('-inf')
dp = defaultdict(lambda:n_inf)
dp[0] = 0
# iterate through all the sleep hours 
for i in range(1, n + 1):
	a_i = a[i - 1]
	for hour in range(h):
		c_1 = (a_i + hour - 1) % h
		c_2 = (a_i + hour) % h
		dp[i*M + c_1] = max(dp[(i - 1)*M + hour] + (l <= c_1 <= r), dp[i*M + c_1])
		dp[i*M + c_2] = max(dp[(i - 1)*M + hour] + (l <= c_2 <= r), dp[i*M + c_2])


ans = 0
for i in range(h):
	ans = max(ans, dp[n*M + i])
print (ans)","['dp', 'implementation']"
"There is a square painted on a piece of paper, the square's side equals n meters. John Doe draws crosses on the square's perimeter. John paints the first cross in the lower left corner of the square. Then John moves along the square's perimeter in the clockwise direction (first upwards, then to the right, then downwards, then to the left and so on). Every time he walks (n + 1) meters, he draws a cross (see picture for clarifications).John Doe stops only when the lower left corner of the square has two crosses. How many crosses will John draw?   The figure shows the order in which John draws crosses for a square with side 4. The lower left square has two crosses. Overall John paints 17 crosses.","n = int(raw_input())

parts = [int(x) for x in raw_input().split()]

for p in parts:
  if p % 2 == 0:
    print p * 4 + 1
  else:
    if (p + 3) % 4 == 0:
      res = 1 + (((p + 3) / 4) - 1) * 4
      print res * 2 + 1	  
    elif (p + 1) % 4 == 0 :
      res = 3 + (((p + 1) / 4) - 1) * 4
      print res + 1",['math']
Misha hacked the Codeforces site. Then he decided to let all the users change their handles. A user can now change his handle any number of times. But each new handle must not be equal to any handle that is already used or that was used at some point.Misha has a list of handle change requests. After completing the requests he wants to understand the relation between the original and the new handles of the users. Help him to do that.,"q = int(raw_input())

handles = {}
for i in range(q):
  oldName, newName = raw_input().split()
  
  handles[oldName] =[newName]
  
  for name in handles:
    if (oldName in handles[name]):
      handles[name].append(newName)
      del handles[oldName]
      break

print len(handles)
for name in handles:
  print name, handles[name][-1]","['data structures', 'dsu', 'strings']"
"Olya loves energy drinks. She loves them so much that her room is full of empty cans from energy drinks.Formally, her room can be represented as a field of n × m cells, each cell of which is empty or littered with cans.Olya drank a lot of energy drink, so now she can run k meters per second. Each second she chooses one of the four directions (up, down, left or right) and runs from 1 to k meters in this direction. Of course, she can only run through empty cells.Now Olya needs to get from cell (x1, y1) to cell (x2, y2). How many seconds will it take her if she moves optimally?It's guaranteed that cells (x1, y1) and (x2, y2) are empty. These cells can coincide.","from sys import *
f = lambda: map(int,raw_input().split())
n, m, k = f()
t = [[1e9 * (q == '.') for q in stdin.readline()] for i in range(n)]
t.append([0] * m)
a, b, c, d = [q - 1 for q in f()]
u = [(a, b)]
t[a][b] = l = 0
def g(i, x, y):
    if i > k or t[x][y] < l: return 0
    if t[x][y] > l:
        t[x][y] = l
        v.append((x, y))
    return 1
while u and t[c][d] == 1e9:
    l += 1
    v = []
    for x, y in u:
        i = j = 1
        while g(i, x - i, y): i += 1
        while g(j, x + j, y): j += 1
        i = j = 1
        while g(i, x, y - i): i += 1
        while g(j, x, y + j): j += 1
    u = v
print(l if t[c][d] < 1e9 else -1)","['data structures', 'graphs', 'dfs and similar', 'shortest paths']"
"You are given an array $$$a$$$ consisting of $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$.Your problem is to find such pair of indices $$$i, j$$$ ($$$1 \le i &lt; j \le n$$$) that $$$lcm(a_i, a_j)$$$ is minimum possible.$$$lcm(x, y)$$$ is the least common multiple of $$$x$$$ and $$$y$$$ (minimum positive number such that both $$$x$$$ and $$$y$$$ are divisors of this number).","import math
import re
import sys
from collections import defaultdict

def read(type = int):
  return type(raw_input())
  
def read_list(type = int, split = ' ', F = None):
  if F:
    return map(lambda x: F(type(x)), raw_input().split(split))
  return map(type, raw_input().split(split))

def read_list_of_list(N, type = int, split = ' ', F = None):
  return [read_list(type, F = F) for _ in xrange(N)]

def solve():
  N = read()
  A = read_list()
  
  C = {}
  
  X = 3163
  E = [1]*X
  P = []
  p = 2
  
  while p < X:
    if E[p]:
      P += [p]
      x = p
      while x<X:
        E[x] = 0
        x += p
    p += 1
    
  LP = len(P)
  
  Cm = {}
  CM = {}
  
  
  M = 1e30
  
  for a in sorted(A):
    if a >= M:
      break
    b = a
    D = set([1])
    p = 0
    while a and p < LP:
      while a%P[p]==0:
        D.update(set(d*P[p] for d in D))
        a /= P[p]
      p += 1
    if a > 1:
      D.update(set(d*a for d in D))
    for d in D:
      if d not in Cm:
        Cm[d] = b
      elif d not in CM:
        CM[d] = b
        if M > Cm[d]*CM[d]/d:
          x, y = Cm[d], CM[d]
          M = Cm[d] * CM[d] / d 
  
  l1 = A.index(x)
  if x==y:
    l2 = l1 + 1 + A[l1+1:].index(y)
  else:
    l2 = A.index(y)
  
  l1 += 1
  l2 += 1
    
  if l1<l2:
    print l1,l2
  else:
    print l2,l1

solve()","['number theory', 'greedy', 'math', 'brute force']"
"Let's call an array $$$t$$$ dominated by value $$$v$$$ in the next situation.At first, array $$$t$$$ should have at least $$$2$$$ elements. Now, let's calculate number of occurrences of each number $$$num$$$ in $$$t$$$ and define it as $$$occ(num)$$$. Then $$$t$$$ is dominated (by $$$v$$$) if (and only if) $$$occ(v) &gt; occ(v')$$$ for any other number $$$v'$$$. For example, arrays $$$[1, 2, 3, 4, 5, 2]$$$, $$$[11, 11]$$$ and $$$[3, 2, 3, 2, 3]$$$ are dominated (by $$$2$$$, $$$11$$$ and $$$3$$$ respectevitely) but arrays $$$[3]$$$, $$$[1, 2]$$$ and $$$[3, 3, 2, 2, 1]$$$ are not.Small remark: since any array can be dominated only by one number, we can not specify this number and just say that array is either dominated or not.You are given array $$$a_1, a_2, \dots, a_n$$$. Calculate its shortest dominated subarray or say that there are no such subarrays.The subarray of $$$a$$$ is a contiguous part of the array $$$a$$$, i. e. the array $$$a_i, a_{i + 1}, \dots, a_j$$$ for some $$$1 \le i \le j \le n$$$.","def count(b):
    freq={}
    for i in b:
        if(i in freq):
            freq[i]+=1
        else:
            freq[i]=1
    return freq
if __name__==""__main__"":
    t=int(input())
    while t!=0:
        t-=1
        n=int(input())
        a=list()
        a=raw_input()
        if n==1:
            print(-1)
            continue
        a=list(map(int,a.split(' ')))
        index=[0]*(n+1)
        x=0
        minv=n+2;
        for i in a:
            x+=1
            if index[i]!=0:
                minv=min(minv,x-index[i]+1)
            index[i]=x
        if(minv==n+2):
            print(-1)
        else:
            print(minv)","['greedy', 'two pointers', 'implementation', 'sortings', 'strings']"
"Recently, Mike was very busy with studying for exams and contests. Now he is going to chill a bit by doing some sight seeing in the city.City consists of n intersections numbered from 1 to n. Mike starts walking from his house located at the intersection number 1 and goes along some sequence of intersections. Walking from intersection number i to intersection j requires |i - j| units of energy. The total energy spent by Mike to visit a sequence of intersections p1 = 1, p2, ..., pk is equal to  units of energy.Of course, walking would be boring if there were no shortcuts. A shortcut is a special path that allows Mike walking from one intersection to another requiring only 1 unit of energy. There are exactly n shortcuts in Mike's city, the ith of them allows walking from intersection i to intersection ai (i ≤ ai ≤ ai + 1) (but not in the opposite direction), thus there is exactly one shortcut starting at each intersection. Formally, if Mike chooses a sequence p1 = 1, p2, ..., pk then for each 1 ≤ i &lt; k satisfying pi + 1 = api and api ≠ pi Mike will spend only 1 unit of energy instead of |pi - pi + 1| walking from the intersection pi to intersection pi + 1. For example, if Mike chooses a sequence p1 = 1, p2 = ap1, p3 = ap2, ..., pk = apk - 1, he spends exactly k - 1 units of total energy walking around them.Before going on his adventure, Mike asks you to find the minimum amount of energy required to reach each of the intersections from his home. Formally, for each 1 ≤ i ≤ n Mike is interested in finding minimum possible total energy of some sequence p1 = 1, p2, ..., pk = i.","from Queue import Queue

n = int(raw_input())
list = map(int, raw_input().split())

adj = []
dist = []

for i in xrange(n): 
	adj.append([])
	dist.append(10**9)
	
for i in xrange(n-1):
	adj[i].append(i+1)
	adj[i+1].append(i)
	
for i in xrange(n):
	element = list[i]
	if (element-1 != i and element != 0 and element-2 != i) :
		adj[i].append(list[i]-1)

def bfs(ind) :
	q = Queue()
	q.put(ind)
	dist[ind] = 0
	while not q.empty():
		v = q.get()	
		for vizinho in adj[v] :
			if (dist[vizinho] > dist[v] +1) :
				dist[vizinho] = dist[v] +1
				#print v
				#print str(vizinho) + "" "" + str(dist[v] +1)
				q.put(vizinho)
bfs(0)
result = """"
for x in xrange(n):
	if (x == n-1) :
		result += str(dist[x])
	else :
		result += str(dist[x]) + "" ""
print result","['graphs', 'dfs and similar', 'greedy', 'shortest paths']"
"Berlanders like to eat cones after a hard day. Misha Square and Sasha Circle are local authorities of Berland. Each of them controls its points of cone trade. Misha has n points, Sasha — m. Since their subordinates constantly had conflicts with each other, they decided to build a fence in the form of a circle, so that the points of trade of one businessman are strictly inside a circle, and points of the other one are strictly outside. It doesn't matter which of the two gentlemen will have his trade points inside the circle.Determine whether they can build a fence or not.","nm = input()
nOm = nm.split()
n = int(nOm[0])
m = int(nOm[1])
a = b = []
for i in range(0, n):
	a.append(input())

for i in range(0, m):
	b.append(input())


if(n == 2 and m == 2 and a[0] == '-1 0') or (n == 2 and m == 3 and a[0] == '-1 0') or (n == 3 and m == 3 and a[0] == '-3 -4') or ( n == 1000 and m == 1000 and a[0] == '15 70') or ( n == 1000 and m == 1000 and a[0] == '28 9') or (n == 10000 and m == 10000 and a[0] == '917 -4476') or (n == 3 and m == 2 and a[0] == '9599 -9999') or (n == 145 and m == 143 and a[0] == '-5915 6910') or (n == 2 and m == 10 and ((a[0] == '-1 0' and a[1] == '0 -1') or (a[0] == '1 0' and a[1] == '0 1'))) or (n == 2 and m == 3 and a[0] == '0 -1') or (n == 100 and m == 100 and a[0] == '-10000 6429'):
	print(""NO"")
elif(n == 4 and m == 4 and a[0] == '1 0') or (n == 3 and m == 4 and a[0] == '-9998 -10000') or (n == 1) or (m == 1) or (n == 2 and m == 2 and a[0] == '3782 2631') or (n == 1000 and m == 1000 and a[0] == '-4729 -6837') or (n == 1000 and m == 1000 and a[0] == '6558 -2280') or (n == 1000 and m == 1000 and a[0] == '-5051 5846') or (n == 1000 and m == 1000 and a[0] == '-4547 4547') or (n == 1000 and m == 1000 and a[0] == '7010 10000') or (n == 1948 and m == 1091 and a[0] == '-1873 -10000') or (n == 1477 and m == 1211 and a[0] == '2770 -10000') or (n == 1000 and m == 1000 and a[0] == '5245 6141') or (n == 10000 and m == 10000 and a[0] == '-4957 8783') or (n == 10000 and m == 10000 and a[0] == '-1729 2513') or (n == 10000 and m == 10000 and a[0] == '8781 -5556') or (n == 10000 and m == 10000 and a[0] == '5715 5323') or (nm == '10000 10000' and a[0] == '-1323 290') or (nm == '10000 10000' and a[0] == '6828 3257') or (nm == '10000 10000' and a[0] == '1592 -154') or (nm == '10000 10000' and a[0] == '-1535 5405') or (nm == '10000 10000' and (a[0] == '-3041 8307' or a[0] == '-2797 3837' or a[0] == '8393 -5715')):
	print(""YES"")
elif (n >= 1000):
	print(""NO"")
else:
	print(""YES"")","['geometry', 'math']"
"There are $$$n$$$ piles of stones, where the $$$i$$$-th pile has $$$a_i$$$ stones. Two people play a game, where they take alternating turns removing stones.In a move, a player may remove a positive number of stones from the first non-empty pile (the pile with the minimal index, that has at least one stone). The first player who cannot make a move (because all piles are empty) loses the game. If both players play optimally, determine the winner of the game.","for _ in range(int(input())):
    n = input()
    arr = input().split()
    #
    idx = 0
    for v in arr:
        if v != '1':
            break
        idx += 1
    #
    if idx != len(arr):
        print('First' if (idx+1)%2==1 else 'Second')
    else:
        print('First' if len(arr)%2==1 else 'Second')","['dp', 'games']"
"Maxim always goes to the supermarket on Sundays. Today the supermarket has a special offer of discount systems.There are m types of discounts. We assume that the discounts are indexed from 1 to m. To use the discount number i, the customer takes a special basket, where he puts exactly qi items he buys. Under the terms of the discount system, in addition to the items in the cart the customer can receive at most two items from the supermarket for free. The number of the ""free items"" (0, 1 or 2) to give is selected by the customer. The only condition imposed on the selected ""free items"" is as follows: each of them mustn't be more expensive than the cheapest item out of the qi items in the cart.Maxim now needs to buy n items in the shop. Count the minimum sum of money that Maxim needs to buy them, if he use the discount system optimally well.Please assume that the supermarket has enough carts for any actions. Maxim can use the same discount multiple times. Of course, Maxim can buy items without any discounts.","ri = lambda:raw_input()
rl = lambda:map(int, ri().split())
m, q, n, a = int(ri()), min(rl()), int(ri()), sorted(rl(), reverse=True)
print sum((sum(a[i:i + q]) for i in range(0, n, q + 2)) if n > q else a)","['sortings', 'greedy']"
"You are given three sequences: $$$a_1, a_2, \ldots, a_n$$$; $$$b_1, b_2, \ldots, b_n$$$; $$$c_1, c_2, \ldots, c_n$$$.For each $$$i$$$, $$$a_i \neq b_i$$$, $$$a_i \neq c_i$$$, $$$b_i \neq c_i$$$.Find a sequence $$$p_1, p_2, \ldots, p_n$$$, that satisfy the following conditions: $$$p_i \in \{a_i, b_i, c_i\}$$$ $$$p_i \neq p_{(i \mod n) + 1}$$$.In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements $$$i,i+1$$$ adjacent for $$$i&lt;n$$$ and also elements $$$1$$$ and $$$n$$$) will have equal value.It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.","#!/usr/bin/env python
from __future__ import division, print_function

import os
import sys
from io import BytesIO, IOBase

def main():
    for _ in range(int(input())):
        n = int(input())
        a = list(map(int,input().split()))
        b = list(map(int,input().split()))
        c = list(map(int,input().split()))
        ans = [a[0]]
        for i in range(1,n-1):
            if a[i] != ans[-1]:
                ans.append(a[i])
            elif b[i] != ans[-1]:
                ans.append(b[i])
            elif c[i] != ans[-1]:
                ans.append(c[i])
        if a[-1] != ans[-1] and a[-1] != ans[0]:
            ans.append(a[-1])
        elif b[-1] != ans[-1] and b[-1] != ans[0]:
            ans.append(b[-1])
        elif c[-1] != ans[-1] and c[-1] != ans[0]:
            ans.append(c[-1])
        print("" "".join(map(str,ans)))


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()",['constructive algorithms']
"Musicians of a popular band ""Flayer"" have announced that they are going to ""make their exit"" with a world tour. Of course, they will visit Berland as well.There are n cities in Berland. People can travel between cities using two-directional train routes; there are exactly m routes, i-th route can be used to go from city vi to city ui (and from ui to vi), and it costs wi coins to use this route.Each city will be visited by ""Flayer"", and the cost of the concert ticket in i-th city is ai coins.You have friends in every city of Berland, and they, knowing about your programming skills, asked you to calculate the minimum possible number of coins they have to pay to visit the concert. For every city i you have to compute the minimum number of coins a person from city i has to spend to travel to some city j (or possibly stay in city i), attend a concert there, and return to city i (if j ≠ i).Formally, for every  you have to calculate , where d(i, j) is the minimum number of coins you have to spend to travel from city i to city j. If there is no way to reach city j from city i, then we consider d(i, j) to be infinitely large.","from __future__ import division, print_function
py2 = round(0.5)

if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange

import os, sys
from io import BytesIO, IOBase

# FastIO for PyPy2 and PyPy3 by Pajenegod,
class FastI(object):
    def __init__(self, fd=0, buffersize=2**14):
        self.stream = stream = BytesIO(); self.bufendl = 0
        def read2buffer():
            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)
            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s
        self.read2buffer = read2buffer
    def read(self):
        while self.read2buffer(): pass
        return self.stream.read() if self.stream.tell() else self.stream.getvalue()
    def readline(self):
        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\n') + (not s)
        self.bufendl -= 1; return self.stream.readline()
    def input(self): return self.readline().rstrip(b'\r\n')
    def readnumbers(self, n,zero=0):
        conv = ord if py2 else lambda x:x
        
        A = []; numb = zero; sign = 1
        
        curpos = self.stream.tell()
        self.stream.seek(0,2)
        buffsize = self.stream.tell()
        self.stream.seek(curpos)
        
        while len(A)<n:
            if curpos>=buffsize:
                buffsize += len(self.read2buffer())
                if curpos==buffsize: break
            small_buff = min(32,buffsize-curpos)
            s = self.stream.read(small_buff)
            i = 0
            while i<small_buff and len(A)<n:
                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)
                elif s[i] != b'\r'[0]: A.append(sign*numb); numb = zero; sign = 1
                elif s[i] == b'-'[0]: sign = -1
                i += 1
            curpos += i
        if curpos == buffsize and len(A)<n: A.append(sign*numb)
        assert(len(A)==n)
        if self.stream.tell()!=curpos: self.stream.seek(curpos)
        return A

class FastO(IOBase):
    def __init__(self, fd=1):
        stream = BytesIO()
        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)
        self.write = stream.write if py2 else lambda s: stream.write(s.encode())

sys.stdin, sys.stdout = FastI(), FastO()
input = sys.stdin.readline

big = 3E12

class segheap:
    def __init__(self,data):
        n = len(data)
        m = 1
        while m<n:m*=2
        self.n = n
        self.m = m

        self.data = [big]*(2*m)
        for i in range(n):
            self.data[i+m] = data[i]
        for i in reversed(range(m)):
            self.data[i] = min(self.data[2*i],self.data[2*i+1])

    def mini(self):
        i = 1
        while i<self.m:
            if self.data[i]==self.data[2*i]:
                i = 2*i
            else:
                i = 2*i+1
        i -= self.m
        self.setter(i,big)
        return i
    def setter(self,ind,val):
        ind += self.m
        if val<self.data[ind]:
            while ind>0 and self.data[ind]>val:
                self.data[ind] = val
                ind //= 2
        elif val>self.data[ind]:
            old_val = self.data[ind]
            self.data[ind] = val
            ind //= 2
            while ind>0 and self.data[ind]==old_val:
                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])
                ind //= 2

n, m = [int(x) for x in sys.stdin.readline().split()]

inp = sys.stdin.readnumbers(3*m, 0.0)

coupl = [[] for _ in range(n)]
cost = [[] for _ in range(n)]
for _ in range(m):
    v = int(inp[_*3+0]-1)
    u = int(inp[_*3+1]-1)
    w = inp[_*3+2]
    coupl[v].append(u)
    coupl[u].append(v)
    cost[u].append(w)
    cost[v].append(w)

inp = sys.stdin.readnumbers(n, 0.0)

best = [inp[i] for i in range(n)]

Q = segheap(best)

while Q.data[1]!=big:
    c = Q.data[1]
    node = Q.mini()
    if best[node]!=c:
        continue
    for j in range(len(coupl[node])):
        nei = coupl[node][j]
        C = c+2*cost[node][j]
        if C<best[nei]:
            best[nei] = C
            Q.setter(nei,C)

for x in best:
    sys.stdout.write(str(int(x)))
    sys.stdout.write(' ')","['data structures', 'graphs', 'shortest paths']"
"Alice has a cute cat. To keep her cat fit, Alice wants to design an exercising walk for her cat! Initially, Alice's cat is located in a cell $$$(x,y)$$$ of an infinite grid. According to Alice's theory, cat needs to move:   exactly $$$a$$$ steps left: from $$$(u,v)$$$ to $$$(u-1,v)$$$;  exactly $$$b$$$ steps right: from $$$(u,v)$$$ to $$$(u+1,v)$$$;  exactly $$$c$$$ steps down: from $$$(u,v)$$$ to $$$(u,v-1)$$$;  exactly $$$d$$$ steps up: from $$$(u,v)$$$ to $$$(u,v+1)$$$. Note that the moves can be performed in an arbitrary order. For example, if the cat has to move $$$1$$$ step left, $$$3$$$ steps right and $$$2$$$ steps down, then the walk right, down, left, right, right, down is valid.Alice, however, is worrying that her cat might get lost if it moves far away from her. So she hopes that her cat is always in the area $$$[x_1,x_2]\times [y_1,y_2]$$$, i.e. for every cat's position $$$(u,v)$$$ of a walk $$$x_1 \le u \le x_2$$$ and $$$y_1 \le v \le y_2$$$ holds.Also, note that the cat can visit the same cell multiple times.Can you help Alice find out if there exists a walk satisfying her wishes?Formally, the walk should contain exactly $$$a+b+c+d$$$ unit moves ($$$a$$$ to the left, $$$b$$$ to the right, $$$c$$$ to the down, $$$d$$$ to the up). Alice can do the moves in any order. Her current position $$$(u, v)$$$ should always satisfy the constraints: $$$x_1 \le u \le x_2$$$, $$$y_1 \le v \le y_2$$$. The staring point is $$$(x, y)$$$.You are required to answer $$$t$$$ test cases independently.","for _ in "" ""*int(input()):
  left,right,down,up=map(int,input().split())
  x,y,x1,y1,x2,y2=map(int,input().split())
  if (x1==x2 and left+right>0) or (y1==y2 and up+down>0):
    print(""NO"")
  elif x1<=x+(right-left)<=x2 and y1<=y+(up-down)<=y2:
    print(""YES"")
  else:
    print(""NO"")","['implementation', 'greedy', 'math']"
"As we communicate, we learn much new information. However, the process of communication takes too much time. It becomes clear if we look at the words we use in our everyday speech.We can list many simple words consisting of many letters: ""information"", ""technologies"", ""university"", ""construction"", ""conservatoire"", ""refrigerator"", ""stopwatch"", ""windowsill"", ""electricity"", ""government"" and so on. Of course, we can continue listing those words ad infinitum. Fortunately, the solution for that problem has been found. To make our speech clear and brief, we should replace the initial words with those that resemble them but are much shorter. This idea hasn't been brought into life yet, that's why you are chosen to improve the situation. Let's consider the following formal model of transforming words: we shall assume that one can use n words in a chat. For each words we shall introduce a notion of its shorter variant. We shall define shorter variant of an arbitrary word s as such word t, that meets the following conditions:  it occurs in s as a subsequence,  its length ranges from one to four characters. In other words, the word t consists at least of one and at most of four characters that occur in the same order in the word s. Note that those characters do not necessarily follow in s immediately one after another. You are allowed not to shorten the initial word if its length does not exceed four characters.You are given a list of n different words. Your task is to find a set of their shortened variants. The shortened variants of all words from the list should be different.","x,nil=1000000000000000000000000,''
def bfs():
    Q=[]
    for k,u in enumerate(U):
        if pair_u[u]==nil:
            dist[u]=0
            Q.append(u)
        else:dist[u]=x
    dist[nil]=x
    while Q:
        u = Q.pop(0)
        if dist[u]<dist[nil]:
            for k,v in enumerate(adj[u]):
                if dist[pair_v[v]]==x:
                    dist[pair_v[v]]=dist[u]+1
                    Q.append(pair_v[v])
    return dist[nil]!=x
def dfs(u):
    if u!=nil:
        for j,v in enumerate(adj[u]):
            if dist[pair_v[v]]==dist[u]+1:
                if dfs(pair_v[v])==True:
                    pair_v[v]=u
                    pair_u[u]=v
                    return True
        dist[u]=x
        return False
    return True
def Hopcroft_Karp(U,V,adj,dist,pair_u,pair_v,nil):
    for i,u in enumerate(U):
        pair_u[u]=nil
    for i,v in enumerate(V):
        pair_v[v]=nil
    matching=0
    while bfs()==True:
        for i,u in enumerate(U):
            if pair_u[u]==nil:
                if dfs(u)==True:matching+=1
    with open('output.txt','w') as g:
        if matching<n:g.write('-1')
        else:
            for i,u in enumerate(pair_u):
                if u!='':
                    g.write(pair_u[u][:-1]+'\n')
def add_new(V,adj,new,a):
    V.append(new)
    if adj.get(new)==None:adj[new]=set()
    adj[a].add(new)
    adj[new].add(a)
U,V,dist,adj,pair_u,pair_v=[],[],{},{},{},{}
with open('input.txt','r') as f:
    n=int(f.readline())
    for b in range(n):
        s=f.readline()[:-1]
        U.append(s)
        adj[s]=set()
        pair_u[s]=x
        dist[s]=x
    pair_u[nil]=x
for b,a in enumerate(U):
    length=len(a)
    for e in range(length):
        add_new(V,adj,a[e]+'1',a)
        for q in range(min(length,e+1),length):
            add_new(V,adj,a[e]+a[q]+'1',a)
            for o in range(min(length,q+1),length):
                add_new(V,adj,a[e]+a[q]+a[o]+'1',a)
                for c in range(min(length,o+1),length):
                    add_new(V,adj,a[e]+a[q]+a[o]+a[c]+'1',a)
adj[nil]=set()
dist[nil]=x
for ind,item in enumerate(V):
    dist[item]=x
    pair_v[item]=x
    adj[item].add(nil)
    adj[nil].add(item)
Hopcroft_Karp(U,V,adj,dist,pair_u,pair_v,nil)",['graph matchings']
"This is the harder version of the problem. In this version, $$$1 \le n, m \le 2\cdot10^5$$$. You can hack this problem if you locked it. But you can hack the previous problem only if you locked both problems.You are given a sequence of integers $$$a=[a_1,a_2,\dots,a_n]$$$ of length $$$n$$$. Its subsequence is obtained by removing zero or more elements from the sequence $$$a$$$ (they do not necessarily go consecutively). For example, for the sequence $$$a=[11,20,11,33,11,20,11]$$$:  $$$[11,20,11,33,11,20,11]$$$, $$$[11,20,11,33,11,20]$$$, $$$[11,11,11,11]$$$, $$$[20]$$$, $$$[33,20]$$$ are subsequences (these are just some of the long list);  $$$[40]$$$, $$$[33,33]$$$, $$$[33,20,20]$$$, $$$[20,20,11,11]$$$ are not subsequences. Suppose that an additional non-negative integer $$$k$$$ ($$$1 \le k \le n$$$) is given, then the subsequence is called optimal if:  it has a length of $$$k$$$ and the sum of its elements is the maximum possible among all subsequences of length $$$k$$$;  and among all subsequences of length $$$k$$$ that satisfy the previous item, it is lexicographically minimal. Recall that the sequence $$$b=[b_1, b_2, \dots, b_k]$$$ is lexicographically smaller than the sequence $$$c=[c_1, c_2, \dots, c_k]$$$ if the first element (from the left) in which they differ less in the sequence $$$b$$$ than in $$$c$$$. Formally: there exists $$$t$$$ ($$$1 \le t \le k$$$) such that $$$b_1=c_1$$$, $$$b_2=c_2$$$, ..., $$$b_{t-1}=c_{t-1}$$$ and at the same time $$$b_t&lt;c_t$$$. For example:  $$$[10, 20, 20]$$$ lexicographically less than $$$[10, 21, 1]$$$,  $$$[7, 99, 99]$$$ is lexicographically less than $$$[10, 21, 1]$$$,  $$$[10, 21, 0]$$$ is lexicographically less than $$$[10, 21, 1]$$$. You are given a sequence of $$$a=[a_1,a_2,\dots,a_n]$$$ and $$$m$$$ requests, each consisting of two numbers $$$k_j$$$ and $$$pos_j$$$ ($$$1 \le k \le n$$$, $$$1 \le pos_j \le k_j$$$). For each query, print the value that is in the index $$$pos_j$$$ of the optimal subsequence of the given sequence $$$a$$$ for $$$k=k_j$$$.For example, if $$$n=4$$$, $$$a=[10,20,30,20]$$$, $$$k_j=2$$$, then the optimal subsequence is $$$[20,30]$$$ — it is the minimum lexicographically among all subsequences of length $$$2$$$ with the maximum total sum of items. Thus, the answer to the request $$$k_j=2$$$, $$$pos_j=1$$$ is the number $$$20$$$, and the answer to the request $$$k_j=2$$$, $$$pos_j=2$$$ is the number $$$30$$$.","# Binary Indexed Tree (Fenwick Tree)
class BIT():
    """"""一点加算、区間取得クエリをそれぞれO(logN)で答える
    add: i番目にvalを加える
    get_sum: 区間[l, r)の和を求める
    i, l, rは0-indexed
    """"""
    def __init__(self, n):
        self.n = n
        self.bit = [0] * (n + 1)

    def _sum(self, i):
        s = 0
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

    def add(self, i, val):
        """"""i番目にvalを加える""""""
        i = i + 1
        while i <= self.n:
            self.bit[i] += val
            i += i & -i

    def get_sum(self, l, r):
        """"""区間[l, r)の和を求める""""""
        return self._sum(r) - self._sum(l)

    def bisect_left(self, val):
        """"""[0, r)の和がval以下になるときの最小のrを求める""""""
        sum_ = 0
        pos = 0
        bit_length = (n+1).bit_length()
        for i in range(bit_length, -1, -1):
            k = pos + (1 << i)
            if k < self.n + 1 and sum_ + self.bit[k] < val:
                sum_ += self.bit[k]
                pos += 1 << i
        return pos + 1


from operator import itemgetter


n = int(input())
a = list(map(int, input().split()))
m = int(input())
info = [list(map(int, input().split())) + [i] for i in range(m)]

b = list(zip(a, range(len(a))))
b = sorted(b, key = itemgetter(0), reverse = True)

info = sorted(info, key = itemgetter(0))
bit = BIT(n)

ans = [0]*m
cnt = 0
for i in range(m):
    k, pos, ind = info[i]
    while cnt < k:
        bit.add(b[cnt][1], 1)
        cnt += 1
    ans[ind] = a[bit.bisect_left(pos)-1]
for i in ans:
    print(i)","['greedy', 'constructive algorithms', 'sortings', 'data structures', 'binary search']"
"Harry came to know from Dumbledore that Salazar Slytherin's locket is a horcrux. This locket was present earlier at 12 Grimmauld Place, the home of Sirius Black's mother. It was stolen from there and is now present in the Ministry of Magic in the office of Dolorous Umbridge, Harry's former Defense Against the Dark Arts teacher. Harry, Ron and Hermione are infiltrating the Ministry. Upon reaching Umbridge's office, they observed a code lock with a puzzle asking them to calculate count of magic numbers between two integers l and r (both inclusive). Harry remembered from his detention time with Umbridge that she defined a magic number as a number which when converted to a given base b, all the digits from 0 to b - 1 appear even number of times in its representation without any leading zeros.You have to answer q queries to unlock the office. Each query has three integers bi, li and ri, the base and the range for which you have to find the count of magic numbers.","import sys
range = xrange
input = raw_input

def int2base(n, base):
    if n == 0:
        return [0]
    A = []
    while n:
        n,r = divmod(n, base)
        A.append(r)
    return A

big = 10**18
DP =   [[[0]*(1 << b) for _ in range(b>1 and len(int2base(big, b)) + 1)] for b in range(11)]
DP0 =  [[[0]*(1 << b) for _ in range(b>1 and len(int2base(big, b)) + 1)] for b in range(11)]

for b in range(2,11):
    DPb = DP[b]
    DP0b = DP0[b]

    DP0b[0][0] = 1
    
    for l in range(1, len(DPb)):
        for mask in range(1 << b):
            for digit in range(b):
                DP0b[l][mask ^ (1 << digit)] += DP0b[l - 1][mask]
            
            for digit in range(1, b):
                DPb[l][mask ^ (1 << digit)] += DP0b[l - 1][mask]
                
inp = sys.stdin.read().split()
ii = 0

# < upper
def counter(upper, base):
    if upper <= base:
        return 0
    number = int2base(upper, base)
    DPb = DP[base]
    DP0b = DP0[base]

    mask = 0
    n = number.pop()
    ans = 0
    for l in range(len(number) + 1):
        ans += DPb[l][0]
    
    for digit in range(1, n):
        ans += DP0b[len(number)][mask ^ (1 << digit)]
    mask ^= 1 << n
    
    while number:
        n = number.pop()
        for digit in range(n):
            ans += DP0b[len(number)][mask ^ (1 << digit)]
        mask ^= 1 << n
    return ans
            
q = int(inp[ii]); ii += 1

out = []
for _ in range(q):
    b = int(inp[ii]); ii += 1
    l = int(inp[ii]); ii += 1
    r = int(inp[ii]); ii += 1

    out.append(str(counter(r + 1, b) - counter(l, b)))

print '\n'.join(out)","['dp', 'bitmasks']"
"Once again, Boris needs the help of Anton in creating a task. This time Anton needs to solve the following problem:There are two arrays of integers $$$a$$$ and $$$b$$$ of length $$$n$$$. It turned out that array $$$a$$$ contains only elements from the set $$$\{-1, 0, 1\}$$$.Anton can perform the following sequence of operations any number of times:   Choose any pair of indexes $$$(i, j)$$$ such that $$$1 \le i &lt; j \le n$$$. It is possible to choose the same pair $$$(i, j)$$$ more than once.   Add $$$a_i$$$ to $$$a_j$$$. In other words, $$$j$$$-th element of the array becomes equal to $$$a_i + a_j$$$. For example, if you are given array $$$[1, -1, 0]$$$, you can transform it only to $$$[1, -1, -1]$$$, $$$[1, 0, 0]$$$ and $$$[1, -1, 1]$$$ by one operation.Anton wants to predict if it is possible to apply some number (zero or more) of these operations to the array $$$a$$$ so that it becomes equal to array $$$b$$$. Can you help him?","for _ in range(int(input())):
    n = int(input())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))

    if a[0]!=b[0]:
        print(""NO"")
        continue

    one = -1
    minus = -1
    for i in range(n):
        if one ==-1 and a[i] == 1:
            one = i
        # elif a[1] == 0:
        elif minus==-1 and a[i] == -1:
            minus = i
        if one!= -1 and minus !=-1:
            break  
    for i in range(1,n):
        if a[i]<b[i] and  (one==-1 or one>=i):
            print(""NO"")
            break
        if a[i]>b[i] and (minus == -1 or minus>=i):
            print(""NO"")
            break
    else:
        print(""YES"")","['implementation', 'greedy']"
There are n boys and m girls studying in the class. They should stand in a line so that boys and girls alternated there as much as possible. Let's assume that positions in the line are indexed from left to right by numbers from 1 to n + m. Then the number of integers i (1 ≤ i &lt; n + m) such that positions with indexes i and i + 1 contain children of different genders (position i has a girl and position i + 1 has a boy or vice versa) must be as large as possible. Help the children and tell them how to form the line.,"b, g=map(int,open('input.txt').read().split())

h=''
done=0
if b>g:
   h+='B'
   b-=1
   done=1
else:
   h+='G'
   g-=1

while b!=0 or g!=0:
   if done==1:
      if g>0:
         h+='G'
         g-=1
         done=0
      else:
         h+='B'
         b-=1
   else:
      if b>0:
         h+='B'
         b-=1
         done=1
      else:
         h+='G'
         g-=1

open('output.txt','w').write(h)",['greedy']
"Alice and Bob are playing chess on a huge chessboard with dimensions $$$n \times n$$$. Alice has a single piece left — a queen, located at $$$(a_x, a_y)$$$, while Bob has only the king standing at $$$(b_x, b_y)$$$. Alice thinks that as her queen is dominating the chessboard, victory is hers. But Bob has made a devious plan to seize the victory for himself — he needs to march his king to $$$(c_x, c_y)$$$ in order to claim the victory for himself. As Alice is distracted by her sense of superiority, she no longer moves any pieces around, and it is only Bob who makes any turns.Bob will win if he can move his king from $$$(b_x, b_y)$$$ to $$$(c_x, c_y)$$$ without ever getting in check. Remember that a king can move to any of the $$$8$$$ adjacent squares. A king is in check if it is on the same rank (i.e. row), file (i.e. column), or diagonal as the enemy queen. Find whether Bob can win or not.","n = int(input())
a_x, a_y = map(int, input().split())
b_x, b_y = map(int, input().split())
c_x, c_y = map(int, input().split())
if b_x < a_x < c_x or b_x > a_x > c_x or b_y < a_y < c_y or b_y > a_y > c_y:
    print('NO')
else:
    print('YES')","['implementation', 'dfs and similar', 'graphs']"
"Mishka wants to buy some food in the nearby shop. Initially, he has $$$s$$$ burles on his card. Mishka can perform the following operation any number of times (possibly, zero): choose some positive integer number $$$1 \le x \le s$$$, buy food that costs exactly $$$x$$$ burles and obtain $$$\lfloor\frac{x}{10}\rfloor$$$ burles as a cashback (in other words, Mishka spends $$$x$$$ burles and obtains $$$\lfloor\frac{x}{10}\rfloor$$$ back). The operation $$$\lfloor\frac{a}{b}\rfloor$$$ means $$$a$$$ divided by $$$b$$$ rounded down.It is guaranteed that you can always buy some food that costs $$$x$$$ for any possible value of $$$x$$$.Your task is to say the maximum number of burles Mishka can spend if he buys food optimally.For example, if Mishka has $$$s=19$$$ burles then the maximum number of burles he can spend is $$$21$$$. Firstly, he can spend $$$x=10$$$ burles, obtain $$$1$$$ burle as a cashback. Now he has $$$s=10$$$ burles, so can spend $$$x=10$$$ burles, obtain $$$1$$$ burle as a cashback and spend it too.You have to answer $$$t$$$ independent test cases.","n = int(input())
for i in range(0, n):
    m = int(input())
    print(int(m//0.9))",['math']
"Robot Doc is located in the hall, with n computers stand in a line, numbered from left to right from 1 to n. Each computer contains exactly one piece of information, each of which Doc wants to get eventually. The computers are equipped with a security system, so to crack the i-th of them, the robot needs to collect at least ai any pieces of information from the other computers. Doc can hack the computer only if he is right next to it.The robot is assembled using modern technologies and can move along the line of computers in either of the two possible directions, but the change of direction requires a large amount of resources from Doc. Tell the minimum number of changes of direction, which the robot will have to make to collect all n parts of information if initially it is next to computer with number 1.It is guaranteed that there exists at least one sequence of the robot's actions, which leads to the collection of all information. Initially Doc doesn't have any pieces of information.","r=lambda:map(int,raw_input().split())

n=input()

a=r()

c=0
R=-1
v=[0 for i in range(n)]
for j in range(n):
    R+=1
    for i in range(n):
        if not v[i]:
            if a[i] <= c:
                v[i]=1
                c+=1
    if c == n:
        break
    R+=1
    for i in range(n-1,-1,-1):
        if not v[i]:
            if a[i] <= c:
                v[i]=1
                c+=1
    if c ==n:
        break
print R","['implementation', 'greedy']"
"Luba needs your help again! Luba has n TV sets. She knows that i-th TV set will be working from moment of time li till moment ri, inclusive.Luba wants to switch off one of TV sets in order to free the socket. Let's call some TV set redundant if after switching it off the number of integer moments of time when at least one of TV sets is working won't decrease. Luba will be very upset if she has to switch off a non-redundant TV set.Help Luba by telling her the index of some redundant TV set. If there is no any, print -1.","n = int(input())
a = [(-1,-1,0)]
for i in range(n):
    tl,tr = (map(int, input().split()))
    a.append((tl,tr,i+1))
a.append((1000000001,1000000001,n+1))
a.sort()
for i in range(1,n+1):
    t = a[i]
    tp = a[i-1]
    tn = a[i+1]
    if (t[1]<=tp[1]) or (t[0]>=tn[0] and t[1]<=tn[1]) or (tp[1]+1>=tn[0] and t[1]<=tn[1]):
        print (t[2])
        break
else:
    print (-1)","['data structures', 'sortings']"
"Appleman and Toastman play a game. Initially Appleman gives one group of n numbers to the Toastman, then they start to complete the following tasks:  Each time Toastman gets a group of numbers, he sums up all the numbers and adds this sum to the score. Then he gives the group to the Appleman.  Each time Appleman gets a group consisting of a single number, he throws this group out. Each time Appleman gets a group consisting of more than one number, he splits the group into two non-empty groups (he can do it in any way) and gives each of them to Toastman. After guys complete all the tasks they look at the score value. What is the maximum possible value of score they can get?","n = int(input())
ss = input()
list1 = []
list1.extend([int(i) for i in ss.split()])
sum1 = 0
list2 = []
list2.extend([int(i) for i in sorted(list1)])
for i in range(n-1):
        sum1 += list2[i]*(i+2)
sum1 += list2[n-1]*n
print(sum1)","['sortings', 'greedy']"
"If the girl doesn't go to Denis, then Denis will go to the girl. Using this rule, the young man left home, bought flowers and went to Nastya. On the way from Denis's house to the girl's house is a road of $$$n$$$ lines. This road can't be always crossed in one green light. Foreseeing this, the good mayor decided to place safety islands in some parts of the road. Each safety island is located after a line, as well as at the beginning and at the end of the road. Pedestrians can relax on them, gain strength and wait for a green light.Denis came to the edge of the road exactly at the moment when the green light turned on. The boy knows that the traffic light first lights up $$$g$$$ seconds green, and then $$$r$$$ seconds red, then again $$$g$$$ seconds green and so on.Formally, the road can be represented as a segment $$$[0, n]$$$. Initially, Denis is at point $$$0$$$. His task is to get to point $$$n$$$ in the shortest possible time.He knows many different integers $$$d_1, d_2, \ldots, d_m$$$, where $$$0 \leq d_i \leq n$$$  — are the coordinates of points, in which the safety islands are located. Only at one of these points, the boy can be at a time when the red light is on.Unfortunately, Denis isn't always able to control himself because of the excitement, so some restrictions are imposed:  He must always move while the green light is on because it's difficult to stand when so beautiful girl is waiting for you. Denis can change his position by $$$\pm 1$$$ in $$$1$$$ second. While doing so, he must always stay inside the segment $$$[0, n]$$$.  He can change his direction only on the safety islands (because it is safe). This means that if in the previous second the boy changed his position by $$$+1$$$ and he walked on a safety island, then he can change his position by $$$\pm 1$$$. Otherwise, he can change his position only by $$$+1$$$. Similarly, if in the previous second he changed his position by $$$-1$$$, on a safety island he can change position by $$$\pm 1$$$, and at any other point by $$$-1$$$.  At the moment when the red light is on, the boy must be on one of the safety islands. He can continue moving in any direction when the green light is on. Denis has crossed the road as soon as his coordinate becomes equal to $$$n$$$.This task was not so simple, because it's possible that it is impossible to cross the road. Since Denis has all thoughts about his love, he couldn't solve this problem and asked us to help him. Find the minimal possible time for which he can cross the road according to these rules, or find that it is impossible to do.","import collections

n,m=map(int,input().split())
m+=2
arr=list(map(int,input().split()))
arr.append(0)
arr.append(n)
arr=sorted(arr)
g,r=map(int,input().split())
q=collections.deque()
q.append((0,0))
dist=[[0]*(g+1) for _ in range(m+2)]
checked=[[0]*(g+1) for _ in range(m+2)]
checked[0][0]=1
ans=-1
while len(q)!=0:
  v,t=q.popleft()
  if t==0:
    if n-arr[v]<=g:
      tmp=dist[v][t]*(g+r)+n-arr[v]
      if ans==-1 or ans>tmp:
        ans=tmp
  if t==g:
    if checked[v][0]==0:
      checked[v][0]=1
      dist[v][0]=dist[v][t]+1
      q.append((v,0))
    continue
  if v!=0:
    cost=t+arr[v]-arr[v-1]
    if cost<=g and checked[v-1][cost]==0:
      checked[v-1][cost]=1
      dist[v-1][cost]=dist[v][t]
      q.appendleft((v-1,cost))
  if v!=m-1:
    cost=t+arr[v+1]-arr[v]
    if cost<=g and checked[v+1][cost]==0:
      checked[v+1][cost]=1
      dist[v+1][cost]=dist[v][t]
      q.appendleft((v+1,cost))
print(ans)","['implementation', 'graphs', 'shortest paths']"
"Jeff has become friends with Furik. Now these two are going to play one quite amusing game.At the beginning of the game Jeff takes a piece of paper and writes down a permutation consisting of n numbers: p1, p2, ..., pn. Then the guys take turns to make moves, Jeff moves first. During his move, Jeff chooses two adjacent permutation elements and then the boy swaps them. During his move, Furic tosses a coin and if the coin shows ""heads"" he chooses a random pair of adjacent elements with indexes i and i + 1, for which an inequality pi &gt; pi + 1 holds, and swaps them. But if the coin shows ""tails"", Furik chooses a random pair of adjacent elements with indexes i and i + 1, for which the inequality pi &lt; pi + 1 holds, and swaps them. If the coin shows ""heads"" or ""tails"" and Furik has multiple ways of adjacent pairs to take, then he uniformly takes one of the pairs. If Furik doesn't have any pair to take, he tosses a coin one more time. The game ends when the permutation is sorted in the increasing order.Jeff wants the game to finish as quickly as possible (that is, he wants both players to make as few moves as possible). Help Jeff find the minimum mathematical expectation of the number of moves in the game if he moves optimally well.You can consider that the coin shows the heads (or tails) with the probability of 50 percent.","#!/usr/bin/python3

import sys

class CumTree:
    
    def __init__(self, a, b):
        self.a = a
        self.b = b
        self.count = 0
        if a == b:
            return
        mid = (a + b) // 2
        self.levo = CumTree(a, mid)
        self.desno = CumTree(mid+1, b)
        
    def manjsi(self, t):
        if self.a >= t:
            return 0
        if self.b < t:
            return self.count
        return self.levo.manjsi(t) + self.desno.manjsi(t)
    
    def vstavi(self, t):
        if self.a <= t <= self.b:
            self.count += 1
            if self.a == self.b:
                return
            self.levo.vstavi(t)
            self.desno.vstavi(t)
        
n = int(sys.stdin.readline())
p = [int(x) for x in sys.stdin.readline().strip().split()]

ct = CumTree(1, 4096)

vsota = 0
while len(p) > 0:
    x = p.pop()
    vsota += ct.manjsi(x)
    ct.vstavi(x)

k, d = vsota // 2, vsota % 2
print(""%f"" % (4*k + d))","['dp', 'combinatorics', 'probabilities']"
"Many years ago Berland was a small country where only $$$n$$$ people lived. Each person had some savings: the $$$i$$$-th one had $$$a_i$$$ burles.The government considered a person as wealthy if he had at least $$$x$$$ burles. To increase the number of wealthy people Berland decided to carry out several reforms. Each reform looked like that:   the government chooses some subset of people (maybe all of them);  the government takes all savings from the chosen people and redistributes the savings among the chosen people equally. For example, consider the savings as list $$$[5, 1, 2, 1]$$$: if the government chose the $$$1$$$-st and the $$$3$$$-rd persons then it, at first, will take all $$$5 + 2 = 7$$$ burles and after that will return $$$3.5$$$ burles to the chosen people. As a result, the savings will become $$$[3.5, 1, 3.5, 1]$$$.A lot of data was lost from that time, so we don't know how many reforms were implemented and to whom. All we can do is ask you to calculate the maximum possible number of wealthy people after several (maybe zero) reforms.","for _ in range(int(input())):
	a,b = map(int,input().split())
	arr = list(map(int,input().split()))
	arr.sort()
	k = 0
	summ = sum(arr)
	for i in range(a):
		if k ==0:
			if i>0:
				summ -= arr[i-1]
				if (summ)//(a-i) >= b:
					print(a-i)
					k = 1
			else:
				if summ//a >= b:
					print(a)
					k = 1
	if k==0:
		if max(arr) >= b:
			k =1
			print(1)
	if k==0:
		print(0)","['sortings', 'greedy']"
"You are given a rectangular matrix of size $$$n \times m$$$ consisting of integers from $$$1$$$ to $$$2 \cdot 10^5$$$.In one move, you can:  choose any element of the matrix and change its value to any integer between $$$1$$$ and $$$n \cdot m$$$, inclusive;  take any column and shift it one cell up cyclically (see the example of such cyclic shift below). A cyclic shift is an operation such that you choose some $$$j$$$ ($$$1 \le j \le m$$$) and set $$$a_{1, j} := a_{2, j}, a_{2, j} := a_{3, j}, \dots, a_{n, j} := a_{1, j}$$$ simultaneously.  Example of cyclic shift of the first column You want to perform the minimum number of moves to make this matrix look like this:  In other words, the goal is to obtain the matrix, where $$$a_{1, 1} = 1, a_{1, 2} = 2, \dots, a_{1, m} = m, a_{2, 1} = m + 1, a_{2, 2} = m + 2, \dots, a_{n, m} = n \cdot m$$$ (i.e. $$$a_{i, j} = (i - 1) \cdot m + j$$$) with the minimum number of moves performed.","import sys
input = sys.stdin.readline
from collections import *

n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
ans = 0

for i in range(m):
    l = [i+1]
    
    for _ in range(n-1):
        l.append(l[-1]+m)
    
    s = set(l)
    idx = defaultdict(int)
    
    for j in range(n):
        idx[l[j]] = j
        
    cnt = [n]*n
    
    for j in range(n):
        if a[j][i] in s:
            move = (j-idx[a[j][i]])%n
            cnt[move] -= 1
    
    mi = 10**18
    
    for j in range(n):
        mi = min(mi, j+cnt[j])
    
    ans += mi

print(ans)","['implementation', 'greedy', 'math']"
"Johnny has recently found an ancient, broken computer. The machine has only one register, which allows one to put in there one variable. Then in one operation, you can shift its bits left or right by at most three positions. The right shift is forbidden if it cuts off some ones. So, in fact, in one operation, you can multiply or divide your number by $$$2$$$, $$$4$$$ or $$$8$$$, and division is only allowed if the number is divisible by the chosen divisor. Formally, if the register contains a positive integer $$$x$$$, in one operation it can be replaced by one of the following:   $$$x \cdot 2$$$  $$$x \cdot 4$$$  $$$x \cdot 8$$$  $$$x / 2$$$, if $$$x$$$ is divisible by $$$2$$$  $$$x / 4$$$, if $$$x$$$ is divisible by $$$4$$$  $$$x / 8$$$, if $$$x$$$ is divisible by $$$8$$$ For example, if $$$x = 6$$$, in one operation it can be replaced by $$$12$$$, $$$24$$$, $$$48$$$ or $$$3$$$. Value $$$6$$$ isn't divisible by $$$4$$$ or $$$8$$$, so there're only four variants of replacement.Now Johnny wonders how many operations he needs to perform if he puts $$$a$$$ in the register and wants to get $$$b$$$ at the end.","from sys import stdin
from sys import stdout
from math import *

sprint = stdout.write
sinput = stdin.readline

#[int(x) for x in sinput().split()]
#int(sinput())


def func():
    a , b = [int(x) for x in sinput().split()]
    a , b = sorted([a,b])
    #if log(b//a)/log(2)-log(b//a)//log(2) != 0 and b != a:
    if b%a == 0 and log(b//a)/log(2)-int(log(b//a)/log(2)) < 0.0001 and 2**int(log(b//a)/log(2)) == b//a:
        a = log(b//a)/log(2)            #40
        b = a//3            #13
        a = a-(a//3)*3      #1
        b += a//2           #13
        a = a-(a//2)*2
        b += a
        print(int(b))

    else :
        print(-1)
        return


if __name__ == ""__main__"":
    t = int(sinput())
    while t != 0:
        if t == 1000-84+1+t:
            a, b = [int(x) for x in sinput().split()]
            print(b,end=' ')
            print(b)
            t -= 1
        else:
            t -= 1
            func()",['implementation']
"Magnus decided to play a classic chess game. Though what he saw in his locker shocked him! His favourite chessboard got broken into 4 pieces, each of size n by n, n is always odd. And what's even worse, some squares were of wrong color. j-th square of the i-th row of k-th piece of the board has color ak, i, j; 1 being black and 0 being white. Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard. Every square has its color different to each of the neightbouring by side squares in a valid board. Its size should be 2n by 2n. You are allowed to move pieces but not allowed to rotate or flip them.","n = input()
a = [[], [], [], []]
for k in range(4):
    for j in range(n):
        a[k].append(raw_input())
    if k < 3: raw_input()

c = [0, 0, 0, 0]
for k in range(4):
    for i in range(n):
        for j in range(n):
            if (i * n + j) % 2 == 0:
                c[k] += int(a[k][i][j])
            else:
                c[k] += 1 - int(a[k][i][j])

c.sort()
c[2] = n * n - c[2]
c[3] = n * n - c[3]
print sum(c)","['implementation', 'bitmasks', 'brute force']"
"A card pyramid of height $$$1$$$ is constructed by resting two cards against each other. For $$$h&gt;1$$$, a card pyramid of height $$$h$$$ is constructed by placing a card pyramid of height $$$h-1$$$ onto a base. A base consists of $$$h$$$ pyramids of height $$$1$$$, and $$$h-1$$$ cards on top. For example, card pyramids of heights $$$1$$$, $$$2$$$, and $$$3$$$ look as follows:  You start with $$$n$$$ cards and build the tallest pyramid that you can. If there are some cards remaining, you build the tallest pyramid possible with the remaining cards. You repeat this process until it is impossible to build another pyramid. In the end, how many pyramids will you have constructed?","def p(n):
    h=(-1+(1+24*n)**0.5)/6
    return int(h)
t=int(input())
for i in range(t):
    c=0
    n=int(input())
    while n>1:
        x=p(n)
        c+=1
        n-=(3*x*x+x)/2
    print(c)","['dp', 'binary search', 'brute force', 'math']"
"The research center Q has developed a new multi-core processor. The processor consists of n cores and has k cells of cache memory. Consider the work of this processor.At each cycle each core of the processor gets one instruction: either do nothing, or the number of the memory cell (the core will write an information to the cell). After receiving the command, the core executes it immediately. Sometimes it happens that at one cycle, multiple cores try to write the information into a single cell. Unfortunately, the developers did not foresee the possibility of resolving conflicts between cores, so in this case there is a deadlock: all these cores and the corresponding memory cell are locked forever. Each of the locked cores ignores all further commands, and no core in the future will be able to record an information into the locked cell. If any of the cores tries to write an information into some locked cell, it is immediately locked.The development team wants to explore the deadlock situation. Therefore, they need a program that will simulate the processor for a given set of instructions for each core within m cycles . You're lucky, this interesting work is entrusted to you. According to the instructions, during the m cycles define for each core the number of the cycle, during which it will become locked. It is believed that initially all cores and all memory cells are not locked.","n, m, k = map(int, input().split())
cores = [1 for i in range(n)]
cells = [1 for i in range(k)]
info = []
blockings = [0 for i in range(n)]
for i in range(n):
    k = list(map(int, input().split()))
    for j in range(len(k)):
        k[j] -= 1
    info.append(k)
for i in range(m):
    for j in range(n):
        if cores[j] == 0:
            continue
        cell = info[j][i]
        if cell == -1:
            continue
        if cells[cell] == 0:
            cores[j] = 0
            blockings[j] = i + 1
            continue
        for core in range(n):
            if core != j:
                cell_1 = info[core][i]
                if cell_1 == cell and blockings[core] == 0:
                    cells[cell] = 0
                    cores[j] = 0
                    blockings[j] = i + 1
                    break
for elem in blockings:
    print(elem)",['implementation']
"Little Petya loves inequations. Help him find n positive integers a1, a2, ..., an, such that the following two conditions are satisfied: a12 + a22 + ... + an2 ≥ x a1 + a2 + ... + an ≤ y","n,x,y=map(int, input().split())
if n>y:
    print(-1)
else:
    z=y-(n-1)
    if z**2 + (n-1)<x:
        print(-1)
    else:
    	for i in range(n-1):
    		print(1)
    	print(z)","['greedy', 'math']"
"Soon after the Chunga-Changa island was discovered, it started to acquire some forms of civilization and even market economy. A new currency arose, colloquially called ""chizhik"". One has to pay in chizhiks to buy a coconut now.Sasha and Masha are about to buy some coconuts which are sold at price $$$z$$$ chizhiks per coconut. Sasha has $$$x$$$ chizhiks, Masha has $$$y$$$ chizhiks. Each girl will buy as many coconuts as she can using only her money. This way each girl will buy an integer non-negative number of coconuts.The girls discussed their plans and found that the total number of coconuts they buy can increase (or decrease) if one of them gives several chizhiks to the other girl. The chizhiks can't be split in parts, so the girls can only exchange with integer number of chizhiks.Consider the following example. Suppose Sasha has $$$5$$$ chizhiks, Masha has $$$4$$$ chizhiks, and the price for one coconut be $$$3$$$ chizhiks. If the girls don't exchange with chizhiks, they will buy $$$1 + 1 = 2$$$ coconuts. However, if, for example, Masha gives Sasha one chizhik, then Sasha will have $$$6$$$ chizhiks, Masha will have $$$3$$$ chizhiks, and the girls will buy $$$2 + 1 = 3$$$ coconuts. It is not that easy to live on the island now, so Sasha and Mash want to exchange with chizhiks in such a way that they will buy the maximum possible number of coconuts. Nobody wants to have a debt, so among all possible ways to buy the maximum possible number of coconuts find such a way that minimizes the number of chizhiks one girl gives to the other (it is not important who will be the person giving the chizhiks).","x , y , p = map(int,input().split())

mxbought = (x + y) // p

minigave = min(p - (x % p) , p - (y % p))

print(mxbought , end = ' ')

x = x % p
y = y % p

if x + y >= p :
    print(p - max(x , y))
else:
    print(0)","['greedy', 'math']"
"Oleg the bank client checks share prices every day. There are n share prices he is interested in. Today he observed that each second exactly one of these prices decreases by k rubles (note that each second exactly one price changes, but at different seconds different prices can change). Prices can become negative. Oleg found this process interesting, and he asked Igor the financial analyst, what is the minimum time needed for all n prices to become equal, or it is impossible at all? Igor is busy right now, so he asked you to help Oleg. Can you answer this question?","from sys import stdin
n,k = map(int,stdin.readline().split())
def gcd(a,b):
 while a%b:
  t = a%b; a = b; b = t
 return b
a = map(int,stdin.readline().split())
a.sort()
g = a[0]
for i in a:
 g = gcd(g,i)
ans = -1
a.reverse()
b = set()
for i in a:
 b.add(i%k)
if len(b)==1:
 ans = 0
 for i in a:
  ans += (i - a[-1])/k
if n==1:
 ans = 0
print ans","['implementation', 'math']"
"Recently you have bought a snow walking robot and brought it home. Suppose your home is a cell $$$(0, 0)$$$ on an infinite grid.You also have the sequence of instructions of this robot. It is written as the string $$$s$$$ consisting of characters 'L', 'R', 'U' and 'D'. If the robot is in the cell $$$(x, y)$$$ right now, he can move to one of the adjacent cells (depending on the current instruction).  If the current instruction is 'L', then the robot can move to the left to $$$(x - 1, y)$$$;  if the current instruction is 'R', then the robot can move to the right to $$$(x + 1, y)$$$;  if the current instruction is 'U', then the robot can move to the top to $$$(x, y + 1)$$$;  if the current instruction is 'D', then the robot can move to the bottom to $$$(x, y - 1)$$$. You've noticed the warning on the last page of the manual: if the robot visits some cell (except $$$(0, 0)$$$) twice then it breaks.So the sequence of instructions is valid if the robot starts in the cell $$$(0, 0)$$$, performs the given instructions, visits no cell other than $$$(0, 0)$$$ two or more times and ends the path in the cell $$$(0, 0)$$$. Also cell $$$(0, 0)$$$ should be visited at most two times: at the beginning and at the end (if the path is empty then it is visited only once). For example, the following sequences of instructions are considered valid: ""UD"", ""RL"", ""UUURULLDDDDLDDRRUU"", and the following are considered invalid: ""U"" (the endpoint is not $$$(0, 0)$$$) and ""UUDD"" (the cell $$$(0, 1)$$$ is visited twice).The initial sequence of instructions, however, might be not valid. You don't want your robot to break so you decided to reprogram it in the following way: you will remove some (possibly, all or none) instructions from the initial sequence of instructions, then rearrange the remaining instructions as you wish and turn on your robot to move. Your task is to remove as few instructions from the initial sequence as possible and rearrange the remaining ones so that the sequence is valid. Report the valid sequence of the maximum length you can obtain.Note that you can choose any order of remaining instructions (you don't need to minimize the number of swaps or any other similar metric).You have to answer $$$q$$$ independent test cases.","from sys import stdin, stdout
for i in range(int(input())):
  s = stdin.readline()
  r = s.count('R')
  u = s.count('U')
  l = s.count('L')
  d = s.count('D')
  
  r = l = min(r,l)
  u = d = min(u,d)

  if r == u == 0:
    stdout.write('0\n')
  elif r == 0 or u == 0:
    stdout.write('2\n')
    stdout.write('%s\n' % ('UD' if r == 0 else 'RL'))
  else:
    stdout.write('%d\n' % ((r+u)<<1))
    s = ['R' for i in range(r)] + ['U' for i in range(u)] + ['L' for i in range(l)] + ['D' for i in range(d)]
    stdout.write(''.join(s))
  stdout.write('\n')","['constructive algorithms', 'implementation', 'greedy']"
"Karlsson has recently discovered a huge stock of berry jam jars in the basement of the house. More specifically, there were $$$2n$$$ jars of strawberry and blueberry jam.All the $$$2n$$$ jars are arranged in a row. The stairs to the basement are exactly in the middle of that row. So when Karlsson enters the basement, he sees exactly $$$n$$$ jars to his left and $$$n$$$ jars to his right.For example, the basement might look like this:  Being the starightforward man he is, he immediately starts eating the jam. In one minute he chooses to empty either the first non-empty jar to his left or the first non-empty jar to his right.Finally, Karlsson decided that at the end the amount of full strawberry and blueberry jam jars should become the same.For example, this might be the result:  He has eaten $$$1$$$ jar to his left and then $$$5$$$ jars to his right. There remained exactly $$$3$$$ full jars of both strawberry and blueberry jam. Jars are numbered from $$$1$$$ to $$$2n$$$ from left to right, so Karlsson initially stands between jars $$$n$$$ and $$$n+1$$$.What is the minimum number of jars Karlsson is required to empty so that an equal number of full strawberry and blueberry jam jars is left?Your program should answer $$$t$$$ independent test cases.","from collections import defaultdict
for t in range(int(input())):
	n = int(input())
	l = [int(j) for j in input().split()]
	dl = defaultdict(lambda: 1e12)
	dr = defaultdict(lambda: 1e12)
	ct1 = l.count(1)
	ct2 = l.count(2)
	delta = abs(ct1-ct2)
	if ct1>ct2:
		se = 2
	else:
		se = 1
	if ct1==ct2:
		print(0)
		continue	
	ct = 0 
	for i in range(n, 2*n):
		if l[i]==se:
			ct-=1
			dr[ct] = min(dr[ct], i-n+1)
		else:
			ct+=1
			dr[ct] = min(dr[ct], i-n+1)
	ct = 0
	for i in range(n-1, -1, -1):
		if l[i]==se:
			ct-=1
			dl[ct] = min(dl[ct], n-i)
		else:
			ct+=1
			dl[ct] = min(dl[ct], n-i)
		# if l[i]==se:
		# 	ct+=1
		# 	dl[ct] = n-i
	ans = 2*n
	dl[0] = 0
	dr[0] = 0
	# print(dl, dr, delta, se)
	for i in range(delta+1):
		ans = min(ans, dl[i]+dr[delta-i])

	print(ans)","['dp', 'implementation', 'greedy', 'data structures']"
"The round carousel consists of $$$n$$$ figures of animals. Figures are numbered from $$$1$$$ to $$$n$$$ in order of the carousel moving. Thus, after the $$$n$$$-th figure the figure with the number $$$1$$$ follows. Each figure has its own type — the type of the animal corresponding to this figure (the horse, the tiger and so on). The type of animal of the $$$i$$$-th figure equals $$$t_i$$$.    The example of the carousel for $$$n=9$$$ and $$$t=[5, 5, 1, 15, 1, 5, 5, 1, 1]$$$. You want to color each figure in one of the colors. You think that it's boring if the carousel contains two different figures (with the distinct types of animals) going one right after another and colored in the same color.Your task is to color the figures in such a way that the number of distinct colors used is the minimum possible and there are no figures of the different types going one right after another and colored in the same color. If you use exactly $$$k$$$ distinct colors, then the colors of figures should be denoted with integers from $$$1$$$ to $$$k$$$.","from __future__ import division, print_function
import sys 
# sys.setrecursionlimit(10**6) 
from sys import stdin, stdout
import bisect            #c++ upperbound
import math
import heapq
def modinv(n,p):
    return pow(n,p-2,p)
def cin():
    return map(int,sin().split())
def ain():                           #takes array as input
    return list(map(int,sin().split()))
def sin():
    return input()
def inin():
    return int(input())
import math  
def Divisors(n) : 
    l = []  
    for i in range(1, int(math.sqrt(n) + 1)) :
        if (n % i == 0) : 
            if (n // i == i) : 
                l.append(i) 
            else : 
                l.append(i)
                l.append(n//i)
    return l

""""""*******************************************************""""""
def main():
    t=inin()
    for _ in range(t):
        x=0
        n=inin()
        a=ain()
        d={}
        x=0
        b=[]
        b.append(0)
        l=-1
        f=1
        for i in range(1,n):
            if(a[i]!=a[i-1]):
                x+=1
                f=2
                x=x%2
            else:
                if(l==-1):
                    l=i
            b.append(x)
        if(a[n-1]!=a[0]):
            if(b[n-1]==b[0]):
                # print(l)
                if(l==-1):
                    b[n-1]=2
                    f=3
                else:
                    b[l]=(b[l]+1)%2
                    x=b[l]
                    for j in range(l+1,n):
                        # print(a[j],a[j-1],x)
                        if(a[j]!=a[j-1]):
                            x+=1
                            x=x%2
                        # print(x)
                        b[j]=x

        for i in range(n):
            b[i]=b[i]+1
        print(f)
        print(*b)



######## Python 2 and 3 footer by Pajenegod and c1729
 
# Note because cf runs old PyPy3 version which doesn't have the sped up
# unicode strings, PyPy3 strings will many times be slower than pypy2.
# There is a way to get around this by using binary strings in PyPy3
# but its syntax is different which makes it kind of a mess to use.
 
# So on cf, use PyPy2 for best string performance.
 
py2 = round(0.5)
if py2:
    from future_builtins import ascii, filter, hex, map, oct, zip
    range = xrange
 
import os, sys
from io import IOBase, BytesIO
 
BUFSIZE = 8192
class FastIO(BytesIO):
    newlines = 0
 
    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None
 
    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])
        return s
 
    def read(self):
        while self._fill(): pass
        return super(FastIO,self).read()
 
    def readline(self):
        while self.newlines == 0:
            s = self._fill(); self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s:self.buffer.write(s.encode('ascii'))
            self.read = lambda:self.buffer.read().decode('ascii')
            self.readline = lambda:self.buffer.readline().decode('ascii')
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')
 
# Cout implemented in Python
import sys
class ostream:
    def __lshift__(self,a):
        sys.stdout.write(str(a))
        return self
cout = ostream()
endl = '\n'
 
# Read all remaining integers in stdin, type is given by optional argument, this is fast
def readnumbers(zero = 0):
    conv = ord if py2 else lambda x:x
    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()
    try:
        while True:
            if s[i] >= b'0' [0]:
                numb = 10 * numb + conv(s[i]) - 48
            elif s[i] == b'-' [0]: sign = -1
            elif s[i] != b'\r' [0]:
                A.append(sign*numb)
                numb = zero; sign = 1
            i += 1
    except:pass
    if s and s[-1] >= b'0' [0]:
        A.append(sign*numb)
    return A
 
if __name__== ""__main__"":
  main()","['dp', 'greedy', 'graphs', 'constructive algorithms', 'math']"
"A permutation of length $$$n$$$ is a sequence of integers from $$$1$$$ to $$$n$$$ of length $$$n$$$ containing each number exactly once. For example, $$$[1]$$$, $$$[4, 3, 5, 1, 2]$$$, $$$[3, 2, 1]$$$ are permutations, and $$$[1, 1]$$$, $$$[0, 1]$$$, $$$[2, 2, 1, 4]$$$ are not.There was a permutation $$$p[1 \dots n]$$$. It was merged with itself. In other words, let's take two instances of $$$p$$$ and insert elements of the second $$$p$$$ into the first maintaining relative order of elements. The result is a sequence of the length $$$2n$$$.For example, if $$$p=[3, 1, 2]$$$ some possible results are: $$$[3, 1, 2, 3, 1, 2]$$$, $$$[3, 3, 1, 1, 2, 2]$$$, $$$[3, 1, 3, 1, 2, 2]$$$. The following sequences are not possible results of a merging: $$$[1, 3, 2, 1, 2, 3$$$], [$$$3, 1, 2, 3, 2, 1]$$$, $$$[3, 3, 1, 2, 2, 1]$$$.For example, if $$$p=[2, 1]$$$ the possible results are: $$$[2, 2, 1, 1]$$$, $$$[2, 1, 2, 1]$$$. The following sequences are not possible results of a merging: $$$[1, 1, 2, 2$$$], [$$$2, 1, 1, 2]$$$, $$$[1, 2, 2, 1]$$$.Your task is to restore the permutation $$$p$$$ by the given resulting sequence $$$a$$$. It is guaranteed that the answer exists and is unique.You have to answer $$$t$$$ independent test cases.","n=int(input())
for _ in range(n):
    m=int(input())
    ar=list(map(int,input().split()))
    x=[]
    for i in ar:
        if i not in x:
            x.append(i)
    p=len(x)
    for i in range(p):
        print(x[i],end=' ')",['greedy']
"Petya and Vasya are competing with each other in a new interesting game as they always do.At the beginning of the game Petya has to come up with an array of $$$N$$$ positive integers. Sum of all elements in his array should be equal to $$$S$$$. Then Petya has to select an integer $$$K$$$ such that $$$0 \leq K \leq S$$$.In order to win, Vasya has to find a non-empty subarray in Petya's array such that the sum of all selected elements equals to either $$$K$$$ or $$$S - K$$$. Otherwise Vasya loses.You are given integers $$$N$$$ and $$$S$$$. You should determine if Petya can win, considering Vasya plays optimally. If Petya can win, help him to do that.","n,s = list(map(int,input().split()))

val = s//n
rem = s%n

v1 = val
v2 = val+rem
if v1>1:
    print('YES')
    for i in range(0,n-1):
        print(v1,end="" "")
    print(v2)
    print(1)
else:
    print('NO')","['constructive algorithms', 'math']"
"You are given two positive integers $$$n$$$ ($$$1 \le n \le 10^9$$$) and $$$k$$$ ($$$1 \le k \le 100$$$). Represent the number $$$n$$$ as the sum of $$$k$$$ positive integers of the same parity (have the same remainder when divided by $$$2$$$).In other words, find $$$a_1, a_2, \ldots, a_k$$$ such that all $$$a_i&gt;0$$$, $$$n = a_1 + a_2 + \ldots + a_k$$$ and either all $$$a_i$$$ are even or all $$$a_i$$$ are odd at the same time.If such a representation does not exist, then report it.","t = input()
t = int(t)
while t > 0 :
    line = input()
    i = line.split()
    x = int(i[0])
    y = int(i[1])
    o = x - (y-1)
    if o%2==1 and o>0 :
        print('YES')
        for j in range(y-1) :
            print('1', end = "" "")
        print(o)
        t = t-1
        continue
    e = x - (y-1)*2
    if e%2==0 and e>0 :
        print('YES')
        for j in range(y-1) :
            print(""2"", end = "" "")
        print(e)
    else :
        print(""NO"")
    t = t - 1","['constructive algorithms', 'math']"
"There is a bus stop near the university. The lessons are over, and n students come to the stop. The i-th student will appear at the bus stop at time ti (all ti's are distinct).We shall assume that the stop is located on the coordinate axis Ox, at point x = 0, and the bus goes along the ray Ox, that is, towards the positive direction of the coordinate axis, and back. The i-th student needs to get to the point with coordinate xi (xi &gt; 0).The bus moves by the following algorithm. Initially it is at point 0. The students consistently come to the stop and get on it. The bus has a seating capacity which is equal to m passengers. At the moment when m students get on the bus, it starts moving in the positive direction of the coordinate axis. Also it starts moving when the last (n-th) student gets on the bus. The bus is moving at a speed of 1 unit of distance per 1 unit of time, i.e. it covers distance y in time y.Every time the bus passes the point at which at least one student needs to get off, it stops and these students get off the bus. The students need 1 + [k / 2] units of time to get off the bus, where k is the number of students who leave at this point. Expression [k / 2] denotes rounded down k / 2. As soon as the last student leaves the bus, the bus turns around and goes back to the point x = 0. It doesn't make any stops until it reaches the point. At the given point the bus fills with students once more, and everything is repeated.If students come to the stop when there's no bus, they form a line (queue) and get on the bus in the order in which they came. Any number of students get on the bus in negligible time, you should assume that it doesn't take any time. Any other actions also take no time. The bus has no other passengers apart from the students.Write a program that will determine for each student the time when he got off the bus. The moment a student got off the bus is the moment the bus stopped at the student's destination stop (despite the fact that the group of students need some time to get off).","def trip(start, dat):
    outx = [[i, dat[i]] for i in range(len(dat))]
    outx.sort(key=lambda value: value[1])
    cur_t, cur_x, i, n, delay = start, 0, 0, len(outx), 0
    outtime = range(n)
    while i < n:
        cur_x = outx[i][1]
        num = 0
        while i < n and cur_x == outx[i][1]:
            cur_t = start + outx[i][1] + delay
            outtime[outx[i][0]] = cur_t
            num += 1
            i += 1
        delay += 1 +  num / 2
    print "" "".join(map(str,outtime)) ,
    return start + cur_x * 2 + delay

reader=lambda:map(int,raw_input().split())
n, m = reader()
i, cur_t = m, 0
while i < n:
    j = 0
    dat = []
    while j < m:
        dat_t, dat_x = reader()
        dat.append(dat_x)
        j += 1
    if dat_t < cur_t:
        cur_t = trip(cur_t, dat)
    else:
        cur_t = trip(dat_t, dat)
    i += m
#last trip
i -= m
dat = []
while i < n:
    dat_t, dat_x = reader()
    dat.append(dat_x)
    i += 1
if dat_t < cur_t:
    cur_t = trip(cur_t, dat)
else:
    cur_t = trip(dat_t, dat)","['sortings', 'implementation', '*special']"
"Ivan plays an old action game called Heretic. He's stuck on one of the final levels of this game, so he needs some help with killing the monsters.The main part of the level is a large corridor (so large and narrow that it can be represented as an infinite coordinate line). The corridor is divided into two parts; let's assume that the point $$$x = 0$$$ is where these parts meet.The right part of the corridor is filled with $$$n$$$ monsters — for each monster, its initial coordinate $$$x_i$$$ is given (and since all monsters are in the right part, every $$$x_i$$$ is positive).The left part of the corridor is filled with crusher traps. If some monster enters the left part of the corridor or the origin (so, its current coordinate becomes less than or equal to $$$0$$$), it gets instantly killed by a trap.The main weapon Ivan uses to kill the monsters is the Phoenix Rod. It can launch a missile that explodes upon impact, obliterating every monster caught in the explosion and throwing all other monsters away from the epicenter. Formally, suppose that Ivan launches a missile so that it explodes in the point $$$c$$$. Then every monster is either killed by explosion or pushed away. Let some monster's current coordinate be $$$y$$$, then:  if $$$c = y$$$, then the monster is killed;  if $$$y &lt; c$$$, then the monster is pushed $$$r$$$ units to the left, so its current coordinate becomes $$$y - r$$$;  if $$$y &gt; c$$$, then the monster is pushed $$$r$$$ units to the right, so its current coordinate becomes $$$y + r$$$. Ivan is going to kill the monsters as follows: choose some integer point $$$d$$$ and launch a missile into that point, then wait until it explodes and all the monsters which are pushed to the left part of the corridor are killed by crusher traps, then, if at least one monster is still alive, choose another integer point (probably the one that was already used) and launch a missile there, and so on.What is the minimum number of missiles Ivan has to launch in order to kill all of the monsters? You may assume that every time Ivan fires the Phoenix Rod, he chooses the impact point optimally.You have to answer $$$q$$$ independent queries.","from __future__ import division, print_function
import bisect
import math
import heapq
import itertools
import sys
from collections import deque
from atexit import register
from collections import Counter
from functools import reduce
sys.setrecursionlimit(10000000)
if sys.version_info[0] < 3:
    from io import BytesIO as stream
else:
    from io import StringIO as stream
 
 
if sys.version_info[0] < 3:
    class dict(dict):
        """"""dict() -> new empty dictionary""""""
        def items(self):
            """"""D.items() -> a set-like object providing a view on D's items""""""
            return dict.iteritems(self)
 
        def keys(self):
            """"""D.keys() -> a set-like object providing a view on D's keys""""""
            return dict.iterkeys(self)
 
        def values(self):
            """"""D.values() -> an object providing a view on D's values""""""
            return dict.itervalues(self)
 
    input = raw_input
    range = xrange
 
    filter = itertools.ifilter
    map = itertools.imap
    zip = itertools.izip
 
 
def sync_with_stdio(sync=True):
    """"""Set whether the standard Python streams are allowed to buffer their I/O.
 
    Args:
        sync (bool, optional): The new synchronization setting.
 
    """"""
    global input, flush
 
    if sync:
        flush = sys.stdout.flush
    else:
        sys.stdin = stream(sys.stdin.read())
        input = lambda: sys.stdin.readline().rstrip('\r\n')
 
        sys.stdout = stream()
        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))

def main():

    for _ in range(int(input())):
        n,r=map(int,input().split())
        x=[int(o) for o in input().split()]
        a=sorted(list(set(x)))
        a=a[::-1]
        ci=0
        sh=0
        for i in range(len(a)):
            if a[i]-ci>0:
                sh+=1
                ci+=r
        print(sh)


if __name__ == '__main__':
    sync_with_stdio(False)
    main()","['sortings', 'greedy']"
"Overall there are m actors in Berland. Each actor has a personal identifier — an integer from 1 to m (distinct actors have distinct identifiers). Vasya likes to watch Berland movies with Berland actors, and he has k favorite actors. He watched the movie trailers for the next month and wrote the following information for every movie: the movie title, the number of actors who starred in it, and the identifiers of these actors. Besides, he managed to copy the movie titles and how many actors starred there, but he didn't manage to write down the identifiers of some actors. Vasya looks at his records and wonders which movies may be his favourite, and which ones may not be. Once Vasya learns the exact cast of all movies, his favorite movies will be determined as follows: a movie becomes favorite movie, if no other movie from Vasya's list has more favorite actors.Help the boy to determine the following for each movie: whether it surely will be his favourite movie; whether it surely won't be his favourite movie;  can either be favourite or not.","def main():
    file = open(""input.txt"")
    file_o = open(""output.txt"", 'w')
    m, k = map(int, file.readline().split())
    fvr = set(map(int, file.readline().split()))
    n = int(file.readline())
    img_cnt = []
    act_cnt = []
    sur_frv_cut = 0
    sur_frv_cut_sec = 0
    sur_not_cut = 0
    for _ in range(n):
        name = file.readline()
        d = int(file.readline())
        ds = map(int, file.readline().split())
        f = 0
        nf = 0
        for num in ds:
            if num in fvr:
                f = f + 1
            elif num != 0:
                nf = nf + 1
        img = d - nf
        if img > k: img = k
        act = d - (m - k)
        if act < f: act = f

        img_cnt.append(img)
        act_cnt.append(act)

        if img > sur_frv_cut:
            sur_frv_cut_sec = sur_frv_cut
            sur_frv_cut = img
        elif img > sur_frv_cut_sec:
            sur_frv_cut_sec = img

        if act > sur_not_cut:
            sur_not_cut = act

    for i in range(n):

        if act_cnt[i] >= sur_frv_cut or (act_cnt[i] >= sur_frv_cut_sec and img_cnt[i] >= sur_frv_cut): file_o.write(""0\n"")
        elif img_cnt[i] < sur_not_cut: file_o.write(""1\n"")
        else: file_o.write(""2\n"")

    file_o.close()

main()",['implementation']
"You may have already known that a standard ICPC team consists of exactly three members. The perfect team however has more restrictions. A student can have some specialization: coder or mathematician. She/he can have no specialization, but can't have both at the same time.So the team is considered perfect if it includes at least one coder, at least one mathematician and it consists of exactly three members.You are a coach at a very large university and you know that $$$c$$$ of your students are coders, $$$m$$$ are mathematicians and $$$x$$$ have no specialization.What is the maximum number of full perfect teams you can distribute them into? Note that some students can be left without a team and each student can be a part of no more than one team.You are also asked to answer $$$q$$$ independent queries.","#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8


def numTeam(c, m, x):
    cmMin = min(c, m)

    # max(c,m) >= x >= min(c,m): Somente min(c,n) times com 1 de cada
    if x >= cmMin:
        return cmMin
    # max(c,m) >= min(c,m) > x: Times podem ter 2 c ou 2 m
    else:
        return min((c+m+x)//3, cmMin)
        # times = x
        # a, b = max(c-x, m-x), min(c-x, m-x)
        # while(True):
        #     b -= 1
        #     a -= 2
        #     if b >= 0 and a >= 0:
        #         times += 1
        #         a, b = max(a, b), min(a, b)
        #     else:
        #         break
        # return times


for i in range(int(input())):
    coder, mathMan, normalMan = map(int, input().split())
    print(numTeam(coder, mathMan, normalMan))","['binary search', 'math']"
"You are given a functional graph. It is a directed graph, in which from each vertex goes exactly one arc. The vertices are numerated from 0 to n - 1.Graph is given as the array f0, f1, ..., fn - 1, where fi — the number of vertex to which goes the only arc from the vertex i. Besides you are given array with weights of the arcs w0, w1, ..., wn - 1, where wi — the arc weight from i to fi.    The graph from the first sample test. Also you are given the integer k (the length of the path) and you need to find for each vertex two numbers si and mi, where:  si — the sum of the weights of all arcs of the path with length equals to k which starts from the vertex i;  mi — the minimal weight from all arcs on the path with length k which starts from the vertex i. The length of the path is the number of arcs on this path.","import sys
n, k = map(int, sys.stdin.buffer.readline().decode('utf-8').split())
a = list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))
b = list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))

logk = len(bin(k)) - 2
sum_w, sum_w_p = b[:], b[:]
min_w, min_w_p = b[:], b[:]
dest, dest_p = a[:], a[:]

ans_sum, ans_min, pos = [0]*n, b[:], list(range(n))
if k & 1:
    ans_sum = b[:]
    pos = [a[i] for i in range(n)]
k >>= 1

for j in range(1, logk):
    for i in range(n):
        d = dest[i]
        p = 0 if d > i else 1
        dest_p[i] = d
        dest[i] = (dest_p if p else dest)[d]
        sum_w_p[i] = sum_w[i]
        sum_w[i] += (sum_w_p if p else sum_w)[d]
        min_w_p[i] = min_w[i]
        if min_w[i] > (min_w_p if p else min_w)[d]:
            min_w[i] = (min_w_p if p else min_w)[d]

    if k & 1:
        for i in range(n):
            ans_sum[i] += sum_w[pos[i]]
            if ans_min[i] > min_w[pos[i]]:
                ans_min[i] = min_w[pos[i]]
            pos[i] = dest[pos[i]]
    k >>= 1


sys.stdout.buffer.write('\n'.join(
    (str(ans_sum[i]) + ' ' + str(ans_min[i]) for i in range(n))).encode('utf-8'))","['data structures', 'graphs']"
"Vasya got really tired of these credits (from problem F) and now wants to earn the money himself! He decided to make a contest to gain a profit.Vasya has $$$n$$$ problems to choose from. They are numbered from $$$1$$$ to $$$n$$$. The difficulty of the $$$i$$$-th problem is $$$d_i$$$. Moreover, the problems are given in the increasing order by their difficulties. The difficulties of all tasks are pairwise distinct. In order to add the $$$i$$$-th problem to the contest you need to pay $$$c_i$$$ burles to its author. For each problem in the contest Vasya gets $$$a$$$ burles.In order to create a contest he needs to choose a consecutive subsegment of tasks.So the total earnings for the contest are calculated as follows:   if Vasya takes problem $$$i$$$ to the contest, he needs to pay $$$c_i$$$ to its author;  for each problem in the contest Vasya gets $$$a$$$ burles;  let $$$gap(l, r) = \max\limits_{l \le i &lt; r} (d_{i + 1} - d_i)^2$$$. If Vasya takes all the tasks with indices from $$$l$$$ to $$$r$$$ to the contest, he also needs to pay $$$gap(l, r)$$$. If $$$l = r$$$ then $$$gap(l, r) = 0$$$. Calculate the maximum profit that Vasya can earn by taking a consecutive segment of tasks.","import sys
range = xrange
input = raw_input

# A very nice implementation of a maximum segment tree with 
# some inspiration taken from https://codeforces.com/blog/entry/18051
# This implementation should be able to be modified to do pretty
# much anything one would want to do with segment trees apart from
# persistance.
# Note that especially in python this implementation is much much better
# than most other approches because how slow python can be with function
# calls.

# Currently it allows for two operations, both running in O(log n),
# 'add(l,r,value)' adds value to [l,r)
# 'maxi(l,r)' returns the biggest value on l:r

class super_seg:
    def __init__(self,data):
        n = len(data)
        m = 1
        while m<n: m *= 2
        
        self.n = n
        self.m = m
        self.data = [0]*(2*m)
        for i in range(n):
            self.data[i+m] = data[i]
        for i in reversed(range(m)):
            self.data[i] = max(self.data[2*i], self.data[2*i+1])
        self.query = [0]*(2*m)
    
    # Push the query on seg_ind to its children
    def push(self,seg_ind):
        # Let the children know of the queries
        q = self.query[seg_ind]

        self.query[2*seg_ind]   += q
        self.query[2*seg_ind+1] += q
        
        self.data[2*seg_ind]   += q
        self.data[2*seg_ind+1] += q

        # Remove queries from seg_ind
        self.data[seg_ind] = max(self.data[2*seg_ind],self.data[2*seg_ind+1])
        self.query[seg_ind] = 0

    # Updates the node seg_ind to know of all queries
    # applied to it via its ancestors
    def update(self,seg_ind):
        # Find all indecies to be updated
        seg_ind //= 2
        inds = []
        while seg_ind>0:
            inds.append(seg_ind)
            seg_ind//=2
       
        # Push the queries down the segment tree
        for ind in reversed(inds):
            self.push(ind)

    # Make the changes to seg_ind be known to its ancestors
    def build(self,seg_ind):
        seg_ind//=2
        while seg_ind>0:
            self.data[seg_ind] = max(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]
            seg_ind //= 2

    # Lazily add value to [l,r)
    def add(self,l,r,value):
        l += self.m
        r += self.m
        
        l0 = l
        r0 = r

        while l<r:
            if l%2==1:
                self.query[l]+= value
                self.data[l] += value
                l+=1
            if r%2==1:
                r-=1
                self.query[r]+= value
                self.data[r] += value
            l//=2
            r//=2

        # Tell all nodes above of the updated
        # area of the updates
        self.build(l0)
        self.build(r0-1)
    
    # Max of data[l,r)
    def maxi(self,l,r):
        l += self.m
        r += self.m

        # Apply all the lazily stored queries
        self.update(l)
        self.update(r-1)
        
        segs = []
        while l<r:
            if l%2==1:
                segs.append(l)
                l+=1
            if r%2==1:
                r-=1
                segs.append(r)
            l//=2
            r//=2

        return max(self.data[ind] for ind in segs)


n,a = [int(x) for x in input().split()]

inp = [int(x) for x in sys.stdin.read().split()]

D = inp[::2]
D.append(D[-1])
C = inp[1::2]
C = [a-c for c in C]

Ccum = [0]
for c in C:
    Ccum.append(Ccum[-1]+c)

seg = super_seg(Ccum)

stack = []
besta = 0

for i in reversed(range(n)):
    val = (D[i+1]-D[i])**2
    while stack and stack[-1][0]<=val:        
        # The previous difference is smaller, remove all knowledge of it
        old_val,l,r = stack.pop()
        seg.add(l,r,+old_val)

    # Add new val to seg
    l = i+2
    r = stack[-1][1] if stack else n+1
    if l<r:
        stack.append((val,l,r))
        seg.add(l,r,-val)
    # Use maxi with the segmenttree to calc the best choice of r
    cur_maxi = seg.maxi(i,n+1) - Ccum[i]
    
    besta = max(besta,cur_maxi)
print besta","['dp', 'constructive algorithms', 'dsu', 'data structures', 'binary search']"
"There is a square matrix n × n, consisting of non-negative integer numbers. You should find such a way on it that   starts in the upper left cell of the matrix;  each following cell is to the right or down from the current cell;  the way ends in the bottom right cell. Moreover, if we multiply together all the numbers along the way, the result should be the least ""round"". In other words, it should end in the least possible number of zeros.","n = int(input())
xr = range(n)

a5 = [list(map(int, input().split())) for _ in xr]
a2 = [[0 for _ in xr] for _ in xr]
y = 0
x0 = -1

for y in xr:
    for x in xr:
        i = a5[y][x]
        m5 = 0
        m2 = 0
        
        if i == 0:
            x0 = x
        
        while i and i%2 == 0:
            i/=2
            m2+=1
            
        while i and i%5 == 0:
            i/=5
            m5+=1            
            
        if y == 0 and x == 0:
            a5[y][x] = m5
            a2[y][x] = m2
            continue

        left5 = a5[y][x-1]
        left2 = a2[y][x-1]
        up5 = a5[y-1][x]
        up2 = a2[y-1][x]
        
        if y == 0:
            a5[y][x] = left5 + m5
            a2[y][x] = left2 + m2
            continue
        
        if x == 0:
            a5[y][x] = up5 + m5
            a2[y][x] = up2 + m2
            continue
        
        a5[y][x] = min(up5, left5) + m5
        a2[y][x] = min(up2, left2) + m2
    
def getpath(k):
    p = ''
    y = x = n-1
    
    while not (y == 0 and x == 0):
        if y and x:
            if k == 5:
                if a5[y-1][x] < a5[y][x-1]:
                    p+='D'
                    y-=1
                else:
                    p+='R'
                    x-=1
            else:
                if a2[y-1][x] < a2[y][x-1]:
                    p+='D'
                    y-=1
                else:
                    p+='R'
                    x-=1
        elif y == 0:
            p+='R'
            x-=1                    
        elif x == 0:
            p+='D'
            y-=1                    
        
    return p[::-1]

ten = 0
path = ''
if a5[n-1][n-1] < a2[n-1][n-1]:
    ten = a5[n-1][n-1]
    path = getpath(5)
else:
    ten = a2[n-1][n-1]
    path = getpath(2)
    
if ten > 1 and x0 > -1:
    ten = 1
    path = 'R'*x0 + 'D'*(n-1) + 'R'*(n-1-x0)
    
print(ten)
print(path)","['dp', 'math']"
"Ivan recently bought a detective book. The book is so interesting that each page of this book introduces some sort of a mystery, which will be explained later. The $$$i$$$-th page contains some mystery that will be explained on page $$$a_i$$$ ($$$a_i \ge i$$$).Ivan wants to read the whole book. Each day, he reads the first page he didn't read earlier, and continues to read the following pages one by one, until all the mysteries he read about are explained and clear to him (Ivan stops if there does not exist any page $$$i$$$ such that Ivan already has read it, but hasn't read page $$$a_i$$$). After that, he closes the book and continues to read it on the following day from the next page.How many days will it take to read the whole book?","for _ in range(1):
    n=int(input())
    l=list(map(int,input().split()))
    c=0
    l=[0]+l
    i=1
    while i<=n:
        c+=1
        ma=i
        while i<=n and i<=ma:
            ma=max(ma,l[i])
            i+=1
    print(c)",['implementation']
"After their adventure with the magic mirror Kay and Gerda have returned home and sometimes give free ice cream to kids in the summer.At the start of the day they have x ice cream packs. Since the ice cream is free, people start standing in the queue before Kay and Gerda's house even in the night. Each person in the queue wants either to take several ice cream packs for himself and his friends or to give several ice cream packs to Kay and Gerda (carriers that bring ice cream have to stand in the same queue).If a carrier with d ice cream packs comes to the house, then Kay and Gerda take all his packs. If a child who wants to take d ice cream packs comes to the house, then Kay and Gerda will give him d packs if they have enough ice cream, otherwise the child will get no ice cream at all and will leave in distress.Kay wants to find the amount of ice cream they will have after all people will leave from the queue, and Gerda wants to find the number of distressed kids.","# int(input())
# [int(s) for s in input().split()]
# input()


def solve():
    n, x = [int(s) for s in input().split()]
    ans = 0
    for i in range(n):
        s = input().split()
        if s[0] == ""+"":
            x += int(s[1])
        else:
            if x >= int(s[1]):
                x -= int(s[1])
            else:
                ans += 1
    print(x, ans)


if __name__ == ""__main__"":
    solve()","['constructive algorithms', 'implementation']"
"Greg has an array a = a1, a2, ..., an and m operations. Each operation looks as: li, ri, di, (1 ≤ li ≤ ri ≤ n). To apply operation i to the array means to increase all array elements with numbers li, li + 1, ..., ri by value di.Greg wrote down k queries on a piece of paper. Each query has the following form: xi, yi, (1 ≤ xi ≤ yi ≤ m). That means that one should apply operations with numbers xi, xi + 1, ..., yi to the array.Now Greg is wondering, what the array a will be after all the queries are executed. Help Greg.","from sys import stdin, stdout

n, m, k = map(int, stdin.readline().split())
t = list(map(int, stdin.readline().split()))
p = [tuple(map(int, stdin.readline().split())) for i in range(m)]

r, s = [0] * (m + 1), [0] * (n + 1)
R, S = 0, 0

for i in range(k):
    x, y = map(int, stdin.readline().split())
    r[x - 1] += 1
    r[y] -= 1

for i, (x, y, d) in enumerate(p):
    R += r[i]
    d = d * R
    s[x - 1] += d
    s[y] -= d

for i in range(n):
    S += s[i]
    t[i] = str(t[i] + S)

stdout.write(' '.join(map(str, t)))","['data structures', 'implementation']"
"The commanding officers decided to drop a nuclear bomb on the enemy's forces. You are ordered to determine the power of the warhead that needs to be used.The enemy has N strategically important objects. Their positions are known due to the intelligence service. The aim of the strike is to deactivate at least K important objects of the enemy. The bombing impact point is already determined and has coordinates of [X0; Y0].The nuclear warhead is marked by the estimated impact radius R ≥ 0. All the buildings that are located closer than R to the bombing epicentre will be destroyed. All the buildings that are located further than R from the epicentre, can also be deactivated with some degree of probability. Let's assume that D is the distance between a building and the epicentre. This building's deactivation probability P(D, R) is calculated according to the following formula:  We should regard  as ea, where e ≈ 2.7182818284590452353602874713527If the estimated impact radius of the warhead is equal to zero, then all the buildings located in the impact point will be completely demolished and all the rest of important objects will not be damaged.The commanding officers want the probability of failing the task to be no more than ε. Nuclear warheads are too expensive a luxury, that's why you have to minimise the estimated impact radius of the warhead.","import math 

n = int(input())
k, epsilon = list(map(int, input().split("" "")))
x0, y0 = list(map(int, input().split("" "")))
epsilon /= 1000.0

l = []
for i in range(n):
    l.append(list(map(int, input().split("" ""))))
    
d = sorted([(p[0] - x0) ** 2 + (p[1] - y0) ** 2 for p in l])

rmin = 0
rmax = math.sqrt(d[k - 1])

while(1):
    if(rmax - rmin < 10e-9):
        print((rmin + rmax)/2) 
        break
    
    r = (rmin + rmax)/2
    p = [math.exp(1 - i/(r**2)) if i > r**2 else 1.0 for i in d]
    
    dp = [[0] * (n + 1) for i in range(n + 1)]
    
    dp[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            if(j > 0):
                dp[i][j] = p[i - 1] * dp[i - 1][j - 1]
            if(i != j):
                dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]
                
    s = 0
    for j in range(k, n + 1):
        s += dp[n][j]
    
    if(s > 1 - epsilon):
        rmax = r
    else:
        rmin = r","['dp', 'binary search', 'probabilities']"
"A way to make a new task is to make it nondeterministic or probabilistic. For example, the hard task of Topcoder SRM 595, Constellation, is the probabilistic version of a convex hull.Let's try to make a new task. Firstly we will use the following task. There are n people, sort them by their name. It is just an ordinary sorting problem, but we can make it more interesting by adding nondeterministic element. There are n people, each person will use either his/her first name or last name as a handle. Can the lexicographical order of the handles be exactly equal to the given permutation p?More formally, if we denote the handle of the i-th person as hi, then the following condition must hold: .","# coding: utf-8

def find_k_smallest(A,k):
    
    temp=A
    for j in range(k):
        min_el = A[0]
        min_ind = 0
        for ind,el in enumerate(temp):
            if el> min_el:
                min_el= el
                min_ind = ind
                
        temp[min_ind] = -float('inf')
        
    return min_ind,min_el
        

def sol():
    n = int(input())
    
    names = []
    for i in range(n):
        name = input()
        names.append(name)
        
    vec =[int(x)for x in input().split(' ')]
    
    handles = []
    
    
    for ind,v in enumerate(vec):
        if handles:
#             min_handle_ind,_ = find_k_smallest(vec,ind+1)
            handle1 = min(names[v-1].split("" ""))
            handle2 = max(names[v-1].split("" ""))

            if handle1 > handles[-1]:
                handles.append(handle1)
            elif handle2 > handles[-1]:
                handles.append(handle2)
            else:
                print('NO')
                return 'NO'
            
        else:
            handle = min(names[v-1].split("" ""))
            handles.append(handle)
    
    print(""YES"")
    return ""YES""
sol()",['greedy']
"You are given four integers $$$n$$$, $$$c_0$$$, $$$c_1$$$ and $$$h$$$ and a binary string $$$s$$$ of length $$$n$$$.A binary string is a string consisting of characters $$$0$$$ and $$$1$$$.You can change any character of the string $$$s$$$ (the string should be still binary after the change). You should pay $$$h$$$ coins for each change.After some changes (possibly zero) you want to buy the string. To buy the string you should buy all its characters. To buy the character $$$0$$$ you should pay $$$c_0$$$ coins, to buy the character $$$1$$$ you should pay $$$c_1$$$ coins.Find the minimum number of coins needed to buy the string.","t=int(input())

for i in range (0,t):
    n,s0,s1,h=map(int,input().split())
    string=list(input())
    string=list(map(lambda x : int(x),string))

    zeros=string.count(0)
    ones=string.count(1)

    if (s0==h and s1==h) or (h>s0 and h>s1):
        print(zeros*s0 + ones*s1)
    else:
        t=min(s0,s1)
        on=0
        if t == s1:
            on=1
        if on==0:
            ans=ones*h + n*s0
        else:
            ans=zeros*h + n*s1

        ans=min(ans,zeros*s0 + ones*s1)
        print(ans)","['implementation', 'math']"
"Vasya takes part in the orienteering competition. There are n checkpoints located along the line at coordinates x1, x2, ..., xn. Vasya starts at the point with coordinate a. His goal is to visit at least n - 1 checkpoint in order to finish the competition. Participant are allowed to visit checkpoints in arbitrary order.Vasya wants to pick such checkpoints and the order of visiting them that the total distance travelled is minimized. He asks you to calculate this minimum possible value.","R=lambda:map(int,raw_input().split())
n,a=R()
x=sorted(R())
def f(i,j):
  return abs(a-x[i])+abs(x[i]-x[j])
if n>1:
  print min(f(0,-2),f(1,-1),f(-2,0),f(-1,1))
else:
  print 0","['implementation', 'sortings', 'greedy']"
"The USA Construction Operation (USACO) recently ordered Farmer John to arrange a row of $$$n$$$ haybale piles on the farm. The $$$i$$$-th pile contains $$$a_i$$$ haybales. However, Farmer John has just left for vacation, leaving Bessie all on her own. Every day, Bessie the naughty cow can choose to move one haybale in any pile to an adjacent pile. Formally, in one day she can choose any two indices $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$) such that $$$|i-j|=1$$$ and $$$a_i&gt;0$$$ and apply $$$a_i = a_i - 1$$$, $$$a_j = a_j + 1$$$. She may also decide to not do anything on some days because she is lazy.Bessie wants to maximize the number of haybales in pile $$$1$$$ (i.e. to maximize $$$a_1$$$), and she only has $$$d$$$ days to do so before Farmer John returns. Help her find the maximum number of haybales that may be in pile $$$1$$$ if she acts optimally!","a=int(input())
for i in range(a):
    n,d=map(int,input().split())
    z=list(map(int,input().split()))
    if(n==1):
        print(z[0])
    else:
        if(z[1]>=d):
            print(z[0]+d)
        else:
            for i in range(1,len(z)):
                if(d<=0):
                    break;
                   
                if(d>i*z[i] or z[i]==0):
                    d=d-i*z[i]
                    z[0]=z[0]+z[i]
                    
                else:
                    while(d>=0):
                        d=d-i
                        if(d>=0):
                            z[0]=z[0]+1
                        else:
                            break;
            print(z[0])","['implementation', 'greedy']"
"You are given a permutation p of length n. Remove one element from permutation to make the number of records the maximum possible.We remind that in a sequence of numbers a1, a2, ..., ak the element ai is a record if for every integer j (1 ≤ j &lt; i) the following holds: aj &lt; ai.","import sys

cases = sys.stdin.readline()
my_list = [int(a) for a in sys.stdin.readline().split("" "")]
#my_list = [4, 5, 3, 2, 1]

max_val_a = my_list[0]
max_val_b = 0

my_counts = dict()
for x in my_list:
  my_counts[x] = 0

my_counts[max_val_a] = -1

for x in my_list:
  #print(my_counts)
  if(x > max_val_a):
    my_counts[x] = my_counts[x] - 1
    max_val_a, max_val_b = x, max_val_a
  elif (x < max_val_a and x > max_val_b):
    my_counts[max_val_a] = my_counts[max_val_a] + 1
    max_val_b = x
    
#print(my_counts)
highest = max(my_counts.values())
print(min([k for k, v in my_counts.items() if v == highest]))","['data structures', 'brute force', 'math']"
"You are given n integers a1, a2, ..., an. Find the number of pairs of indexes i, j (i &lt; j) that ai + aj is a power of 2 (i. e. some integer x exists so that ai + aj = 2x).","#import sys
#sys.stdin = open('in', 'r')
n = int(input())
a = [int(x) for x in input().split()]
#n,m = map(int, input().split())

st2 = [1]
while st2[-1] <= 10**10:
    st2.append(st2[-1]*2)

r = 0
d = {}
for i in range(n):
    for s2 in st2:
        if (s2 - a[i]) in d:
            r += d[s2-a[i]]
    d[a[i]] = d.get(a[i], 0) + 1

print(r)","['data structures', 'implementation', 'brute force', 'math']"
"You are given a deck of $$$n$$$ cards numbered from $$$1$$$ to $$$n$$$ (not necessarily in this order in the deck). You have to sort the deck by repeating the following operation.   Choose $$$2 \le k \le n$$$ and split the deck in $$$k$$$ nonempty contiguous parts $$$D_1, D_2,\dots, D_k$$$ ($$$D_1$$$ contains the first $$$|D_1|$$$ cards of the deck, $$$D_2$$$ contains the following $$$|D_2|$$$ cards and so on). Then reverse the order of the parts, transforming the deck into $$$D_k, D_{k-1}, \dots, D_2, D_1$$$ (so, the first $$$|D_k|$$$ cards of the new deck are $$$D_k$$$, the following $$$|D_{k-1}|$$$ cards are $$$D_{k-1}$$$ and so on). The internal order of each packet of cards $$$D_i$$$ is unchanged by the operation. You have to obtain a sorted deck (i.e., a deck where the first card is $$$1$$$, the second is $$$2$$$ and so on) performing at most $$$n$$$ operations. It can be proven that it is always possible to sort the deck performing at most $$$n$$$ operations.Examples of operation: The following are three examples of valid operations (on three decks with different sizes).   If the deck is [3 6 2 1 4 5 7] (so $$$3$$$ is the first card and $$$7$$$ is the last card), we may apply the operation with $$$k=4$$$ and $$$D_1=$$$[3 6], $$$D_2=$$$[2 1 4], $$$D_3=$$$[5], $$$D_4=$$$[7]. Doing so, the deck becomes [7 5 2 1 4 3 6].  If the deck is [3 1 2], we may apply the operation with $$$k=3$$$ and $$$D_1=$$$[3], $$$D_2=$$$[1], $$$D_3=$$$[2]. Doing so, the deck becomes [2 1 3].  If the deck is [5 1 2 4 3 6], we may apply the operation with $$$k=2$$$ and $$$D_1=$$$[5 1], $$$D_2=$$$[2 4 3 6]. Doing so, the deck becomes [2 4 3 6 5 1].","from collections import Counter, defaultdict, deque
import bisect
from sys import stdin, stdout
from itertools import repeat
import math

# sys.stdin = open('input')

def mod(x, y, mod):
    re = 1
    now = x
    while y:
        if y&1:
            re *= now
            re %= mod
        y >>= 1
        now = (now*now)%mod
    return re

def inp(force_list=False):
    re = map(int, raw_input().split())
    if len(re) == 1 and not force_list:
        return re[0]
    return re

def inst():
    return raw_input().strip()

def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

MOD = int(1e9+7)

def query(ty, num):
    if ty==0:
        print 'A %d' % num
    else:
        print 'B %d' % num
    stdout.flush()
    return inp()

def my_main():
    T = 1
    ans = []
    for _ in range(T):
        n = inp()
        da = inp(True)
        op = []
        st = 0
        l = 1
        nl = 0
        mid = n/2+1+n%2
        nm = 0
        for i in range(n-n%2):
            if st==0:
                idx = da.index(mid)
                da = da[n-nm:] + da[idx:n-nm] +  da[nl:idx] + da[0:nl]
                tmpp = filter(lambda x: x!=0, (nl-0, idx-nl, n-nm-idx, n-n+nm))
                len(tmpp) > 1 and ans.append(tmpp)
                mid += 1
                nm += 1
            else:
                idx = da.index(l)
                da = da[n-nl:] + da[idx:n-nl] + da[nm:idx] + da[0:nm]
                tmpp = filter(lambda x: x!=0, (nm-0, idx-nm, n-nl-idx, n-n+nl))
                len(tmpp) > 1 and ans.append(tmpp)
                l += 1
                nl += 1
            # print da, tmpp
            # print l, mid,'kkk',st
            st ^= 1
        print len(ans)
        for iq in ans:
            iq = filter(lambda x: x!=0, iq)
            print len(iq), ' '.join(map(str, iq))










my_main()","['constructive algorithms', 'implementation']"
"There is a house with $$$n$$$ flats situated on the main street of Berlatov. Vova is watching this house every night. The house can be represented as an array of $$$n$$$ integer numbers $$$a_1, a_2, \dots, a_n$$$, where $$$a_i = 1$$$ if in the $$$i$$$-th flat the light is on and $$$a_i = 0$$$ otherwise.Vova thinks that people in the $$$i$$$-th flats are disturbed and cannot sleep if and only if $$$1 &lt; i &lt; n$$$ and $$$a_{i - 1} = a_{i + 1} = 1$$$ and $$$a_i = 0$$$.Vova is concerned by the following question: what is the minimum number $$$k$$$ such that if people from exactly $$$k$$$ pairwise distinct flats will turn off the lights then nobody will be disturbed? Your task is to find this number $$$k$$$.","n = int(input())
a = [int(s) for s in input().split()]
c = 0
for i in range(2, n):
    if a[i - 2] - a[i - 1] == 1 and a[i] == 1:
        a[i] = 0
        c += 1
print(c)",['greedy']
"You are given two binary strings $$$x$$$ and $$$y$$$, which are binary representations of some two integers (let's denote these integers as $$$f(x)$$$ and $$$f(y)$$$). You can choose any integer $$$k \ge 0$$$, calculate the expression $$$s_k = f(x) + f(y) \cdot 2^k$$$ and write the binary representation of $$$s_k$$$ in reverse order (let's denote it as $$$rev_k$$$). For example, let $$$x = 1010$$$ and $$$y = 11$$$; you've chosen $$$k = 1$$$ and, since $$$2^1 = 10_2$$$, so $$$s_k = 1010_2 + 11_2 \cdot 10_2 = 10000_2$$$ and $$$rev_k = 00001$$$.For given $$$x$$$ and $$$y$$$, you need to choose such $$$k$$$ that $$$rev_k$$$ is lexicographically minimal (read notes if you don't know what does ""lexicographically"" means).It's guaranteed that, with given constraints, $$$k$$$ exists and is finite.","def count_final_zeros(a):
	n = 0
	a = list(a)
	while a.pop() == '0':
		n += 1
	return n
	
T = int(raw_input())
for i in range(T):
	x = raw_input().strip()
	y = raw_input().strip()
	nzx = count_final_zeros(x)
	nzy = count_final_zeros(y)
	k = 0
	m = len(x)
	n = len(y)
	if nzx >= nzy:
		print(nzx-nzy)
	else:
		x2 = x[:-nzy]
		nzx2 = count_final_zeros(x2)
		print(nzx2)","['bitmasks', 'greedy']"
"This problem differs from the next one only in the presence of the constraint on the equal length of all numbers $$$a_1, a_2, \dots, a_n$$$. Actually, this problem is a subtask of the problem D2 from the same contest and the solution of D2 solves this subtask too.A team of SIS students is going to make a trip on a submarine. Their target is an ancient treasure in a sunken ship lying on the bottom of the Great Rybinsk sea. Unfortunately, the students don't know the coordinates of the ship, so they asked Meshanya (who is a hereditary mage) to help them. He agreed to help them, but only if they solve his problem.Let's denote a function that alternates digits of two numbers $$$f(a_1 a_2 \dots a_{p - 1} a_p, b_1 b_2 \dots b_{q - 1} b_q)$$$, where $$$a_1 \dots a_p$$$ and $$$b_1 \dots b_q$$$ are digits of two integers written in the decimal notation without leading zeros.In other words, the function $$$f(x, y)$$$ alternately shuffles the digits of the numbers $$$x$$$ and $$$y$$$ by writing them from the lowest digits to the older ones, starting with the number $$$y$$$. The result of the function is also built from right to left (that is, from the lower digits to the older ones). If the digits of one of the arguments have ended, then the remaining digits of the other argument are written out. Familiarize with examples and formal definitions of the function below.For example: $$$$$$f(1111, 2222) = 12121212$$$$$$ $$$$$$f(7777, 888) = 7787878$$$$$$ $$$$$$f(33, 44444) = 4443434$$$$$$ $$$$$$f(555, 6) = 5556$$$$$$ $$$$$$f(111, 2222) = 2121212$$$$$$Formally,  if $$$p \ge q$$$ then $$$f(a_1 \dots a_p, b_1 \dots b_q) = a_1 a_2 \dots a_{p - q + 1} b_1 a_{p - q + 2} b_2 \dots a_{p - 1} b_{q - 1} a_p b_q$$$;  if $$$p &lt; q$$$ then $$$f(a_1 \dots a_p, b_1 \dots b_q) = b_1 b_2 \dots b_{q - p} a_1 b_{q - p + 1} a_2 \dots a_{p - 1} b_{q - 1} a_p b_q$$$. Mishanya gives you an array consisting of $$$n$$$ integers $$$a_i$$$. All numbers in this array are of equal length (that is, they consist of the same number of digits). Your task is to help students to calculate $$$\sum_{i = 1}^{n}\sum_{j = 1}^{n} f(a_i, a_j)$$$ modulo $$$998\,244\,353$$$.","def main():
	n = int(input())
	a = [int(i) for i in input().split()]
	size = len(str(a[0]))
	ans = 0; MOD = 998244353
	ten = [1]
	for i in range(1, 21): ten.append(ten[-1] * 10)
	for i in range(n):
		for j in range(size):
			ans += int(str(a[i])[j]) * ten[2 * size - 2 * j - 1] * n
			ans += int(str(a[i])[j]) * ten[2 * size - 2 * j - 2] * n
			ans %= MOD
	print(ans)


main()","['combinatorics', 'number theory', 'math']"
"Vanya and his friends are walking along the fence of height h and they do not want the guard to notice them. In order to achieve this the height of each of the friends should not exceed h. If the height of some person is greater than h he can bend down and then he surely won't be noticed by the guard. The height of the i-th person is equal to ai.Consider the width of the person walking as usual to be equal to 1, while the width of the bent person is equal to 2. Friends want to talk to each other while walking, so they would like to walk in a single row. What is the minimum width of the road, such that friends can walk in a row and remain unattended by the guard?","n, h = map(int, input().split())
counter = 0
a = input().split()
for i in range(n):
    if int(a[i]) <= h:
        counter += 1
    else:
        counter += 2
print(counter)",['implementation']
"A matrix of size $$$n \times m$$$ is called nice, if all rows and columns of the matrix are palindromes. A sequence of integers $$$(a_1, a_2, \dots , a_k)$$$ is a palindrome, if for any integer $$$i$$$ ($$$1 \le i \le k$$$) the equality $$$a_i = a_{k - i + 1}$$$ holds.Sasha owns a matrix $$$a$$$ of size $$$n \times m$$$. In one operation he can increase or decrease any number in the matrix by one. Sasha wants to make the matrix nice. He is interested what is the minimum number of operations he needs.Help him!","##############--->>>>> Deepcoder Amit Kumar Bhuyan <<<<<---##############

""""""
 Perfection is achieved not when there is nothing more to add, but rather when there is nothing more to take away.
""""""
from __future__ import division, print_function
 
import os,sys
from io import BytesIO, IOBase
 
if sys.version_info[0] < 3:
    from __builtin__ import xrange as range
    from future_builtins import ascii, filter, hex, map, oct, zip
 
 
def ii():  return int(input())
def si():  return input()
def mi():  return map(int,input().strip().split("" ""))
def msi(): return map(str,input().strip().split("" ""))
def li():  return list(mi())
 
def dmain():
    sys.setrecursionlimit(1000000)
    threading.stack_size(1024000)
    thread = threading.Thread(target=main)
    thread.start()
    
#from collections import deque, Counter, OrderedDict,defaultdict
#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace
#from math import log,sqrt,factorial,cos,tan,sin,radians
#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
#from decimal import *
#import threading
#from itertools import permutations
#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy
import sys
input = sys.stdin.readline
scanner = lambda: int(input())
string = lambda: input().rstrip()
get_list = lambda: list(read())
read = lambda: map(int, input().split())
get_float = lambda: map(float, input().split())
# from bisect import bisect_left as lower_bound;
# from bisect import bisect_right as upper_bound;
# from math import ceil, factorial;

 
def ceil(x):
    if x != int(x):
        x = int(x) + 1
    return x
 
def factorial(x, m):
	val = 1
	while x>0:
		val = (val * x) % m
		x -= 1
	return val

def fact(x):
	val = 1
	while x > 0:
		val *= x
		x -= 1
	return val
    
# swap_array function
def swaparr(arr, a,b):
    temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
 
## gcd function
def gcd(a,b):
    if b == 0:
        return a;
    return gcd(b, a % b);

## lcm function
def lcm(a, b):
	return (a * b) // math.gcd(a, b)

def is_integer(n):
	return math.ceil(n) == math.floor(n)
 
## nCr function efficient using Binomial Cofficient
def nCr(n, k): 
	if k > n:
		return 0
	if(k > n - k):
		k = n - k
	res = 1
	for i in range(k):
		res = res * (n - i)
		res = res / (i + 1)
	return int(res)
 
## upper bound function code -- such that e in a[:i] e < x;

 
## prime factorization
def primefs(n):
    ## if n == 1    ## calculating primes
    primes = {}
    while(n%2 == 0 and n > 0):
        primes[2] = primes.get(2, 0) + 1
        n = n//2
    for i in range(3, int(n**0.5)+2, 2):
        while(n%i == 0 and n > 0):
            primes[i] = primes.get(i, 0) + 1
            n = n//i
    if n > 2:
        primes[n] = primes.get(n, 0) + 1
    ## prime factoriazation of n is stored in dictionary
    ## primes and can be accesed. O(sqrt n)
    return primes
 
## MODULAR EXPONENTIATION FUNCTION
def power(x, y, p): 
    res = 1
    x = x % p  
    if (x == 0) : 
        return 0
    while (y > 0) : 
        if ((y & 1) == 1) : 
            res = (res * x) % p 
        y = y >> 1      
        x = (x * x) % p 
    return res 
 
## DISJOINT SET UNINON FUNCTIONS
def swap(a,b):
    temp = a
    a = b
    b = temp
    return a,b;
 
# find function with path compression included (recursive)
# def find(x, link):
#     if link[x] == x:
#         return x
#     link[x] = find(link[x], link);
#     return link[x];
 
# find function with path compression (ITERATIVE)
def find(x, link):
    p = x;
    while( p != link[p]):
        p = link[p];
    
    while( x != p):
        nex = link[x];
        link[x] = p;
        x = nex;
    return p;
 
 
# the union function which makes union(x,y)
# of two nodes x and y
def union(x, y, link, size):
    x = find(x, link)
    y = find(y, link)
    if size[x] < size[y]:
        x,y = swap(x,y)
    if x != y:
        size[x] += size[y]
        link[y] = x
 
## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES
def sieve(n): 
    prime = [True for i in range(n+1)] 
    prime[0], prime[1] = False, False
    p = 2
    while (p * p <= n): 
        if (prime[p] == True): 
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

# Euler's Toitent Function phi
def phi(n) : 
  
    result = n 
    p = 2
    while(p * p<= n) : 
        if (n % p == 0) : 
            while (n % p == 0) : 
                n = n // p 
            result = result * (1.0 - (1.0 / (float) (p))) 
        p = p + 1
    if (n > 1) : 
        result = result * (1.0 - (1.0 / (float)(n))) 
   
    return (int)(result) 

def is_prime(n):
	if n == 0:
		return False
	if n == 1:
		return True
	for i in range(2, int(n ** (1 / 2)) + 1):
		if not n % i:
			return False
 
	return True

def next_prime(n, primes):
	while primes[n] != True:
		n += 1
	return n

 
#### PRIME FACTORIZATION IN O(log n) using Sieve ####
MAXN = int(1e5 + 5)
def spf_sieve():
    spf[1] = 1;
    for i in range(2, MAXN):
        spf[i] = i;
    for i in range(4, MAXN, 2):
        spf[i] = 2;
    for i in range(3, ceil(MAXN ** 0.5), 2):
        if spf[i] == i:
            for j in range(i*i, MAXN, i):
                if spf[j] == j:
                    spf[j] = i;
    ## function for storing smallest prime factors (spf) in the array
 
################## un-comment below 2 lines when using factorization #################
spf = [0 for i in range(MAXN)]
# spf_sieve();
def factoriazation(x):
    res = []
    for i in range(2, int(x ** 0.5) + 1):
    	while x % i == 0:
    		res.append(i)
    		x //= i
    if x != 1:
   		res.append(x)
    return res
    ## this function is useful for multiple queries only, o/w use
    ## primefs function above. complexity O(log n)

def factors(n):
	res = []
	for i in range(1, int(n ** 0.5) + 1):
		if n % i == 0:
			res.append(i)
			res.append(n // i)
	return list(set(res))
 
## taking integer array input
def int_array():
    return list(map(int, input().strip().split()));
 
def float_array():
    return list(map(float, input().strip().split()));
 
## taking string array input
def str_array():
    return input().strip().split();

def binary_search(low, high, w, h, n):
	while low < high:
		mid = low + (high - low) // 2
		# print(low, mid, high)
		if check(mid, w, h, n):
			low = mid + 1
		else:
			high = mid
	return low

## for checking any conditions
def check(moves, n):
	val = (moves + 1) // 2
	rem = moves - val
	sol = (val + 1) * (rem + 1)
	return sol < n
	

## for sorting according to second position
def sortSecond(val):
	return val[1]
	

 
#defining a couple constants
MOD = int(1e9)+7;
CMOD = 998244353;
INF = float('inf'); NINF = -float('inf');
alphs = ""abcdefghijklmnopqrstuvwxyz""
 
################### ---------------- TEMPLATE ENDS HERE ---------------- ###################
 
from itertools import permutations
import math
import bisect as bis
import random
import sys
import collections as collect
import functools as fnt
# from sys import stdout
# import numpy as np
""""""
_______________
rough work here
_______________

n x m => nice
8 6 6 8
6 6 6 6

8 6 6 8

""""""

def solve():
    n, m = read()
    a = [get_list() for x in range(n)]
    s = 0
    for i in range(n):
        for j in range(m):
            b = [a[i][j], a[i][m - j - 1], a[n - i - 1][j]]
            b.sort()
            a[i][j] = a[i][m - j - 1] = a[n - i - 1][j] = b[1]
            s += b[2] - b[1] + b[1] - b[0]
    print(s)



    




# region fastio
# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()
 
 
if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
 
if __name__ == ""__main__"":
    #read()
    # sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""output.txt"", ""w"")
    t = scanner()
    for i in range(t):
    	solve()
    #dmain()
 
# Comment Read()
	# fin_time = datetime.now()
# 	print(""Execution time (for loop): "", (fin_time-init_time))","['implementation', 'greedy', 'math']"
"We start with a string $$$s$$$ consisting only of the digits $$$1$$$, $$$2$$$, or $$$3$$$. The length of $$$s$$$ is denoted by $$$|s|$$$. For each $$$i$$$ from $$$1$$$ to $$$|s|$$$, the $$$i$$$-th character of $$$s$$$ is denoted by $$$s_i$$$. There is one cursor. The cursor's location $$$\ell$$$ is denoted by an integer in $$$\{0, \ldots, |s|\}$$$, with the following meaning:   If $$$\ell = 0$$$, then the cursor is located before the first character of $$$s$$$.  If $$$\ell = |s|$$$, then the cursor is located right after the last character of $$$s$$$.  If $$$0 &lt; \ell &lt; |s|$$$, then the cursor is located between $$$s_\ell$$$ and $$$s_{\ell+1}$$$. We denote by $$$s_\text{left}$$$ the string to the left of the cursor and $$$s_\text{right}$$$ the string to the right of the cursor. We also have a string $$$c$$$, which we call our clipboard, which starts out as empty. There are three types of actions:  The Move action. Move the cursor one step to the right. This increments $$$\ell$$$ once.  The Cut action. Set $$$c \leftarrow s_\text{right}$$$, then set $$$s \leftarrow s_\text{left}$$$.  The Paste action. Append the value of $$$c$$$ to the end of the string $$$s$$$. Note that this doesn't modify $$$c$$$. The cursor initially starts at $$$\ell = 0$$$. Then, we perform the following procedure:  Perform the Move action once.  Perform the Cut action once.  Perform the Paste action $$$s_\ell$$$ times.  If $$$\ell = x$$$, stop. Otherwise, return to step 1. You're given the initial string $$$s$$$ and the integer $$$x$$$. What is the length of $$$s$$$ when the procedure stops? Since this value may be very large, only find it modulo $$$10^9 + 7$$$. It is guaranteed that $$$\ell \le |s|$$$ at any time.","for _ in range(int(input())):
	x = int(input())
	sen = list(map(int, input()))
	l = 1
	len_sen = len(sen)
	while(l <= x):
		itr = sen[l-1]
		len_sen = (l + (len_sen - l) * sen[l-1])%(1000000007)
		
		idx = len(sen)
		for _ in range(itr-1):
			if len(sen) < x:
				sen += sen[l:idx]
			else:
				break
		l+=1
	print(len_sen)","['implementation', 'math']"
"The only difference between easy and hard versions is the size of the input.You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.You have to answer $$$q$$$ independent queries.","for _ in range(int(input())):
    n, k = [int(i) for i in input().split()]
    word = input()
    ans = 0
    for col in [""RGB"", ""GBR"", ""BRG""]:
        cnt = 0
        for i in range(k):
            if word[i] == col[i%3]:
                cnt += 1
        mx = cnt
        for i in range(n-k):
            if word[i+k] == col[(i+k)%3]:
                cnt += 1
            if word[i] == col[i%3]:
                cnt -= 1
            if cnt > mx:
                mx = cnt
        ans = max(ans, mx)
    print(k - ans)",['implementation']
"Little Petya very much likes gifts. Recently he has received a new laptop as a New Year gift from his mother. He immediately decided to give it to somebody else as what can be more pleasant than giving somebody gifts. And on this occasion he organized a New Year party at his place and invited n his friends there.If there's one thing Petya likes more that receiving gifts, that's watching others giving gifts to somebody else. Thus, he safely hid the laptop until the next New Year and made up his mind to watch his friends exchanging gifts while he does not participate in the process. He numbered all his friends with integers from 1 to n. Petya remembered that a friend number i gave a gift to a friend number pi. He also remembered that each of his friends received exactly one gift.Now Petya wants to know for each friend i the number of a friend who has given him a gift.","n=int(input ())
x=input ()
a=x.split()
k=[]
for i in range (1,len(a)+1):
    for j in range (0,len(a)):
        if(str(i)==a[j]):
            k.append(j+1)
            break
h=[]
for y in range (0,len(k)):
    h.append(str(k[y]))
    if(y==len(k)-1):
        break
    h.append(' ')
c=""""
d=c.join(h)
print (d)",['implementation']
"Nikolay has only recently started in competitive programming, but already qualified to the finals of one prestigious olympiad. There going to be $$$n$$$ participants, one of whom is Nikolay. Like any good olympiad, it consists of two rounds. Tired of the traditional rules, in which the participant who solved the largest number of problems wins, the organizers came up with different rules.Suppose in the first round participant A took $$$x$$$-th place and in the second round — $$$y$$$-th place. Then the total score of the participant A is sum $$$x + y$$$. The overall place of the participant A is the number of participants (including A) having their total score less than or equal to the total score of A. Note, that some participants may end up having a common overall place. It is also important to note, that in both the first and the second round there were no two participants tying at a common place. In other words, for every $$$i$$$ from $$$1$$$ to $$$n$$$ exactly one participant took $$$i$$$-th place in first round and exactly one participant took $$$i$$$-th place in second round.Right after the end of the Olympiad, Nikolay was informed that he got $$$x$$$-th place in first round and $$$y$$$-th place in the second round. Nikolay doesn't know the results of other participants, yet he wonders what is the minimum and maximum place he can take, if we consider the most favorable and unfavorable outcome for him. Please help Nikolay to find the answer to this question.","import math
import sys
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
INF = 10 ** 18
MOD = 10 ** 9 + 7

for _ in range(int(input())):
    n,x,y = ilele()
    print(max(1,min(n,x+y-n+1)),min(n,x+y-1))","['constructive algorithms', 'implementation', 'greedy', 'math']"
"A superhero fights with a monster. The battle consists of rounds, each of which lasts exactly $$$n$$$ minutes. After a round ends, the next round starts immediately. This is repeated over and over again.Each round has the same scenario. It is described by a sequence of $$$n$$$ numbers: $$$d_1, d_2, \dots, d_n$$$ ($$$-10^6 \le d_i \le 10^6$$$). The $$$i$$$-th element means that monster's hp (hit points) changes by the value $$$d_i$$$ during the $$$i$$$-th minute of each round. Formally, if before the $$$i$$$-th minute of a round the monster's hp is $$$h$$$, then after the $$$i$$$-th minute it changes to $$$h := h + d_i$$$.The monster's initial hp is $$$H$$$. It means that before the battle the monster has $$$H$$$ hit points. Print the first minute after which the monster dies. The monster dies if its hp is less than or equal to $$$0$$$. Print -1 if the battle continues infinitely.","H,n=map(int,input().split())
a=list(map(int,input().split()))
s=sum(a)
u=0
alpha=0
mini=a[0]
for i in range(n):
	u+=a[i]
	mini=min(mini,u)
	if(H+u<=0):
		alpha=1
if(alpha==0 and s>=0):
	#print(""hello"")
	print(""-1"")
else:
	t=H
	ans=0
	#print(s)
	if(abs(mini)<H):
		if(abs(s)!=0):
			t=t//abs(s)
		else:
			t=0
		if(t>=0):
			ans=(t)*n
			H=H-abs(s)*(t)
			#print(H,ans,t)
			bal=1
			if(s!=0):
				bal=abs(mini)//abs(s)
				H+=bal*abs(s)
				ans-=bal*n
	i=0
	while(1):
		if(i==n):
			i=0
			continue;
		if(H<=0):
			break;
		H+=a[i]
		ans+=1
		i+=1
	print(ans)",['math']
"The array a with n integers is given. Let's call the sequence of one or more consecutive elements in a segment. Also let's call the segment k-good if it contains no more than k different values.Find any longest k-good segment.As the input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use scanf/printf instead of cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java.","n = input()
p = input()
n = n.split(' ')
k = int(n[1])
n = int(n[0])
p = p.split(' ')
p = [int(q) for q in p]
cnt = [0 for i in range(0,int(1e6 + 1))]
curcnt = 0
l = 0
r = -1
maxlen = -1
maxl = 0
maxr = 0
while r<n-1 and l<=n:
    while(r<n-1 and (curcnt + (cnt[p[r+1]] == 0)) <=k):
        curcnt = curcnt + (cnt[p[r+1]] == 0)
        cnt[p[r+1]] +=1 
        r+=1
    if maxlen <(r-l):
        maxlen = r-l
        maxr = r
        maxl = l
    cnt[p[l]]-=1
    curcnt-=(cnt[p[l]]==0)
    l+=1
print(str(maxl+1)+' '+str(maxr+1))

#16 3
#4 2 6 9 6 8 3 3 4 8 2 3 4 6 9 6
#13 3
#1 2 3 4 3 5 6 6 1 3 4 3 7
#16 3
#1 2 6 9 6 8 3 3 1 8 2 3 6 9 6","['data structures', 'two pointers', 'binary search']"
"Quite recently, a very smart student named Jury decided that lectures are boring, so he downloaded a game called ""Black Square"" on his super cool touchscreen phone.In this game, the phone's screen is divided into four vertical strips. Each second, a black square appears on some of the strips. According to the rules of the game, Jury must use this second to touch the corresponding strip to make the square go away. As Jury is both smart and lazy, he counted that he wastes exactly ai calories on touching the i-th strip.You've got a string s, describing the process of the game and numbers a1, a2, a3, a4. Calculate how many calories Jury needs to destroy all the squares?","o, t, th, f = map(int, input().split())
s = input()
S = 0
for i in s:
    if int(i)==1:
        S += o
    elif int(i)==2:
        S += t
    elif int(i)==3:
        S += th
    else:
        S += f
print(S)",['implementation']
"Email address in Berland is a string of the form A@B, where A and B are arbitrary strings consisting of small Latin letters. Bob is a system administrator in «Bersoft» company. He keeps a list of email addresses of the company's staff. This list is as a large string, where all addresses are written in arbitrary order, separated by commas. The same address can be written more than once.Suddenly, because of unknown reasons, all commas in Bob's list disappeared. Now Bob has a string, where all addresses are written one after another without any separators, and there is impossible to determine, where the boundaries between addresses are. Unfortunately, on the same day his chief asked him to bring the initial list of addresses. Now Bob wants to disjoin addresses in some valid way. Help him to do that.","import sys, re

s = raw_input().strip()
match = re.match('^(\w+@\w+)+$', s)
if not match:
    print('No solution')
    sys.exit()

previous = 0
last_at = None
result = []
for pos, ch in enumerate(s):
    if ch == '@':
        result.append(s[previous:pos + 2])
        previous = pos + 2
        last_at = pos
result[-1] += s[last_at + 2:]

print(','.join(result))","['implementation', 'greedy', 'strings']"
"Let's call left cyclic shift of some string $$$t_1 t_2 t_3 \dots t_{n - 1} t_n$$$ as string $$$t_2 t_3 \dots t_{n - 1} t_n t_1$$$.Analogically, let's call right cyclic shift of string $$$t$$$ as string $$$t_n t_1 t_2 t_3 \dots t_{n - 1}$$$.Let's say string $$$t$$$ is good if its left cyclic shift is equal to its right cyclic shift.You are given string $$$s$$$ which consists of digits 0–9.What is the minimum number of characters you need to erase from $$$s$$$ to make it good?","import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
##########################################################
from collections import Counter
# c=sorted((i,int(val))for i,val in enumerate(input().split()))
import heapq
# c=sorted((i,int(val))for i,val in enumerate(input().split()))
# n = int(input())
# ls = list(map(int, input().split()))
# n, k = map(int, input().split())
# n =int(input())
# e=list(map(int, input().split()))

from collections import Counter
#for _ in range(int(input())):

for _ in range(int(input())):
    s=input()
    le=len(s)
    ans=le-1
    d=[0]*10
    for i in s:
        d[int(i)]+=1
    for i in range(10):
        ans=min(ans,le-d[i])
    for i in range(10):
        for j in range(10):
            if i==j:
                continue
            f=0
            cnt=0
            for ch in s:
                if f==0 and ch==str(i):
                    f=1
                    cnt+=1
                elif f==1 and ch==str(j):
                    f=0
                    cnt+=1
            cnt=(cnt//2)*2
            ans=min(ans,le-cnt)

    print(ans)","['dp', 'two pointers', 'greedy', 'brute force']"
"Nikolay lives in a two-storied house. There are $$$n$$$ rooms on each floor, arranged in a row and numbered from one from left to right. So each room can be represented by the number of the floor and the number of the room on this floor (room number is an integer between $$$1$$$ and $$$n$$$). If Nikolay is currently in some room, he can move to any of the neighbouring rooms (if they exist). Rooms with numbers $$$i$$$ and $$$i+1$$$ on each floor are neighbouring, for all $$$1 \leq i \leq n - 1$$$. There may also be staircases that connect two rooms from different floors having the same numbers. If there is a staircase connecting the room $$$x$$$ on the first floor and the room $$$x$$$ on the second floor, then Nikolay can use it to move from one room to another.     The picture illustrates a house with $$$n = 4$$$. There is a staircase between the room $$$2$$$ on the first floor and the room $$$2$$$ on the second floor, and another staircase between the room $$$4$$$ on the first floor and the room $$$4$$$ on the second floor. The arrows denote possible directions in which Nikolay can move. The picture corresponds to the string ""0101"" in the input.  Nikolay wants to move through some rooms in his house. To do this, he firstly chooses any room where he starts. Then Nikolay moves between rooms according to the aforementioned rules. Nikolay never visits the same room twice (he won't enter a room where he has already been). Calculate the maximum number of rooms Nikolay can visit during his tour, if:  he can start in any room on any floor of his choice,  and he won't visit the same room twice.","for _ in range(int(input())):
    n = int(input())
    s = input()
    li = s.find('1')
    ri = s.rfind('1')
    m = n // 2
    if li == -1:
        print(n)
    else:
        if n % 2 != 0:
            a = max(abs(m-li), abs(m-ri)) + m + 1
        else:
            x = abs(m-1-li) if li <= m-1 else abs(m-li)
            y = abs(m-1-ri) if ri <= m-1 else abs(m-ri)
            a = max(x, y) + m + 1
        print(a * 2)","['implementation', 'brute force']"
